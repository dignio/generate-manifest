import './sourcemap-register.cjs';import { createRequire as __WEBPACK_EXTERNAL_createRequire } from "module";
/******/ var __webpack_modules__ = ({

/***/ 5241:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issue = exports.issueCommand = void 0;
const os = __importStar(__nccwpck_require__(2037));
const utils_1 = __nccwpck_require__(5278);
/**
 * Commands
 *
 * Command Format:
 *   ::name key=value,key=value::message
 *
 * Examples:
 *   ::warning::This is the message
 *   ::set-env name=MY_VAR::some value
 */
function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
}
exports.issueCommand = issueCommand;
function issue(name, message = '') {
    issueCommand(name, {}, message);
}
exports.issue = issue;
const CMD_STRING = '::';
class Command {
    constructor(command, properties, message) {
        if (!command) {
            command = 'missing.command';
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
    }
    toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
            cmdStr += ' ';
            let first = true;
            for (const key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    const val = this.properties[key];
                    if (val) {
                        if (first) {
                            first = false;
                        }
                        else {
                            cmdStr += ',';
                        }
                        cmdStr += `${key}=${escapeProperty(val)}`;
                    }
                }
            }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
    }
}
function escapeData(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A');
}
function escapeProperty(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A')
        .replace(/:/g, '%3A')
        .replace(/,/g, '%2C');
}
//# sourceMappingURL=command.js.map

/***/ }),

/***/ 2186:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
const command_1 = __nccwpck_require__(5241);
const file_command_1 = __nccwpck_require__(717);
const utils_1 = __nccwpck_require__(5278);
const os = __importStar(__nccwpck_require__(2037));
const path = __importStar(__nccwpck_require__(1017));
const oidc_utils_1 = __nccwpck_require__(573);
/**
 * The code to exit an action
 */
var ExitCode;
(function (ExitCode) {
    /**
     * A code indicating that the action was successful
     */
    ExitCode[ExitCode["Success"] = 0] = "Success";
    /**
     * A code indicating that the action was a failure
     */
    ExitCode[ExitCode["Failure"] = 1] = "Failure";
})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
//-----------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------
/**
 * Sets env variable for this action and future actions in the job
 * @param name the name of the variable to set
 * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function exportVariable(name, val) {
    const convertedVal = utils_1.toCommandValue(val);
    process.env[name] = convertedVal;
    const filePath = process.env['GITHUB_ENV'] || '';
    if (filePath) {
        const delimiter = '_GitHubActionsFileCommandDelimeter_';
        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;
        file_command_1.issueCommand('ENV', commandValue);
    }
    else {
        command_1.issueCommand('set-env', { name }, convertedVal);
    }
}
exports.exportVariable = exportVariable;
/**
 * Registers a secret which will get masked from logs
 * @param secret value of the secret
 */
function setSecret(secret) {
    command_1.issueCommand('add-mask', {}, secret);
}
exports.setSecret = setSecret;
/**
 * Prepends inputPath to the PATH (for this action and future actions)
 * @param inputPath
 */
function addPath(inputPath) {
    const filePath = process.env['GITHUB_PATH'] || '';
    if (filePath) {
        file_command_1.issueCommand('PATH', inputPath);
    }
    else {
        command_1.issueCommand('add-path', {}, inputPath);
    }
    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
}
exports.addPath = addPath;
/**
 * Gets the value of an input.
 * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
 * Returns an empty string if the value is not defined.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string
 */
function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
    if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
    }
    if (options && options.trimWhitespace === false) {
        return val;
    }
    return val.trim();
}
exports.getInput = getInput;
/**
 * Gets the values of an multiline input.  Each value is also trimmed.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string[]
 *
 */
function getMultilineInput(name, options) {
    const inputs = getInput(name, options)
        .split('\n')
        .filter(x => x !== '');
    return inputs;
}
exports.getMultilineInput = getMultilineInput;
/**
 * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
 * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
 * The return value is also in boolean type.
 * ref: https://yaml.org/spec/1.2/spec.html#id2804923
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   boolean
 */
function getBooleanInput(name, options) {
    const trueValue = ['true', 'True', 'TRUE'];
    const falseValue = ['false', 'False', 'FALSE'];
    const val = getInput(name, options);
    if (trueValue.includes(val))
        return true;
    if (falseValue.includes(val))
        return false;
    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
        `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
}
exports.getBooleanInput = getBooleanInput;
/**
 * Sets the value of an output.
 *
 * @param     name     name of the output to set
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function setOutput(name, value) {
    process.stdout.write(os.EOL);
    command_1.issueCommand('set-output', { name }, value);
}
exports.setOutput = setOutput;
/**
 * Enables or disables the echoing of commands into stdout for the rest of the step.
 * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
 *
 */
function setCommandEcho(enabled) {
    command_1.issue('echo', enabled ? 'on' : 'off');
}
exports.setCommandEcho = setCommandEcho;
//-----------------------------------------------------------------------
// Results
//-----------------------------------------------------------------------
/**
 * Sets the action status to failed.
 * When the action exits it will be with an exit code of 1
 * @param message add error issue message
 */
function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error(message);
}
exports.setFailed = setFailed;
//-----------------------------------------------------------------------
// Logging Commands
//-----------------------------------------------------------------------
/**
 * Gets whether Actions Step Debug is on or not
 */
function isDebug() {
    return process.env['RUNNER_DEBUG'] === '1';
}
exports.isDebug = isDebug;
/**
 * Writes debug message to user log
 * @param message debug message
 */
function debug(message) {
    command_1.issueCommand('debug', {}, message);
}
exports.debug = debug;
/**
 * Adds an error issue
 * @param message error issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function error(message, properties = {}) {
    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.error = error;
/**
 * Adds a warning issue
 * @param message warning issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function warning(message, properties = {}) {
    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.warning = warning;
/**
 * Adds a notice issue
 * @param message notice issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function notice(message, properties = {}) {
    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.notice = notice;
/**
 * Writes info to log with console.log.
 * @param message info message
 */
function info(message) {
    process.stdout.write(message + os.EOL);
}
exports.info = info;
/**
 * Begin an output group.
 *
 * Output until the next `groupEnd` will be foldable in this group
 *
 * @param name The name of the output group
 */
function startGroup(name) {
    command_1.issue('group', name);
}
exports.startGroup = startGroup;
/**
 * End an output group.
 */
function endGroup() {
    command_1.issue('endgroup');
}
exports.endGroup = endGroup;
/**
 * Wrap an asynchronous function call in a group.
 *
 * Returns the same type as the function itself.
 *
 * @param name The name of the group
 * @param fn The function to wrap in the group
 */
function group(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
            result = yield fn();
        }
        finally {
            endGroup();
        }
        return result;
    });
}
exports.group = group;
//-----------------------------------------------------------------------
// Wrapper action state
//-----------------------------------------------------------------------
/**
 * Saves state for current action, the state can only be retrieved by this action's post job execution.
 *
 * @param     name     name of the state to store
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function saveState(name, value) {
    command_1.issueCommand('save-state', { name }, value);
}
exports.saveState = saveState;
/**
 * Gets the value of an state set by this action's main execution.
 *
 * @param     name     name of the state to get
 * @returns   string
 */
function getState(name) {
    return process.env[`STATE_${name}`] || '';
}
exports.getState = getState;
function getIDToken(aud) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
    });
}
exports.getIDToken = getIDToken;
/**
 * Summary exports
 */
var summary_1 = __nccwpck_require__(1327);
Object.defineProperty(exports, "summary", ({ enumerable: true, get: function () { return summary_1.summary; } }));
/**
 * @deprecated use core.summary
 */
var summary_2 = __nccwpck_require__(1327);
Object.defineProperty(exports, "markdownSummary", ({ enumerable: true, get: function () { return summary_2.markdownSummary; } }));
//# sourceMappingURL=core.js.map

/***/ }),

/***/ 717:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


// For internal use, subject to change.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issueCommand = void 0;
// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
const fs = __importStar(__nccwpck_require__(7147));
const os = __importStar(__nccwpck_require__(2037));
const utils_1 = __nccwpck_require__(5278);
function issueCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
        encoding: 'utf8'
    });
}
exports.issueCommand = issueCommand;
//# sourceMappingURL=file-command.js.map

/***/ }),

/***/ 573:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OidcClient = void 0;
const http_client_1 = __nccwpck_require__(6255);
const auth_1 = __nccwpck_require__(5526);
const core_1 = __nccwpck_require__(2186);
class OidcClient {
    static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
            allowRetries: allowRetry,
            maxRetries: maxRetry
        };
        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
    }
    static getRequestToken() {
        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];
        if (!token) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');
        }
        return token;
    }
    static getIDTokenUrl() {
        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];
        if (!runtimeUrl) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');
        }
        return runtimeUrl;
    }
    static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const httpclient = OidcClient.createHttpClient();
            const res = yield httpclient
                .getJson(id_token_url)
                .catch(error => {
                throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.result.message}`);
            });
            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
            if (!id_token) {
                throw new Error('Response json body do not have ID Token field');
            }
            return id_token;
        });
    }
    static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // New ID Token is requested from action service
                let id_token_url = OidcClient.getIDTokenUrl();
                if (audience) {
                    const encodedAudience = encodeURIComponent(audience);
                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;
                }
                core_1.debug(`ID token url is ${id_token_url}`);
                const id_token = yield OidcClient.getCall(id_token_url);
                core_1.setSecret(id_token);
                return id_token;
            }
            catch (error) {
                throw new Error(`Error message: ${error.message}`);
            }
        });
    }
}
exports.OidcClient = OidcClient;
//# sourceMappingURL=oidc-utils.js.map

/***/ }),

/***/ 1327:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
const os_1 = __nccwpck_require__(2037);
const fs_1 = __nccwpck_require__(7147);
const { access, appendFile, writeFile } = fs_1.promises;
exports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';
exports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';
class Summary {
    constructor() {
        this._buffer = '';
    }
    /**
     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
     * Also checks r/w permissions.
     *
     * @returns step summary file path
     */
    filePath() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._filePath) {
                return this._filePath;
            }
            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
            if (!pathFromEnv) {
                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
            }
            try {
                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
            }
            catch (_a) {
                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
            }
            this._filePath = pathFromEnv;
            return this._filePath;
        });
    }
    /**
     * Wraps content in an HTML tag, adding any HTML attributes
     *
     * @param {string} tag HTML tag to wrap
     * @param {string | null} content content within the tag
     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
     *
     * @returns {string} content wrapped in HTML element
     */
    wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs)
            .map(([key, value]) => ` ${key}="${value}"`)
            .join('');
        if (!content) {
            return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
    }
    /**
     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
     *
     * @param {SummaryWriteOptions} [options] (optional) options for write operation
     *
     * @returns {Promise<Summary>} summary instance
     */
    write(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
            const filePath = yield this.filePath();
            const writeFunc = overwrite ? writeFile : appendFile;
            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });
            return this.emptyBuffer();
        });
    }
    /**
     * Clears the summary buffer and wipes the summary file
     *
     * @returns {Summary} summary instance
     */
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.emptyBuffer().write({ overwrite: true });
        });
    }
    /**
     * Returns the current summary buffer as a string
     *
     * @returns {string} string of summary buffer
     */
    stringify() {
        return this._buffer;
    }
    /**
     * If the summary buffer is empty
     *
     * @returns {boolen} true if the buffer is empty
     */
    isEmptyBuffer() {
        return this._buffer.length === 0;
    }
    /**
     * Resets the summary buffer without writing to summary file
     *
     * @returns {Summary} summary instance
     */
    emptyBuffer() {
        this._buffer = '';
        return this;
    }
    /**
     * Adds raw text to the summary buffer
     *
     * @param {string} text content to add
     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
     *
     * @returns {Summary} summary instance
     */
    addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
    }
    /**
     * Adds the operating system-specific end-of-line marker to the buffer
     *
     * @returns {Summary} summary instance
     */
    addEOL() {
        return this.addRaw(os_1.EOL);
    }
    /**
     * Adds an HTML codeblock to the summary buffer
     *
     * @param {string} code content to render within fenced code block
     * @param {string} lang (optional) language to syntax highlight code
     *
     * @returns {Summary} summary instance
     */
    addCodeBlock(code, lang) {
        const attrs = Object.assign({}, (lang && { lang }));
        const element = this.wrap('pre', this.wrap('code', code), attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML list to the summary buffer
     *
     * @param {string[]} items list of items to render
     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
     *
     * @returns {Summary} summary instance
     */
    addList(items, ordered = false) {
        const tag = ordered ? 'ol' : 'ul';
        const listItems = items.map(item => this.wrap('li', item)).join('');
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML table to the summary buffer
     *
     * @param {SummaryTableCell[]} rows table rows
     *
     * @returns {Summary} summary instance
     */
    addTable(rows) {
        const tableBody = rows
            .map(row => {
            const cells = row
                .map(cell => {
                if (typeof cell === 'string') {
                    return this.wrap('td', cell);
                }
                const { header, data, colspan, rowspan } = cell;
                const tag = header ? 'th' : 'td';
                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));
                return this.wrap(tag, data, attrs);
            })
                .join('');
            return this.wrap('tr', cells);
        })
            .join('');
        const element = this.wrap('table', tableBody);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds a collapsable HTML details element to the summary buffer
     *
     * @param {string} label text for the closed state
     * @param {string} content collapsable content
     *
     * @returns {Summary} summary instance
     */
    addDetails(label, content) {
        const element = this.wrap('details', this.wrap('summary', label) + content);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML image tag to the summary buffer
     *
     * @param {string} src path to the image you to embed
     * @param {string} alt text description of the image
     * @param {SummaryImageOptions} options (optional) addition image attributes
     *
     * @returns {Summary} summary instance
     */
    addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));
        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML section heading element
     *
     * @param {string} text heading text
     * @param {number | string} [level=1] (optional) the heading level, default: 1
     *
     * @returns {Summary} summary instance
     */
    addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)
            ? tag
            : 'h1';
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML thematic break (<hr>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addSeparator() {
        const element = this.wrap('hr', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML line break (<br>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addBreak() {
        const element = this.wrap('br', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML blockquote to the summary buffer
     *
     * @param {string} text quote text
     * @param {string} cite (optional) citation url
     *
     * @returns {Summary} summary instance
     */
    addQuote(text, cite) {
        const attrs = Object.assign({}, (cite && { cite }));
        const element = this.wrap('blockquote', text, attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML anchor tag to the summary buffer
     *
     * @param {string} text link text/content
     * @param {string} href hyperlink
     *
     * @returns {Summary} summary instance
     */
    addLink(text, href) {
        const element = this.wrap('a', text, { href });
        return this.addRaw(element).addEOL();
    }
}
const _summary = new Summary();
/**
 * @deprecated use `core.summary`
 */
exports.markdownSummary = _summary;
exports.summary = _summary;
//# sourceMappingURL=summary.js.map

/***/ }),

/***/ 5278:
/***/ ((__unused_webpack_module, exports) => {


// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toCommandProperties = exports.toCommandValue = void 0;
/**
 * Sanitizes an input into a string so it can be passed into issueCommand safely
 * @param input input to sanitize into a string
 */
function toCommandValue(input) {
    if (input === null || input === undefined) {
        return '';
    }
    else if (typeof input === 'string' || input instanceof String) {
        return input;
    }
    return JSON.stringify(input);
}
exports.toCommandValue = toCommandValue;
/**
 *
 * @param annotationProperties
 * @returns The command properties to send with the actual annotation command
 * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
 */
function toCommandProperties(annotationProperties) {
    if (!Object.keys(annotationProperties).length) {
        return {};
    }
    return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
    };
}
exports.toCommandProperties = toCommandProperties;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 5526:
/***/ (function(__unused_webpack_module, exports) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
class BasicCredentialHandler {
    constructor(username, password) {
        this.username = username;
        this.password = password;
    }
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BasicCredentialHandler = BasicCredentialHandler;
class BearerCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Bearer ${this.token}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BearerCredentialHandler = BearerCredentialHandler;
class PersonalAccessTokenCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
//# sourceMappingURL=auth.js.map

/***/ }),

/***/ 6255:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


/* eslint-disable @typescript-eslint/no-explicit-any */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
const http = __importStar(__nccwpck_require__(3685));
const https = __importStar(__nccwpck_require__(5687));
const pm = __importStar(__nccwpck_require__(9835));
const tunnel = __importStar(__nccwpck_require__(4294));
var HttpCodes;
(function (HttpCodes) {
    HttpCodes[HttpCodes["OK"] = 200] = "OK";
    HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
    HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
    HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
    HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
    HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
    HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
    HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
    HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
    HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
    HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));
var Headers;
(function (Headers) {
    Headers["Accept"] = "accept";
    Headers["ContentType"] = "content-type";
})(Headers = exports.Headers || (exports.Headers = {}));
var MediaTypes;
(function (MediaTypes) {
    MediaTypes["ApplicationJson"] = "application/json";
})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));
/**
 * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
 */
function getProxyUrl(serverUrl) {
    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : '';
}
exports.getProxyUrl = getProxyUrl;
const HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
];
const HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
];
const RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];
const ExponentialBackoffCeiling = 10;
const ExponentialBackoffTimeSlice = 5;
class HttpClientError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.name = 'HttpClientError';
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, HttpClientError.prototype);
    }
}
exports.HttpClientError = HttpClientError;
class HttpClientResponse {
    constructor(message) {
        this.message = message;
    }
    readBody() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                let output = Buffer.alloc(0);
                this.message.on('data', (chunk) => {
                    output = Buffer.concat([output, chunk]);
                });
                this.message.on('end', () => {
                    resolve(output.toString());
                });
            }));
        });
    }
}
exports.HttpClientResponse = HttpClientResponse;
function isHttps(requestUrl) {
    const parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === 'https:';
}
exports.isHttps = isHttps;
class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
            if (requestOptions.ignoreSslError != null) {
                this._ignoreSslError = requestOptions.ignoreSslError;
            }
            this._socketTimeout = requestOptions.socketTimeout;
            if (requestOptions.allowRedirects != null) {
                this._allowRedirects = requestOptions.allowRedirects;
            }
            if (requestOptions.allowRedirectDowngrade != null) {
                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
            }
            if (requestOptions.maxRedirects != null) {
                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
            }
            if (requestOptions.keepAlive != null) {
                this._keepAlive = requestOptions.keepAlive;
            }
            if (requestOptions.allowRetries != null) {
                this._allowRetries = requestOptions.allowRetries;
            }
            if (requestOptions.maxRetries != null) {
                this._maxRetries = requestOptions.maxRetries;
            }
        }
    }
    options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});
        });
    }
    get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('GET', requestUrl, null, additionalHeaders || {});
        });
    }
    del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('DELETE', requestUrl, null, additionalHeaders || {});
        });
    }
    post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('POST', requestUrl, data, additionalHeaders || {});
        });
    }
    patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PATCH', requestUrl, data, additionalHeaders || {});
        });
    }
    put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PUT', requestUrl, data, additionalHeaders || {});
        });
    }
    head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('HEAD', requestUrl, null, additionalHeaders || {});
        });
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request(verb, requestUrl, stream, additionalHeaders);
        });
    }
    /**
     * Gets a typed object from an endpoint
     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
     */
    getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            const res = yield this.get(requestUrl, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.post(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.put(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.patch(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    /**
     * Makes a raw http request.
     * All other methods such as get, post, patch, and request ultimately call this.
     * Prefer get, del, post and patch
     */
    request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._disposed) {
                throw new Error('Client has already been disposed.');
            }
            const parsedUrl = new URL(requestUrl);
            let info = this._prepareRequest(verb, parsedUrl, headers);
            // Only perform retries on reads since writes may not be idempotent.
            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)
                ? this._maxRetries + 1
                : 1;
            let numTries = 0;
            let response;
            do {
                response = yield this.requestRaw(info, data);
                // Check if it's an authentication challenge
                if (response &&
                    response.message &&
                    response.message.statusCode === HttpCodes.Unauthorized) {
                    let authenticationHandler;
                    for (const handler of this.handlers) {
                        if (handler.canHandleAuthentication(response)) {
                            authenticationHandler = handler;
                            break;
                        }
                    }
                    if (authenticationHandler) {
                        return authenticationHandler.handleAuthentication(this, info, data);
                    }
                    else {
                        // We have received an unauthorized response but have no handlers to handle it.
                        // Let the response return to the caller.
                        return response;
                    }
                }
                let redirectsRemaining = this._maxRedirects;
                while (response.message.statusCode &&
                    HttpRedirectCodes.includes(response.message.statusCode) &&
                    this._allowRedirects &&
                    redirectsRemaining > 0) {
                    const redirectUrl = response.message.headers['location'];
                    if (!redirectUrl) {
                        // if there's no location to redirect to, we won't
                        break;
                    }
                    const parsedRedirectUrl = new URL(redirectUrl);
                    if (parsedUrl.protocol === 'https:' &&
                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&
                        !this._allowRedirectDowngrade) {
                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');
                    }
                    // we need to finish reading the response before reassigning response
                    // which will leak the open socket.
                    yield response.readBody();
                    // strip authorization header if redirected to a different hostname
                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                        for (const header in headers) {
                            // header names are case insensitive
                            if (header.toLowerCase() === 'authorization') {
                                delete headers[header];
                            }
                        }
                    }
                    // let's make the request with the new redirectUrl
                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);
                    response = yield this.requestRaw(info, data);
                    redirectsRemaining--;
                }
                if (!response.message.statusCode ||
                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {
                    // If not a retry code, return immediately instead of retrying
                    return response;
                }
                numTries += 1;
                if (numTries < maxTries) {
                    yield response.readBody();
                    yield this._performExponentialBackoff(numTries);
                }
            } while (numTries < maxTries);
            return response;
        });
    }
    /**
     * Needs to be called if keepAlive is set to true in request options.
     */
    dispose() {
        if (this._agent) {
            this._agent.destroy();
        }
        this._disposed = true;
    }
    /**
     * Raw request.
     * @param info
     * @param data
     */
    requestRaw(info, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                function callbackForResult(err, res) {
                    if (err) {
                        reject(err);
                    }
                    else if (!res) {
                        // If `err` is not passed, then `res` must be passed.
                        reject(new Error('Unknown error'));
                    }
                    else {
                        resolve(res);
                    }
                }
                this.requestRawWithCallback(info, data, callbackForResult);
            });
        });
    }
    /**
     * Raw request with callback.
     * @param info
     * @param data
     * @param onResult
     */
    requestRawWithCallback(info, data, onResult) {
        if (typeof data === 'string') {
            if (!info.options.headers) {
                info.options.headers = {};
            }
            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
        }
        let callbackCalled = false;
        function handleResult(err, res) {
            if (!callbackCalled) {
                callbackCalled = true;
                onResult(err, res);
            }
        }
        const req = info.httpModule.request(info.options, (msg) => {
            const res = new HttpClientResponse(msg);
            handleResult(undefined, res);
        });
        let socket;
        req.on('socket', sock => {
            socket = sock;
        });
        // If we ever get disconnected, we want the socket to timeout eventually
        req.setTimeout(this._socketTimeout || 3 * 60000, () => {
            if (socket) {
                socket.end();
            }
            handleResult(new Error(`Request timeout: ${info.options.path}`));
        });
        req.on('error', function (err) {
            // err has statusCode property
            // res should have headers
            handleResult(err);
        });
        if (data && typeof data === 'string') {
            req.write(data, 'utf8');
        }
        if (data && typeof data !== 'string') {
            data.on('close', function () {
                req.end();
            });
            data.pipe(req);
        }
        else {
            req.end();
        }
    }
    /**
     * Gets an http agent. This function is useful when you need an http agent that handles
     * routing through a proxy server - depending upon the url and proxy environment variables.
     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
     */
    getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === 'https:';
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port
            ? parseInt(info.parsedUrl.port)
            : defaultPort;
        info.options.path =
            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
            info.options.headers['user-agent'] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        // gives handlers an opportunity to participate
        if (this.handlers) {
            for (const handler of this.handlers) {
                handler.prepareRequest(info.options);
            }
        }
        return info;
    }
    _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
        }
        return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
            agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
            agent = this._agent;
        }
        // if agent is already assigned use that agent.
        if (agent) {
            return agent;
        }
        const usingSsl = parsedUrl.protocol === 'https:';
        let maxSockets = 100;
        if (this.requestOptions) {
            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.
        if (proxyUrl && proxyUrl.hostname) {
            const agentOptions = {
                maxSockets,
                keepAlive: this._keepAlive,
                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {
                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
                })), { host: proxyUrl.hostname, port: proxyUrl.port })
            };
            let tunnelAgent;
            const overHttps = proxyUrl.protocol === 'https:';
            if (usingSsl) {
                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
            }
            else {
                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
            }
            agent = tunnelAgent(agentOptions);
            this._proxyAgent = agent;
        }
        // if reusing agent across request and tunneling agent isn't assigned create a new agent
        if (this._keepAlive && !agent) {
            const options = { keepAlive: this._keepAlive, maxSockets };
            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
            this._agent = agent;
        }
        // if not using private agent and tunnel agent isn't setup then use global agent
        if (!agent) {
            agent = usingSsl ? https.globalAgent : http.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
            // we have to cast it to any and change it directly
            agent.options = Object.assign(agent.options || {}, {
                rejectUnauthorized: false
            });
        }
        return agent;
    }
    _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
            return new Promise(resolve => setTimeout(() => resolve(), ms));
        });
    }
    _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const statusCode = res.message.statusCode || 0;
                const response = {
                    statusCode,
                    result: null,
                    headers: {}
                };
                // not found leads to null obj returned
                if (statusCode === HttpCodes.NotFound) {
                    resolve(response);
                }
                // get the result from the body
                function dateTimeDeserializer(key, value) {
                    if (typeof value === 'string') {
                        const a = new Date(value);
                        if (!isNaN(a.valueOf())) {
                            return a;
                        }
                    }
                    return value;
                }
                let obj;
                let contents;
                try {
                    contents = yield res.readBody();
                    if (contents && contents.length > 0) {
                        if (options && options.deserializeDates) {
                            obj = JSON.parse(contents, dateTimeDeserializer);
                        }
                        else {
                            obj = JSON.parse(contents);
                        }
                        response.result = obj;
                    }
                    response.headers = res.message.headers;
                }
                catch (err) {
                    // Invalid resource (contents not json);  leaving result obj null
                }
                // note that 3xx redirects are handled by the http layer.
                if (statusCode > 299) {
                    let msg;
                    // if exception/error in body, attempt to get better error
                    if (obj && obj.message) {
                        msg = obj.message;
                    }
                    else if (contents && contents.length > 0) {
                        // it may be the case that the exception is in the body message as string
                        msg = contents;
                    }
                    else {
                        msg = `Failed request: (${statusCode})`;
                    }
                    const err = new HttpClientError(msg, statusCode);
                    err.result = response.result;
                    reject(err);
                }
                else {
                    resolve(response);
                }
            }));
        });
    }
}
exports.HttpClient = HttpClient;
const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9835:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkBypass = exports.getProxyUrl = void 0;
function getProxyUrl(reqUrl) {
    const usingSsl = reqUrl.protocol === 'https:';
    if (checkBypass(reqUrl)) {
        return undefined;
    }
    const proxyVar = (() => {
        if (usingSsl) {
            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];
        }
        else {
            return process.env['http_proxy'] || process.env['HTTP_PROXY'];
        }
    })();
    if (proxyVar) {
        return new URL(proxyVar);
    }
    else {
        return undefined;
    }
}
exports.getProxyUrl = getProxyUrl;
function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
        return false;
    }
    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
    if (!noProxy) {
        return false;
    }
    // Determine the request port
    let reqPort;
    if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
    }
    else if (reqUrl.protocol === 'http:') {
        reqPort = 80;
    }
    else if (reqUrl.protocol === 'https:') {
        reqPort = 443;
    }
    // Format the request hostname and hostname with port
    const upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === 'number') {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    // Compare request host against noproxy
    for (const upperNoProxyItem of noProxy
        .split(',')
        .map(x => x.trim().toUpperCase())
        .filter(x => x)) {
        if (upperReqHosts.some(x => x === upperNoProxyItem)) {
            return true;
        }
    }
    return false;
}
exports.checkBypass = checkBypass;
//# sourceMappingURL=proxy.js.map

/***/ }),

/***/ 4778:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Action = void 0;
const k8s = __nccwpck_require__(4879);
/**
 * Utility class to implement the conversion between our API and the k8s action
 * structure. Used both for probes and handlers.
 *
 * @internal
 */
class Action {
    static fromTcpSocket(container, options = {}) {
        var _a, _b;
        return {
            port: k8s.IntOrString.fromNumber((_b = (_a = options.port) !== null && _a !== void 0 ? _a : container.port) !== null && _b !== void 0 ? _b : 80),
            host: options.host,
        };
    }
    static fromCommand(command) {
        return { command };
    }
    static fromHttpGet(container, path, options = {}) {
        var _a, _b;
        return {
            path,
            port: k8s.IntOrString.fromNumber((_b = (_a = options.port) !== null && _a !== void 0 ? _a : container.port) !== null && _b !== void 0 ? _b : 80),
        };
    }
}
exports.Action = Action;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiX2FjdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9fYWN0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLHFDQUFxQztBQUVyQzs7Ozs7R0FLRztBQUNILE1BQWEsTUFBTTtJQUVWLE1BQU0sQ0FBQyxhQUFhLENBQUMsU0FBb0IsRUFBRSxVQUE0QyxFQUFFOztRQUM5RixPQUFPO1lBQ0wsSUFBSSxFQUFFLEdBQUcsQ0FBQyxXQUFXLENBQUMsVUFBVSxhQUFDLE9BQU8sQ0FBQyxJQUFJLG1DQUFJLFNBQVMsQ0FBQyxJQUFJLG1DQUFJLEVBQUUsQ0FBQztZQUN0RSxJQUFJLEVBQUUsT0FBTyxDQUFDLElBQUk7U0FDbkIsQ0FBQztJQUNKLENBQUM7SUFFTSxNQUFNLENBQUMsV0FBVyxDQUFDLE9BQWlCO1FBQ3pDLE9BQU8sRUFBRSxPQUFPLEVBQUUsQ0FBQztJQUNyQixDQUFDO0lBRU0sTUFBTSxDQUFDLFdBQVcsQ0FBQyxTQUFvQixFQUFFLElBQVksRUFBRSxVQUE2QixFQUFHOztRQUM1RixPQUFPO1lBQ0wsSUFBSTtZQUNKLElBQUksRUFBRSxHQUFHLENBQUMsV0FBVyxDQUFDLFVBQVUsYUFBQyxPQUFPLENBQUMsSUFBSSxtQ0FBSSxTQUFTLENBQUMsSUFBSSxtQ0FBSSxFQUFFLENBQUM7U0FDdkUsQ0FBQztJQUNKLENBQUM7Q0FDRjtBQW5CRCx3QkFtQkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb250YWluZXIgfSBmcm9tICcuL2NvbnRhaW5lcic7XG5pbXBvcnQgKiBhcyBrOHMgZnJvbSAnLi9pbXBvcnRzL2s4cyc7XG5cbi8qKlxuICogVXRpbGl0eSBjbGFzcyB0byBpbXBsZW1lbnQgdGhlIGNvbnZlcnNpb24gYmV0d2VlbiBvdXIgQVBJIGFuZCB0aGUgazhzIGFjdGlvblxuICogc3RydWN0dXJlLiBVc2VkIGJvdGggZm9yIHByb2JlcyBhbmQgaGFuZGxlcnMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBBY3Rpb24ge1xuXG4gIHB1YmxpYyBzdGF0aWMgZnJvbVRjcFNvY2tldChjb250YWluZXI6IENvbnRhaW5lciwgb3B0aW9uczogeyBwb3J0PzogbnVtYmVyOyBob3N0Pzogc3RyaW5nIH0gPSB7fSk6IGs4cy5UY3BTb2NrZXRBY3Rpb24ge1xuICAgIHJldHVybiB7XG4gICAgICBwb3J0OiBrOHMuSW50T3JTdHJpbmcuZnJvbU51bWJlcihvcHRpb25zLnBvcnQgPz8gY29udGFpbmVyLnBvcnQgPz8gODApLFxuICAgICAgaG9zdDogb3B0aW9ucy5ob3N0LFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGZyb21Db21tYW5kKGNvbW1hbmQ6IHN0cmluZ1tdKTogazhzLkV4ZWNBY3Rpb24ge1xuICAgIHJldHVybiB7IGNvbW1hbmQgfTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZnJvbUh0dHBHZXQoY29udGFpbmVyOiBDb250YWluZXIsIHBhdGg6IHN0cmluZywgb3B0aW9uczogeyBwb3J0PzogbnVtYmVyIH0gPSB7IH0pOiBrOHMuSHR0cEdldEFjdGlvbiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGgsXG4gICAgICBwb3J0OiBrOHMuSW50T3JTdHJpbmcuZnJvbU51bWJlcihvcHRpb25zLnBvcnQgPz8gY29udGFpbmVyLnBvcnQgPz8gODApLFxuICAgIH07XG4gIH1cbn0iXX0=

/***/ }),

/***/ 6419:
/***/ ((__unused_webpack_module, exports) => {


var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NonApiResource = exports.ApiResource = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
/**
 * Represents information about an API resource type.
 */
class ApiResource {
    constructor(options) {
        this.apiGroup = options.apiGroup;
        this.resourceType = options.resourceType;
    }
    /**
     * API resource information for a custom resource type.
     */
    static custom(options) {
        return new ApiResource(options);
    }
    ;
    asApiResource() {
        return this;
    }
    asNonApiResource() {
        return undefined;
    }
}
exports.ApiResource = ApiResource;
_a = JSII_RTTI_SYMBOL_1;
ApiResource[_a] = { fqn: "cdk8s-plus-22.ApiResource", version: "2.0.0-rc.2" };
/**
 * API resource information for Binding.
 */
ApiResource.BINDINGS = new ApiResource({
    apiGroup: '',
    resourceType: 'bindings',
});
/**
 * API resource information for ComponentStatus.
 */
ApiResource.COMPONENT_STATUSES = new ApiResource({
    apiGroup: '',
    resourceType: 'componentstatuses',
});
/**
 * API resource information for ConfigMap.
 */
ApiResource.CONFIG_MAPS = new ApiResource({
    apiGroup: '',
    resourceType: 'configmaps',
});
/**
 * API resource information for Endpoints.
 */
ApiResource.ENDPOINTS = new ApiResource({
    apiGroup: '',
    resourceType: 'endpoints',
});
/**
 * API resource information for Event.
 */
ApiResource.EVENTS = new ApiResource({
    apiGroup: '',
    resourceType: 'events',
});
/**
 * API resource information for LimitRange.
 */
ApiResource.LIMIT_RANGES = new ApiResource({
    apiGroup: '',
    resourceType: 'limitranges',
});
/**
 * API resource information for Namespace.
 */
ApiResource.NAMESPACES = new ApiResource({
    apiGroup: '',
    resourceType: 'namespaces',
});
/**
 * API resource information for Node.
 */
ApiResource.NODES = new ApiResource({
    apiGroup: '',
    resourceType: 'nodes',
});
/**
 * API resource information for PersistentVolumeClaim.
 */
ApiResource.PERSISTENT_VOLUME_CLAIMS = new ApiResource({
    apiGroup: '',
    resourceType: 'persistentvolumeclaims',
});
/**
 * API resource information for PersistentVolume.
 */
ApiResource.PERSISTENT_VOLUMES = new ApiResource({
    apiGroup: '',
    resourceType: 'persistentvolumes',
});
/**
 * API resource information for Pod.
 */
ApiResource.PODS = new ApiResource({
    apiGroup: '',
    resourceType: 'pods',
});
/**
 * API resource information for PodTemplate.
 */
ApiResource.POD_TEMPLATES = new ApiResource({
    apiGroup: '',
    resourceType: 'podtemplates',
});
/**
 * API resource information for ReplicationController.
 */
ApiResource.REPLICATION_CONTROLLERS = new ApiResource({
    apiGroup: '',
    resourceType: 'replicationcontrollers',
});
/**
 * API resource information for ResourceQuota.
 */
ApiResource.RESOURCE_QUOTAS = new ApiResource({
    apiGroup: '',
    resourceType: 'resourcequotas',
});
/**
 * API resource information for Secret.
 */
ApiResource.SECRETS = new ApiResource({
    apiGroup: '',
    resourceType: 'secrets',
});
/**
 * API resource information for ServiceAccount.
 */
ApiResource.SERVICE_ACCOUNTS = new ApiResource({
    apiGroup: '',
    resourceType: 'serviceaccounts',
});
/**
 * API resource information for Service.
 */
ApiResource.SERVICES = new ApiResource({
    apiGroup: '',
    resourceType: 'services',
});
/**
 * API resource information for MutatingWebhookConfiguration.
 */
ApiResource.MUTATING_WEBHOOK_CONFIGURATIONS = new ApiResource({
    apiGroup: 'admissionregistration.k8s.io',
    resourceType: 'mutatingwebhookconfigurations',
});
/**
 * API resource information for ValidatingWebhookConfiguration.
 */
ApiResource.VALIDATING_WEBHOOK_CONFIGURATIONS = new ApiResource({
    apiGroup: 'admissionregistration.k8s.io',
    resourceType: 'validatingwebhookconfigurations',
});
/**
 * API resource information for CustomResourceDefinition.
 */
ApiResource.CUSTOM_RESOURCE_DEFINITIONS = new ApiResource({
    apiGroup: 'apiextensions.k8s.io',
    resourceType: 'customresourcedefinitions',
});
/**
 * API resource information for APIService.
 */
ApiResource.API_SERVICES = new ApiResource({
    apiGroup: 'apiregistration.k8s.io',
    resourceType: 'apiservices',
});
/**
 * API resource information for ControllerRevision.
 */
ApiResource.CONTROLLER_REVISIONS = new ApiResource({
    apiGroup: 'apps',
    resourceType: 'controllerrevisions',
});
/**
 * API resource information for DaemonSet.
 */
ApiResource.DAEMON_SETS = new ApiResource({
    apiGroup: 'apps',
    resourceType: 'daemonsets',
});
/**
 * API resource information for Deployment.
 */
ApiResource.DEPLOYMENTS = new ApiResource({
    apiGroup: 'apps',
    resourceType: 'deployments',
});
/**
 * API resource information for ReplicaSet.
 */
ApiResource.REPLICA_SETS = new ApiResource({
    apiGroup: 'apps',
    resourceType: 'replicasets',
});
/**
 * API resource information for StatefulSet.
 */
ApiResource.STATEFUL_SETS = new ApiResource({
    apiGroup: 'apps',
    resourceType: 'statefulsets',
});
/**
 * API resource information for TokenReview.
 */
ApiResource.TOKEN_REVIEWS = new ApiResource({
    apiGroup: 'authentication.k8s.io',
    resourceType: 'tokenreviews',
});
/**
 * API resource information for LocalSubjectAccessReview.
 */
ApiResource.LOCAL_SUBJECT_ACCESS_REVIEWS = new ApiResource({
    apiGroup: 'authorization.k8s.io',
    resourceType: 'localsubjectaccessreviews',
});
/**
 * API resource information for SelfSubjectAccessReview.
 */
ApiResource.SELF_SUBJECT_ACCESS_REVIEWS = new ApiResource({
    apiGroup: 'authorization.k8s.io',
    resourceType: 'selfsubjectaccessreviews',
});
/**
 * API resource information for SelfSubjectRulesReview.
 */
ApiResource.SELF_SUBJECT_RULES_REVIEWS = new ApiResource({
    apiGroup: 'authorization.k8s.io',
    resourceType: 'selfsubjectrulesreviews',
});
/**
 * API resource information for SubjectAccessReview.
 */
ApiResource.SUBJECT_ACCESS_REVIEWS = new ApiResource({
    apiGroup: 'authorization.k8s.io',
    resourceType: 'subjectaccessreviews',
});
/**
 * API resource information for HorizontalPodAutoscaler.
 */
ApiResource.HORIZONTAL_POD_AUTOSCALERS = new ApiResource({
    apiGroup: 'autoscaling',
    resourceType: 'horizontalpodautoscalers',
});
/**
 * API resource information for CronJob.
 */
ApiResource.CRON_JOBS = new ApiResource({
    apiGroup: 'batch',
    resourceType: 'cronjobs',
});
/**
 * API resource information for Job.
 */
ApiResource.JOBS = new ApiResource({
    apiGroup: 'batch',
    resourceType: 'jobs',
});
/**
 * API resource information for CertificateSigningRequest.
 */
ApiResource.CERTIFICATE_SIGNING_REQUESTS = new ApiResource({
    apiGroup: 'certificates.k8s.io',
    resourceType: 'certificatesigningrequests',
});
/**
 * API resource information for Lease.
 */
ApiResource.LEASES = new ApiResource({
    apiGroup: 'coordination.k8s.io',
    resourceType: 'leases',
});
/**
 * API resource information for EndpointSlice.
 */
ApiResource.ENDPOINT_SLICES = new ApiResource({
    apiGroup: 'discovery.k8s.io',
    resourceType: 'endpointslices',
});
/**
 * API resource information for FlowSchema.
 */
ApiResource.FLOW_SCHEMAS = new ApiResource({
    apiGroup: 'flowcontrol.apiserver.k8s.io',
    resourceType: 'flowschemas',
});
/**
 * API resource information for PriorityLevelConfiguration.
 */
ApiResource.PRIORITY_LEVEL_CONFIGURATIONS = new ApiResource({
    apiGroup: 'flowcontrol.apiserver.k8s.io',
    resourceType: 'prioritylevelconfigurations',
});
/**
 * API resource information for IngressClass.
 */
ApiResource.INGRESS_CLASSES = new ApiResource({
    apiGroup: 'networking.k8s.io',
    resourceType: 'ingressclasses',
});
/**
 * API resource information for Ingress.
 */
ApiResource.INGRESSES = new ApiResource({
    apiGroup: 'networking.k8s.io',
    resourceType: 'ingresses',
});
/**
 * API resource information for NetworkPolicy.
 */
ApiResource.NETWORK_POLICIES = new ApiResource({
    apiGroup: 'networking.k8s.io',
    resourceType: 'networkpolicies',
});
/**
 * API resource information for RuntimeClass.
 */
ApiResource.RUNTIME_CLASSES = new ApiResource({
    apiGroup: 'node.k8s.io',
    resourceType: 'runtimeclasses',
});
/**
 * API resource information for PodDisruptionBudget.
 */
ApiResource.POD_DISRUPTION_BUDGETS = new ApiResource({
    apiGroup: 'policy',
    resourceType: 'poddisruptionbudgets',
});
/**
 * API resource information for PodSecurityPolicy.
 */
ApiResource.POD_SECURITY_POLICIES = new ApiResource({
    apiGroup: 'policy',
    resourceType: 'podsecuritypolicies',
});
/**
 * API resource information for ClusterRoleBinding.
 */
ApiResource.CLUSTER_ROLE_BINDINGS = new ApiResource({
    apiGroup: 'rbac.authorization.k8s.io',
    resourceType: 'clusterrolebindings',
});
/**
 * API resource information for ClusterRole.
 */
ApiResource.CLUSTER_ROLES = new ApiResource({
    apiGroup: 'rbac.authorization.k8s.io',
    resourceType: 'clusterroles',
});
/**
 * API resource information for RoleBinding.
 */
ApiResource.ROLE_BINDINGS = new ApiResource({
    apiGroup: 'rbac.authorization.k8s.io',
    resourceType: 'rolebindings',
});
/**
 * API resource information for Role.
 */
ApiResource.ROLES = new ApiResource({
    apiGroup: 'rbac.authorization.k8s.io',
    resourceType: 'roles',
});
/**
 * API resource information for PriorityClass.
 */
ApiResource.PRIORITY_CLASSES = new ApiResource({
    apiGroup: 'scheduling.k8s.io',
    resourceType: 'priorityclasses',
});
/**
 * API resource information for CSIDriver.
 */
ApiResource.CSI_DRIVERS = new ApiResource({
    apiGroup: 'storage.k8s.io',
    resourceType: 'csidrivers',
});
/**
 * API resource information for CSINode.
 */
ApiResource.CSI_NODES = new ApiResource({
    apiGroup: 'storage.k8s.io',
    resourceType: 'csinodes',
});
/**
 * API resource information for CSIStorageCapacity.
 */
ApiResource.CSI_STORAGE_CAPACITIES = new ApiResource({
    apiGroup: 'storage.k8s.io',
    resourceType: 'csistoragecapacities',
});
/**
 * API resource information for StorageClass.
 */
ApiResource.STORAGE_CLASSES = new ApiResource({
    apiGroup: 'storage.k8s.io',
    resourceType: 'storageclasses',
});
/**
 * API resource information for VolumeAttachment.
 */
ApiResource.VOLUME_ATTACHMENTS = new ApiResource({
    apiGroup: 'storage.k8s.io',
    resourceType: 'volumeattachments',
});
/**
 * Factory for creating non api resources.
 */
class NonApiResource {
    constructor(nonResourceUrl) {
        this.nonResourceUrl = nonResourceUrl;
    }
    static of(url) {
        return new NonApiResource(url);
    }
    ;
    asApiResource() {
        return undefined;
    }
    asNonApiResource() {
        return this.nonResourceUrl;
    }
}
exports.NonApiResource = NonApiResource;
_b = JSII_RTTI_SYMBOL_1;
NonApiResource[_b] = { fqn: "cdk8s-plus-22.NonApiResource", version: "2.0.0-rc.2" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBpLXJlc291cmNlLmdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9hcGktcmVzb3VyY2UuZ2VuZXJhdGVkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBNERBOztHQUVHO0FBQ0gsTUFBYSxXQUFXO0lBbWR0QixZQUFvQixPQUEyQjtRQUM3QyxJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUM7UUFDakMsSUFBSSxDQUFDLFlBQVksR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDO0lBQzNDLENBQUM7SUE3QkQ7O09BRUc7SUFDSSxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQTJCO1FBQzlDLE9BQU8sSUFBSSxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDbEMsQ0FBQztJQUFBLENBQUM7SUFjSyxhQUFhO1FBQ2xCLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVNLGdCQUFnQjtRQUNyQixPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDOztBQWxkSCxrQ0F1ZEM7OztBQXRkQzs7R0FFRztBQUNvQixvQkFBUSxHQUFHLElBQUksV0FBVyxDQUFDO0lBQ2hELFFBQVEsRUFBRSxFQUFFO0lBQ1osWUFBWSxFQUFFLFVBQVU7Q0FDekIsQ0FBQyxDQUFDO0FBRUg7O0dBRUc7QUFDb0IsOEJBQWtCLEdBQUcsSUFBSSxXQUFXLENBQUM7SUFDMUQsUUFBUSxFQUFFLEVBQUU7SUFDWixZQUFZLEVBQUUsbUJBQW1CO0NBQ2xDLENBQUMsQ0FBQztBQUVIOztHQUVHO0FBQ29CLHVCQUFXLEdBQUcsSUFBSSxXQUFXLENBQUM7SUFDbkQsUUFBUSxFQUFFLEVBQUU7SUFDWixZQUFZLEVBQUUsWUFBWTtDQUMzQixDQUFDLENBQUM7QUFFSDs7R0FFRztBQUNvQixxQkFBUyxHQUFHLElBQUksV0FBVyxDQUFDO0lBQ2pELFFBQVEsRUFBRSxFQUFFO0lBQ1osWUFBWSxFQUFFLFdBQVc7Q0FDMUIsQ0FBQyxDQUFDO0FB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Q0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBRThELENBQUM7SUFFekQsYUFBYTtRQUNsQixPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0lBRU0sZ0JBQWdCO1FBRXJCLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQztJQUM3QixDQUFDOztBQWZILHdDQWdCQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIH5+IEdlbmVyYXRlZCBieSBwcm9qZW4uIFRvIG1vZGlmeSwgZWRpdCAucHJvamVucmMuanMgYW5kIHJ1biBcIm5weCBwcm9qZW5cIi5cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcmVzb3VyY2Ugb3IgY29sbGVjdGlvbiBvZiByZXNvdXJjZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUFwaVJlc291cmNlIHtcbiAgLyoqXG4gICAqIFRoZSBncm91cCBwb3J0aW9uIG9mIHRoZSBBUEkgdmVyc2lvbiAoZS5nLiBgYXV0aG9yaXphdGlvbi5rOHMuaW9gKS5cbiAgICovXG4gIHJlYWRvbmx5IGFwaUdyb3VwOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIGEgcmVzb3VyY2UgdHlwZSBhcyBpdCBhcHBlYXJzIGluIHRoZSByZWxldmFudCBBUEkgZW5kcG9pbnQuXG4gICAqIEBleGFtcGxlIC0gXCJwb2RzXCIgb3IgXCJwb2RzL2xvZ1wiXG4gICAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvcmVmZXJlbmNlL2FjY2Vzcy1hdXRobi1hdXRoei9yYmFjLyNyZWZlcnJpbmctdG8tcmVzb3VyY2VzXG4gICAqL1xuICByZWFkb25seSByZXNvdXJjZVR5cGU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSwgbmFtZXNwYWNlLWdsb2JhbCwgbmFtZSBvZiBhbiBvYmplY3QgaW5zaWRlIHRoZSBLdWJlcm5ldGVzIGNsdXN0ZXIuXG4gICAqXG4gICAqIElmIHRoaXMgaXMgb21pdHRlZCwgdGhlIEFwaVJlc291cmNlIHNob3VsZCByZXByZXNlbnQgYWxsIG9iamVjdHMgb2YgdGhlIGdpdmVuIHR5cGUuXG4gICAqL1xuICByZWFkb25seSByZXNvdXJjZU5hbWU/OiBzdHJpbmc7XG59XG4vKipcbiAqIEFuIEFQSSBFbmRwb2ludCBjYW4gZWl0aGVyIGJlIGEgcmVzb3VyY2UgZGVzY3JpcHRvciAoZS5nIC9wb2RzKVxuICogb3IgYSBub24gcmVzb3VyY2UgdXJsIChlLmcgL2hlYWx0aHopLiBJdCBtdXN0IGJlIG9uZSBvciB0aGUgb3RoZXIsIGFuZCBub3QgYm90aC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJQXBpRW5kcG9pbnQge1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIElBcGlSZXNvdXJjZSB0aGlzIG9iamVjdCByZXByZXNlbnRzLlxuICAgKi9cbiAgYXNBcGlSZXNvdXJjZSgpOiBJQXBpUmVzb3VyY2UgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbm9uIHJlc291cmNlIHVybCB0aGlzIG9iamVjdCByZXByZXNlbnRzLlxuICAgKi9cbiAgYXNOb25BcGlSZXNvdXJjZSgpOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBgQXBpUmVzb3VyY2VgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFwaVJlc291cmNlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgZ3JvdXAgcG9ydGlvbiBvZiB0aGUgQVBJIHZlcnNpb24gKGUuZy4gYGF1dGhvcml6YXRpb24uazhzLmlvYCkuXG4gICAqL1xuICByZWFkb25seSBhcGlHcm91cDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgcmVzb3VyY2UgdHlwZSBhcyBpdCBhcHBlYXJzIGluIHRoZSByZWxldmFudCBBUEkgZW5kcG9pbnQuXG4gICAqIEBleGFtcGxlIC0gXCJwb2RzXCIgb3IgXCJwb2RzL2xvZ1wiXG4gICAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvcmVmZXJlbmNlL2FjY2Vzcy1hdXRobi1hdXRoei9yYmFjLyNyZWZlcnJpbmctdG8tcmVzb3VyY2VzXG4gICAqL1xuICByZWFkb25seSByZXNvdXJjZVR5cGU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGluZm9ybWF0aW9uIGFib3V0IGFuIEFQSSByZXNvdXJjZSB0eXBlLlxuICovXG5leHBvcnQgY2xhc3MgQXBpUmVzb3VyY2UgaW1wbGVtZW50cyBJQXBpUmVzb3VyY2UsIElBcGlFbmRwb2ludCB7XG4gIC8qKlxuICAgKiBBUEkgcmVzb3VyY2UgaW5mb3JtYXRpb24gZm9yIEJpbmRpbmcuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEJJTkRJTkdTID0gbmV3IEFwaVJlc291cmNlKHtcbiAgICBhcGlHcm91cDogJycsXG4gICAgcmVzb3VyY2VUeXBlOiAnYmluZGluZ3MnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBDb21wb25lbnRTdGF0dXMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IENPTVBPTkVOVF9TVEFUVVNFUyA9IG5ldyBBcGlSZXNvdXJjZSh7XG4gICAgYXBpR3JvdXA6ICcnLFxuICAgIHJlc291cmNlVHlwZTogJ2NvbXBvbmVudHN0YXR1c2VzJyxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFQSSByZXNvdXJjZSBpbmZvcm1hdGlvbiBmb3IgQ29uZmlnTWFwLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBDT05GSUdfTUFQUyA9IG5ldyBBcGlSZXNvdXJjZSh7XG4gICAgYXBpR3JvdXA6ICcnLFxuICAgIHJlc291cmNlVHlwZTogJ2NvbmZpZ21hcHMnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBFbmRwb2ludHMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEVORFBPSU5UUyA9IG5ldyBBcGlSZXNvdXJjZSh7XG4gICAgYXBpR3JvdXA6ICcnLFxuICAgIHJlc291cmNlVHlwZTogJ2VuZHBvaW50cycsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBUEkgcmVzb3VyY2UgaW5mb3JtYXRpb24gZm9yIEV2ZW50LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBFVkVOVFMgPSBuZXcgQXBpUmVzb3VyY2Uoe1xuICAgIGFwaUdyb3VwOiAnJyxcbiAgICByZXNvdXJjZVR5cGU6ICdldmVudHMnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBMaW1pdFJhbmdlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBMSU1JVF9SQU5HRVMgPSBuZXcgQXBpUmVzb3VyY2Uoe1xuICAgIGFwaUdyb3VwOiAnJyxcbiAgICByZXNvdXJjZVR5cGU6ICdsaW1pdHJhbmdlcycsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBUEkgcmVzb3VyY2UgaW5mb3JtYXRpb24gZm9yIE5hbWVzcGFjZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTkFNRVNQQUNFUyA9IG5ldyBBcGlSZXNvdXJjZSh7XG4gICAgYXBpR3JvdXA6ICcnLFxuICAgIHJlc291cmNlVHlwZTogJ25hbWVzcGFjZXMnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBOb2RlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBOT0RFUyA9IG5ldyBBcGlSZXNvdXJjZSh7XG4gICAgYXBpR3JvdXA6ICcnLFxuICAgIHJlc291cmNlVHlwZTogJ25vZGVzJyxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFQSSByZXNvdXJjZSBpbmZvcm1hdGlvbiBmb3IgUGVyc2lzdGVudFZvbHVtZUNsYWltLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBQRVJTSVNURU5UX1ZPTFVNRV9DTEFJTVMgPSBuZXcgQXBpUmVzb3VyY2Uoe1xuICAgIGFwaUdyb3VwOiAnJyxcbiAgICByZXNvdXJjZVR5cGU6ICdwZXJzaXN0ZW50dm9sdW1lY2xhaW1zJyxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFQSSByZXNvdXJjZSBpbmZvcm1hdGlvbiBmb3IgUGVyc2lzdGVudFZvbHVtZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUEVSU0lTVEVOVF9WT0xVTUVTID0gbmV3IEFwaVJlc291cmNlKHtcbiAgICBhcGlHcm91cDogJycsXG4gICAgcmVzb3VyY2VUeXBlOiAncGVyc2lzdGVudHZvbHVtZXMnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBQb2QuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFBPRFMgPSBuZXcgQXBpUmVzb3VyY2Uoe1xuICAgIGFwaUdyb3VwOiAnJyxcbiAgICByZXNvdXJjZVR5cGU6ICdwb2RzJyxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFQSSByZXNvdXJjZSBpbmZvcm1hdGlvbiBmb3IgUG9kVGVtcGxhdGUuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFBPRF9URU1QTEFURVMgPSBuZXcgQXBpUmVzb3VyY2Uoe1xuICAgIGFwaUdyb3VwOiAnJyxcbiAgICByZXNvdXJjZVR5cGU6ICdwb2R0ZW1wbGF0ZXMnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBSZXBsaWNhdGlvbkNvbnRyb2xsZXIuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFJFUExJQ0FUSU9OX0NPTlRST0xMRVJTID0gbmV3IEFwaVJlc291cmNlKHtcbiAgICBhcGlHcm91cDogJycsXG4gICAgcmVzb3VyY2VUeXBlOiAncmVwbGljYXRpb25jb250cm9sbGVycycsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBUEkgcmVzb3VyY2UgaW5mb3JtYXRpb24gZm9yIFJlc291cmNlUXVvdGEuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFJFU09VUkNFX1FVT1RBUyA9IG5ldyBBcGlSZXNvdXJjZSh7XG4gICAgYXBpR3JvdXA6ICcnLFxuICAgIHJlc291cmNlVHlwZTogJ3Jlc291cmNlcXVvdGFzJyxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFQSSByZXNvdXJjZSBpbmZvcm1hdGlvbiBmb3IgU2VjcmV0LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBTRUNSRVRTID0gbmV3IEFwaVJlc291cmNlKHtcbiAgICBhcGlHcm91cDogJycsXG4gICAgcmVzb3VyY2VUeXBlOiAnc2VjcmV0cycsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBUEkgcmVzb3VyY2UgaW5mb3JtYXRpb24gZm9yIFNlcnZpY2VBY2NvdW50LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBTRVJWSUNFX0FDQ09VTlRTID0gbmV3IEFwaVJlc291cmNlKHtcbiAgICBhcGlHcm91cDogJycsXG4gICAgcmVzb3VyY2VUeXBlOiAnc2VydmljZWFjY291bnRzJyxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFQSSByZXNvdXJjZSBpbmZvcm1hdGlvbiBmb3IgU2VydmljZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgU0VSVklDRVMgPSBuZXcgQXBpUmVzb3VyY2Uoe1xuICAgIGFwaUdyb3VwOiAnJyxcbiAgICByZXNvdXJjZVR5cGU6ICdzZXJ2aWNlcycsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBUEkgcmVzb3VyY2UgaW5mb3JtYXRpb24gZm9yIE11dGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb24uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IE1VVEFUSU5HX1dFQkhPT0tfQ09ORklHVVJBVElPTlMgPSBuZXcgQXBpUmVzb3VyY2Uoe1xuICAgIGFwaUdyb3VwOiAnYWRtaXNzaW9ucmVnaXN0cmF0aW9uLms4cy5pbycsXG4gICAgcmVzb3VyY2VUeXBlOiAnbXV0YXRpbmd3ZWJob29rY29uZmlndXJhdGlvbnMnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBWYWxpZGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb24uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFZBTElEQVRJTkdfV0VCSE9PS19DT05GSUdVUkFUSU9OUyA9IG5ldyBBcGlSZXNvdXJjZSh7XG4gICAgYXBpR3JvdXA6ICdhZG1pc3Npb25yZWdpc3RyYXRpb24uazhzLmlvJyxcbiAgICByZXNvdXJjZVR5cGU6ICd2YWxpZGF0aW5nd2ViaG9va2NvbmZpZ3VyYXRpb25zJyxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFQSSByZXNvdXJjZSBpbmZvcm1hdGlvbiBmb3IgQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBDVVNUT01fUkVTT1VSQ0VfREVGSU5JVElPTlMgPSBuZXcgQXBpUmVzb3VyY2Uoe1xuICAgIGFwaUdyb3VwOiAnYXBpZXh0ZW5zaW9ucy5rOHMuaW8nLFxuICAgIHJlc291cmNlVHlwZTogJ2N1c3RvbXJlc291cmNlZGVmaW5pdGlvbnMnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBBUElTZXJ2aWNlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBBUElfU0VSVklDRVMgPSBuZXcgQXBpUmVzb3VyY2Uoe1xuICAgIGFwaUdyb3VwOiAnYXBpcmVnaXN0cmF0aW9uLms4cy5pbycsXG4gICAgcmVzb3VyY2VUeXBlOiAnYXBpc2VydmljZXMnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBDb250cm9sbGVyUmV2aXNpb24uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IENPTlRST0xMRVJfUkVWSVNJT05TID0gbmV3IEFwaVJlc291cmNlKHtcbiAgICBhcGlHcm91cDogJ2FwcHMnLFxuICAgIHJlc291cmNlVHlwZTogJ2NvbnRyb2xsZXJyZXZpc2lvbnMnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBEYWVtb25TZXQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERBRU1PTl9TRVRTID0gbmV3IEFwaVJlc291cmNlKHtcbiAgICBhcGlHcm91cDogJ2FwcHMnLFxuICAgIHJlc291cmNlVHlwZTogJ2RhZW1vbnNldHMnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBEZXBsb3ltZW50LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBERVBMT1lNRU5UUyA9IG5ldyBBcGlSZXNvdXJjZSh7XG4gICAgYXBpR3JvdXA6ICdhcHBzJyxcbiAgICByZXNvdXJjZVR5cGU6ICdkZXBsb3ltZW50cycsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBUEkgcmVzb3VyY2UgaW5mb3JtYXRpb24gZm9yIFJlcGxpY2FTZXQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFJFUExJQ0FfU0VUUyA9IG5ldyBBcGlSZXNvdXJjZSh7XG4gICAgYXBpR3JvdXA6ICdhcHBzJyxcbiAgICByZXNvdXJjZVR5cGU6ICdyZXBsaWNhc2V0cycsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBUEkgcmVzb3VyY2UgaW5mb3JtYXRpb24gZm9yIFN0YXRlZnVsU2V0LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBTVEFURUZVTF9TRVRTID0gbmV3IEFwaVJlc291cmNlKHtcbiAgICBhcGlHcm91cDogJ2FwcHMnLFxuICAgIHJlc291cmNlVHlwZTogJ3N0YXRlZnVsc2V0cycsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBUEkgcmVzb3VyY2UgaW5mb3JtYXRpb24gZm9yIFRva2VuUmV2aWV3LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBUT0tFTl9SRVZJRVdTID0gbmV3IEFwaVJlc291cmNlKHtcbiAgICBhcGlHcm91cDogJ2F1dGhlbnRpY2F0aW9uLms4cy5pbycsXG4gICAgcmVzb3VyY2VUeXBlOiAndG9rZW5yZXZpZXdzJyxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFQSSByZXNvdXJjZSBpbmZvcm1hdGlvbiBmb3IgTG9jYWxTdWJqZWN0QWNjZXNzUmV2aWV3LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBMT0NBTF9TVUJKRUNUX0FDQ0VTU19SRVZJRVdTID0gbmV3IEFwaVJlc291cmNlKHtcbiAgICBhcGlHcm91cDogJ2F1dGhvcml6YXRpb24uazhzLmlvJyxcbiAgICByZXNvdXJjZVR5cGU6ICdsb2NhbHN1YmplY3RhY2Nlc3NyZXZpZXdzJyxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFQSSByZXNvdXJjZSBpbmZvcm1hdGlvbiBmb3IgU2VsZlN1YmplY3RBY2Nlc3NSZXZpZXcuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFNFTEZfU1VCSkVDVF9BQ0NFU1NfUkVWSUVXUyA9IG5ldyBBcGlSZXNvdXJjZSh7XG4gICAgYXBpR3JvdXA6ICdhdXRob3JpemF0aW9uLms4cy5pbycsXG4gICAgcmVzb3VyY2VUeXBlOiAnc2VsZnN1YmplY3RhY2Nlc3NyZXZpZXdzJyxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFQSSByZXNvdXJjZSBpbmZvcm1hdGlvbiBmb3IgU2VsZlN1YmplY3RSdWxlc1Jldmlldy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgU0VMRl9TVUJKRUNUX1JVTEVTX1JFVklFV1MgPSBuZXcgQXBpUmVzb3VyY2Uoe1xuICAgIGFwaUdyb3VwOiAnYXV0aG9yaXphdGlvbi5rOHMuaW8nLFxuICAgIHJlc291cmNlVHlwZTogJ3NlbGZzdWJqZWN0cnVsZXNyZXZpZXdzJyxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFQSSByZXNvdXJjZSBpbmZvcm1hdGlvbiBmb3IgU3ViamVjdEFjY2Vzc1Jldmlldy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgU1VCSkVDVF9BQ0NFU1NfUkVWSUVXUyA9IG5ldyBBcGlSZXNvdXJjZSh7XG4gICAgYXBpR3JvdXA6ICdhdXRob3JpemF0aW9uLms4cy5pbycsXG4gICAgcmVzb3VyY2VUeXBlOiAnc3ViamVjdGFjY2Vzc3Jldmlld3MnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBIb3Jpem9udGFsUG9kQXV0b3NjYWxlci5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgSE9SSVpPTlRBTF9QT0RfQVVUT1NDQUxFUlMgPSBuZXcgQXBpUmVzb3VyY2Uoe1xuICAgIGFwaUdyb3VwOiAnYXV0b3NjYWxpbmcnLFxuICAgIHJlc291cmNlVHlwZTogJ2hvcml6b250YWxwb2RhdXRvc2NhbGVycycsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBUEkgcmVzb3VyY2UgaW5mb3JtYXRpb24gZm9yIENyb25Kb2IuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IENST05fSk9CUyA9IG5ldyBBcGlSZXNvdXJjZSh7XG4gICAgYXBpR3JvdXA6ICdiYXRjaCcsXG4gICAgcmVzb3VyY2VUeXBlOiAnY3JvbmpvYnMnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBKb2IuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEpPQlMgPSBuZXcgQXBpUmVzb3VyY2Uoe1xuICAgIGFwaUdyb3VwOiAnYmF0Y2gnLFxuICAgIHJlc291cmNlVHlwZTogJ2pvYnMnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBDZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBDRVJUSUZJQ0FURV9TSUdOSU5HX1JFUVVFU1RTID0gbmV3IEFwaVJlc291cmNlKHtcbiAgICBhcGlHcm91cDogJ2NlcnRpZmljYXRlcy5rOHMuaW8nLFxuICAgIHJlc291cmNlVHlwZTogJ2NlcnRpZmljYXRlc2lnbmluZ3JlcXVlc3RzJyxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFQSSByZXNvdXJjZSBpbmZvcm1hdGlvbiBmb3IgTGVhc2UuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IExFQVNFUyA9IG5ldyBBcGlSZXNvdXJjZSh7XG4gICAgYXBpR3JvdXA6ICdjb29yZGluYXRpb24uazhzLmlvJyxcbiAgICByZXNvdXJjZVR5cGU6ICdsZWFzZXMnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBFbmRwb2ludFNsaWNlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBFTkRQT0lOVF9TTElDRVMgPSBuZXcgQXBpUmVzb3VyY2Uoe1xuICAgIGFwaUdyb3VwOiAnZGlzY292ZXJ5Lms4cy5pbycsXG4gICAgcmVzb3VyY2VUeXBlOiAnZW5kcG9pbnRzbGljZXMnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBGbG93U2NoZW1hLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBGTE9XX1NDSEVNQVMgPSBuZXcgQXBpUmVzb3VyY2Uoe1xuICAgIGFwaUdyb3VwOiAnZmxvd2NvbnRyb2wuYXBpc2VydmVyLms4cy5pbycsXG4gICAgcmVzb3VyY2VUeXBlOiAnZmxvd3NjaGVtYXMnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBQcmlvcml0eUxldmVsQ29uZmlndXJhdGlvbi5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUFJJT1JJVFlfTEVWRUxfQ09ORklHVVJBVElPTlMgPSBuZXcgQXBpUmVzb3VyY2Uoe1xuICAgIGFwaUdyb3VwOiAnZmxvd2NvbnRyb2wuYXBpc2VydmVyLms4cy5pbycsXG4gICAgcmVzb3VyY2VUeXBlOiAncHJpb3JpdHlsZXZlbGNvbmZpZ3VyYXRpb25zJyxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFQSSByZXNvdXJjZSBpbmZvcm1hdGlvbiBmb3IgSW5ncmVzc0NsYXNzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBJTkdSRVNTX0NMQVNTRVMgPSBuZXcgQXBpUmVzb3VyY2Uoe1xuICAgIGFwaUdyb3VwOiAnbmV0d29ya2luZy5rOHMuaW8nLFxuICAgIHJlc291cmNlVHlwZTogJ2luZ3Jlc3NjbGFzc2VzJyxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFQSSByZXNvdXJjZSBpbmZvcm1hdGlvbiBmb3IgSW5ncmVzcy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgSU5HUkVTU0VTID0gbmV3IEFwaVJlc291cmNlKHtcbiAgICBhcGlHcm91cDogJ25ldHdvcmtpbmcuazhzLmlvJyxcbiAgICByZXNvdXJjZVR5cGU6ICdpbmdyZXNzZXMnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBOZXR3b3JrUG9saWN5LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBORVRXT1JLX1BPTElDSUVTID0gbmV3IEFwaVJlc291cmNlKHtcbiAgICBhcGlHcm91cDogJ25ldHdvcmtpbmcuazhzLmlvJyxcbiAgICByZXNvdXJjZVR5cGU6ICduZXR3b3JrcG9saWNpZXMnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBSdW50aW1lQ2xhc3MuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFJVTlRJTUVfQ0xBU1NFUyA9IG5ldyBBcGlSZXNvdXJjZSh7XG4gICAgYXBpR3JvdXA6ICdub2RlLms4cy5pbycsXG4gICAgcmVzb3VyY2VUeXBlOiAncnVudGltZWNsYXNzZXMnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBQb2REaXNydXB0aW9uQnVkZ2V0LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBQT0RfRElTUlVQVElPTl9CVURHRVRTID0gbmV3IEFwaVJlc291cmNlKHtcbiAgICBhcGlHcm91cDogJ3BvbGljeScsXG4gICAgcmVzb3VyY2VUeXBlOiAncG9kZGlzcnVwdGlvbmJ1ZGdldHMnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBQb2RTZWN1cml0eVBvbGljeS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUE9EX1NFQ1VSSVRZX1BPTElDSUVTID0gbmV3IEFwaVJlc291cmNlKHtcbiAgICBhcGlHcm91cDogJ3BvbGljeScsXG4gICAgcmVzb3VyY2VUeXBlOiAncG9kc2VjdXJpdHlwb2xpY2llcycsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBUEkgcmVzb3VyY2UgaW5mb3JtYXRpb24gZm9yIENsdXN0ZXJSb2xlQmluZGluZy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgQ0xVU1RFUl9ST0xFX0JJTkRJTkdTID0gbmV3IEFwaVJlc291cmNlKHtcbiAgICBhcGlHcm91cDogJ3JiYWMuYXV0aG9yaXphdGlvbi5rOHMuaW8nLFxuICAgIHJlc291cmNlVHlwZTogJ2NsdXN0ZXJyb2xlYmluZGluZ3MnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBDbHVzdGVyUm9sZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgQ0xVU1RFUl9ST0xFUyA9IG5ldyBBcGlSZXNvdXJjZSh7XG4gICAgYXBpR3JvdXA6ICdyYmFjLmF1dGhvcml6YXRpb24uazhzLmlvJyxcbiAgICByZXNvdXJjZVR5cGU6ICdjbHVzdGVycm9sZXMnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBSb2xlQmluZGluZy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUk9MRV9CSU5ESU5HUyA9IG5ldyBBcGlSZXNvdXJjZSh7XG4gICAgYXBpR3JvdXA6ICdyYmFjLmF1dGhvcml6YXRpb24uazhzLmlvJyxcbiAgICByZXNvdXJjZVR5cGU6ICdyb2xlYmluZGluZ3MnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBSb2xlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBST0xFUyA9IG5ldyBBcGlSZXNvdXJjZSh7XG4gICAgYXBpR3JvdXA6ICdyYmFjLmF1dGhvcml6YXRpb24uazhzLmlvJyxcbiAgICByZXNvdXJjZVR5cGU6ICdyb2xlcycsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBUEkgcmVzb3VyY2UgaW5mb3JtYXRpb24gZm9yIFByaW9yaXR5Q2xhc3MuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFBSSU9SSVRZX0NMQVNTRVMgPSBuZXcgQXBpUmVzb3VyY2Uoe1xuICAgIGFwaUdyb3VwOiAnc2NoZWR1bGluZy5rOHMuaW8nLFxuICAgIHJlc291cmNlVHlwZTogJ3ByaW9yaXR5Y2xhc3NlcycsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBUEkgcmVzb3VyY2UgaW5mb3JtYXRpb24gZm9yIENTSURyaXZlci5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgQ1NJX0RSSVZFUlMgPSBuZXcgQXBpUmVzb3VyY2Uoe1xuICAgIGFwaUdyb3VwOiAnc3RvcmFnZS5rOHMuaW8nLFxuICAgIHJlc291cmNlVHlwZTogJ2NzaWRyaXZlcnMnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBDU0lOb2RlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBDU0lfTk9ERVMgPSBuZXcgQXBpUmVzb3VyY2Uoe1xuICAgIGFwaUdyb3VwOiAnc3RvcmFnZS5rOHMuaW8nLFxuICAgIHJlc291cmNlVHlwZTogJ2NzaW5vZGVzJyxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFQSSByZXNvdXJjZSBpbmZvcm1hdGlvbiBmb3IgQ1NJU3RvcmFnZUNhcGFjaXR5LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBDU0lfU1RPUkFHRV9DQVBBQ0lUSUVTID0gbmV3IEFwaVJlc291cmNlKHtcbiAgICBhcGlHcm91cDogJ3N0b3JhZ2UuazhzLmlvJyxcbiAgICByZXNvdXJjZVR5cGU6ICdjc2lzdG9yYWdlY2FwYWNpdGllcycsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBUEkgcmVzb3VyY2UgaW5mb3JtYXRpb24gZm9yIFN0b3JhZ2VDbGFzcy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgU1RPUkFHRV9DTEFTU0VTID0gbmV3IEFwaVJlc291cmNlKHtcbiAgICBhcGlHcm91cDogJ3N0b3JhZ2UuazhzLmlvJyxcbiAgICByZXNvdXJjZVR5cGU6ICdzdG9yYWdlY2xhc3NlcycsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBUEkgcmVzb3VyY2UgaW5mb3JtYXRpb24gZm9yIFZvbHVtZUF0dGFjaG1lbnQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFZPTFVNRV9BVFRBQ0hNRU5UUyA9IG5ldyBBcGlSZXNvdXJjZSh7XG4gICAgYXBpR3JvdXA6ICdzdG9yYWdlLms4cy5pbycsXG4gICAgcmVzb3VyY2VUeXBlOiAndm9sdW1lYXR0YWNobWVudHMnLFxuICB9KTtcblxuICAvKipcbiAgICogQVBJIHJlc291cmNlIGluZm9ybWF0aW9uIGZvciBhIGN1c3RvbSByZXNvdXJjZSB0eXBlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBjdXN0b20ob3B0aW9uczogQXBpUmVzb3VyY2VPcHRpb25zKTogQXBpUmVzb3VyY2Uge1xuICAgIHJldHVybiBuZXcgQXBpUmVzb3VyY2Uob3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBncm91cCBwb3J0aW9uIG9mIHRoZSBBUEkgdmVyc2lvbiAoZS5nLiBgYXV0aG9yaXphdGlvbi5rOHMuaW9gKS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBhcGlHcm91cDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgcmVzb3VyY2UgdHlwZSBhcyBpdCBhcHBlYXJzIGluIHRoZSByZWxldmFudCBBUEkgZW5kcG9pbnQuXG4gICAqIEBleGFtcGxlIC0gXCJwb2RzXCIgb3IgXCJwb2RzL2xvZ1wiXG4gICAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvcmVmZXJlbmNlL2FjY2Vzcy1hdXRobi1hdXRoei9yYmFjLyNyZWZlcnJpbmctdG8tcmVzb3VyY2VzXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgcmVzb3VyY2VUeXBlOiBzdHJpbmc7XG5cbiAgcHVibGljIGFzQXBpUmVzb3VyY2UoKTogSUFwaVJlc291cmNlIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHB1YmxpYyBhc05vbkFwaVJlc291cmNlKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBwcml2YXRlIGNvbnN0cnVjdG9yKG9wdGlvbnM6IEFwaVJlc291cmNlT3B0aW9ucykge1xuICAgIHRoaXMuYXBpR3JvdXAgPSBvcHRpb25zLmFwaUdyb3VwO1xuICAgIHRoaXMucmVzb3VyY2VUeXBlID0gb3B0aW9ucy5yZXNvdXJjZVR5cGU7XG4gIH1cbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZvciBjcmVhdGluZyBub24gYXBpIHJlc291cmNlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIE5vbkFwaVJlc291cmNlIGltcGxlbWVudHMgSUFwaUVuZHBvaW50IHtcblxuICBwdWJsaWMgc3RhdGljIG9mKHVybDogc3RyaW5nKTogTm9uQXBpUmVzb3VyY2Uge1xuICAgIHJldHVybiBuZXcgTm9uQXBpUmVzb3VyY2UodXJsKTtcbiAgfVxuXG4gIHByaXZhdGUgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBub25SZXNvdXJjZVVybDogc3RyaW5nKSB7fTtcblxuICBwdWJsaWMgYXNBcGlSZXNvdXJjZSgpOiBJQXBpUmVzb3VyY2UgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBwdWJsaWMgYXNOb25BcGlSZXNvdXJjZSgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuXG4gICAgcmV0dXJuIHRoaXMubm9uUmVzb3VyY2VVcmw7XG4gIH1cbn0iXX0=

/***/ }),

/***/ 415:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ResourcePermissions = exports.Resource = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const constructs_1 = __nccwpck_require__(1963);
/**
 * Base class for all Kubernetes objects in stdk8s. Represents a single
 * resource.
 */
class Resource extends constructs_1.Construct {
    constructor(scope, id) {
        super(scope, id);
        this.permissions = new ResourcePermissions(this);
    }
    get metadata() {
        return this.apiObject.metadata;
    }
    /**
     * The name of this API object.
     */
    get name() {
        return this.apiObject.name;
    }
    /**
     * The object's API version (e.g. "authorization.k8s.io/v1")
     */
    get apiVersion() {
        return this.apiObject.apiVersion;
    }
    /**
     * The group portion of the API version (e.g. "authorization.k8s.io").
     */
    get apiGroup() {
        return this.apiObject.apiGroup;
    }
    /**
     * The object kind (e.g. "Deployment").
     */
    get kind() {
        return this.apiObject.kind;
    }
    get resourceName() {
        return this.name;
    }
    asApiResource() {
        return this;
    }
    asNonApiResource() {
        return undefined;
    }
}
exports.Resource = Resource;
_a = JSII_RTTI_SYMBOL_1;
Resource[_a] = { fqn: "cdk8s-plus-22.Resource", version: "2.0.0-rc.2" };
/**
 * Controls permissions for operations on resources.
 */
class ResourcePermissions {
    constructor(instance) {
        this.instance = instance;
    }
    /**
     * Grants the list of subjects permissions to read this resource.
     */
    grantRead(...subjects) {
        const subjectsAddress = utils_1.address(...subjects);
        const role = new r.Role(this.instance, `Role${subjectsAddress}`, {
            metadata: { namespace: this.instance.metadata.namespace },
        });
        role.allowRead(this.instance);
        return role.bind(...subjects);
    }
    /**
     * Grants the list of subjects permissions to read and write this resource.
     */
    grantReadWrite(...subjects) {
        const subjectsAddress = utils_1.address(...subjects);
        const role = new r.Role(this.instance, `Role${subjectsAddress}`, {
            metadata: { namespace: this.instance.metadata.namespace },
        });
        role.allowReadWrite(this.instance);
        return role.bind(...subjects);
    }
}
exports.ResourcePermissions = ResourcePermissions;
_b = JSII_RTTI_SYMBOL_1;
ResourcePermissions[_b] = { fqn: "cdk8s-plus-22.ResourcePermissions", version: "2.0.0-rc.2" };
// meh, avoiding errors due to circular imports...
const r = __nccwpck_require__(1886);
const utils_1 = __nccwpck_require__(6594);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9iYXNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0EsMkNBQW1EO0FBdUNuRDs7O0dBR0c7QUFDSCxNQUFzQixRQUFTLFNBQVEsc0JBQVM7SUFXOUMsWUFBbUIsS0FBZ0IsRUFBRSxFQUFVO1FBQzdDLEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDakIsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFRCxJQUFXLFFBQVE7UUFDakIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQztJQUNqQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFXLElBQUk7UUFDYixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDO0lBQzdCLENBQUM7SUFFRDs7T0FFRztJQUNILElBQVcsVUFBVTtRQUNuQixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDO0lBQ25DLENBQUM7SUFFRDs7T0FFRztJQUNILElBQVcsUUFBUTtRQUNqQixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDO0lBQ2pDLENBQUM7SUFFRDs7T0FFRztJQUNILElBQVcsSUFBSTtRQUNiLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUM7SUFDN0IsQ0FBQztJQUVELElBQVcsWUFBWTtRQUNyQixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDbkIsQ0FBQztJQUVNLGFBQWE7UUFDbEIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRU0sZ0JBQWdCO1FBQ3JCLE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7O0FBMURILDRCQTREQzs7O0FBRUQ7O0dBRUc7QUFDSCxNQUFhLG1CQUFtQjtJQUU5QixZQUErQixRQUFrQjtRQUFsQixhQUFRLEdBQVIsUUFBUSxDQUFVO0lBQUcsQ0FBQztJQUVyRDs7T0FFRztJQUNJLFNBQVMsQ0FBQyxHQUFHLFFBQXVCO1FBQ3pDLE1BQU0sZUFBZSxHQUFHLGVBQU8sQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDO1FBQzdDLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLE9BQU8sZUFBZSxFQUFFLEVBQUU7WUFDL0QsUUFBUSxFQUFFLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRTtTQUMxRCxDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM5QixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRUQ7O09BRUc7SUFDSSxjQUFjLENBQUMsR0FBRyxRQUF1QjtRQUM5QyxNQUFNLGVBQWUsR0FBRyxlQUFPLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQztRQUM3QyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxPQUFPLGVBQWUsRUFBRSxFQUFFO1lBQy9ELFFBQVEsRUFBRSxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUU7U0FDMUQsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDbkMsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUM7SUFDaEMsQ0FBQzs7QUExQkgsa0RBNEJDOzs7QUFFRCxrREFBa0Q7QUFDbEQsNEJBQTRCO0FBRTVCLG1DQUFrQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwaU9iamVjdE1ldGFkYXRhLCBBcGlPYmplY3QsIEFwaU9iamVjdE1ldGFkYXRhRGVmaW5pdGlvbiB9IGZyb20gJ2NkazhzJztcbmltcG9ydCB7IENvbnN0cnVjdCwgSUNvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xuaW1wb3J0IHsgSUFwaVJlc291cmNlLCBJQXBpRW5kcG9pbnQgfSBmcm9tICcuL2FwaS1yZXNvdXJjZS5nZW5lcmF0ZWQnO1xuXG4vKipcbiAqIEluaXRpYWxpemF0aW9uIHByb3BlcnRpZXMgZm9yIHJlc291cmNlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNvdXJjZVByb3BzIHtcbiAgLyoqXG4gICAqIE1ldGFkYXRhIHRoYXQgYWxsIHBlcnNpc3RlZCByZXNvdXJjZXMgbXVzdCBoYXZlLCB3aGljaCBpbmNsdWRlcyBhbGwgb2JqZWN0c1xuICAgKiB1c2VycyBtdXN0IGNyZWF0ZS5cbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogQXBpT2JqZWN0TWV0YWRhdGE7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHJlc291cmNlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElSZXNvdXJjZSBleHRlbmRzIElDb25zdHJ1Y3Qge1xuICAvKipcbiAgICogVGhlIEt1YmVybmV0ZXMgbmFtZSBvZiB0aGlzIHJlc291cmNlLlxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0J3MgQVBJIHZlcnNpb24gKGUuZy4gXCJhdXRob3JpemF0aW9uLms4cy5pby92MVwiKVxuICAgKi9cbiAgcmVhZG9ubHkgYXBpVmVyc2lvbjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZ3JvdXAgcG9ydGlvbiBvZiB0aGUgQVBJIHZlcnNpb24gKGUuZy4gXCJhdXRob3JpemF0aW9uLms4cy5pb1wiKVxuICAgKi9cbiAgcmVhZG9ubHkgYXBpR3JvdXA6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG9iamVjdCBraW5kIChlLmcuIFwiRGVwbG95bWVudFwiKS5cbiAgICovXG4gIHJlYWRvbmx5IGtpbmQ6IHN0cmluZztcbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgS3ViZXJuZXRlcyBvYmplY3RzIGluIHN0ZGs4cy4gUmVwcmVzZW50cyBhIHNpbmdsZVxuICogcmVzb3VyY2UuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZXNvdXJjZSBleHRlbmRzIENvbnN0cnVjdCBpbXBsZW1lbnRzIElSZXNvdXJjZSwgSUFwaVJlc291cmNlLCBJQXBpRW5kcG9pbnQge1xuXG4gIC8qKlxuICAgKiBUaGUgdW5kZXJseWluZyBjZGs4cyBBUEkgb2JqZWN0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHJlYWRvbmx5IGFwaU9iamVjdDogQXBpT2JqZWN0O1xuXG4gIHB1YmxpYyByZWFkb25seSBhYnN0cmFjdCByZXNvdXJjZVR5cGU6IHN0cmluZztcblxuICBwdWJsaWMgcmVhZG9ubHkgcGVybWlzc2lvbnM6IFJlc291cmNlUGVybWlzc2lvbnM7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcpIHtcbiAgICBzdXBlcihzY29wZSwgaWQpO1xuICAgIHRoaXMucGVybWlzc2lvbnMgPSBuZXcgUmVzb3VyY2VQZXJtaXNzaW9ucyh0aGlzKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgbWV0YWRhdGEoKTogQXBpT2JqZWN0TWV0YWRhdGFEZWZpbml0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5hcGlPYmplY3QubWV0YWRhdGE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhpcyBBUEkgb2JqZWN0LlxuICAgKi9cbiAgcHVibGljIGdldCBuYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuYXBpT2JqZWN0Lm5hbWU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG9iamVjdCdzIEFQSSB2ZXJzaW9uIChlLmcuIFwiYXV0aG9yaXphdGlvbi5rOHMuaW8vdjFcIilcbiAgICovXG4gIHB1YmxpYyBnZXQgYXBpVmVyc2lvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmFwaU9iamVjdC5hcGlWZXJzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBncm91cCBwb3J0aW9uIG9mIHRoZSBBUEkgdmVyc2lvbiAoZS5nLiBcImF1dGhvcml6YXRpb24uazhzLmlvXCIpLlxuICAgKi9cbiAgcHVibGljIGdldCBhcGlHcm91cCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmFwaU9iamVjdC5hcGlHcm91cDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IGtpbmQgKGUuZy4gXCJEZXBsb3ltZW50XCIpLlxuICAgKi9cbiAgcHVibGljIGdldCBraW5kKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuYXBpT2JqZWN0LmtpbmQ7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHJlc291cmNlTmFtZSgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICBwdWJsaWMgYXNBcGlSZXNvdXJjZSgpOiBJQXBpUmVzb3VyY2UgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcHVibGljIGFzTm9uQXBpUmVzb3VyY2UoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbn1cblxuLyoqXG4gKiBDb250cm9scyBwZXJtaXNzaW9ucyBmb3Igb3BlcmF0aW9ucyBvbiByZXNvdXJjZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBSZXNvdXJjZVBlcm1pc3Npb25zIHtcblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgcmVhZG9ubHkgaW5zdGFuY2U6IFJlc291cmNlKSB7fVxuXG4gIC8qKlxuICAgKiBHcmFudHMgdGhlIGxpc3Qgb2Ygc3ViamVjdHMgcGVybWlzc2lvbnMgdG8gcmVhZCB0aGlzIHJlc291cmNlLlxuICAgKi9cbiAgcHVibGljIGdyYW50UmVhZCguLi5zdWJqZWN0czogcmIuSVN1YmplY3RbXSk6IHJiLlJvbGVCaW5kaW5nIHtcbiAgICBjb25zdCBzdWJqZWN0c0FkZHJlc3MgPSBhZGRyZXNzKC4uLnN1YmplY3RzKTtcbiAgICBjb25zdCByb2xlID0gbmV3IHIuUm9sZSh0aGlzLmluc3RhbmNlLCBgUm9sZSR7c3ViamVjdHNBZGRyZXNzfWAsIHtcbiAgICAgIG1ldGFkYXRhOiB7IG5hbWVzcGFjZTogdGhpcy5pbnN0YW5jZS5tZXRhZGF0YS5uYW1lc3BhY2UgfSxcbiAgICB9KTtcbiAgICByb2xlLmFsbG93UmVhZCh0aGlzLmluc3RhbmNlKTtcbiAgICByZXR1cm4gcm9sZS5iaW5kKC4uLnN1YmplY3RzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHcmFudHMgdGhlIGxpc3Qgb2Ygc3ViamVjdHMgcGVybWlzc2lvbnMgdG8gcmVhZCBhbmQgd3JpdGUgdGhpcyByZXNvdXJjZS5cbiAgICovXG4gIHB1YmxpYyBncmFudFJlYWRXcml0ZSguLi5zdWJqZWN0czogcmIuSVN1YmplY3RbXSk6IHJiLlJvbGVCaW5kaW5nIHtcbiAgICBjb25zdCBzdWJqZWN0c0FkZHJlc3MgPSBhZGRyZXNzKC4uLnN1YmplY3RzKTtcbiAgICBjb25zdCByb2xlID0gbmV3IHIuUm9sZSh0aGlzLmluc3RhbmNlLCBgUm9sZSR7c3ViamVjdHNBZGRyZXNzfWAsIHtcbiAgICAgIG1ldGFkYXRhOiB7IG5hbWVzcGFjZTogdGhpcy5pbnN0YW5jZS5tZXRhZGF0YS5uYW1lc3BhY2UgfSxcbiAgICB9KTtcbiAgICByb2xlLmFsbG93UmVhZFdyaXRlKHRoaXMuaW5zdGFuY2UpO1xuICAgIHJldHVybiByb2xlLmJpbmQoLi4uc3ViamVjdHMpO1xuICB9XG5cbn1cblxuLy8gbWVoLCBhdm9pZGluZyBlcnJvcnMgZHVlIHRvIGNpcmN1bGFyIGltcG9ydHMuLi5cbmltcG9ydCAqIGFzIHIgZnJvbSAnLi9yb2xlJztcbmltcG9ydCAqIGFzIHJiIGZyb20gJy4vcm9sZS1iaW5kaW5nJztcbmltcG9ydCB7IGFkZHJlc3MgfSBmcm9tICcuL3V0aWxzJztcbiJdfQ==

/***/ }),

/***/ 9998:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigMap = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const configmap = __nccwpck_require__(7147);
const path = __nccwpck_require__(1017);
const cdk8s_1 = __nccwpck_require__(1227);
const constructs_1 = __nccwpck_require__(1963);
const minimatch_1 = __nccwpck_require__(7457);
const base = __nccwpck_require__(415);
const k8s = __nccwpck_require__(4879);
const utils_1 = __nccwpck_require__(6594);
class ImportedConfigMap extends constructs_1.Construct {
    constructor(scope, id, name) {
        super(scope, id);
        this._name = name;
    }
    get name() {
        return this._name;
    }
    get apiVersion() {
        return k8s.KubeConfigMap.GVK.apiVersion;
    }
    get apiGroup() {
        return '';
    }
    get kind() {
        return k8s.KubeConfigMap.GVK.kind;
    }
}
/**
 * ConfigMap holds configuration data for pods to consume.
 */
class ConfigMap extends base.Resource {
    constructor(scope, id, props = {}) {
        var _b, _c, _d;
        super(scope, id);
        this.resourceType = 'configmaps';
        this._binaryData = {};
        this._data = {};
        this.immutable = (_b = props.immutable) !== null && _b !== void 0 ? _b : false;
        this.apiObject = new k8s.KubeConfigMap(this, 'Resource', {
            metadata: props.metadata,
            // we need lazy here because we filter empty
            data: cdk8s_1.Lazy.any({ produce: () => this.synthesizeData() }),
            binaryData: cdk8s_1.Lazy.any({ produce: () => this.synthesizeBinaryData() }),
            immutable: this.immutable,
        });
        for (const [k, v] of Object.entries((_c = props.data) !== null && _c !== void 0 ? _c : {})) {
            this.addData(k, v);
        }
        for (const [k, v] of Object.entries((_d = props.binaryData) !== null && _d !== void 0 ? _d : {})) {
            this.addBinaryData(k, v);
        }
    }
    /**
     * Represents a ConfigMap created elsewhere.
     */
    static fromConfigMapName(scope, id, name) {
        return new ImportedConfigMap(scope, id, name);
    }
    /**
     * Adds a data entry to the config map.
     * @param key The key
     * @param value The value
     *
     * @throws if there is either a `data` or `binaryData` entry with the same key
     */
    addData(key, value) {
        this.verifyKeyAvailable(key);
        this._data[key] = value;
    }
    /**
     * The data associated with this config map.
     *
     * Returns an copy. To add data records, use `addData()` or `addBinaryData()`.
     */
    get data() {
        return { ...this._data };
    }
    /**
     * Adds a binary data entry to the config map. BinaryData can contain byte
     * sequences that are not in the UTF-8 range.
     * @param key The key
     * @param value The value
     *
     * @throws if there is either a `data` or `binaryData` entry with the same key
     */
    addBinaryData(key, value) {
        this.verifyKeyAvailable(key);
        this._binaryData[key] = value;
    }
    /**
     * The binary data associated with this config map.
     *
     * Returns a copy. To add data records, use `addBinaryData()` or `addData()`.
     */
    get binaryData() {
        return { ...this._binaryData };
    }
    /**
     * Adds a file to the ConfigMap.
     * @param localFile The path to the local file
     * @param key The ConfigMap key (default to the file name).
     */
    addFile(localFile, key) {
        key = key !== null && key !== void 0 ? key : path.basename(localFile);
        const value = configmap.readFileSync(localFile, 'utf-8');
        this.addData(key, value);
    }
    /**
     * Adds a directory to the ConfigMap.
     * @param localDir A path to a local directory
     * @param options Options
     */
    addDirectory(localDir, options = {}) {
        var _b, _c;
        const exclude = (_b = options.exclude) !== null && _b !== void 0 ? _b : [];
        const shouldInclude = (file) => {
            for (const pattern of exclude) {
                const mm = new minimatch_1.Minimatch(pattern);
                if (mm.match(file)) {
                    return false;
                }
            }
            return true;
        };
        const keyPrefix = (_c = options.keyPrefix) !== null && _c !== void 0 ? _c : '';
        for (const file of configmap.readdirSync(localDir)) {
            const filePath = path.join(localDir, file);
            if (configmap.statSync(filePath).isDirectory()) {
                continue;
            }
            if (!shouldInclude(file)) {
                continue;
            }
            const relativeFilePath = keyPrefix + file;
            this.addFile(filePath, relativeFilePath);
        }
    }
    verifyKeyAvailable(key) {
        if (key in this._data || key in this._binaryData) {
            throw new Error(`unable to add a ConfigMap entry with key "${key}". It is already used`);
        }
    }
    synthesizeData() {
        return utils_1.undefinedIfEmpty(this._data);
    }
    synthesizeBinaryData() {
        return utils_1.undefinedIfEmpty(this._binaryData);
    }
}
exports.ConfigMap = ConfigMap;
_a = JSII_RTTI_SYMBOL_1;
ConfigMap[_a] = { fqn: "cdk8s-plus-22.ConfigMap", version: "2.0.0-rc.2" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uZmlnLW1hcC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9jb25maWctbWFwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsZ0NBQWdDO0FBQ2hDLDZCQUE2QjtBQUM3QixpQ0FBd0M7QUFDeEMsMkNBQXVDO0FBQ3ZDLHlDQUFzQztBQUN0QywrQkFBK0I7QUFDL0IscUNBQXFDO0FBQ3JDLG1DQUEyQztBQStDM0MsTUFBTSxpQkFBa0IsU0FBUSxzQkFBUztJQUl2QyxZQUFZLEtBQWdCLEVBQUUsRUFBVSxFQUFFLElBQVk7UUFDcEQsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNqQixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztJQUNwQixDQUFDO0lBRUQsSUFBVyxJQUFJO1FBQ2IsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ3BCLENBQUM7SUFFRCxJQUFXLFVBQVU7UUFDbkIsT0FBTyxHQUFHLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUM7SUFDMUMsQ0FBQztJQUVELElBQVcsUUFBUTtRQUNqQixPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFFRCxJQUFXLElBQUk7UUFDYixPQUFPLEdBQUcsQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztJQUNwQyxDQUFDO0NBRUY7QUFFRDs7R0FFRztBQUNILE1BQWEsU0FBVSxTQUFRLElBQUksQ0FBQyxRQUFRO0lBd0IxQyxZQUFtQixLQUFnQixFQUFFLEVBQVUsRUFBRSxRQUF3QixFQUFHOztRQUMxRSxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBWEgsaUJBQVksR0FBRyxZQUFZLENBQUM7UUFFM0IsZ0JBQVcsR0FBOEIsRUFBRyxDQUFDO1FBQzdDLFVBQUssR0FBOEIsRUFBRyxDQUFDO1FBVXRELElBQUksQ0FBQyxTQUFTLFNBQUcsS0FBSyxDQUFDLFNBQVMsbUNBQUksS0FBSyxD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KiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgQXBpT2JqZWN0LCBMYXp5IH0gZnJvbSAnY2RrOHMnO1xuaW1wb3J0IHsgQ29uc3RydWN0IH0gZnJvbSAnY29uc3RydWN0cyc7XG5pbXBvcnQgeyBNaW5pbWF0Y2ggfSBmcm9tICdtaW5pbWF0Y2gnO1xuaW1wb3J0ICogYXMgYmFzZSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0ICogYXMgazhzIGZyb20gJy4vaW1wb3J0cy9rOHMnO1xuaW1wb3J0IHsgdW5kZWZpbmVkSWZFbXB0eSB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIFByb3BlcnRpZXMgZm9yIGluaXRpYWxpemF0aW9uIG9mIGBDb25maWdNYXBgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbmZpZ01hcFByb3BzIGV4dGVuZHMgYmFzZS5SZXNvdXJjZVByb3BzIHtcbiAgLyoqXG4gICAqIEJpbmFyeURhdGEgY29udGFpbnMgdGhlIGJpbmFyeSBkYXRhLlxuICAgKlxuICAgKiBFYWNoIGtleSBtdXN0IGNvbnNpc3Qgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMsICctJywgJ18nIG9yICcuJy5cbiAgICogQmluYXJ5RGF0YSBjYW4gY29udGFpbiBieXRlIHNlcXVlbmNlcyB0aGF0IGFyZSBub3QgaW4gdGhlIFVURi04IHJhbmdlLiBUaGVcbiAgICoga2V5cyBzdG9yZWQgaW4gQmluYXJ5RGF0YSBtdXN0IG5vdCBvdmVybGFwIHdpdGggdGhlIG9uZXMgaW4gdGhlIERhdGEgZmllbGQsXG4gICAqIHRoaXMgaXMgZW5mb3JjZWQgZHVyaW5nIHZhbGlkYXRpb24gcHJvY2Vzcy5cbiAgICpcbiAgICogWW91IGNhbiBhbHNvIGFkZCBiaW5hcnkgZGF0YSB1c2luZyBgY29uZmlnTWFwLmFkZEJpbmFyeURhdGEoKWAuXG4gICAqL1xuICByZWFkb25seSBiaW5hcnlEYXRhPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcblxuICAvKipcbiAgICogRGF0YSBjb250YWlucyB0aGUgY29uZmlndXJhdGlvbiBkYXRhLlxuICAgKlxuICAgKiBFYWNoIGtleSBtdXN0IGNvbnNpc3Qgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMsICctJywgJ18nIG9yICcuJy4gVmFsdWVzXG4gICAqIHdpdGggbm9uLVVURi04IGJ5dGUgc2VxdWVuY2VzIG11c3QgdXNlIHRoZSBCaW5hcnlEYXRhIGZpZWxkLiBUaGUga2V5c1xuICAgKiBzdG9yZWQgaW4gRGF0YSBtdXN0IG5vdCBvdmVybGFwIHdpdGggdGhlIGtleXMgaW4gdGhlIEJpbmFyeURhdGEgZmllbGQsIHRoaXNcbiAgICogaXMgZW5mb3JjZWQgZHVyaW5nIHZhbGlkYXRpb24gcHJvY2Vzcy5cbiAgICpcbiAgICogWW91IGNhbiBhbHNvIGFkZCBkYXRhIHVzaW5nIGBjb25maWdNYXAuYWRkRGF0YSgpYC5cbiAgICovXG4gIHJlYWRvbmx5IGRhdGE/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXG4gIC8qKlxuICAgKiBJZiBzZXQgdG8gdHJ1ZSwgZW5zdXJlcyB0aGF0IGRhdGEgc3RvcmVkIGluIHRoZSBDb25maWdNYXAgY2Fubm90IGJlIHVwZGF0ZWQgKG9ubHkgb2JqZWN0IG1ldGFkYXRhIGNhbiBiZSBtb2RpZmllZCkuXG4gICAqIElmIG5vdCBzZXQgdG8gdHJ1ZSwgdGhlIGZpZWxkIGNhbiBiZSBtb2RpZmllZCBhdCBhbnkgdGltZS5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IGltbXV0YWJsZT86IGJvb2xlYW47XG5cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY29uZmlnIG1hcC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJQ29uZmlnTWFwIGV4dGVuZHMgYmFzZS5JUmVzb3VyY2Uge1xuXG59XG5cbmNsYXNzIEltcG9ydGVkQ29uZmlnTWFwIGV4dGVuZHMgQ29uc3RydWN0IGltcGxlbWVudHMgSUNvbmZpZ01hcCB7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBfbmFtZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIG5hbWU6IHN0cmluZykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCk7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIH1cblxuICBwdWJsaWMgZ2V0IG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYXBpVmVyc2lvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiBrOHMuS3ViZUNvbmZpZ01hcC5HVksuYXBpVmVyc2lvbjtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYXBpR3JvdXAoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGtpbmQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gazhzLkt1YmVDb25maWdNYXAuR1ZLLmtpbmQ7XG4gIH1cblxufVxuXG4vKipcbiAqIENvbmZpZ01hcCBob2xkcyBjb25maWd1cmF0aW9uIGRhdGEgZm9yIHBvZHMgdG8gY29uc3VtZS5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbmZpZ01hcCBleHRlbmRzIGJhc2UuUmVzb3VyY2UgaW1wbGVtZW50cyBJQ29uZmlnTWFwIHtcblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIENvbmZpZ01hcCBjcmVhdGVkIGVsc2V3aGVyZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbUNvbmZpZ01hcE5hbWUoc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgbmFtZTogc3RyaW5nKTogSUNvbmZpZ01hcCB7XG4gICAgcmV0dXJuIG5ldyBJbXBvcnRlZENvbmZpZ01hcChzY29wZSwgaWQsIG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgYmFzZS5SZXNvdXJjZS5hcGlPYmplY3RcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBhcGlPYmplY3Q6IEFwaU9iamVjdDtcblxuICBwdWJsaWMgcmVhZG9ubHkgcmVzb3VyY2VUeXBlID0gJ2NvbmZpZ21hcHMnO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgX2JpbmFyeURhdGE6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7IH07XG4gIHByaXZhdGUgcmVhZG9ubHkgX2RhdGE6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7IH07XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoaXMgY29uZmlnIG1hcCBpcyBpbW11dGFibGUuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgaW1tdXRhYmxlOiBib29sZWFuO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogQ29uZmlnTWFwUHJvcHMgPSB7IH0pIHtcbiAgICBzdXBlcihzY29wZSwgaWQpO1xuXG4gICAgdGhpcy5pbW11dGFibGUgPSBwcm9wcy5pbW11dGFibGUgPz8gZmFsc2U7XG4gICAgdGhpcy5hcGlPYmplY3QgPSBuZXcgazhzLkt1YmVDb25maWdNYXAodGhpcywgJ1Jlc291cmNlJywge1xuICAgICAgbWV0YWRhdGE6IHByb3BzLm1ldGFkYXRhLFxuXG4gICAgICAvLyB3ZSBuZWVkIGxhenkgaGVyZSBiZWNhdXNlIHdlIGZpbHRlciBlbXB0eVxuICAgICAgZGF0YTogTGF6eS5hbnkoeyBwcm9kdWNlOiAoKSA9PiB0aGlzLnN5bnRoZXNpemVEYXRhKCkgfSksXG4gICAgICBiaW5hcnlEYXRhOiBMYXp5LmFueSh7IHByb2R1Y2U6ICgpID0+IHRoaXMuc3ludGhlc2l6ZUJpbmFyeURhdGEoKSB9KSxcbiAgICAgIGltbXV0YWJsZTogdGhpcy5pbW11dGFibGUsXG4gICAgfSk7XG5cbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhwcm9wcy5kYXRhID8/IHsgfSkpIHtcbiAgICAgIHRoaXMuYWRkRGF0YShrLCB2KTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhwcm9wcy5iaW5hcnlEYXRhID8/IHsgfSkpIHtcbiAgICAgIHRoaXMuYWRkQmluYXJ5RGF0YShrLCB2KTtcbiAgICB9XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgZGF0YSBlbnRyeSB0byB0aGUgY29uZmlnIG1hcC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5XG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWVcbiAgICpcbiAgICogQHRocm93cyBpZiB0aGVyZSBpcyBlaXRoZXIgYSBgZGF0YWAgb3IgYGJpbmFyeURhdGFgIGVudHJ5IHdpdGggdGhlIHNhbWUga2V5XG4gICAqL1xuICBwdWJsaWMgYWRkRGF0YShrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMudmVyaWZ5S2V5QXZhaWxhYmxlKGtleSk7XG5cbiAgICB0aGlzLl9kYXRhW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb25maWcgbWFwLlxuICAgKlxuICAgKiBSZXR1cm5zIGFuIGNvcHkuIFRvIGFkZCBkYXRhIHJlY29yZHMsIHVzZSBgYWRkRGF0YSgpYCBvciBgYWRkQmluYXJ5RGF0YSgpYC5cbiAgICovXG4gIHB1YmxpYyBnZXQgZGF0YSgpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICByZXR1cm4geyAuLi50aGlzLl9kYXRhIH07XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGJpbmFyeSBkYXRhIGVudHJ5IHRvIHRoZSBjb25maWcgbWFwLiBCaW5hcnlEYXRhIGNhbiBjb250YWluIGJ5dGVcbiAgICogc2VxdWVuY2VzIHRoYXQgYXJlIG5vdCBpbiB0aGUgVVRGLTggcmFuZ2UuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleVxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlXG4gICAqXG4gICAqIEB0aHJvd3MgaWYgdGhlcmUgaXMgZWl0aGVyIGEgYGRhdGFgIG9yIGBiaW5hcnlEYXRhYCBlbnRyeSB3aXRoIHRoZSBzYW1lIGtleVxuICAgKi9cbiAgcHVibGljIGFkZEJpbmFyeURhdGEoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLnZlcmlmeUtleUF2YWlsYWJsZShrZXkpO1xuXG4gICAgdGhpcy5fYmluYXJ5RGF0YVtrZXldID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJpbmFyeSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbmZpZyBtYXAuXG4gICAqXG4gICAqIFJldHVybnMgYSBjb3B5LiBUbyBhZGQgZGF0YSByZWNvcmRzLCB1c2UgYGFkZEJpbmFyeURhdGEoKWAgb3IgYGFkZERhdGEoKWAuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGJpbmFyeURhdGEoKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5fYmluYXJ5RGF0YSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBmaWxlIHRvIHRoZSBDb25maWdNYXAuXG4gICAqIEBwYXJhbSBsb2NhbEZpbGUgVGhlIHBhdGggdG8gdGhlIGxvY2FsIGZpbGVcbiAgICogQHBhcmFtIGtleSBUaGUgQ29uZmlnTWFwIGtleSAoZGVmYXVsdCB0byB0aGUgZmlsZSBuYW1lKS5cbiAgICovXG4gIHB1YmxpYyBhZGRGaWxlKGxvY2FsRmlsZTogc3RyaW5nLCBrZXk/OiBzdHJpbmcpIHtcbiAgICBrZXkgPSBrZXkgPz8gcGF0aC5iYXNlbmFtZShsb2NhbEZpbGUpO1xuICAgIGNvbnN0IHZhbHVlID0gY29uZmlnbWFwLnJlYWRGaWxlU3luYyhsb2NhbEZpbGUsICd1dGYtOCcpO1xuXG4gICAgdGhpcy5hZGREYXRhKGtleSwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBkaXJlY3RvcnkgdG8gdGhlIENvbmZpZ01hcC5cbiAgICogQHBhcmFtIGxvY2FsRGlyIEEgcGF0aCB0byBhIGxvY2FsIGRpcmVjdG9yeVxuICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zXG4gICAqL1xuICBwdWJsaWMgYWRkRGlyZWN0b3J5KGxvY2FsRGlyOiBzdHJpbmcsIG9wdGlvbnM6IEFkZERpcmVjdG9yeU9wdGlvbnMgPSB7IH0pIHtcbiAgICBjb25zdCBleGNsdWRlID0gb3B0aW9ucy5leGNsdWRlID8/IFtdO1xuICAgIGNvbnN0IHNob3VsZEluY2x1ZGUgPSAoZmlsZTogc3RyaW5nKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgZXhjbHVkZSkge1xuICAgICAgICBjb25zdCBtbSA9IG5ldyBNaW5pbWF0Y2gocGF0dGVybik7XG4gICAgICAgIGlmIChtbS5tYXRjaChmaWxlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIGNvbnN0IGtleVByZWZpeCA9IG9wdGlvbnMua2V5UHJlZml4ID8/ICcnO1xuICAgIGZvciAoY29uc3QgZmlsZSBvZiBjb25maWdtYXAucmVhZGRpclN5bmMobG9jYWxEaXIpKSB7XG5cbiAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKGxvY2FsRGlyLCBmaWxlKTtcblxuICAgICAgaWYgKGNvbmZpZ21hcC5zdGF0U3luYyhmaWxlUGF0aCkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzaG91bGRJbmNsdWRlKGZpbGUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZWxhdGl2ZUZpbGVQYXRoID0ga2V5UHJlZml4ICsgZmlsZTtcbiAgICAgIHRoaXMuYWRkRmlsZShmaWxlUGF0aCwgcmVsYXRpdmVGaWxlUGF0aCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB2ZXJpZnlLZXlBdmFpbGFibGUoa2V5OiBzdHJpbmcpIHtcbiAgICBpZiAoa2V5IGluIHRoaXMuX2RhdGEgfHwga2V5IGluIHRoaXMuX2JpbmFyeURhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5hYmxlIHRvIGFkZCBhIENvbmZpZ01hcCBlbnRyeSB3aXRoIGtleSBcIiR7a2V5fVwiLiBJdCBpcyBhbHJlYWR5IHVzZWRgKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN5bnRoZXNpemVEYXRhKCkge1xuICAgIHJldHVybiB1bmRlZmluZWRJZkVtcHR5KHRoaXMuX2RhdGEpO1xuICB9XG5cbiAgcHJpdmF0ZSBzeW50aGVzaXplQmluYXJ5RGF0YSgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkSWZFbXB0eSh0aGlzLl9iaW5hcnlEYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGBjb25maWdtYXAuYWRkRGlyZWN0b3J5KClgXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWRkRGlyZWN0b3J5T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBBIHByZWZpeCB0byBhZGQgdG8gYWxsIGtleXMgaW4gdGhlIGNvbmZpZyBtYXAuXG4gICAqIEBkZWZhdWx0IFwiXCJcbiAgICovXG4gIHJlYWRvbmx5IGtleVByZWZpeD86IHN0cmluZztcblxuICAvKipcbiAgICogR2xvYiBwYXR0ZXJucyB0byBleGNsdWRlIHdoZW4gYWRkaW5nIGZpbGVzLlxuICAgKiBAZGVmYXVsdCAtIGluY2x1ZGUgYWxsIGZpbGVzXG4gICAqL1xuICByZWFkb25seSBleGNsdWRlPzogc3RyaW5nW107XG59XG4iXX0=

/***/ }),

/***/ 4255:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Env = exports.extractContainerPorts = exports.EnvFrom = exports.Cpu = exports.MountPropagation = exports.Container = exports.ImagePullPolicy = exports.EnvValue = exports.ResourceFieldPaths = exports.EnvFieldPaths = exports.ContainerSecurityContext = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const k8s = __nccwpck_require__(4879);
const utils_1 = __nccwpck_require__(6594);
/**
 * Container security attributes and settings.
 */
class ContainerSecurityContext {
    constructor(props = {}) {
        var _g, _h, _j;
        this.ensureNonRoot = (_g = props.ensureNonRoot) !== null && _g !== void 0 ? _g : false;
        this.privileged = (_h = props.privileged) !== null && _h !== void 0 ? _h : false;
        this.readOnlyRootFilesystem = (_j = props.readOnlyRootFilesystem) !== null && _j !== void 0 ? _j : false;
        this.user = props.user;
        this.group = props.group;
    }
    /**
     * @internal
     */
    _toKube() {
        return {
            runAsGroup: this.group,
            runAsUser: this.user,
            runAsNonRoot: this.ensureNonRoot,
            privileged: this.privileged,
            readOnlyRootFilesystem: this.readOnlyRootFilesystem,
        };
    }
}
exports.ContainerSecurityContext = ContainerSecurityContext;
_a = JSII_RTTI_SYMBOL_1;
ContainerSecurityContext[_a] = { fqn: "cdk8s-plus-22.ContainerSecurityContext", version: "2.0.0-rc.2" };
var EnvFieldPaths;
(function (EnvFieldPaths) {
    /**
     * The name of the pod.
     */
    EnvFieldPaths["POD_NAME"] = "metadata.name";
    /**
     * The namespace of the pod.
     */
    EnvFieldPaths["POD_NAMESPACE"] = "metadata.namespace";
    /**
     * The uid of the pod.
     */
    EnvFieldPaths["POD_UID"] = "metadata.uid";
    /**
     * The labels of the pod.
     */
    EnvFieldPaths["POD_LABEL"] = "metadata.labels";
    /**
     * The annotations of the pod.
     */
    EnvFieldPaths["POD_ANNOTATION"] = "metadata.annotations";
    /**
     * The ipAddress of the pod.
     */
    EnvFieldPaths["POD_IP"] = "status.podIP";
    /**
     * The service account name of the pod.
     */
    EnvFieldPaths["SERVICE_ACCOUNT_NAME"] = "spec.serviceAccountName";
    /**
     * The name of the node.
     */
    EnvFieldPaths["NODE_NAME"] = "spec.nodeName";
    /**
     * The ipAddress of the node.
     */
    EnvFieldPaths["NODE_IP"] = "status.hostIP";
    /**
     * The ipAddresess of the pod.
     */
    EnvFieldPaths["POD_IPS"] = "status.podIPs";
})(EnvFieldPaths = exports.EnvFieldPaths || (exports.EnvFieldPaths = {}));
var ResourceFieldPaths;
(function (ResourceFieldPaths) {
    /**
     * CPU limit of the container.
     */
    ResourceFieldPaths["CPU_LIMIT"] = "limits.cpu";
    /**
     * Memory limit of the container.
     */
    ResourceFieldPaths["MEMORY_LIMIT"] = "limits.memory";
    /**
     * CPU request of the container.
     */
    ResourceFieldPaths["CPU_REQUEST"] = "requests.cpu";
    /**
     * Memory request of the container.
     */
    ResourceFieldPaths["MEMORY_REQUEST"] = "requests.memory";
    /**
     * Ephemeral storage limit of the container.
     */
    ResourceFieldPaths["STORAGE_LIMIT"] = "limits.ephemeral-storage";
    /**
     * Ephemeral storage request of the container.
     */
    ResourceFieldPaths["STORAGE_REQUEST"] = "requests.ephemeral-storage";
})(ResourceFieldPaths = exports.ResourceFieldPaths || (exports.ResourceFieldPaths = {}));
/**
 * Utility class for creating reading env values from various sources.
 */
class EnvValue {
    constructor(value, valueFrom) {
        this.value = value;
        this.valueFrom = valueFrom;
    }
    /**
     * Create a value by reading a specific key inside a config map.
     *
     * @param configMap - The config map.
     * @param key - The key to extract the value from.
     * @param options - Additional options.
     */
    static fromConfigMap(configMap, key, options = {}) {
        const source = {
            configMapKeyRef: {
                name: configMap.name,
                key,
                optional: options.optional,
            },
        };
        return new EnvValue(undefined, source);
    }
    /**
     * Defines an environment value from a secret JSON value.
     *
     * @param secretValue The secret value (secrent + key)
     * @param options Additional options
     */
    static fromSecretValue(secretValue, options = {}) {
        const source = {
            secretKeyRef: {
                name: secretValue.secret.name,
                key: secretValue.key,
                optional: options.optional,
            },
        };
        return new EnvValue(undefined, source);
    }
    /**
     * Create a value from the given argument.
     *
     * @param value - The value.
     */
    static fromValue(value) {
        return new EnvValue(value);
    }
    /**
     *
     * Create a value from a field reference.
     *
     * @param fieldPath: The field reference.
     * @param options: Additional options.
     */
    static fromFieldRef(fieldPath, options = {}) {
        let needsKey = false;
        if (fieldPath === EnvFieldPaths.POD_LABEL || fieldPath === EnvFieldPaths.POD_ANNOTATION) {
            needsKey = true;
        }
        if (needsKey && options.key === undefined) {
            throw new Error(`${fieldPath} requires a key`);
        }
        const source = {
            fieldRef: {
                fieldPath: (`${fieldPath}` + (needsKey ? `['${options.key}']` : '')),
                ...(options.apiVersion ? { apiVersion: options.apiVersion } : {}),
            },
        };
        return new EnvValue(undefined, source);
    }
    /**
     * Create a value from a resource.
     *
     * @param resource: Resource to select the value from.
     * @param options: Additional options.
     */
    static fromResource(resource, options = {}) {
        const source = {
            resourceFieldRef: {
                resource: `${resource}`,
                ...(options.divisor ? { divisor: k8s.IntOrString.fromString(options.divisor) } : {}),
                ...(options.container ? { containerName: options.container.name } : {}),
            },
        };
        return new EnvValue(undefined, source);
    }
    /**
     * Create a value from a key in the current process environment.
     *
     * @param key - The key to read.
     * @param options - Additional options.
     */
    static fromProcess(key, options = {}) {
        const value = process.env[key];
        if (options.required && !value) {
            throw new Error(`Missing ${key} env variable`);
        }
        return EnvValue.fromValue(value);
    }
}
exports.EnvValue = EnvValue;
_b = JSII_RTTI_SYMBOL_1;
EnvValue[_b] = { fqn: "cdk8s-plus-22.EnvValue", version: "2.0.0-rc.2" };
var ImagePullPolicy;
(function (ImagePullPolicy) {
    /**
     * Every time the kubelet launches a container, the kubelet queries the container image registry
     * to resolve the name to an image digest. If the kubelet has a container image with that exact
     * digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads
     * (pulls) the image with the resolved digest, and uses that image to launch the container.
     *
     * Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or
     * the image tag is omitted.
     */
    ImagePullPolicy["ALWAYS"] = "Always";
    /**
     * The image is pulled only if it is not already present locally.
     *
     * Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but
     * not :latest
     */
    ImagePullPolicy["IF_NOT_PRESENT"] = "IfNotPresent";
    /**
     * The image is assumed to exist locally. No attempt is made to pull the image.
     */
    ImagePullPolicy["NEVER"] = "Never";
})(ImagePullPolicy = exports.ImagePullPolicy || (exports.ImagePullPolicy = {}));
/**
 * A single application container that you want to run within a pod.
 */
class Container {
    constructor(props) {
        var _g, _h, _j, _k, _l;
        if (props instanceof Container) {
            throw new Error('Attempted to construct a container from a Container object.');
        }
        this.name = (_g = props.name) !== null && _g !== void 0 ? _g : 'main';
        this.image = props.image;
        this.port = props.port;
        this._command = props.command;
        this._args = props.args;
        this._readiness = props.readiness;
        this._liveness = props.liveness;
        this._startup = props.startup;
        this._lifecycle = props.lifecycle;
        this.resources = props.resources;
        this.workingDir = props.workingDir;
        this.mounts = (_h = props.volumeMounts) !== null && _h !== void 0 ? _h : [];
        this.imagePullPolicy = (_j = props.imagePullPolicy) !== null && _j !== void 0 ? _j : ImagePullPolicy.ALWAYS;
        this.securityContext = new ContainerSecurityContext(props.securityContext);
        this.env = new Env((_k = props.envFrom) !== null && _k !== void 0 ? _k : [], (_l = props.envVariables) !== null && _l !== void 0 ? _l : {});
    }
    /**
     * Entrypoint array (the command to execute when the container starts).
     * @returns a copy of the entrypoint array, cannot be modified
     */
    get command() {
        return this._command ? [...this._command] : undefined;
    }
    /**
     * Arguments to the entrypoint.
     *
     * @returns a copy of the arguments array, cannot be modified.
     */
    get args() {
        return this._args ? [...this._args] : undefined;
    }
    /**
     * Mount a volume to a specific path so that it is accessible by the container.
     * Every pod that is configured to use this container will autmoatically have access to the volume.
     *
     * @param path - The desired path in the container.
     * @param storage - The storage to mount.
     */
    mount(path, storage, options = {}) {
        this.mounts.push({ path, volume: storage.asVolume(), ...options });
    }
    /**
     * @internal
     */
    _toKube() {
        var _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;
        const volumeMounts = [];
        for (const mount of this.mounts) {
            volumeMounts.push({
                name: mount.volume.name,
                mountPath: mount.path,
                readOnly: mount.readOnly,
                mountPropagation: mount.propagation,
                subPath: mount.subPath,
                subPathExpr: mount.subPathExpr,
            });
        }
        const ports = new Array();
        if (this.port) {
            ports.push({
                containerPort: this.port,
            });
        }
        // Resource requests and limits
        const cpuLimit = (_j = (_h = (_g = this.resources) === null || _g === void 0 ? void 0 : _g.cpu) === null || _h === void 0 ? void 0 : _h.limit) === null || _j === void 0 ? void 0 : _j.amount;
        const cpuRequest = (_m = (_l = (_k = this.resources) === null || _k === void 0 ? void 0 : _k.cpu) === null || _l === void 0 ? void 0 : _l.request) === null || _m === void 0 ? void 0 : _m.amount;
        const memoryLimit = (_p = (_o = this.resources) === null || _o === void 0 ? void 0 : _o.memory) === null || _p === void 0 ? void 0 : _p.limit;
        const memoryRequest = (_r = (_q = this.resources) === null || _q === void 0 ? void 0 : _q.memory) === null || _r === void 0 ? void 0 : _r.request;
        const limits = {};
        const requests = {};
        if (cpuLimit) {
            limits.cpu = k8s.Quantity.fromString(cpuLimit);
        }
        if (memoryLimit) {
            limits.memory = k8s.Quantity.fromString(memoryLimit.toMebibytes().toString() + 'Mi');
        }
        if (cpuRequest) {
            requests.cpu = k8s.Quantity.fromString(cpuRequest);
        }
        if (memoryRequest) {
            requests.memory = k8s.Quantity.fromString(memoryRequest.toMebibytes().toString() + 'Mi');
        }
        let resourceRequirements = undefined;
        if (Object.keys(limits).length > 0 || Object.keys(requests).length > 0) {
            resourceRequirements = {
                limits: limits,
                requests: requests,
            };
        }
        const env = this.env._toKube();
        return {
            name: this.name,
            image: this.image,
            imagePullPolicy: this.imagePullPolicy,
            ports: utils_1.undefinedIfEmpty(ports),
            volumeMounts: utils_1.undefinedIfEmpty(volumeMounts),
            command: this.command,
            args: this.args,
            workingDir: this.workingDir,
            env: env.variables,
            envFrom: env.from,
            readinessProbe: (_s = this._readiness) === null || _s === void 0 ? void 0 : _s._toKube(this),
            livenessProbe: (_t = this._liveness) === null || _t === void 0 ? void 0 : _t._toKube(this),
            startupProbe: (_u = this._startup) === null || _u === void 0 ? void 0 : _u._toKube(this),
            lifecycle: this._lifecycle ? {
                postStart: (_v = this._lifecycle.postStart) === null || _v === void 0 ? void 0 : _v._toKube(this),
                preStop: (_w = this._lifecycle.preStop) === null || _w === void 0 ? void 0 : _w._toKube(this),
            } : undefined,
            resources: resourceRequirements,
            securityContext: this.securityContext._toKube(),
        };
    }
}
exports.Container = Container;
_c = JSII_RTTI_SYMBOL_1;
Container[_c] = { fqn: "cdk8s-plus-22.Container", version: "2.0.0-rc.2" };
var MountPropagation;
(function (MountPropagation) {
    /**
     * This volume mount will not receive any subsequent mounts that are mounted
     * to this volume or any of its subdirectories by the host. In similar
     * fashion, no mounts created by the Container will be visible on the host.
     *
     * This is the default mode.
     *
     * This mode is equal to `private` mount propagation as described in the Linux
     * kernel documentation
     */
    MountPropagation["NONE"] = "None";
    /**
     * This volume mount will receive all subsequent mounts that are mounted to
     * this volume or any of its subdirectories.
     *
     * In other words, if the host mounts anything inside the volume mount, the
     * Container will see it mounted there.
     *
     * Similarly, if any Pod with Bidirectional mount propagation to the same
     * volume mounts anything there, the Container with HostToContainer mount
     * propagation will see it.
     *
     * This mode is equal to `rslave` mount propagation as described in the Linux
     * kernel documentation
     */
    MountPropagation["HOST_TO_CONTAINER"] = "HostToContainer";
    /**
     * This volume mount behaves the same the HostToContainer mount. In addition,
     * all volume mounts created by the Container will be propagated back to the
     * host and to all Containers of all Pods that use the same volume
     *
     * A typical use case for this mode is a Pod with a FlexVolume or CSI driver
     * or a Pod that needs to mount something on the host using a hostPath volume.
     *
     * This mode is equal to `rshared` mount propagation as described in the Linux
     * kernel documentation
     *
     * Caution: Bidirectional mount propagation can be dangerous. It can damage
     * the host operating system and therefore it is allowed only in privileged
     * Containers. Familiarity with Linux kernel behavior is strongly recommended.
     * In addition, any volume mounts created by Containers in Pods must be
     * destroyed (unmounted) by the Containers on termination.
     *
     */
    MountPropagation["BIDIRECTIONAL"] = "Bidirectional";
})(MountPropagation = exports.MountPropagation || (exports.MountPropagation = {}));
/**
 * Represents the amount of CPU.
 * The amount can be passed as millis or units.
 */
class Cpu {
    constructor(amount) {
        this.amount = amount;
    }
    static millis(amount) {
        return new Cpu(amount + 'm');
    }
    static units(amount) {
        return new Cpu(amount.toString());
    }
}
exports.Cpu = Cpu;
_d = JSII_RTTI_SYMBOL_1;
Cpu[_d] = { fqn: "cdk8s-plus-22.Cpu", version: "2.0.0-rc.2" };
/**
 * A collection of env variables defined in other resources.
 */
class EnvFrom {
    constructor(configMap, prefix, sec) {
        this.configMap = configMap;
        this.prefix = prefix;
        this.sec = sec;
    }
    ;
    /**
     * @internal
     */
    _toKube() {
        return {
            configMapRef: this.configMap ? {
                name: this.configMap.name,
            } : undefined,
            secretRef: this.sec ? {
                name: this.sec.name,
            } : undefined,
            prefix: this.prefix,
        };
    }
}
exports.EnvFrom = EnvFrom;
_e = JSII_RTTI_SYMBOL_1;
EnvFrom[_e] = { fqn: "cdk8s-plus-22.EnvFrom", version: "2.0.0-rc.2" };
function extractContainerPorts(selector) {
    if (!selector) {
        return [];
    }
    const ports = [];
    // we don't use instanceof intentionally since it can create
    // cyclic import problems.
    const containers = selector.containers;
    for (const con of containers !== null && containers !== void 0 ? containers : []) {
        if (con.port) {
            ports.push(con.port);
        }
    }
    return ports;
}
exports.extractContainerPorts = extractContainerPorts;
/**
 * Container environment variables.
 */
class Env {
    constructor(sources, variables) {
        this._sources = sources;
        this._variables = variables;
    }
    /**
     * Selects a ConfigMap to populate the environment variables with.
     * The contents of the target ConfigMap's Data field will represent
     * the key-value pairs as environment variables.
     */
    static fromConfigMap(configMap, prefix) {
        return new EnvFrom(configMap, prefix, undefined);
    }
    /**
     * Selects a Secret to populate the environment variables with.
     * The contents of the target Secret's Data field will represent
     * the key-value pairs as environment variables.
     */
    static fromSecret(secr) {
        return new EnvFrom(undefined, undefined, secr);
    }
    /**
     * Add a single variable by name and value.
     * The variable value can come from various dynamic sources such a secrets of config maps.
     * Use `EnvValue.fromXXX` to select sources.
     */
    addVariable(name, value) {
        this._variables[name] = value;
    }
    /**
     * The environment variables for this container.
     * Returns a copy. To add environment variables use `container.env.addVariable()`.
     */
    get variables() {
        return { ...this._variables };
    }
    /**
     * Add a collection of variables by copying from another source.
     * Use `Env.fromXXX` functions to select sources.
     */
    copyFrom(from) {
        this._sources.push(from);
    }
    /**
     * The list of sources used to populate the container environment,
     * in addition to the `variables`.
     *
     * Returns a copy. To add a source use `container.env.copyFrom()`.
     */
    get sources() {
        return [...this._sources];
    }
    renderEnv(env) {
        const result = new Array();
        for (const [name, v] of Object.entries(env)) {
            result.push({
                name,
                value: v.value,
                valueFrom: v.valueFrom,
            });
        }
        return result;
    }
    /**
     * @internal
     */
    _toKube() {
        return {
            from: utils_1.undefinedIfEmpty(this._sources.map(s => s._toKube())),
            variables: utils_1.undefinedIfEmpty(this.renderEnv(this._variables)),
        };
    }
}
exports.Env = Env;
_f = JSII_RTTI_SYMBOL_1;
Env[_f] = { fqn: "cdk8s-plus-22.Env", version: "2.0.0-rc.2" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGFpbmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2NvbnRhaW5lci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUdBLHFDQUFxQztBQUdyQyxtQ0FBMkM7QUErQzNDOztHQUVHO0FBQ0gsTUFBYSx3QkFBd0I7SUFRbkMsWUFBWSxRQUF1QyxFQUFFOztRQUNuRCxJQUFJLENBQUMsYUFBYSxTQUFHLEtBQUssQ0FBQyxhQUFhLG1DQUFJLEtBQUssQ0FBQztRQUNsRCxJQUFJLENBQUMsVUFBVSxTQUFHLEtBQUssQ0FBQyxVQUFVLG1DQUFJLEtBQUssQ0FBQztRQUM1QyxJQUFJLENBQUMsc0JBQXNCLFNBQUcsS0FBSyxDQUFDLHNCQUFzQixtQ0FBSSxLQUFLLENBQUM7UUFDcEUsSUFBSSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQztJQUMzQixDQUFDO0lBRUQ7O09BRUc7SUFDSSxPQUFPO1FBQ1osT0FBTztZQUNMLFVBQVUsRUFBRSxJQUFJLENBQUMsS0FBSztZQUN0QixTQUFTLEVBQUUsSUFBSSxDQUFDLElBQUk7WUFDcEIsWUFBWSxFQUFFLElBQUksQ0FBQyxhQUFhO1lBQ2hDLFVBQVUsRUFBRSxJQUFJLENBQUMsVUFBVTtZQUMzQixzQkFBc0IsRUFBRSxJQUFJLENBQUMsc0JBQXNCO1NBQ3BELENBQUM7SUFDSixDQUFDOztBQTNCSCw0REE2QkM7OztBQUVELElBQVksYUFrRFg7QUFsREQsV0FBWSxhQUFhO0lBQ3ZCOztPQUVHO0lBQ0gsMkNBQTBCLENBQUE7SUFFMUI7O09BRUc7SUFDSCxxREFBb0MsQ0FBQTtJQUVwQzs7T0FFRztJQUNILHlDQUF3QixDQUFBO0lBRXhCOztPQUVHO0lBQ0gsOENBQTZCLENBQUE7SUFFN0I7O09BRUc7SUFDSCx3REFBdUMsQ0FBQTtJQUV2Qzs7T0FFRztJQUNILHdDQUF1QixDQUFB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QUFNLENBQUM7SUFDaEIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksT0FBTztRQUNaLE9BQU87WUFDTCxJQUFJLEVBQUUsd0JBQWdCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztZQUMzRCxTQUFTLEVBQUUsd0JBQWdCLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDN0QsQ0FBQztJQUNKLENBQUM7O0FBbkZILGtCQW9GQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNpemUgYXMgY29udGFpbmVyIH0gZnJvbSAnY2RrOHMnO1xuaW1wb3J0ICogYXMgY29uZmlnbWFwIGZyb20gJy4vY29uZmlnLW1hcCc7XG5pbXBvcnQgKiBhcyBoYW5kbGVyIGZyb20gJy4vaGFuZGxlcic7XG5pbXBvcnQgKiBhcyBrOHMgZnJvbSAnLi9pbXBvcnRzL2s4cyc7XG5pbXBvcnQgKiBhcyBwcm9iZSBmcm9tICcuL3Byb2JlJztcbmltcG9ydCAqIGFzIHNlY3JldCBmcm9tICcuL3NlY3JldCc7XG5pbXBvcnQgeyB1bmRlZmluZWRJZkVtcHR5IH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgKiBhcyB2b2x1bWUgZnJvbSAnLi92b2x1bWUnO1xuXG4vKipcbiAqIFByb3BlcnRpZXMgZm9yIGBDb250YWluZXJTZWN1cml0eUNvbnRleHRgXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGFpbmVyU2VjdXJpdHlDb250ZXh0UHJvcHMge1xuXG4gIC8qKlxuICAgICogVGhlIFVJRCB0byBydW4gdGhlIGVudHJ5cG9pbnQgb2YgdGhlIGNvbnRhaW5lciBwcm9jZXNzLlxuICAgICpcbiAgICAqIEBkZWZhdWx0IC0gVXNlciBzcGVjaWZpZWQgaW4gaW1hZ2UgbWV0YWRhdGFcbiAgICAqL1xuICByZWFkb25seSB1c2VyPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgICogVGhlIEdJRCB0byBydW4gdGhlIGVudHJ5cG9pbnQgb2YgdGhlIGNvbnRhaW5lciBwcm9jZXNzLlxuICAgICpcbiAgICAqIEBkZWZhdWx0IC0gR3JvdXAgY29uZmlndXJlZCBieSBjb250YWluZXIgcnVudGltZVxuICAgICovXG4gIHJlYWRvbmx5IGdyb3VwPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgICogSW5kaWNhdGVzIHRoYXQgdGhlIGNvbnRhaW5lciBtdXN0IHJ1biBhcyBhIG5vbi1yb290IHVzZXIuXG4gICAgKiBJZiB0cnVlLCB0aGUgS3ViZWxldCB3aWxsIHZhbGlkYXRlIHRoZSBpbWFnZSBhdCBydW50aW1lIHRvIGVuc3VyZSB0aGF0IGl0IGRvZXNcbiAgICAqIG5vdCBydW4gYXMgVUlEIDAgKHJvb3QpIGFuZCBmYWlsIHRvIHN0YXJ0IHRoZSBjb250YWluZXIgaWYgaXQgZG9lcy5cbiAgICAqXG4gICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICovXG4gIHJlYWRvbmx5IGVuc3VyZU5vblJvb3Q/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBSdW4gY29udGFpbmVyIGluIHByaXZpbGVnZWQgbW9kZS4gUHJvY2Vzc2VzIGluIHByaXZpbGVnZWQgY29udGFpbmVycyBhcmUgZXNzZW50aWFsbHkgZXF1aXZhbGVudCB0byByb290IG9uIHRoZSBob3N0LlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgcHJpdmlsZWdlZD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBjb250YWluZXIgaGFzIGEgcmVhZC1vbmx5IHJvb3QgZmlsZXN5c3RlbS5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IHJlYWRPbmx5Um9vdEZpbGVzeXN0ZW0/OiBib29sZWFuO1xuXG59XG5cbi8qKlxuICogQ29udGFpbmVyIHNlY3VyaXR5IGF0dHJpYnV0ZXMgYW5kIHNldHRpbmdzLlxuICovXG5leHBvcnQgY2xhc3MgQ29udGFpbmVyU2VjdXJpdHlDb250ZXh0IHtcblxuICBwdWJsaWMgcmVhZG9ubHkgZW5zdXJlTm9uUm9vdDogYm9vbGVhbjtcbiAgcHVibGljIHJlYWRvbmx5IHByaXZpbGVnZWQ6IGJvb2xlYW47XG4gIHB1YmxpYyByZWFkb25seSByZWFkT25seVJvb3RGaWxlc3lzdGVtOiBib29sZWFuO1xuICBwdWJsaWMgcmVhZG9ubHkgdXNlcj86IG51bWJlcjtcbiAgcHVibGljIHJlYWRvbmx5IGdyb3VwPzogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBDb250YWluZXJTZWN1cml0eUNvbnRleHRQcm9wcyA9IHt9KSB7XG4gICAgdGhpcy5lbnN1cmVOb25Sb290ID0gcHJvcHMuZW5zdXJlTm9uUm9vdCA/PyBmYWxzZTtcbiAgICB0aGlzLnByaXZpbGVnZWQgPSBwcm9wcy5wcml2aWxlZ2VkID8/IGZhbHNlO1xuICAgIHRoaXMucmVhZE9ubHlSb290RmlsZXN5c3RlbSA9IHByb3BzLnJlYWRPbmx5Um9vdEZpbGVzeXN0ZW0gPz8gZmFsc2U7XG4gICAgdGhpcy51c2VyID0gcHJvcHMudXNlcjtcbiAgICB0aGlzLmdyb3VwID0gcHJvcHMuZ3JvdXA7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgX3RvS3ViZSgpOiBrOHMuU2VjdXJpdHlDb250ZXh0IHtcbiAgICByZXR1cm4ge1xuICAgICAgcnVuQXNHcm91cDogdGhpcy5ncm91cCxcbiAgICAgIHJ1bkFzVXNlcjogdGhpcy51c2VyLFxuICAgICAgcnVuQXNOb25Sb290OiB0aGlzLmVuc3VyZU5vblJvb3QsXG4gICAgICBwcml2aWxlZ2VkOiB0aGlzLnByaXZpbGVnZWQsXG4gICAgICByZWFkT25seVJvb3RGaWxlc3lzdGVtOiB0aGlzLnJlYWRPbmx5Um9vdEZpbGVzeXN0ZW0sXG4gICAgfTtcbiAgfVxuXG59XG5cbmV4cG9ydCBlbnVtIEVudkZpZWxkUGF0aHMge1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHBvZC5cbiAgICovXG4gIFBPRF9OQU1FID0gJ21ldGFkYXRhLm5hbWUnLFxuXG4gIC8qKlxuICAgKiBUaGUgbmFtZXNwYWNlIG9mIHRoZSBwb2QuXG4gICAqL1xuICBQT0RfTkFNRVNQQUNFID0gJ21ldGFkYXRhLm5hbWVzcGFjZScsXG5cbiAgLyoqXG4gICAqIFRoZSB1aWQgb2YgdGhlIHBvZC5cbiAgICovXG4gIFBPRF9VSUQgPSAnbWV0YWRhdGEudWlkJyxcblxuICAvKipcbiAgICogVGhlIGxhYmVscyBvZiB0aGUgcG9kLlxuICAgKi9cbiAgUE9EX0xBQkVMID0gJ21ldGFkYXRhLmxhYmVscycsXG5cbiAgLyoqXG4gICAqIFRoZSBhbm5vdGF0aW9ucyBvZiB0aGUgcG9kLlxuICAgKi9cbiAgUE9EX0FOTk9UQVRJT04gPSAnbWV0YWRhdGEuYW5ub3RhdGlvbnMnLFxuXG4gIC8qKlxuICAgKiBUaGUgaXBBZGRyZXNzIG9mIHRoZSBwb2QuXG4gICAqL1xuICBQT0RfSVAgPSAnc3RhdHVzLnBvZElQJyxcblxuICAvKipcbiAgICogVGhlIHNlcnZpY2UgYWNjb3VudCBuYW1lIG9mIHRoZSBwb2QuXG4gICAqL1xuICBTRVJWSUNFX0FDQ09VTlRfTkFNRSA9ICdzcGVjLnNlcnZpY2VBY2NvdW50TmFtZScsXG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBub2RlLlxuICAgKi9cbiAgTk9ERV9OQU1FID0gJ3NwZWMubm9kZU5hbWUnLFxuXG4gIC8qKlxuICAgKiBUaGUgaXBBZGRyZXNzIG9mIHRoZSBub2RlLlxuICAgKi9cbiAgTk9ERV9JUCA9ICdzdGF0dXMuaG9zdElQJyxcblxuICAvKipcbiAgICogVGhlIGlwQWRkcmVzZXNzIG9mIHRoZSBwb2QuXG4gICAqL1xuICBQT0RfSVBTID0gJ3N0YXR1cy5wb2RJUHMnLFxufVxuXG5leHBvcnQgZW51bSBSZXNvdXJjZUZpZWxkUGF0aHMge1xuICAvKipcbiAgICogQ1BVIGxpbWl0IG9mIHRoZSBjb250YWluZXIuXG4gICAqL1xuICBDUFVfTElNSVQgPSAnbGltaXRzLmNwdScsXG5cbiAgLyoqXG4gICAqIE1lbW9yeSBsaW1pdCBvZiB0aGUgY29udGFpbmVyLlxuICAgKi9cbiAgTUVNT1JZX0xJTUlUID0gJ2xpbWl0cy5tZW1vcnknLFxuXG4gIC8qKlxuICAgKiBDUFUgcmVxdWVzdCBvZiB0aGUgY29udGFpbmVyLlxuICAgKi9cbiAgQ1BVX1JFUVVFU1QgPSAncmVxdWVzdHMuY3B1JyxcblxuICAvKipcbiAgICogTWVtb3J5IHJlcXVlc3Qgb2YgdGhlIGNvbnRhaW5lci5cbiAgICovXG4gIE1FTU9SWV9SRVFVRVNUID0gJ3JlcXVlc3RzLm1lbW9yeScsXG5cbiAgLyoqXG4gICAqIEVwaGVtZXJhbCBzdG9yYWdlIGxpbWl0IG9mIHRoZSBjb250YWluZXIuXG4gICAqL1xuICBTVE9SQUdFX0xJTUlUID0gJ2xpbWl0cy5lcGhlbWVyYWwtc3RvcmFnZScsXG5cbiAgLyoqXG4gICAqIEVwaGVtZXJhbCBzdG9yYWdlIHJlcXVlc3Qgb2YgdGhlIGNvbnRhaW5lci5cbiAgICovXG4gIFNUT1JBR0VfUkVRVUVTVCA9ICdyZXF1ZXN0cy5lcGhlbWVyYWwtc3RvcmFnZScsXG59XG5cbi8qKlxuICogT3B0aW9ucyB0byBzcGVjaWZ5IGFuIGVudmlvbm1lbnQgdmFyaWFibGUgdmFsdWUgZnJvbSBhIENvbmZpZ01hcCBrZXkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRW52VmFsdWVGcm9tQ29uZmlnTWFwT3B0aW9ucyB7XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgd2hldGhlciB0aGUgQ29uZmlnTWFwIG9yIGl0cyBrZXkgbXVzdCBiZSBkZWZpbmVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgb3B0aW9uYWw/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgdG8gc3BlY2lmeSBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZSB2YWx1ZSBmcm9tIGEgU2VjcmV0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVudlZhbHVlRnJvbVNlY3JldE9wdGlvbnMge1xuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgdGhlIFNlY3JldCBvciBpdHMga2V5IG11c3QgYmUgZGVmaW5lZC5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IG9wdGlvbmFsPzogYm9vbGVhbjtcblxufVxuXG4vKipcbiAqIE9wdGlvbnMgdG8gc3BlY2lmeSBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZSB2YWx1ZSBmcm9tIHRoZSBwcm9jZXNzIGVudmlyb25tZW50LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVudlZhbHVlRnJvbVByb2Nlc3NPcHRpb25zIHtcblxuICAvKipcbiAgICogU3BlY2lmeSB3aGV0aGVyIHRoZSBrZXkgbXVzdCBleGlzdCBpbiB0aGUgZW52aXJvbm1lbnQuXG4gICAqIElmIHRoaXMgaXMgc2V0IHRvIHRydWUsIGFuZCB0aGUga2V5IGRvZXMgbm90IGV4aXN0LCBhbiBlcnJvciB3aWxsIHRocm93bi5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IHJlcXVpcmVkPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBPcHRpb25zIHRvIHNwZWNpZnkgYW4gZW52aXJvbm1lbnQgdmFyaWFibGUgdmFsdWUgZnJvbSBhIGZpZWxkIHJlZmVyZW5jZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFbnZWYWx1ZUZyb21GaWVsZFJlZk9wdGlvbnMge1xuICAvKipcbiAgICogVmVyc2lvbiBvZiB0aGUgc2NoZW1hIHRoZSBGaWVsZFBhdGggaXMgd3JpdHRlbiBpbiB0ZXJtcyBvZi5cbiAgICovXG4gIHJlYWRvbmx5IGFwaVZlcnNpb24/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBrZXkgdG8gc2VsZWN0IHRoZSBwb2QgbGFiZWwgb3IgYW5ub3RhdGlvbi5cbiAgICovXG4gIHJlYWRvbmx5IGtleT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBPcHRpb25zIHRvIHNwZWNpZnkgYW4gZW52aXJvbm1lbnQgdmFyaWFibGUgdmFsdWUgZnJvbSBhIHJlc291cmNlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVudlZhbHVlRnJvbVJlc291cmNlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgY29udGFpbmVyIHRvIHNlbGVjdCB0aGUgdmFsdWUgZnJvbS5cbiAgICovXG4gIHJlYWRvbmx5IGNvbnRhaW5lcj86IENvbnRhaW5lcjtcblxuICAvKipcbiAgICogVGhlIG91dHB1dCBmb3JtYXQgb2YgdGhlIGV4cG9zZWQgcmVzb3VyY2UuXG4gICAqL1xuICByZWFkb25seSBkaXZpc29yPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFV0aWxpdHkgY2xhc3MgZm9yIGNyZWF0aW5nIHJlYWRpbmcgZW52IHZhbHVlcyBmcm9tIHZhcmlvdXMgc291cmNlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEVudlZhbHVlIHtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgdmFsdWUgYnkgcmVhZGluZyBhIHNwZWNpZmljIGtleSBpbnNpZGUgYSBjb25maWcgbWFwLlxuICAgKlxuICAgKiBAcGFyYW0gY29uZmlnTWFwIC0gVGhlIGNvbmZpZyBtYXAuXG4gICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIGV4dHJhY3QgdGhlIHZhbHVlIGZyb20uXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tQ29uZmlnTWFwKGNvbmZpZ01hcDogY29uZmlnbWFwLklDb25maWdNYXAsIGtleTogc3RyaW5nLCBvcHRpb25zOiBFbnZWYWx1ZUZyb21Db25maWdNYXBPcHRpb25zID0geyB9KTogRW52VmFsdWUge1xuXG4gICAgY29uc3Qgc291cmNlOiBrOHMuRW52VmFyU291cmNlID0ge1xuICAgICAgY29uZmlnTWFwS2V5UmVmOiB7XG4gICAgICAgIG5hbWU6IGNvbmZpZ01hcC5uYW1lLFxuICAgICAgICBrZXksXG4gICAgICAgIG9wdGlvbmFsOiBvcHRpb25zLm9wdGlvbmFsLFxuICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBuZXcgRW52VmFsdWUodW5kZWZpbmVkLCBzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYW4gZW52aXJvbm1lbnQgdmFsdWUgZnJvbSBhIHNlY3JldCBKU09OIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gc2VjcmV0VmFsdWUgVGhlIHNlY3JldCB2YWx1ZSAoc2VjcmVudCArIGtleSlcbiAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21TZWNyZXRWYWx1ZShzZWNyZXRWYWx1ZTogc2VjcmV0LlNlY3JldFZhbHVlLCBvcHRpb25zOiBFbnZWYWx1ZUZyb21TZWNyZXRPcHRpb25zID0ge30pOiBFbnZWYWx1ZSB7XG4gICAgY29uc3Qgc291cmNlOiBrOHMuRW52VmFyU291cmNlID0ge1xuICAgICAgc2VjcmV0S2V5UmVmOiB7XG4gICAgICAgIG5hbWU6IHNlY3JldFZhbHVlLnNlY3JldC5uYW1lLFxuICAgICAgICBrZXk6IHNlY3JldFZhbHVlLmtleSxcbiAgICAgICAgb3B0aW9uYWw6IG9wdGlvbnMub3B0aW9uYWwsXG4gICAgICB9LFxuICAgIH07XG5cbiAgICByZXR1cm4gbmV3IEVudlZhbHVlKHVuZGVmaW5lZCwgc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBhcmd1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tVmFsdWUodmFsdWU6IHN0cmluZyk6IEVudlZhbHVlIHtcbiAgICByZXR1cm4gbmV3IEVudlZhbHVlKHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBDcmVhdGUgYSB2YWx1ZSBmcm9tIGEgZmllbGQgcmVmZXJlbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gZmllbGRQYXRoOiBUaGUgZmllbGQgcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0gb3B0aW9uczogQWRkaXRpb25hbCBvcHRpb25zLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tRmllbGRSZWYoZmllbGRQYXRoOiBFbnZGaWVsZFBhdGhzLCBvcHRpb25zOiBFbnZWYWx1ZUZyb21GaWVsZFJlZk9wdGlvbnMgPSB7fSk6IEVudlZhbHVlIHtcbiAgICBsZXQgbmVlZHNLZXk6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIGlmIChmaWVsZFBhdGggPT09IEVudkZpZWxkUGF0aHMuUE9EX0xBQkVMIHx8IGZpZWxkUGF0aCA9PT0gRW52RmllbGRQYXRocy5QT0RfQU5OT1RBVElPTikge1xuICAgICAgbmVlZHNLZXkgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChuZWVkc0tleSAmJiBvcHRpb25zLmtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZmllbGRQYXRofSByZXF1aXJlcyBhIGtleWApO1xuICAgIH1cblxuICAgIGNvbnN0IHNvdXJjZTogazhzLkVudlZhclNvdXJjZSA9IHtcbiAgICAgIGZpZWxkUmVmOiB7XG4gICAgICAgIGZpZWxkUGF0aDogKGAke2ZpZWxkUGF0aH1gICsgKG5lZWRzS2V5ID8gYFsnJHtvcHRpb25zLmtleX0nXWAgOiAnJykpLFxuICAgICAgICAuLi4ob3B0aW9ucy5hcGlWZXJzaW9uID8geyBhcGlWZXJzaW9uOiBvcHRpb25zLmFwaVZlcnNpb24gfSA6IHt9KSxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIHJldHVybiBuZXcgRW52VmFsdWUodW5kZWZpbmVkLCBzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHZhbHVlIGZyb20gYSByZXNvdXJjZS5cbiAgICpcbiAgICogQHBhcmFtIHJlc291cmNlOiBSZXNvdXJjZSB0byBzZWxlY3QgdGhlIHZhbHVlIGZyb20uXG4gICAqIEBwYXJhbSBvcHRpb25zOiBBZGRpdGlvbmFsIG9wdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21SZXNvdXJjZShyZXNvdXJjZTogUmVzb3VyY2VGaWVsZFBhdGhzLCBvcHRpb25zOiBFbnZWYWx1ZUZyb21SZXNvdXJjZU9wdGlvbnMgPSB7fSk6IEVudlZhbHVlIHtcbiAgICBjb25zdCBzb3VyY2U6IGs4cy5FbnZWYXJTb3VyY2UgPSB7XG4gICAgICByZXNvdXJjZUZpZWxkUmVmOiB7XG4gICAgICAgIHJlc291cmNlOiBgJHtyZXNvdXJjZX1gLFxuICAgICAgICAuLi4gKG9wdGlvbnMuZGl2aXNvciA/IHsgZGl2aXNvcjogazhzLkludE9yU3RyaW5nLmZyb21TdHJpbmcob3B0aW9ucy5kaXZpc29yKSB9IDoge30pLFxuICAgICAgICAuLi4gKG9wdGlvbnMuY29udGFpbmVyID8geyBjb250YWluZXJOYW1lOiBvcHRpb25zLmNvbnRhaW5lci5uYW1lIH0gOiB7fSksXG4gICAgICB9LFxuICAgIH07XG5cbiAgICByZXR1cm4gbmV3IEVudlZhbHVlKHVuZGVmaW5lZCwgc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB2YWx1ZSBmcm9tIGEga2V5IGluIHRoZSBjdXJyZW50IHByb2Nlc3MgZW52aXJvbm1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIHJlYWQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tUHJvY2VzcyhrZXk6IHN0cmluZywgb3B0aW9uczogRW52VmFsdWVGcm9tUHJvY2Vzc09wdGlvbnMgPSB7fSk6IEVudlZhbHVlIHtcblxuICAgIGNvbnN0IHZhbHVlID0gcHJvY2Vzcy5lbnZba2V5XTtcblxuICAgIGlmIChvcHRpb25zLnJlcXVpcmVkICYmICF2YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nICR7a2V5fSBlbnYgdmFyaWFibGVgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gRW52VmFsdWUuZnJvbVZhbHVlKHZhbHVlISk7XG4gIH1cblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSB2YWx1ZT86IGFueSwgcHVibGljIHJlYWRvbmx5IHZhbHVlRnJvbT86IGFueSkge31cbn1cblxuZXhwb3J0IGVudW0gSW1hZ2VQdWxsUG9saWN5IHtcbiAgLyoqXG4gICAqIEV2ZXJ5IHRpbWUgdGhlIGt1YmVsZXQgbGF1bmNoZXMgYSBjb250YWluZXIsIHRoZSBrdWJlbGV0IHF1ZXJpZXMgdGhlIGNvbnRhaW5lciBpbWFnZSByZWdpc3RyeVxuICAgKiB0byByZXNvbHZlIHRoZSBuYW1lIHRvIGFuIGltYWdlIGRpZ2VzdC4gSWYgdGhlIGt1YmVsZXQgaGFzIGEgY29udGFpbmVyIGltYWdlIHdpdGggdGhhdCBleGFjdFxuICAgKiBkaWdlc3QgY2FjaGVkIGxvY2FsbHksIHRoZSBrdWJlbGV0IHVzZXMgaXRzIGNhY2hlZCBpbWFnZTsgb3RoZXJ3aXNlLCB0aGUga3ViZWxldCBkb3dubG9hZHNcbiAgICogKHB1bGxzKSB0aGUgaW1hZ2Ugd2l0aCB0aGUgcmVzb2x2ZWQgZGlnZXN0LCBhbmQgdXNlcyB0aGF0IGltYWdlIHRvIGxhdW5jaCB0aGUgY29udGFpbmVyLlxuICAgKlxuICAgKiBEZWZhdWx0IGlzIEFsd2F5cyBpZiBJbWFnZVB1bGxQb2xpY3kgaXMgb21pdHRlZCBhbmQgZWl0aGVyIHRoZSBpbWFnZSB0YWcgaXMgOmxhdGVzdCBvclxuICAgKiB0aGUgaW1hZ2UgdGFnIGlzIG9taXR0ZWQuXG4gICAqL1xuICBBTFdBWVMgPSAnQWx3YXlzJyxcblxuICAvKipcbiAgICogVGhlIGltYWdlIGlzIHB1bGxlZCBvbmx5IGlmIGl0IGlzIG5vdCBhbHJlYWR5IHByZXNlbnQgbG9jYWxseS5cbiAgICpcbiAgICogRGVmYXVsdCBpcyBJZk5vdFByZXNlbnQgaWYgSW1hZ2VQdWxsUG9saWN5IGlzIG9taXR0ZWQgYW5kIHRoZSBpbWFnZSB0YWcgaXMgcHJlc2VudCBidXRcbiAgICogbm90IDpsYXRlc3RcbiAgICovXG4gIElGX05PVF9QUkVTRU5UID0gJ0lmTm90UHJlc2VudCcsXG5cbiAgLyoqXG4gICAqIFRoZSBpbWFnZSBpcyBhc3N1bWVkIHRvIGV4aXN0IGxvY2FsbHkuIE5vIGF0dGVtcHQgaXMgbWFkZSB0byBwdWxsIHRoZSBpbWFnZS5cbiAgICovXG4gIE5FVkVSID0gJ05ldmVyJyxcbn1cblxuLyoqXG4gKiBDb250YWluZXIgbGlmZWN5Y2xlIHByb3BlcnRpZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGFpbmVyTGlmZWN5Y2xlIHtcblxuICAvKipcbiAgICogVGhpcyBob29rIGlzIGV4ZWN1dGVkIGltbWVkaWF0ZWx5IGFmdGVyIGEgY29udGFpbmVyIGlzIGNyZWF0ZWQuIEhvd2V2ZXIsXG4gICAqIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBob29rIHdpbGwgZXhlY3V0ZSBiZWZvcmUgdGhlIGNvbnRhaW5lciBFTlRSWVBPSU5ULlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIE5vIHBvc3Qgc3RhcnQgaGFuZGxlci5cbiAgICovXG4gIHJlYWRvbmx5IHBvc3RTdGFydD86IGhhbmRsZXIuSGFuZGxlcjtcblxuICAvKipcbiAgICogVGhpcyBob29rIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBiZWZvcmUgYSBjb250YWluZXIgaXMgdGVybWluYXRlZCBkdWUgdG8gYW4gQVBJIHJlcXVlc3Qgb3IgbWFuYWdlbWVudFxuICAgKiBldmVudCBzdWNoIGFzIGEgbGl2ZW5lc3Mvc3RhcnR1cCBwcm9iZSBmYWlsdXJlLCBwcmVlbXB0aW9uLCByZXNvdXJjZSBjb250ZW50aW9uIGFuZCBvdGhlcnMuXG4gICAqIEEgY2FsbCB0byB0aGUgUHJlU3RvcCBob29rIGZhaWxzIGlmIHRoZSBjb250YWluZXIgaXMgYWxyZWFkeSBpbiBhIHRlcm1pbmF0ZWQgb3IgY29tcGxldGVkIHN0YXRlXG4gICAqIGFuZCB0aGUgaG9vayBtdXN0IGNvbXBsZXRlIGJlZm9yZSB0aGUgVEVSTSBzaWduYWwgdG8gc3RvcCB0aGUgY29udGFpbmVyIGNhbiBiZSBzZW50LlxuICAgKiBUaGUgUG9kJ3MgdGVybWluYXRpb24gZ3JhY2UgcGVyaW9kIGNvdW50ZG93biBiZWdpbnMgYmVmb3JlIHRoZSBQcmVTdG9wIGhvb2sgaXMgZXhlY3V0ZWQsXG4gICAqIHNvIHJlZ2FyZGxlc3Mgb2YgdGhlIG91dGNvbWUgb2YgdGhlIGhhbmRsZXIsIHRoZSBjb250YWluZXIgd2lsbCBldmVudHVhbGx5IHRlcm1pbmF0ZVxuICAgKiB3aXRoaW4gdGhlIFBvZCdzIHRlcm1pbmF0aW9uIGdyYWNlIHBlcmlvZC4gTm8gcGFyYW1ldGVycyBhcmUgcGFzc2VkIHRvIHRoZSBoYW5kbGVyLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3dvcmtsb2Fkcy9wb2RzL3BvZC1saWZlY3ljbGUvI3BvZC10ZXJtaW5hdGlvblxuICAgKlxuICAgKiBAZGVmYXVsdCAtIE5vIHByZSBzdG9wIGhhbmRsZXIuXG4gICAqL1xuICByZWFkb25seSBwcmVTdG9wPzogaGFuZGxlci5IYW5kbGVyO1xuXG59XG5cbi8qKlxuICogUHJvcGVydGllcyBmb3IgY3JlYXRpbmcgYSBjb250YWluZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGFpbmVyUHJvcHMge1xuXG4gIC8qKlxuICAgKiBEb2NrZXIgaW1hZ2UgbmFtZS5cbiAgICovXG4gIHJlYWRvbmx5IGltYWdlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIGNvbnRhaW5lciBzcGVjaWZpZWQgYXMgYSBETlNfTEFCRUwuIEVhY2ggY29udGFpbmVyIGluIGEgcG9kIG11c3QgaGF2ZSBhIHVuaXF1ZSBuYW1lIChETlNfTEFCRUwpLiBDYW5ub3QgYmUgdXBkYXRlZC5cbiAgICpcbiAgICogQGRlZmF1bHQgJ21haW4nXG4gICAqL1xuICByZWFkb25seSBuYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgcG9ydCB0byBleHBvc2Ugb24gdGhlIHBvZCdzIElQIGFkZHJlc3MuIFRoaXMgbXVzdCBiZSBhIHZhbGlkIHBvcnQgbnVtYmVyLCAwIDwgeCA8IDY1NTM2LlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIE5vIHBvcnQgaXMgZXhwb3NlZC5cbiAgICovXG4gIHJlYWRvbmx5IHBvcnQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEVudHJ5cG9pbnQgYXJyYXkuIE5vdCBleGVjdXRlZCB3aXRoaW4gYSBzaGVsbC4gVGhlIGRvY2tlciBpbWFnZSdzIEVOVFJZUE9JTlQgaXMgdXNlZCBpZiB0aGlzIGlzIG5vdCBwcm92aWRlZC4gVmFyaWFibGUgcmVmZXJlbmNlcyAkKFZBUl9OQU1FKSBhcmUgZXhwYW5kZWQgdXNpbmcgdGhlIGNvbnRhaW5lcidzIGVudmlyb25tZW50LlxuICAgKiBJZiBhIHZhcmlhYmxlIGNhbm5vdCBiZSByZXNvbHZlZCwgdGhlIHJlZmVyZW5jZSBpbiB0aGUgaW5wdXQgc3RyaW5nIHdpbGwgYmUgdW5jaGFuZ2VkLiBUaGUgJChWQVJfTkFNRSkgc3ludGF4IGNhbiBiZSBlc2NhcGVkIHdpdGggYSBkb3VibGUgJCQsIGllOiAkJChWQVJfTkFNRSkuXG4gICAqIEVzY2FwZWQgcmVmZXJlbmNlcyB3aWxsIG5ldmVyIGJlIGV4cGFuZGVkLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIHZhcmlhYmxlIGV4aXN0cyBvciBub3QuIENhbm5vdCBiZSB1cGRhdGVkLlxuICAgKiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL3Rhc2tzL2luamVjdC1kYXRhLWFwcGxpY2F0aW9uL2RlZmluZS1jb21tYW5kLWFyZ3VtZW50LWNvbnRhaW5lci8jcnVubmluZy1hLWNvbW1hbmQtaW4tYS1zaGVsbFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIFRoZSBkb2NrZXIgaW1hZ2UncyBFTlRSWVBPSU5ULlxuICAgKi9cbiAgcmVhZG9ubHkgY29tbWFuZD86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBBcmd1bWVudHMgdG8gdGhlIGVudHJ5cG9pbnQuIFRoZSBkb2NrZXIgaW1hZ2UncyBDTUQgaXMgdXNlZCBpZiBgY29tbWFuZGAgaXNcbiAgICogbm90IHByb3ZpZGVkLlxuICAgKlxuICAgKiBWYXJpYWJsZSByZWZlcmVuY2VzICQoVkFSX05BTUUpIGFyZSBleHBhbmRlZCB1c2luZyB0aGUgY29udGFpbmVyJ3NcbiAgICogZW52aXJvbm1lbnQuIElmIGEgdmFyaWFibGUgY2Fubm90IGJlIHJlc29sdmVkLCB0aGUgcmVmZXJlbmNlIGluIHRoZSBpbnB1dFxuICAgKiBzdHJpbmcgd2lsbCBiZSB1bmNoYW5nZWQuIFRoZSAkKFZBUl9OQU1FKSBzeW50YXggY2FuIGJlIGVzY2FwZWQgd2l0aCBhXG4gICAqIGRvdWJsZSAkJCwgaWU6ICQkKFZBUl9OQU1FKS4gRXNjYXBlZCByZWZlcmVuY2VzIHdpbGwgbmV2ZXIgYmUgZXhwYW5kZWQsXG4gICAqIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdmFyaWFibGUgZXhpc3RzIG9yIG5vdC5cbiAgICpcbiAgICogQ2Fubm90IGJlIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvdGFza3MvaW5qZWN0LWRhdGEtYXBwbGljYXRpb24vZGVmaW5lLWNvbW1hbmQtYXJndW1lbnQtY29udGFpbmVyLyNydW5uaW5nLWEtY29tbWFuZC1pbi1hLXNoZWxsXG4gICAqIEBkZWZhdWx0IFtdXG4gICAqL1xuICByZWFkb25seSBhcmdzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIENvbnRhaW5lcidzIHdvcmtpbmcgZGlyZWN0b3J5LiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgY29udGFpbmVyIHJ1bnRpbWUncyBkZWZhdWx0IHdpbGwgYmUgdXNlZCwgd2hpY2ggbWlnaHQgYmUgY29uZmlndXJlZCBpbiB0aGUgY29udGFpbmVyIGltYWdlLiBDYW5ub3QgYmUgdXBkYXRlZC5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBUaGUgY29udGFpbmVyIHJ1bnRpbWUncyBkZWZhdWx0LlxuICAgKi9cbiAgcmVhZG9ubHkgd29ya2luZ0Rpcj86IHN0cmluZztcblxuICAvKipcbiAgICogRW52aXJvbm1lbnQgdmFyaWFibGVzIHRvIHNldCBpbiB0aGUgY29udGFpbmVyLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIE5vIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAgICovXG4gIHJlYWRvbmx5IGVudlZhcmlhYmxlcz86IHsgW25hbWU6IHN0cmluZ106IEVudlZhbHVlIH07XG5cbiAgLyoqXG4gICAqIExpc3Qgb2Ygc291cmNlcyB0byBwb3B1bGF0ZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgaW4gdGhlIGNvbnRhaW5lci5cbiAgICogV2hlbiBhIGtleSBleGlzdHMgaW4gbXVsdGlwbGUgc291cmNlcywgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aFxuICAgKiB0aGUgbGFzdCBzb3VyY2Ugd2lsbCB0YWtlIHByZWNlZGVuY2UuIFZhbHVlcyBkZWZpbmVkIGJ5IHRoZSBgZW52VmFyaWFibGVzYCBwcm9wZXJ0eVxuICAgKiB3aXRoIGEgZHVwbGljYXRlIGtleSB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyBzb3VyY2VzLlxuICAgKi9cbiAgcmVhZG9ubHkgZW52RnJvbT86IEVudkZyb21bXTtcblxuICAvKipcbiAgICogUG9kIHZvbHVtZXMgdG8gbW91bnQgaW50byB0aGUgY29udGFpbmVyJ3MgZmlsZXN5c3RlbS4gQ2Fubm90IGJlIHVwZGF0ZWQuXG4gICAqL1xuICByZWFkb25seSB2b2x1bWVNb3VudHM/OiBWb2x1bWVNb3VudFtdO1xuXG4gIC8qKlxuICAgKiBJbWFnZSBwdWxsIHBvbGljeSBmb3IgdGhpcyBjb250YWluZXJcbiAgICogQGRlZmF1bHQgSW1hZ2VQdWxsUG9saWN5LkFMV0FZU1xuICAgKi9cbiAgcmVhZG9ubHkgaW1hZ2VQdWxsUG9saWN5PzogSW1hZ2VQdWxsUG9saWN5O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZW4gdGhlIGNvbnRhaW5lciBpcyByZWFkeSB0byBzZXJ2ZSB0cmFmZmljLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIG5vIHJlYWRpbmVzcyBwcm9iZSBpcyBkZWZpbmVkXG4gICAqL1xuICByZWFkb25seSByZWFkaW5lc3M/OiBwcm9iZS5Qcm9iZTtcblxuICAvKipcbiAgICogUGVyaW9kaWMgcHJvYmUgb2YgY29udGFpbmVyIGxpdmVuZXNzLiBDb250YWluZXIgd2lsbCBiZSByZXN0YXJ0ZWQgaWYgdGhlIHByb2JlIGZhaWxzLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIG5vIGxpdmVuZXNzIHByb2JlIGlzIGRlZmluZWRcbiAgICovXG4gIHJlYWRvbmx5IGxpdmVuZXNzPzogcHJvYmUuUHJvYmU7XG5cbiAgLyoqXG4gICAqIFN0YXJ0dXBQcm9iZSBpbmRpY2F0ZXMgdGhhdCB0aGUgUG9kIGhhcyBzdWNjZXNzZnVsbHkgaW5pdGlhbGl6ZWQuXG4gICAqIElmIHNwZWNpZmllZCwgbm8gb3RoZXIgcHJvYmVzIGFyZSBleGVjdXRlZCB1bnRpbCB0aGlzIGNvbXBsZXRlcyBzdWNjZXNzZnVsbHlcbiAgICpcbiAgICogQGRlZmF1bHQgLSBubyBzdGFydHVwIHByb2JlIGlzIGRlZmluZWQuXG4gICAqL1xuICByZWFkb25seSBzdGFydHVwPzogcHJvYmUuUHJvYmU7XG5cbiAgLyoqXG4gICAqIERlc2NyaWJlcyBhY3Rpb25zIHRoYXQgdGhlIG1hbmFnZW1lbnQgc3lzdGVtIHNob3VsZCB0YWtlIGluIHJlc3BvbnNlIHRvIGNvbnRhaW5lciBsaWZlY3ljbGUgZXZlbnRzLlxuICAgKi9cbiAgcmVhZG9ubHkgbGlmZWN5Y2xlPzogQ29udGFpbmVyTGlmZWN5Y2xlO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHJlc291cmNlcyAoQ1BVIGFuZCBtZW1vcnkgcmVxdWVzdHMgYW5kIGxpbWl0cykgcmVxdWlyZWQgYnkgdGhlIGNvbnRhaW5lclxuICAgKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL2NvbmZpZ3VyYXRpb24vbWFuYWdlLXJlc291cmNlcy1jb250YWluZXJzL1xuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VzPzogQ29udGFpbmVyUmVzb3VyY2VzO1xuXG4gIC8qKlxuICAgKiBTZWN1cml0eUNvbnRleHQgZGVmaW5lcyB0aGUgc2VjdXJpdHkgb3B0aW9ucyB0aGUgY29udGFpbmVyIHNob3VsZCBiZSBydW4gd2l0aC5cbiAgICogSWYgc2V0LCB0aGUgZmllbGRzIG92ZXJyaWRlIGVxdWl2YWxlbnQgZmllbGRzIG9mIHRoZSBwb2QncyBzZWN1cml0eSBjb250ZXh0LlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL3Rhc2tzL2NvbmZpZ3VyZS1wb2QtY29udGFpbmVyL3NlY3VyaXR5LWNvbnRleHQvXG4gICAqIEBkZWZhdWx0XG4gICAqXG4gICAqICAgZW5zdXJlTm9uUm9vdDogZmFsc2VcbiAgICogICBwcml2aWxlZ2VkOiBmYWxzZVxuICAgKiAgIHJlYWRPbmx5Um9vdEZpbGVzeXN0ZW06IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBzZWN1cml0eUNvbnRleHQ/OiBDb250YWluZXJTZWN1cml0eUNvbnRleHRQcm9wcztcbn1cblxuLyoqXG4gKiBBIHNpbmdsZSBhcHBsaWNhdGlvbiBjb250YWluZXIgdGhhdCB5b3Ugd2FudCB0byBydW4gd2l0aGluIGEgcG9kLlxuICovXG5leHBvcnQgY2xhc3MgQ29udGFpbmVyIHtcblxuICAvKipcbiAgICogVGhlIHBvcnQgdGhpcyBjb250YWluZXIgZXhwb3Nlcy5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBwb3J0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBWb2x1bWUgbW91bnRzIGNvbmZpZ3VyZWQgZm9yIHRoaXMgY29udGFpbmVyLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IG1vdW50czogVm9sdW1lTW91bnRbXTtcblxuICAvKipcbiAgICogSW1hZ2UgcHVsbCBwb2xpY3kgZm9yIHRoaXMgY29udGFpbmVyXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgaW1hZ2VQdWxsUG9saWN5OiBJbWFnZVB1bGxQb2xpY3k7XG5cbiAgLyoqXG4gICAqIFRoZSBjb250YWluZXIgaW1hZ2UuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgaW1hZ2U6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGNvbnRhaW5lci5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBpbnNpZGUgdGhlIGNvbnRhaW5lci5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSB3b3JraW5nRGlyPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHJlc291cmNlcyAoQ1BVIGFuZCBtZW1vcnkgcmVxdWVzdHMgYW5kIGxpbWl0cykgcmVxdWlyZWQgYnkgdGhlIGNvbnRhaW5lclxuICAgKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL2NvbmZpZ3VyYXRpb24vbWFuYWdlLXJlc291cmNlcy1jb250YWluZXJzL1xuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHJlc291cmNlcz86IENvbnRhaW5lclJlc291cmNlcztcblxuICAvKipcbiAgICogVGhlIHNlY3VyaXR5IGNvbnRleHQgb2YgdGhlIGNvbnRhaW5lci5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBzZWN1cml0eUNvbnRleHQ6IENvbnRhaW5lclNlY3VyaXR5Q29udGV4dDtcblxuICAvKipcbiAgICogVGhlIGVudmlyb25tZW50IG9mIHRoZSBjb250YWluZXIuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgZW52OiBFbnY7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBfY29tbWFuZD86IHJlYWRvbmx5IHN0cmluZ1tdO1xuICBwcml2YXRlIHJlYWRvbmx5IF9hcmdzPzogcmVhZG9ubHkgc3RyaW5nW107XG4gIHByaXZhdGUgcmVhZG9ubHkgX3JlYWRpbmVzcz86IHByb2JlLlByb2JlO1xuICBwcml2YXRlIHJlYWRvbmx5IF9saXZlbmVzcz86IHByb2JlLlByb2JlO1xuICBwcml2YXRlIHJlYWRvbmx5IF9zdGFydHVwPzogcHJvYmUuUHJvYmU7XG4gIHByaXZhdGUgcmVhZG9ubHkgX2xpZmVjeWNsZT86IENvbnRhaW5lckxpZmVjeWNsZTtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogQ29udGFpbmVyUHJvcHMpIHtcbiAgICBpZiAocHJvcHMgaW5zdGFuY2VvZiBDb250YWluZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGNvbnN0cnVjdCBhIGNvbnRhaW5lciBmcm9tIGEgQ29udGFpbmVyIG9iamVjdC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSBwcm9wcy5uYW1lID8/ICdtYWluJztcbiAgICB0aGlzLmltYWdlID0gcHJvcHMuaW1hZ2U7XG4gICAgdGhpcy5wb3J0ID0gcHJvcHMucG9ydDtcbiAgICB0aGlzLl9jb21tYW5kID0gcHJvcHMuY29tbWFuZDtcbiAgICB0aGlzLl9hcmdzID0gcHJvcHMuYXJncztcbiAgICB0aGlzLl9yZWFkaW5lc3MgPSBwcm9wcy5yZWFkaW5lc3M7XG4gICAgdGhpcy5fbGl2ZW5lc3MgPSBwcm9wcy5saXZlbmVzcztcbiAgICB0aGlzLl9zdGFydHVwID0gcHJvcHMuc3RhcnR1cDtcbiAgICB0aGlzLl9saWZlY3ljbGUgPSBwcm9wcy5saWZlY3ljbGU7XG4gICAgdGhpcy5yZXNvdXJjZXMgPSBwcm9wcy5yZXNvdXJjZXM7XG4gICAgdGhpcy53b3JraW5nRGlyID0gcHJvcHMud29ya2luZ0RpcjtcbiAgICB0aGlzLm1vdW50cyA9IHByb3BzLnZvbHVtZU1vdW50cyA/PyBbXTtcbiAgICB0aGlzLmltYWdlUHVsbFBvbGljeSA9IHByb3BzLmltYWdlUHVsbFBvbGljeSA/PyBJbWFnZVB1bGxQb2xpY3kuQUxXQVlTO1xuICAgIHRoaXMuc2VjdXJpdHlDb250ZXh0ID0gbmV3IENvbnRhaW5lclNlY3VyaXR5Q29udGV4dChwcm9wcy5zZWN1cml0eUNvbnRleHQpO1xuICAgIHRoaXMuZW52ID0gbmV3IEVudihwcm9wcy5lbnZGcm9tID8/IFtdLCBwcm9wcy5lbnZWYXJpYWJsZXMgPz8ge30pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVudHJ5cG9pbnQgYXJyYXkgKHRoZSBjb21tYW5kIHRvIGV4ZWN1dGUgd2hlbiB0aGUgY29udGFpbmVyIHN0YXJ0cykuXG4gICAqIEByZXR1cm5zIGEgY29weSBvZiB0aGUgZW50cnlwb2ludCBhcnJheSwgY2Fubm90IGJlIG1vZGlmaWVkXG4gICAqL1xuICBwdWJsaWMgZ2V0IGNvbW1hbmQoKTogc3RyaW5nW10gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9jb21tYW5kID8gWy4uLnRoaXMuX2NvbW1hbmRdIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFyZ3VtZW50cyB0byB0aGUgZW50cnlwb2ludC5cbiAgICpcbiAgICogQHJldHVybnMgYSBjb3B5IG9mIHRoZSBhcmd1bWVudHMgYXJyYXksIGNhbm5vdCBiZSBtb2RpZmllZC5cbiAgICovXG4gIHB1YmxpYyBnZXQgYXJncygpOiBzdHJpbmdbXSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX2FyZ3MgPyBbLi4udGhpcy5fYXJnc10gOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogTW91bnQgYSB2b2x1bWUgdG8gYSBzcGVjaWZpYyBwYXRoIHNvIHRoYXQgaXQgaXMgYWNjZXNzaWJsZSBieSB0aGUgY29udGFpbmVyLlxuICAgKiBFdmVyeSBwb2QgdGhhdCBpcyBjb25maWd1cmVkIHRvIHVzZSB0aGlzIGNvbnRhaW5lciB3aWxsIGF1dG1vYXRpY2FsbHkgaGF2ZSBhY2Nlc3MgdG8gdGhlIHZvbHVtZS5cbiAgICpcbiAgICogQHBhcmFtIHBhdGggLSBUaGUgZGVzaXJlZCBwYXRoIGluIHRoZSBjb250YWluZXIuXG4gICAqIEBwYXJhbSBzdG9yYWdlIC0gVGhlIHN0b3JhZ2UgdG8gbW91bnQuXG4gICAqL1xuICBwdWJsaWMgbW91bnQocGF0aDogc3RyaW5nLCBzdG9yYWdlOiB2b2x1bWUuSVN0b3JhZ2UsIG9wdGlvbnM6IE1vdW50T3B0aW9ucyA9IHsgfSkge1xuICAgIHRoaXMubW91bnRzLnB1c2goeyBwYXRoLCB2b2x1bWU6IHN0b3JhZ2UuYXNWb2x1bWUoKSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHB1YmxpYyBfdG9LdWJlKCk6IGs4cy5Db250YWluZXIge1xuICAgIGNvbnN0IHZvbHVtZU1vdW50czogazhzLlZvbHVtZU1vdW50W10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgbW91bnQgb2YgdGhpcy5tb3VudHMpIHtcbiAgICAgIHZvbHVtZU1vdW50cy5wdXNoKHtcbiAgICAgICAgbmFtZTogbW91bnQudm9sdW1lLm5hbWUsXG4gICAgICAgIG1vdW50UGF0aDogbW91bnQucGF0aCxcbiAgICAgICAgcmVhZE9ubHk6IG1vdW50LnJlYWRPbmx5LFxuICAgICAgICBtb3VudFByb3BhZ2F0aW9uOiBtb3VudC5wcm9wYWdhdGlvbixcbiAgICAgICAgc3ViUGF0aDogbW91bnQuc3ViUGF0aCxcbiAgICAgICAgc3ViUGF0aEV4cHI6IG1vdW50LnN1YlBhdGhFeHByLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcG9ydHMgPSBuZXcgQXJyYXk8azhzLkNvbnRhaW5lclBvcnQ+KCk7XG5cbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBwb3J0cy5wdXNoKHtcbiAgICAgICAgY29udGFpbmVyUG9ydDogdGhpcy5wb3J0LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmVzb3VyY2UgcmVxdWVzdHMgYW5kIGxpbWl0c1xuICAgIGNvbnN0IGNwdUxpbWl0ID0gdGhpcy5yZXNvdXJjZXM/LmNwdT8ubGltaXQ/LmFtb3VudDtcbiAgICBjb25zdCBjcHVSZXF1ZXN0ID0gdGhpcy5yZXNvdXJjZXM/LmNwdT8ucmVxdWVzdD8uYW1vdW50O1xuICAgIGNvbnN0IG1lbW9yeUxpbWl0ID0gdGhpcy5yZXNvdXJjZXM/Lm1lbW9yeT8ubGltaXQ7XG4gICAgY29uc3QgbWVtb3J5UmVxdWVzdCA9IHRoaXMucmVzb3VyY2VzPy5tZW1vcnk/LnJlcXVlc3Q7XG5cbiAgICBjb25zdCBsaW1pdHM6IHsgW2tleTogc3RyaW5nXTogazhzLlF1YW50aXR5IH0gPSB7fTtcbiAgICBjb25zdCByZXF1ZXN0czogeyBba2V5OiBzdHJpbmddOiBrOHMuUXVhbnRpdHkgfSA9IHt9O1xuXG4gICAgaWYgKGNwdUxpbWl0KSB7XG4gICAgICBsaW1pdHMuY3B1ID0gazhzLlF1YW50aXR5LmZyb21TdHJpbmcoY3B1TGltaXQpO1xuICAgIH1cbiAgICBpZiAobWVtb3J5TGltaXQpIHtcbiAgICAgIGxpbWl0cy5tZW1vcnkgPSBrOHMuUXVhbnRpdHkuZnJvbVN0cmluZyhtZW1vcnlMaW1pdC50b01lYmlieXRlcygpLnRvU3RyaW5nKCkgKyAnTWknKTtcbiAgICB9XG4gICAgaWYgKGNwdVJlcXVlc3QpIHtcbiAgICAgIHJlcXVlc3RzLmNwdSA9IGs4cy5RdWFudGl0eS5mcm9tU3RyaW5nKGNwdVJlcXVlc3QpO1xuICAgIH1cbiAgICBpZiAobWVtb3J5UmVxdWVzdCkge1xuICAgICAgcmVxdWVzdHMubWVtb3J5ID0gazhzLlF1YW50aXR5LmZyb21TdHJpbmcobWVtb3J5UmVxdWVzdC50b01lYmlieXRlcygpLnRvU3RyaW5nKCkgKyAnTWknKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzb3VyY2VSZXF1aXJlbWVudHM6IGs4cy5SZXNvdXJjZVJlcXVpcmVtZW50cyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoT2JqZWN0LmtleXMobGltaXRzKS5sZW5ndGggPiAwIHx8IE9iamVjdC5rZXlzKHJlcXVlc3RzKS5sZW5ndGggPiAwKSB7XG4gICAgICByZXNvdXJjZVJlcXVpcmVtZW50cyA9IHtcbiAgICAgICAgbGltaXRzOiBsaW1pdHMsXG4gICAgICAgIHJlcXVlc3RzOiByZXF1ZXN0cyxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgZW52ID0gdGhpcy5lbnYuX3RvS3ViZSgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIGltYWdlOiB0aGlzLmltYWdlLFxuICAgICAgaW1hZ2VQdWxsUG9saWN5OiB0aGlzLmltYWdlUHVsbFBvbGljeSxcbiAgICAgIHBvcnRzOiB1bmRlZmluZWRJZkVtcHR5KHBvcnRzKSxcbiAgICAgIHZvbHVtZU1vdW50czogdW5kZWZpbmVkSWZFbXB0eSh2b2x1bWVNb3VudHMpLFxuICAgICAgY29tbWFuZDogdGhpcy5jb21tYW5kLFxuICAgICAgYXJnczogdGhpcy5hcmdzLFxuICAgICAgd29ya2luZ0RpcjogdGhpcy53b3JraW5nRGlyLFxuICAgICAgZW52OiBlbnYudmFyaWFibGVzLFxuICAgICAgZW52RnJvbTogZW52LmZyb20sXG4gICAgICByZWFkaW5lc3NQcm9iZTogdGhpcy5fcmVhZGluZXNzPy5fdG9LdWJlKHRoaXMpLFxuICAgICAgbGl2ZW5lc3NQcm9iZTogdGhpcy5fbGl2ZW5lc3M/Ll90b0t1YmUodGhpcyksXG4gICAgICBzdGFydHVwUHJvYmU6IHRoaXMuX3N0YXJ0dXA/Ll90b0t1YmUodGhpcyksXG4gICAgICBsaWZlY3ljbGU6IHRoaXMuX2xpZmVjeWNsZSA/IHtcbiAgICAgICAgcG9zdFN0YXJ0OiB0aGlzLl9saWZlY3ljbGUucG9zdFN0YXJ0Py5fdG9LdWJlKHRoaXMpLFxuICAgICAgICBwcmVTdG9wOiB0aGlzLl9saWZlY3ljbGUucHJlU3RvcD8uX3RvS3ViZSh0aGlzKSxcbiAgICAgIH0gOiB1bmRlZmluZWQsXG4gICAgICByZXNvdXJjZXM6IHJlc291cmNlUmVxdWlyZW1lbnRzLFxuICAgICAgc2VjdXJpdHlDb250ZXh0OiB0aGlzLnNlY3VyaXR5Q29udGV4dC5fdG9LdWJlKCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIG1vdW50cy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNb3VudE9wdGlvbnMge1xuICAvKipcbiAgICogRGV0ZXJtaW5lcyBob3cgbW91bnRzIGFyZSBwcm9wYWdhdGVkIGZyb20gdGhlIGhvc3QgdG8gY29udGFpbmVyIGFuZCB0aGVcbiAgICogb3RoZXIgd2F5IGFyb3VuZC4gV2hlbiBub3Qgc2V0LCBNb3VudFByb3BhZ2F0aW9uTm9uZSBpcyB1c2VkLlxuICAgKlxuICAgKiBNb3VudCBwcm9wYWdhdGlvbiBhbGxvd3MgZm9yIHNoYXJpbmcgdm9sdW1lcyBtb3VudGVkIGJ5IGEgQ29udGFpbmVyIHRvXG4gICAqIG90aGVyIENvbnRhaW5lcnMgaW4gdGhlIHNhbWUgUG9kLCBvciBldmVuIHRvIG90aGVyIFBvZHMgb24gdGhlIHNhbWUgbm9kZS5cbiAgICpcbiAgICogQGRlZmF1bHQgTW91bnRQcm9wYWdhdGlvbi5OT05FXG4gICAqL1xuICByZWFkb25seSBwcm9wYWdhdGlvbj86IE1vdW50UHJvcGFnYXRpb247XG5cbiAgLyoqXG4gICAqIE1vdW50ZWQgcmVhZC1vbmx5IGlmIHRydWUsIHJlYWQtd3JpdGUgb3RoZXJ3aXNlIChmYWxzZSBvciB1bnNwZWNpZmllZCkuXG4gICAqIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgcmVhZE9ubHk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBQYXRoIHdpdGhpbiB0aGUgdm9sdW1lIGZyb20gd2hpY2ggdGhlIGNvbnRhaW5lcidzIHZvbHVtZSBzaG91bGQgYmUgbW91bnRlZC4pLlxuICAgKlxuICAgKiBAZGVmYXVsdCBcIlwiIHRoZSB2b2x1bWUncyByb290XG4gICAqL1xuICByZWFkb25seSBzdWJQYXRoPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBFeHBhbmRlZCBwYXRoIHdpdGhpbiB0aGUgdm9sdW1lIGZyb20gd2hpY2ggdGhlIGNvbnRhaW5lcidzIHZvbHVtZSBzaG91bGQgYmVcbiAgICogbW91bnRlZC4gQmVoYXZlcyBzaW1pbGFybHkgdG8gU3ViUGF0aCBidXQgZW52aXJvbm1lbnQgdmFyaWFibGUgcmVmZXJlbmNlc1xuICAgKiAkKFZBUl9OQU1FKSBhcmUgZXhwYW5kZWQgdXNpbmcgdGhlIGNvbnRhaW5lcidzIGVudmlyb25tZW50LiBEZWZhdWx0cyB0byBcIlwiXG4gICAqICh2b2x1bWUncyByb290KS5cbiAgICpcbiAgICogYHN1YlBhdGhFeHByYCBhbmQgYHN1YlBhdGhgIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuXG4gICAqXG4gICAqIEBkZWZhdWx0IFwiXCIgdm9sdW1lJ3Mgcm9vdC5cbiAgICovXG4gIHJlYWRvbmx5IHN1YlBhdGhFeHByPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIE1vdW50IGEgdm9sdW1lIGZyb20gdGhlIHBvZCB0byB0aGUgY29udGFpbmVyLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZvbHVtZU1vdW50IGV4dGVuZHMgTW91bnRPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB2b2x1bWUgdG8gbW91bnQuXG4gICAqL1xuICByZWFkb25seSB2b2x1bWU6IHZvbHVtZS5Wb2x1bWU7XG5cbiAgLyoqXG4gICAqIFBhdGggd2l0aGluIHRoZSBjb250YWluZXIgYXQgd2hpY2ggdGhlIHZvbHVtZSBzaG91bGQgYmUgbW91bnRlZC4gTXVzdCBub3RcbiAgICogY29udGFpbiAnOicuXG4gICAqL1xuICByZWFkb25seSBwYXRoOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBlbnVtIE1vdW50UHJvcGFnYXRpb24ge1xuICAvKipcbiAgICogVGhpcyB2b2x1bWUgbW91bnQgd2lsbCBub3QgcmVjZWl2ZSBhbnkgc3Vic2VxdWVudCBtb3VudHMgdGhhdCBhcmUgbW91bnRlZFxuICAgKiB0byB0aGlzIHZvbHVtZSBvciBhbnkgb2YgaXRzIHN1YmRpcmVjdG9yaWVzIGJ5IHRoZSBob3N0LiBJbiBzaW1pbGFyXG4gICAqIGZhc2hpb24sIG5vIG1vdW50cyBjcmVhdGVkIGJ5IHRoZSBDb250YWluZXIgd2lsbCBiZSB2aXNpYmxlIG9uIHRoZSBob3N0LlxuICAgKlxuICAgKiBUaGlzIGlzIHRoZSBkZWZhdWx0IG1vZGUuXG4gICAqXG4gICAqIFRoaXMgbW9kZSBpcyBlcXVhbCB0byBgcHJpdmF0ZWAgbW91bnQgcHJvcGFnYXRpb24gYXMgZGVzY3JpYmVkIGluIHRoZSBMaW51eFxuICAgKiBrZXJuZWwgZG9jdW1lbnRhdGlvblxuICAgKi9cbiAgTk9ORSA9ICdOb25lJyxcblxuICAvKipcbiAgICogVGhpcyB2b2x1bWUgbW91bnQgd2lsbCByZWNlaXZlIGFsbCBzdWJzZXF1ZW50IG1vdW50cyB0aGF0IGFyZSBtb3VudGVkIHRvXG4gICAqIHRoaXMgdm9sdW1lIG9yIGFueSBvZiBpdHMgc3ViZGlyZWN0b3JpZXMuXG4gICAqXG4gICAqIEluIG90aGVyIHdvcmRzLCBpZiB0aGUgaG9zdCBtb3VudHMgYW55dGhpbmcgaW5zaWRlIHRoZSB2b2x1bWUgbW91bnQsIHRoZVxuICAgKiBDb250YWluZXIgd2lsbCBzZWUgaXQgbW91bnRlZCB0aGVyZS5cbiAgICpcbiAgICogU2ltaWxhcmx5LCBpZiBhbnkgUG9kIHdpdGggQmlkaXJlY3Rpb25hbCBtb3VudCBwcm9wYWdhdGlvbiB0byB0aGUgc2FtZVxuICAgKiB2b2x1bWUgbW91bnRzIGFueXRoaW5nIHRoZXJlLCB0aGUgQ29udGFpbmVyIHdpdGggSG9zdFRvQ29udGFpbmVyIG1vdW50XG4gICAqIHByb3BhZ2F0aW9uIHdpbGwgc2VlIGl0LlxuICAgKlxuICAgKiBUaGlzIG1vZGUgaXMgZXF1YWwgdG8gYHJzbGF2ZWAgbW91bnQgcHJvcGFnYXRpb24gYXMgZGVzY3JpYmVkIGluIHRoZSBMaW51eFxuICAgKiBrZXJuZWwgZG9jdW1lbnRhdGlvblxuICAgKi9cbiAgSE9TVF9UT19DT05UQUlORVIgPSAnSG9zdFRvQ29udGFpbmVyJyxcblxuICAvKipcbiAgICogVGhpcyB2b2x1bWUgbW91bnQgYmVoYXZlcyB0aGUgc2FtZSB0aGUgSG9zdFRvQ29udGFpbmVyIG1vdW50LiBJbiBhZGRpdGlvbixcbiAgICogYWxsIHZvbHVtZSBtb3VudHMgY3JlYXRlZCBieSB0aGUgQ29udGFpbmVyIHdpbGwgYmUgcHJvcGFnYXRlZCBiYWNrIHRvIHRoZVxuICAgKiBob3N0IGFuZCB0byBhbGwgQ29udGFpbmVycyBvZiBhbGwgUG9kcyB0aGF0IHVzZSB0aGUgc2FtZSB2b2x1bWVcbiAgICpcbiAgICogQSB0eXBpY2FsIHVzZSBjYXNlIGZvciB0aGlzIG1vZGUgaXMgYSBQb2Qgd2l0aCBhIEZsZXhWb2x1bWUgb3IgQ1NJIGRyaXZlclxuICAgKiBvciBhIFBvZCB0aGF0IG5lZWRzIHRvIG1vdW50IHNvbWV0aGluZyBvbiB0aGUgaG9zdCB1c2luZyBhIGhvc3RQYXRoIHZvbHVtZS5cbiAgICpcbiAgICogVGhpcyBtb2RlIGlzIGVxdWFsIHRvIGByc2hhcmVkYCBtb3VudCBwcm9wYWdhdGlvbiBhcyBkZXNjcmliZWQgaW4gdGhlIExpbnV4XG4gICAqIGtlcm5lbCBkb2N1bWVudGF0aW9uXG4gICAqXG4gICAqIENhdXRpb246IEJpZGlyZWN0aW9uYWwgbW91bnQgcHJvcGFnYXRpb24gY2FuIGJlIGRhbmdlcm91cy4gSXQgY2FuIGRhbWFnZVxuICAgKiB0aGUgaG9zdCBvcGVyYXRpbmcgc3lzdGVtIGFuZCB0aGVyZWZvcmUgaXQgaXMgYWxsb3dlZCBvbmx5IGluIHByaXZpbGVnZWRcbiAgICogQ29udGFpbmVycy4gRmFtaWxpYXJpdHkgd2l0aCBMaW51eCBrZXJuZWwgYmVoYXZpb3IgaXMgc3Ryb25nbHkgcmVjb21tZW5kZWQuXG4gICAqIEluIGFkZGl0aW9uLCBhbnkgdm9sdW1lIG1vdW50cyBjcmVhdGVkIGJ5IENvbnRhaW5lcnMgaW4gUG9kcyBtdXN0IGJlXG4gICAqIGRlc3Ryb3llZCAodW5tb3VudGVkKSBieSB0aGUgQ29udGFpbmVycyBvbiB0ZXJtaW5hdGlvbi5cbiAgICpcbiAgICovXG4gIEJJRElSRUNUSU9OQUwgPSAnQmlkaXJlY3Rpb25hbCcsXG59XG5cbi8qKlxuICogQ1BVIGFuZCBtZW1vcnkgY29tcHV0ZSByZXNvdXJjZXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb250YWluZXJSZXNvdXJjZXMge1xuICByZWFkb25seSBjcHU6IENwdVJlc291cmNlcztcbiAgcmVhZG9ubHkgbWVtb3J5OiBNZW1vcnlSZXNvdXJjZXM7XG59XG5cbi8qKlxuICogQ1BVIHJlcXVlc3QgYW5kIGxpbWl0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3B1UmVzb3VyY2VzIHtcbiAgcmVhZG9ubHkgcmVxdWVzdDogQ3B1O1xuICByZWFkb25seSBsaW1pdDogQ3B1O1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGFtb3VudCBvZiBDUFUuXG4gKiBUaGUgYW1vdW50IGNhbiBiZSBwYXNzZWQgYXMgbWlsbGlzIG9yIHVuaXRzLlxuICovXG5leHBvcnQgY2xhc3MgQ3B1IHtcbiAgc3RhdGljIG1pbGxpcyhhbW91bnQ6IG51bWJlcik6IENwdSB7XG4gICAgcmV0dXJuIG5ldyBDcHUoYW1vdW50ICsgJ20nKTtcbiAgfVxuICBzdGF0aWMgdW5pdHMoYW1vdW50OiBudW1iZXIpOiBDcHUge1xuICAgIHJldHVybiBuZXcgQ3B1KGFtb3VudC50b1N0cmluZygpKTtcbiAgfVxuICBhbW91bnQ6IHN0cmluZztcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihhbW91bnQ6IHN0cmluZykge1xuICAgIHRoaXMuYW1vdW50ID0gYW1vdW50O1xuICB9XG59XG5cbi8qKlxuICogTWVtb3J5IHJlcXVlc3QgYW5kIGxpbWl0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWVtb3J5UmVzb3VyY2VzIHtcbiAgcmVhZG9ubHkgcmVxdWVzdDogY29udGFpbmVyO1xuICByZWFkb25seSBsaW1pdDogY29udGFpbmVyO1xufVxuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBlbnYgdmFyaWFibGVzIGRlZmluZWQgaW4gb3RoZXIgcmVzb3VyY2VzLlxuICovXG5leHBvcnQgY2xhc3MgRW52RnJvbSB7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBjb25maWdNYXA/OiBjb25maWdtYXAuSUNvbmZpZ01hcCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHByZWZpeD86IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNlYz86IHNlY3JldC5JU2VjcmV0KSB7fTtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgX3RvS3ViZSgpOiBrOHMuRW52RnJvbVNvdXJjZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbmZpZ01hcFJlZjogdGhpcy5jb25maWdNYXAgPyB7XG4gICAgICAgIG5hbWU6IHRoaXMuY29uZmlnTWFwLm5hbWUsXG4gICAgICB9IDogdW5kZWZpbmVkLFxuICAgICAgc2VjcmV0UmVmOiB0aGlzLnNlYyA/IHtcbiAgICAgICAgbmFtZTogdGhpcy5zZWMubmFtZSxcbiAgICAgIH0gOiB1bmRlZmluZWQsXG4gICAgICBwcmVmaXg6IHRoaXMucHJlZml4LFxuICAgIH07XG4gIH1cblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdENvbnRhaW5lclBvcnRzKHNlbGVjdG9yPzogYW55KTogbnVtYmVyW10ge1xuXG4gIGlmICghc2VsZWN0b3IpIHsgcmV0dXJuIFtdOyB9XG5cbiAgY29uc3QgcG9ydHMgPSBbXTtcblxuICAvLyB3ZSBkb24ndCB1c2UgaW5zdGFuY2VvZiBpbnRlbnRpb25hbGx5IHNpbmNlIGl0IGNhbiBjcmVhdGVcbiAgLy8gY3ljbGljIGltcG9ydCBwcm9ibGVtcy5cbiAgY29uc3QgY29udGFpbmVyczogQ29udGFpbmVyW10gPSAoc2VsZWN0b3IgYXMgYW55KS5jb250YWluZXJzO1xuXG4gIGZvciAoY29uc3QgY29uIG9mIGNvbnRhaW5lcnMgPz8gW10pIHtcbiAgICBpZiAoY29uLnBvcnQpIHtcbiAgICAgIHBvcnRzLnB1c2goY29uLnBvcnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwb3J0cztcbn1cblxuLyoqXG4gKiBDb250YWluZXIgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICovXG5leHBvcnQgY2xhc3MgRW52IHtcblxuICAvKipcbiAgICogU2VsZWN0cyBhIENvbmZpZ01hcCB0byBwb3B1bGF0ZSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIHdpdGguXG4gICAqIFRoZSBjb250ZW50cyBvZiB0aGUgdGFyZ2V0IENvbmZpZ01hcCdzIERhdGEgZmllbGQgd2lsbCByZXByZXNlbnRcbiAgICogdGhlIGtleS12YWx1ZSBwYWlycyBhcyBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21Db25maWdNYXAoY29uZmlnTWFwOiBjb25maWdtYXAuSUNvbmZpZ01hcCwgcHJlZml4Pzogc3RyaW5nKTogRW52RnJvbSB7XG4gICAgcmV0dXJuIG5ldyBFbnZGcm9tKGNvbmZpZ01hcCwgcHJlZml4LCB1bmRlZmluZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgYSBTZWNyZXQgdG8gcG9wdWxhdGUgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcyB3aXRoLlxuICAgKiBUaGUgY29udGVudHMgb2YgdGhlIHRhcmdldCBTZWNyZXQncyBEYXRhIGZpZWxkIHdpbGwgcmVwcmVzZW50XG4gICAqIHRoZSBrZXktdmFsdWUgcGFpcnMgYXMgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tU2VjcmV0KHNlY3I6IHNlY3JldC5JU2VjcmV0KTogRW52RnJvbSB7XG4gICAgcmV0dXJuIG5ldyBFbnZGcm9tKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBzZWNyKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZG9ubHkgX3NvdXJjZXM6IEVudkZyb21bXTtcbiAgcHJpdmF0ZSByZWFkb25seSBfdmFyaWFibGVzOiB7IFtrZXk6IHN0cmluZ106IEVudlZhbHVlIH07XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNvdXJjZXM6IEVudkZyb21bXSwgdmFyaWFibGVzOiB7IFtuYW1lOiBzdHJpbmddOiBFbnZWYWx1ZSB9KSB7XG4gICAgdGhpcy5fc291cmNlcyA9IHNvdXJjZXM7XG4gICAgdGhpcy5fdmFyaWFibGVzID0gdmFyaWFibGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHNpbmdsZSB2YXJpYWJsZSBieSBuYW1lIGFuZCB2YWx1ZS5cbiAgICogVGhlIHZhcmlhYmxlIHZhbHVlIGNhbiBjb21lIGZyb20gdmFyaW91cyBkeW5hbWljIHNvdXJjZXMgc3VjaCBhIHNlY3JldHMgb2YgY29uZmlnIG1hcHMuXG4gICAqIFVzZSBgRW52VmFsdWUuZnJvbVhYWGAgdG8gc2VsZWN0IHNvdXJjZXMuXG4gICAqL1xuICBwdWJsaWMgYWRkVmFyaWFibGUobmFtZTogc3RyaW5nLCB2YWx1ZTogRW52VmFsdWUpIHtcbiAgICB0aGlzLl92YXJpYWJsZXNbbmFtZV0gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIGZvciB0aGlzIGNvbnRhaW5lci5cbiAgICogUmV0dXJucyBhIGNvcHkuIFRvIGFkZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdXNlIGBjb250YWluZXIuZW52LmFkZFZhcmlhYmxlKClgLlxuICAgKi9cbiAgcHVibGljIGdldCB2YXJpYWJsZXMoKTogeyBbbmFtZTogc3RyaW5nXTogRW52VmFsdWUgfSB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5fdmFyaWFibGVzIH07XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgY29sbGVjdGlvbiBvZiB2YXJpYWJsZXMgYnkgY29weWluZyBmcm9tIGFub3RoZXIgc291cmNlLlxuICAgKiBVc2UgYEVudi5mcm9tWFhYYCBmdW5jdGlvbnMgdG8gc2VsZWN0IHNvdXJjZXMuXG4gICAqL1xuICBwdWJsaWMgY29weUZyb20oZnJvbTogRW52RnJvbSkge1xuICAgIHRoaXMuX3NvdXJjZXMucHVzaChmcm9tKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBzb3VyY2VzIHVzZWQgdG8gcG9wdWxhdGUgdGhlIGNvbnRhaW5lciBlbnZpcm9ubWVudCxcbiAgICogaW4gYWRkaXRpb24gdG8gdGhlIGB2YXJpYWJsZXNgLlxuICAgKlxuICAgKiBSZXR1cm5zIGEgY29weS4gVG8gYWRkIGEgc291cmNlIHVzZSBgY29udGFpbmVyLmVudi5jb3B5RnJvbSgpYC5cbiAgICovXG4gIHB1YmxpYyBnZXQgc291cmNlcygpOiBFbnZGcm9tW10ge1xuICAgIHJldHVybiBbLi4udGhpcy5fc291cmNlc107XG4gIH1cblxuICBwcml2YXRlIHJlbmRlckVudihlbnY6IHsgW25hbWU6IHN0cmluZ106IEVudlZhbHVlIH0pOiBrOHMuRW52VmFyW10ge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheTxrOHMuRW52VmFyPigpO1xuICAgIGZvciAoY29uc3QgW25hbWUsIHZdIG9mIE9iamVjdC5lbnRyaWVzKGVudikpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdmFsdWU6IHYudmFsdWUsXG4gICAgICAgIHZhbHVlRnJvbTogdi52YWx1ZUZyb20sXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHB1YmxpYyBfdG9LdWJlKCk6IHsgdmFyaWFibGVzPzogazhzLkVudlZhcltdOyBmcm9tPzogazhzLkVudkZyb21Tb3VyY2VbXSB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbTogdW5kZWZpbmVkSWZFbXB0eSh0aGlzLl9zb3VyY2VzLm1hcChzID0+IHMuX3RvS3ViZSgpKSksXG4gICAgICB2YXJpYWJsZXM6IHVuZGVmaW5lZElmRW1wdHkodGhpcy5yZW5kZXJFbnYodGhpcy5fdmFyaWFibGVzKSksXG4gICAgfTtcbiAgfVxufVxuIl19

/***/ }),

/***/ 8118:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DaemonSet = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const cdk8s_1 = __nccwpck_require__(1227);
const k8s = __nccwpck_require__(4879);
const workload = __nccwpck_require__(7967);
/**
 * A DaemonSet ensures that all (or some) Nodes run a copy of a Pod.
 * As nodes are added to the cluster, Pods are added to them.
 * As nodes are removed from the cluster, those Pods are garbage collected.
 * Deleting a DaemonSet will clean up the Pods it created.
 *
 * Some typical uses of a DaemonSet are:
 *
 * - running a cluster storage daemon on every node
 * - running a logs collection daemon on every node
 * - running a node monitoring daemon on every node
 *
 * In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon.
 * A more complex setup might use multiple DaemonSets for a single type of daemon,
 * but with different flags and/or different memory and cpu requests for different hardware types.
 */
class DaemonSet extends workload.Workload {
    constructor(scope, id, props = {}) {
        var _b;
        super(scope, id, props);
        this.resourceType = 'daemonsets';
        this.apiObject = new k8s.KubeDaemonSet(this, 'Resource', {
            metadata: props.metadata,
            spec: cdk8s_1.Lazy.any({ produce: () => this._toKube() }),
        });
        this.minReadySeconds = (_b = props.minReadySeconds) !== null && _b !== void 0 ? _b : 0;
    }
    /**
     * @internal
     */
    _toKube() {
        return {
            minReadySeconds: this.minReadySeconds,
            template: {
                metadata: this.podMetadata.toJson(),
                spec: this._toPodSpec(),
            },
            selector: this._toLabelSelector(),
        };
    }
}
exports.DaemonSet = DaemonSet;
_a = JSII_RTTI_SYMBOL_1;
DaemonSet[_a] = { fqn: "cdk8s-plus-22.DaemonSet", version: "2.0.0-rc.2" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGFlbW9uLXNldC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9kYWVtb24tc2V0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsaUNBQXdDO0FBRXhDLHFDQUFxQztBQUNyQyx1Q0FBdUM7QUFpQnZDOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILE1BQWEsU0FBVSxTQUFRLFFBQVEsQ0FBQyxRQUFRO0lBVzlDLFlBQVksS0FBZ0IsRUFBRSxFQUFVLEVBQUUsUUFBd0IsRUFBRTs7UUFDbEUsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFMVixpQkFBWSxHQUFHLFlBQVksQ0FBQztRQU8xQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksR0FBRyxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFO1lBQ3ZELFFBQVEsRUFBRSxLQUFLLENBQUMsUUFBUTtZQUN4QixJQUFJLEVBQUUsWUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQztTQUNsRCxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsZUFBZSxTQUFHLEtBQUssQ0FBQyxlQUFlLG1DQUFJLENBQUMsQ0FBQztJQUVwRCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxPQUFPO1FBQ1osT0FBTztZQUNMLGVBQWUsRUFBRSxJQUFJLENBQUMsZUFBZTtZQUNyQyxRQUFRLEVBQUU7Z0JBQ1IsUUFBUSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFO2dCQUNuQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFVBQVUsRUFBRTthQUN4QjtZQUNELFFBQVEsRUFBRSxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7U0FDbEMsQ0FBQztJQUNKLENBQUM7O0FBbkNILDhCQXFDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwaU9iamVjdCwgTGF6eSB9IGZyb20gJ2NkazhzJztcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xuaW1wb3J0ICogYXMgazhzIGZyb20gJy4vaW1wb3J0cy9rOHMnO1xuaW1wb3J0ICogYXMgd29ya2xvYWQgZnJvbSAnLi93b3JrbG9hZCc7XG5cbi8qKlxuICogUHJvcGVydGllcyBmb3IgYERhZW1vblNldGAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGFlbW9uU2V0UHJvcHMgZXh0ZW5kcyB3b3JrbG9hZC5Xb3JrbG9hZFByb3BzIHtcblxuICAvKipcbiAgICogTWluaW11bSBudW1iZXIgb2Ygc2Vjb25kcyBmb3Igd2hpY2ggYSBuZXdseSBjcmVhdGVkIHBvZCBzaG91bGRcbiAgICogYmUgcmVhZHkgd2l0aG91dCBhbnkgb2YgaXRzIGNvbnRhaW5lciBjcmFzaGluZywgZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICByZWFkb25seSBtaW5SZWFkeVNlY29uZHM/OiBudW1iZXI7XG5cbn1cblxuLyoqXG4gKiBBIERhZW1vblNldCBlbnN1cmVzIHRoYXQgYWxsIChvciBzb21lKSBOb2RlcyBydW4gYSBjb3B5IG9mIGEgUG9kLlxuICogQXMgbm9kZXMgYXJlIGFkZGVkIHRvIHRoZSBjbHVzdGVyLCBQb2RzIGFyZSBhZGRlZCB0byB0aGVtLlxuICogQXMgbm9kZXMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgY2x1c3RlciwgdGhvc2UgUG9kcyBhcmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gKiBEZWxldGluZyBhIERhZW1vblNldCB3aWxsIGNsZWFuIHVwIHRoZSBQb2RzIGl0IGNyZWF0ZWQuXG4gKlxuICogU29tZSB0eXBpY2FsIHVzZXMgb2YgYSBEYWVtb25TZXQgYXJlOlxuICpcbiAqIC0gcnVubmluZyBhIGNsdXN0ZXIgc3RvcmFnZSBkYWVtb24gb24gZXZlcnkgbm9kZVxuICogLSBydW5uaW5nIGEgbG9ncyBjb2xsZWN0aW9uIGRhZW1vbiBvbiBldmVyeSBub2RlXG4gKiAtIHJ1bm5pbmcgYSBub2RlIG1vbml0b3JpbmcgZGFlbW9uIG9uIGV2ZXJ5IG5vZGVcbiAqXG4gKiBJbiBhIHNpbXBsZSBjYXNlLCBvbmUgRGFlbW9uU2V0LCBjb3ZlcmluZyBhbGwgbm9kZXMsIHdvdWxkIGJlIHVzZWQgZm9yIGVhY2ggdHlwZSBvZiBkYWVtb24uXG4gKiBBIG1vcmUgY29tcGxleCBzZXR1cCBtaWdodCB1c2UgbXVsdGlwbGUgRGFlbW9uU2V0cyBmb3IgYSBzaW5nbGUgdHlwZSBvZiBkYWVtb24sXG4gKiBidXQgd2l0aCBkaWZmZXJlbnQgZmxhZ3MgYW5kL29yIGRpZmZlcmVudCBtZW1vcnkgYW5kIGNwdSByZXF1ZXN0cyBmb3IgZGlmZmVyZW50IGhhcmR3YXJlIHR5cGVzLlxuICovXG5leHBvcnQgY2xhc3MgRGFlbW9uU2V0IGV4dGVuZHMgd29ya2xvYWQuV29ya2xvYWQge1xuXG4gIC8qKlxuICAgKiBAc2VlIGJhc2UuUmVzb3VyY2UuYXBpT2JqZWN0XG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgYXBpT2JqZWN0OiBBcGlPYmplY3Q7XG5cbiAgcHVibGljIHJlYWRvbmx5IHJlc291cmNlVHlwZSA9ICdkYWVtb25zZXRzJztcblxuICBwdWJsaWMgcmVhZG9ubHkgbWluUmVhZHlTZWNvbmRzOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IERhZW1vblNldFByb3BzID0ge30pIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHByb3BzKTtcblxuICAgIHRoaXMuYXBpT2JqZWN0ID0gbmV3IGs4cy5LdWJlRGFlbW9uU2V0KHRoaXMsICdSZXNvdXJjZScsIHtcbiAgICAgIG1ldGFkYXRhOiBwcm9wcy5tZXRhZGF0YSxcbiAgICAgIHNwZWM6IExhenkuYW55KHsgcHJvZHVjZTogKCkgPT4gdGhpcy5fdG9LdWJlKCkgfSksXG4gICAgfSk7XG5cbiAgICB0aGlzLm1pblJlYWR5U2Vjb25kcyA9IHByb3BzLm1pblJlYWR5U2Vjb25kcyA/PyAwO1xuXG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgX3RvS3ViZSgpOiBrOHMuRGFlbW9uU2V0U3BlYyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pblJlYWR5U2Vjb25kczogdGhpcy5taW5SZWFkeVNlY29uZHMsXG4gICAgICB0ZW1wbGF0ZToge1xuICAgICAgICBtZXRhZGF0YTogdGhpcy5wb2RNZXRhZGF0YS50b0pzb24oKSxcbiAgICAgICAgc3BlYzogdGhpcy5fdG9Qb2RTcGVjKCksXG4gICAgICB9LFxuICAgICAgc2VsZWN0b3I6IHRoaXMuX3RvTGFiZWxTZWxlY3RvcigpLFxuICAgIH07XG4gIH1cblxufSJdfQ==

/***/ }),

/***/ 4587:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeploymentStrategy = exports.PercentOrAbsolute = exports.Deployment = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const cdk8s_1 = __nccwpck_require__(1227);
const container = __nccwpck_require__(4255);
const k8s = __nccwpck_require__(4879);
const service = __nccwpck_require__(5445);
const workload = __nccwpck_require__(7967);
/**
*
* A Deployment provides declarative updates for Pods and ReplicaSets.
*
* You describe a desired state in a Deployment, and the Deployment Controller changes the actual
* state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove
* existing Deployments and adopt all their resources with new Deployments.
*
* > Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.
*
* Use Case
* ---------
*
* The following are typical use cases for Deployments:
*
* - Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background.
*   Check the status of the rollout to see if it succeeds or not.
* - Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment.
*   A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate.
*   Each new ReplicaSet updates the revision of the Deployment.
* - Rollback to an earlier Deployment revision if the current state of the Deployment is not stable.
*   Each rollback updates the revision of the Deployment.
* - Scale up the Deployment to facilitate more load.
* - Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout.
* - Use the status of the Deployment as an indicator that a rollout has stuck.
* - Clean up older ReplicaSets that you don't need anymore.
*
**/
class Deployment extends workload.Workload {
    constructor(scope, id, props = {}) {
        var _d, _e, _f, _g;
        super(scope, id, props);
        this.resourceType = 'deployments';
        this.apiObject = new k8s.KubeDeployment(this, 'Resource', {
            metadata: props.metadata,
            spec: cdk8s_1.Lazy.any({ produce: () => this._toKube() }),
        });
        this.minReady = (_d = props.minReady) !== null && _d !== void 0 ? _d : cdk8s_1.Duration.seconds(0);
        this.progressDeadline = (_e = props.progressDeadline) !== null && _e !== void 0 ? _e : cdk8s_1.Duration.seconds(600);
        if (this.progressDeadline.toSeconds() <= this.minReady.toSeconds()) {
            throw new Error(`'progressDeadline' (${this.progressDeadline.toSeconds()}s) must be greater than 'minReady' (${this.minReady.toSeconds()}s)`);
        }
        this.replicas = (_f = props.replicas) !== null && _f !== void 0 ? _f : 1;
        this.strategy = (_g = props.strategy) !== null && _g !== void 0 ? _g : DeploymentStrategy.rollingUpdate();
    }
    /**
     * Expose a deployment via a service.
     *
     * This is equivalent to running `kubectl expose deployment <deployment-name>`.
     *
     * @param options Options to determine details of the service and port exposed.
     */
    exposeViaService(options = {}) {
        var _d, _e, _f;
        const ports = (_d = options.ports) !== null && _d !== void 0 ? _d : this.extractPorts();
        if (ports.length === 0) {
            throw new Error(`Unable to expose deployment ${this.name} via a service: `
                + 'Deployment port cannot be determined.'
                + 'Either pass \'ports\', or configure ports on the containers of the deployment');
        }
        return new service.Service(this, `${(_e = options.name) !== null && _e !== void 0 ? _e : ''}Service`, {
            selector: this,
            ports,
            metadata: options.name ? { name: options.name } : undefined,
            type: (_f = options.serviceType) !== null && _f !== void 0 ? _f : service.ServiceType.CLUSTER_IP,
        });
    }
    /**
     * Expose a deployment via an ingress.
     *
     * This will first expose the deployment with a service, and then expose the service via an ingress.
     *
     * @param path The ingress path to register under.
     * @param options Additional options.
     */
    exposeViaIngress(path, options = {}) {
        const ser = this.exposeViaService(options);
        return ser.exposeViaIngress(path, options);
    }
    extractPorts() {
        return container.extractContainerPorts(this).map(port => ({ targetPort: port, port }));
    }
    /**
     * @internal
     */
    _toKube() {
        return {
            replicas: this.replicas,
            minReadySeconds: this.minReady.toSeconds(),
            progressDeadlineSeconds: this.progressDeadline.toSeconds(),
            template: {
                metadata: this.podMetadata.toJson(),
                spec: this._toPodSpec(),
            },
            selector: this._toLabelSelector(),
            strategy: this.strategy._toKube(),
        };
    }
}
exports.Deployment = Deployment;
_a = JSII_RTTI_SYMBOL_1;
Deployment[_a] = { fqn: "cdk8s-plus-22.Deployment", version: "2.0.0-rc.2" };
/**
 * Union like class repsenting either a ration in
 * percents or an absolute number.
 */
class PercentOrAbsolute {
    constructor(value) {
        this.value = value;
    }
    /**
     * Percent ratio.
     */
    static percent(percent) {
        return new PercentOrAbsolute(`${percent}%`);
    }
    /**
     * Absolute number.
     */
    static absolute(num) {
        return new PercentOrAbsolute(num);
    }
    isZero() {
        return this.value === PercentOrAbsolute.absolute(0).value || this.value === PercentOrAbsolute.percent(0).value;
    }
}
exports.PercentOrAbsolute = PercentOrAbsolute;
_b = JSII_RTTI_SYMBOL_1;
PercentOrAbsolute[_b] = { fqn: "cdk8s-plus-22.PercentOrAbsolute", version: "2.0.0-rc.2" };
/**
 * Deployment strategies.
 */
class DeploymentStrategy {
    constructor(strategy) {
        this.strategy = strategy;
    }
    /**
     * All existing Pods are killed before new ones are created.
     *
     * @see https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#recreate-deployment
     */
    static recreate() {
        return new DeploymentStrategy({
            type: 'Recreate',
        });
    }
    static rollingUpdate(options = {}) {
        var _d, _e;
        const maxSurge = (_d = options.maxSurge) !== null && _d !== void 0 ? _d : PercentOrAbsolute.percent(25);
        const maxUnavailable = (_e = options.maxUnavailable) !== null && _e !== void 0 ? _e : PercentOrAbsolute.percent(25);
        if (maxSurge.isZero() && maxUnavailable.isZero()) {
            throw new Error('\'maxSurge\' and \'maxUnavailable\' cannot be both zero');
        }
        return new DeploymentStrategy({
            type: 'RollingUpdate',
            rollingUpdate: { maxSurge, maxUnavailable },
        });
    }
    /**
     * @internal
     */
    _toKube() {
        return this.strategy;
    }
}
exports.DeploymentStrategy = DeploymentStrategy;
_c = JSII_RTTI_SYMBOL_1;
DeploymentStrategy[_c] = { fqn: "cdk8s-plus-22.DeploymentStrategy", version: "2.0.0-rc.2" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwbG95bWVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9kZXBsb3ltZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsaUNBQWtEO0FBRWxELHlDQUF5QztBQUN6QyxxQ0FBcUM7QUFFckMscUNBQXFDO0FBQ3JDLHVDQUF1QztBQWdGdkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTJCRztBQUNILE1BQWEsVUFBVyxTQUFRLFFBQVEsQ0FBQyxRQUFRO0lBOEIvQyxZQUFZLEtBQWdCLEVBQUUsRUFBVSxFQUFFLFFBQXlCLEVBQUU7O1FBQ25FLEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBSFYsaUJBQVksR0FBRyxhQUFhLENBQUM7UUFLM0MsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRTtZQUN4RCxRQUFRLEVBQUUsS0FBSyxDQUFDLFFBQVE7WUFDeEIsSUFBSSxFQUFFLFlBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUM7U0FDbEQsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLFFBQVEsU0FBRyxLQUFLLENBQUMsUUFBUSxtQ0FBSSxnQkFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0RCxJQUFJLENBQUMsZ0JBQWdCLFNBQUcsS0FBSyxDQUFDLGdCQUFnQixtQ0FBSSxnQkFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUV4RSxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxFQUFFO1lBQ2xFLE1BQU0sSUFBSSxLQUFLLENBQUMsdUJBQXVCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFT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J2NkazhzJztcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xuaW1wb3J0ICogYXMgY29udGFpbmVyIGZyb20gJy4vY29udGFpbmVyJztcbmltcG9ydCAqIGFzIGs4cyBmcm9tICcuL2ltcG9ydHMvazhzJztcbmltcG9ydCAqIGFzIGluZ3Jlc3MgZnJvbSAnLi9pbmdyZXNzJztcbmltcG9ydCAqIGFzIHNlcnZpY2UgZnJvbSAnLi9zZXJ2aWNlJztcbmltcG9ydCAqIGFzIHdvcmtsb2FkIGZyb20gJy4vd29ya2xvYWQnO1xuXG4vKipcbiAqIFByb3BlcnRpZXMgZm9yIGBEZXBsb3ltZW50YC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZXBsb3ltZW50UHJvcHMgZXh0ZW5kcyB3b3JrbG9hZC5Xb3JrbG9hZFByb3BzIHtcblxuICAvKipcbiAgICogTnVtYmVyIG9mIGRlc2lyZWQgcG9kcy5cbiAgICpcbiAgICogQGRlZmF1bHQgMVxuICAgKi9cbiAgcmVhZG9ubHkgcmVwbGljYXM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgc3RyYXRlZ3kgdXNlZCB0byByZXBsYWNlIG9sZCBQb2RzIGJ5IG5ldyBvbmVzLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIFJvbGxpbmdVcGRhdGUgd2l0aCBtYXhTdXJnZSBhbmQgbWF4VW5hdmFpbGFibGUgc2V0IHRvIDI1JS5cbiAgICovXG4gIHJlYWRvbmx5IHN0cmF0ZWd5PzogRGVwbG95bWVudFN0cmF0ZWd5O1xuXG4gIC8qKlxuICAgKiBNaW5pbXVtIGR1cmF0aW9uIGZvciB3aGljaCBhIG5ld2x5IGNyZWF0ZWQgcG9kIHNob3VsZCBiZSByZWFkeSB3aXRob3V0XG4gICAqIGFueSBvZiBpdHMgY29udGFpbmVyIGNyYXNoaW5nLCBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhdmFpbGFibGUuXG4gICAqXG4gICAqIFplcm8gbWVhbnMgdGhlIHBvZCB3aWxsIGJlIGNvbnNpZGVyZWQgYXZhaWxhYmxlIGFzIHNvb24gYXMgaXQgaXMgcmVhZHkuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL2NvbnRyb2xsZXJzL2RlcGxveW1lbnQvI21pbi1yZWFkeS1zZWNvbmRzXG4gICAqIEBkZWZhdWx0IER1cmF0aW9uLnNlY29uZHMoMClcbiAgICovXG4gIHJlYWRvbmx5IG1pblJlYWR5PzogRHVyYXRpb247XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIGR1cmF0aW9uIGZvciBhIGRlcGxveW1lbnQgdG8gbWFrZSBwcm9ncmVzcyBiZWZvcmUgaXRcbiAgICogaXMgY29uc2lkZXJlZCB0byBiZSBmYWlsZWQuIFRoZSBkZXBsb3ltZW50IGNvbnRyb2xsZXIgd2lsbCBjb250aW51ZVxuICAgKiB0byBwcm9jZXNzIGZhaWxlZCBkZXBsb3ltZW50cyBhbmQgYSBjb25kaXRpb24gd2l0aCBhIFByb2dyZXNzRGVhZGxpbmVFeGNlZWRlZFxuICAgKiByZWFzb24gd2lsbCBiZSBzdXJmYWNlZCBpbiB0aGUgZGVwbG95bWVudCBzdGF0dXMuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBwcm9ncmVzcyB3aWxsIG5vdCBiZSBlc3RpbWF0ZWQgZHVyaW5nIHRoZSB0aW1lIGEgZGVwbG95bWVudCBpcyBwYXVzZWQuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL2NvbnRyb2xsZXJzL2RlcGxveW1lbnQvI3Byb2dyZXNzLWRlYWRsaW5lLXNlY29uZHNcbiAgICogQGRlZmF1bHQgRHVyYXRpb24uc2Vjb25kcyg2MDApXG4gICAqL1xuICByZWFkb25seSBwcm9ncmVzc0RlYWRsaW5lPzogRHVyYXRpb247XG5cbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBgRGVwbG95bWVudC5leHBvc2VWaWFTZXJ2aWNlYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZXBsb3ltZW50RXhwb3NlVmlhU2VydmljZU9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHBvcnRzIHRoYXQgdGhlIHNlcnZpY2Ugc2hvdWxkIGJpbmQgdG8uXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gZXh0cmFjdGVkIGZyb20gdGhlIGRlcGxveW1lbnQuXG4gICAqL1xuICByZWFkb25seSBwb3J0cz86IHNlcnZpY2UuU2VydmljZVBvcnRbXTtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIGV4cG9zZWQgc2VydmljZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBDbHVzdGVySVAuXG4gICAqL1xuICByZWFkb25seSBzZXJ2aWNlVHlwZT86IHNlcnZpY2UuU2VydmljZVR5cGU7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBzZXJ2aWNlIHRvIGV4cG9zZS5cbiAgICogSWYgeW91J2QgbGlrZSB0byBleHBvc2UgdGhlIGRlcGxveW1lbnQgbXVsdGlwbGUgdGltZXMsXG4gICAqIHlvdSBtdXN0IGV4cGxpY2l0bHkgc2V0IGEgbmFtZSBzdGFydGluZyBmcm9tIHRoZSBzZWNvbmQgZXhwb3NlIGNhbGwuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gYXV0byBnZW5lcmF0ZWQuXG4gICAqL1xuICByZWFkb25seSBuYW1lPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGV4cG9zaW5nIGEgZGVwbG95bWVudCB2aWEgYW4gaW5ncmVzcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFeHBvc2VEZXBsb3ltZW50VmlhSW5ncmVzc09wdGlvbnMgZXh0ZW5kcyBEZXBsb3ltZW50RXhwb3NlVmlhU2VydmljZU9wdGlvbnMsIHNlcnZpY2UuRXhwb3NlU2VydmljZVZpYUluZ3Jlc3NPcHRpb25zIHt9XG5cbi8qKlxuKlxuKiBBIERlcGxveW1lbnQgcHJvdmlkZXMgZGVjbGFyYXRpdmUgdXBkYXRlcyBmb3IgUG9kcyBhbmQgUmVwbGljYVNldHMuXG4qXG4qIFlvdSBkZXNjcmliZSBhIGRlc2lyZWQgc3RhdGUgaW4gYSBEZXBsb3ltZW50LCBhbmQgdGhlIERlcGxveW1lbnQgQ29udHJvbGxlciBjaGFuZ2VzIHRoZSBhY3R1YWxcbiogc3RhdGUgdG8gdGhlIGRlc2lyZWQgc3RhdGUgYXQgYSBjb250cm9sbGVkIHJhdGUuIFlvdSBjYW4gZGVmaW5lIERlcGxveW1lbnRzIHRvIGNyZWF0ZSBuZXcgUmVwbGljYVNldHMsIG9yIHRvIHJlbW92ZVxuKiBleGlzdGluZyBEZXBsb3ltZW50cyBhbmQgYWRvcHQgYWxsIHRoZWlyIHJlc291cmNlcyB3aXRoIG5ldyBEZXBsb3ltZW50cy5cbipcbiogPiBOb3RlOiBEbyBub3QgbWFuYWdlIFJlcGxpY2FTZXRzIG93bmVkIGJ5IGEgRGVwbG95bWVudC4gQ29uc2lkZXIgb3BlbmluZyBhbiBpc3N1ZSBpbiB0aGUgbWFpbiBLdWJlcm5ldGVzIHJlcG9zaXRvcnkgaWYgeW91ciB1c2UgY2FzZSBpcyBub3QgY292ZXJlZCBiZWxvdy5cbipcbiogVXNlIENhc2VcbiogLS0tLS0tLS0tXG4qXG4qIFRoZSBmb2xsb3dpbmcgYXJlIHR5cGljYWwgdXNlIGNhc2VzIGZvciBEZXBsb3ltZW50czpcbipcbiogLSBDcmVhdGUgYSBEZXBsb3ltZW50IHRvIHJvbGxvdXQgYSBSZXBsaWNhU2V0LiBUaGUgUmVwbGljYVNldCBjcmVhdGVzIFBvZHMgaW4gdGhlIGJhY2tncm91bmQuXG4qICAgQ2hlY2sgdGhlIHN0YXR1cyBvZiB0aGUgcm9sbG91dCB0byBzZWUgaWYgaXQgc3VjY2VlZHMgb3Igbm90LlxuKiAtIERlY2xhcmUgdGhlIG5ldyBzdGF0ZSBvZiB0aGUgUG9kcyBieSB1cGRhdGluZyB0aGUgUG9kVGVtcGxhdGVTcGVjIG9mIHRoZSBEZXBsb3ltZW50LlxuKiAgIEEgbmV3IFJlcGxpY2FTZXQgaXMgY3JlYXRlZCBhbmQgdGhlIERlcGxveW1lbnQgbWFuYWdlcyBtb3ZpbmcgdGhlIFBvZHMgZnJvbSB0aGUgb2xkIFJlcGxpY2FTZXQgdG8gdGhlIG5ldyBvbmUgYXQgYSBjb250cm9sbGVkIHJhdGUuXG4qICAgRWFjaCBuZXcgUmVwbGljYVNldCB1cGRhdGVzIHRoZSByZXZpc2lvbiBvZiB0aGUgRGVwbG95bWVudC5cbiogLSBSb2xsYmFjayB0byBhbiBlYXJsaWVyIERlcGxveW1lbnQgcmV2aXNpb24gaWYgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIERlcGxveW1lbnQgaXMgbm90IHN0YWJsZS5cbiogICBFYWNoIHJvbGxiYWNrIHVwZGF0ZXMgdGhlIHJldmlzaW9uIG9mIHRoZSBEZXBsb3ltZW50LlxuKiAtIFNjYWxlIHVwIHRoZSBEZXBsb3ltZW50IHRvIGZhY2lsaXRhdGUgbW9yZSBsb2FkLlxuKiAtIFBhdXNlIHRoZSBEZXBsb3ltZW50IHRvIGFwcGx5IG11bHRpcGxlIGZpeGVzIHRvIGl0cyBQb2RUZW1wbGF0ZVNwZWMgYW5kIHRoZW4gcmVzdW1lIGl0IHRvIHN0YXJ0IGEgbmV3IHJvbGxvdXQuXG4qIC0gVXNlIHRoZSBzdGF0dXMgb2YgdGhlIERlcGxveW1lbnQgYXMgYW4gaW5kaWNhdG9yIHRoYXQgYSByb2xsb3V0IGhhcyBzdHVjay5cbiogLSBDbGVhbiB1cCBvbGRlciBSZXBsaWNhU2V0cyB0aGF0IHlvdSBkb24ndCBuZWVkIGFueW1vcmUuXG4qXG4qKi9cbmV4cG9ydCBjbGFzcyBEZXBsb3ltZW50IGV4dGVuZHMgd29ya2xvYWQuV29ya2xvYWQge1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgZGVzaXJlZCBwb2RzLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHJlcGxpY2FzOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE1pbmltdW0gZHVyYXRpb24gZm9yIHdoaWNoIGEgbmV3bHkgY3JlYXRlZCBwb2Qgc2hvdWxkIGJlIHJlYWR5IHdpdGhvdXRcbiAgICogYW55IG9mIGl0cyBjb250YWluZXIgY3Jhc2hpbmcsIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGF2YWlsYWJsZS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBtaW5SZWFkeTogRHVyYXRpb247XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIGR1cmF0aW9uIGZvciBhIGRlcGxveW1lbnQgdG8gbWFrZSBwcm9ncmVzcyBiZWZvcmUgaXQgaXMgY29uc2lkZXJlZCB0byBiZSBmYWlsZWQuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgcHJvZ3Jlc3NEZWFkbGluZTogRHVyYXRpb247XG5cbiAgLypcbiAgICogVGhlIHVwZ3JhZGUgc3RyYXRlZ3kgb2YgdGhpcyBkZXBsb3ltZW50LlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHN0cmF0ZWd5OiBEZXBsb3ltZW50U3RyYXRlZ3k7XG5cbiAgLyoqXG4gICAqIEBzZWUgYmFzZS5SZXNvdXJjZS5hcGlPYmplY3RcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBhcGlPYmplY3Q6IEFwaU9iamVjdDtcblxuICBwdWJsaWMgcmVhZG9ubHkgcmVzb3VyY2VUeXBlID0gJ2RlcGxveW1lbnRzJztcblxuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogRGVwbG95bWVudFByb3BzID0ge30pIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHByb3BzKTtcblxuICAgIHRoaXMuYXBpT2JqZWN0ID0gbmV3IGs4cy5LdWJlRGVwbG95bWVudCh0aGlzLCAnUmVzb3VyY2UnLCB7XG4gICAgICBtZXRhZGF0YTogcHJvcHMubWV0YWRhdGEsXG4gICAgICBzcGVjOiBMYXp5LmFueSh7IHByb2R1Y2U6ICgpID0+IHRoaXMuX3RvS3ViZSgpIH0pLFxuICAgIH0pO1xuXG4gICAgdGhpcy5taW5SZWFkeSA9IHByb3BzLm1pblJlYWR5ID8/IER1cmF0aW9uLnNlY29uZHMoMCk7XG4gICAgdGhpcy5wcm9ncmVzc0RlYWRsaW5lID0gcHJvcHMucHJvZ3Jlc3NEZWFkbGluZSA/PyBEdXJhdGlvbi5zZWNvbmRzKDYwMCk7XG5cbiAgICBpZiAodGhpcy5wcm9ncmVzc0RlYWRsaW5lLnRvU2Vjb25kcygpIDw9IHRoaXMubWluUmVhZHkudG9TZWNvbmRzKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJ3Byb2dyZXNzRGVhZGxpbmUnICgke3RoaXMucHJvZ3Jlc3NEZWFkbGluZS50b1NlY29uZHMoKX1zKSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAnbWluUmVhZHknICgke3RoaXMubWluUmVhZHkudG9TZWNvbmRzKCl9cylgKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlcGxpY2FzID0gcHJvcHMucmVwbGljYXMgPz8gMTtcbiAgICB0aGlzLnN0cmF0ZWd5ID0gcHJvcHMuc3RyYXRlZ3kgPz8gRGVwbG95bWVudFN0cmF0ZWd5LnJvbGxpbmdVcGRhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvc2UgYSBkZXBsb3ltZW50IHZpYSBhIHNlcnZpY2UuXG4gICAqXG4gICAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byBydW5uaW5nIGBrdWJlY3RsIGV4cG9zZSBkZXBsb3ltZW50IDxkZXBsb3ltZW50LW5hbWU+YC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBkZXRlcm1pbmUgZGV0YWlscyBvZiB0aGUgc2VydmljZSBhbmQgcG9ydCBleHBvc2VkLlxuICAgKi9cbiAgcHVibGljIGV4cG9zZVZpYVNlcnZpY2Uob3B0aW9uczogRGVwbG95bWVudEV4cG9zZVZpYVNlcnZpY2VPcHRpb25zID0ge30pOiBzZXJ2aWNlLlNlcnZpY2Uge1xuICAgIGNvbnN0IHBvcnRzID0gb3B0aW9ucy5wb3J0cyA/PyB0aGlzLmV4dHJhY3RQb3J0cygpO1xuICAgIGlmIChwb3J0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGV4cG9zZSBkZXBsb3ltZW50ICR7dGhpcy5uYW1lfSB2aWEgYSBzZXJ2aWNlOiBgXG4gICAgICAgICsgJ0RlcGxveW1lbnQgcG9ydCBjYW5ub3QgYmUgZGV0ZXJtaW5lZC4nXG4gICAgICAgICsgJ0VpdGhlciBwYXNzIFxcJ3BvcnRzXFwnLCBvciBjb25maWd1cmUgcG9ydHMgb24gdGhlIGNvbnRhaW5lcnMgb2YgdGhlIGRlcGxveW1lbnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBzZXJ2aWNlLlNlcnZpY2UodGhpcywgYCR7b3B0aW9ucy5uYW1lID8/ICcnfVNlcnZpY2VgLCB7XG4gICAgICBzZWxlY3RvcjogdGhpcyxcbiAgICAgIHBvcnRzLFxuICAgICAgbWV0YWRhdGE6IG9wdGlvbnMubmFtZSA/IHsgbmFtZTogb3B0aW9ucy5uYW1lIH0gOiB1bmRlZmluZWQsXG4gICAgICB0eXBlOiBvcHRpb25zLnNlcnZpY2VUeXBlID8/IHNlcnZpY2UuU2VydmljZVR5cGUuQ0xVU1RFUl9JUCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvc2UgYSBkZXBsb3ltZW50IHZpYSBhbiBpbmdyZXNzLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgZmlyc3QgZXhwb3NlIHRoZSBkZXBsb3ltZW50IHdpdGggYSBzZXJ2aWNlLCBhbmQgdGhlbiBleHBvc2UgdGhlIHNlcnZpY2UgdmlhIGFuIGluZ3Jlc3MuXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBpbmdyZXNzIHBhdGggdG8gcmVnaXN0ZXIgdW5kZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICovXG4gIHB1YmxpYyBleHBvc2VWaWFJbmdyZXNzKHBhdGg6IHN0cmluZywgb3B0aW9uczogRXhwb3NlRGVwbG95bWVudFZpYUluZ3Jlc3NPcHRpb25zID0ge30pOiBpbmdyZXNzLkluZ3Jlc3Mge1xuICAgIGNvbnN0IHNlciA9IHRoaXMuZXhwb3NlVmlhU2VydmljZShvcHRpb25zKTtcbiAgICByZXR1cm4gc2VyLmV4cG9zZVZpYUluZ3Jlc3MocGF0aCwgb3B0aW9ucyk7XG4gIH1cblxuICBwcml2YXRlIGV4dHJhY3RQb3J0cygpOiBzZXJ2aWNlLlNlcnZpY2VQb3J0W10ge1xuICAgIHJldHVybiBjb250YWluZXIuZXh0cmFjdENvbnRhaW5lclBvcnRzKHRoaXMpLm1hcChwb3J0ID0+ICh7IHRhcmdldFBvcnQ6IHBvcnQsIHBvcnQgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHVibGljIF90b0t1YmUoKTogazhzLkRlcGxveW1lbnRTcGVjIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVwbGljYXM6IHRoaXMucmVwbGljYXMsXG4gICAgICBtaW5SZWFkeVNlY29uZHM6IHRoaXMubWluUmVhZHkudG9TZWNvbmRzKCksXG4gICAgICBwcm9ncmVzc0RlYWRsaW5lU2Vjb25kczogdGhpcy5wcm9ncmVzc0RlYWRsaW5lLnRvU2Vjb25kcygpLFxuICAgICAgdGVtcGxhdGU6IHtcbiAgICAgICAgbWV0YWRhdGE6IHRoaXMucG9kTWV0YWRhdGEudG9Kc29uKCksXG4gICAgICAgIHNwZWM6IHRoaXMuX3RvUG9kU3BlYygpLFxuICAgICAgfSxcbiAgICAgIHNlbGVjdG9yOiB0aGlzLl90b0xhYmVsU2VsZWN0b3IoKSxcbiAgICAgIHN0cmF0ZWd5OiB0aGlzLnN0cmF0ZWd5Ll90b0t1YmUoKSxcbiAgICB9O1xuICB9XG5cbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBgRGVwbG95bWVudFN0cmF0ZWd5LnJvbGxpbmdVcGRhdGVgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIERlcGxveW1lbnRTdHJhdGVneVJvbGxpbmdVcGRhdGVPcHRpb25zIHtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHBvZHMgdGhhdCBjYW4gYmUgc2NoZWR1bGVkIGFib3ZlIHRoZSBkZXNpcmVkIG51bWJlciBvZiBwb2RzLlxuICAgKiBWYWx1ZSBjYW4gYmUgYW4gYWJzb2x1dGUgbnVtYmVyIChleDogNSkgb3IgYSBwZXJjZW50YWdlIG9mIGRlc2lyZWQgcG9kcyAoZXg6IDEwJSkuXG4gICAqIEFic29sdXRlIG51bWJlciBpcyBjYWxjdWxhdGVkIGZyb20gcGVyY2VudGFnZSBieSByb3VuZGluZyB1cC5cbiAgICogVGhpcyBjYW4gbm90IGJlIDAgaWYgYG1heFVuYXZhaWxhYmxlYCBpcyAwLlxuICAgKlxuICAgKiBFeGFtcGxlOiB3aGVuIHRoaXMgaXMgc2V0IHRvIDMwJSwgdGhlIG5ldyBSZXBsaWNhU2V0IGNhbiBiZSBzY2FsZWQgdXAgaW1tZWRpYXRlbHkgd2hlbiB0aGUgcm9sbGluZyB1cGRhdGVcbiAgICogc3RhcnRzLCBzdWNoIHRoYXQgdGhlIHRvdGFsIG51bWJlciBvZiBvbGQgYW5kIG5ldyBwb2RzIGRvIG5vdCBleGNlZWQgMTMwJSBvZiBkZXNpcmVkIHBvZHMuXG4gICAqIE9uY2Ugb2xkIHBvZHMgaGF2ZSBiZWVuIGtpbGxlZCwgbmV3IFJlcGxpY2FTZXQgY2FuIGJlIHNjYWxlZCB1cCBmdXJ0aGVyLCBlbnN1cmluZyB0aGF0XG4gICAqIHRvdGFsIG51bWJlciBvZiBwb2RzIHJ1bm5pbmcgYXQgYW55IHRpbWUgZHVyaW5nIHRoZSB1cGRhdGUgaXMgYXQgbW9zdCAxMzAlIG9mIGRlc2lyZWQgcG9kcy5cbiAgICpcbiAgICogQGRlZmF1bHQgJzI1JSdcbiAgICovXG4gIHJlYWRvbmx5IG1heFN1cmdlPzogUGVyY2VudE9yQWJzb2x1dGU7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBwb2RzIHRoYXQgY2FuIGJlIHVuYXZhaWxhYmxlIGR1cmluZyB0aGUgdXBkYXRlLlxuICAgKiBWYWx1ZSBjYW4gYmUgYW4gYWJzb2x1dGUgbnVtYmVyIChleDogNSkgb3IgYSBwZXJjZW50YWdlIG9mIGRlc2lyZWQgcG9kcyAoZXg6IDEwJSkuXG4gICAqIEFic29sdXRlIG51bWJlciBpcyBjYWxjdWxhdGVkIGZyb20gcGVyY2VudGFnZSBieSByb3VuZGluZyBkb3duLlxuICAgKiBUaGlzIGNhbiBub3QgYmUgMCBpZiBgbWF4U3VyZ2VgIGlzIDAuXG4gICAqXG4gICAqIEV4YW1wbGU6IHdoZW4gdGhpcyBpcyBzZXQgdG8gMzAlLCB0aGUgb2xkIFJlcGxpY2FTZXQgY2FuIGJlIHNjYWxlZCBkb3duIHRvIDcwJSBvZiBkZXNpcmVkXG4gICAqIHBvZHMgaW1tZWRpYXRlbHkgd2hlbiB0aGUgcm9sbGluZyB1cGRhdGUgc3RhcnRzLiBPbmNlIG5ldyBwb2RzIGFyZSByZWFkeSwgb2xkIFJlcGxpY2FTZXQgY2FuXG4gICAqIGJlIHNjYWxlZCBkb3duIGZ1cnRoZXIsIGZvbGxvd2VkIGJ5IHNjYWxpbmcgdXAgdGhlIG5ldyBSZXBsaWNhU2V0LCBlbnN1cmluZyB0aGF0IHRoZSB0b3RhbFxuICAgKiBudW1iZXIgb2YgcG9kcyBhdmFpbGFibGUgYXQgYWxsIHRpbWVzIGR1cmluZyB0aGUgdXBkYXRlIGlzIGF0IGxlYXN0IDcwJSBvZiBkZXNpcmVkIHBvZHMuXG4gICAqXG4gICAqIEBkZWZhdWx0ICcyNSUnXG4gICAqL1xuICByZWFkb25seSBtYXhVbmF2YWlsYWJsZT86IFBlcmNlbnRPckFic29sdXRlO1xuXG59XG5cbi8qKlxuICogVW5pb24gbGlrZSBjbGFzcyByZXBzZW50aW5nIGVpdGhlciBhIHJhdGlvbiBpblxuICogcGVyY2VudHMgb3IgYW4gYWJzb2x1dGUgbnVtYmVyLlxuICovXG5leHBvcnQgY2xhc3MgUGVyY2VudE9yQWJzb2x1dGUge1xuXG4gIC8qKlxuICAgKiBQZXJjZW50IHJhdGlvLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBwZXJjZW50KHBlcmNlbnQ6IG51bWJlcik6IFBlcmNlbnRPckFic29sdXRlIHtcbiAgICByZXR1cm4gbmV3IFBlcmNlbnRPckFic29sdXRlKGAke3BlcmNlbnR9JWApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFic29sdXRlIG51bWJlci5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYWJzb2x1dGUobnVtOiBudW1iZXIpOiBQZXJjZW50T3JBYnNvbHV0ZSB7XG4gICAgcmV0dXJuIG5ldyBQZXJjZW50T3JBYnNvbHV0ZShudW0pO1xuICB9XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgdmFsdWU6IGFueSkge31cblxuICBwdWJsaWMgaXNaZXJvKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnZhbHVlID09PSBQZXJjZW50T3JBYnNvbHV0ZS5hYnNvbHV0ZSgwKS52YWx1ZSB8fCB0aGlzLnZhbHVlID09PSBQZXJjZW50T3JBYnNvbHV0ZS5wZXJjZW50KDApLnZhbHVlO1xuICB9XG5cbn1cblxuLyoqXG4gKiBEZXBsb3ltZW50IHN0cmF0ZWdpZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZXBsb3ltZW50U3RyYXRlZ3kge1xuXG4gIC8qKlxuICAgKiBBbGwgZXhpc3RpbmcgUG9kcyBhcmUga2lsbGVkIGJlZm9yZSBuZXcgb25lcyBhcmUgY3JlYXRlZC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy93b3JrbG9hZHMvY29udHJvbGxlcnMvZGVwbG95bWVudC8jcmVjcmVhdGUtZGVwbG95bWVudFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWNyZWF0ZSgpOiBEZXBsb3ltZW50U3RyYXRlZ3kge1xuICAgIHJldHVybiBuZXcgRGVwbG95bWVudFN0cmF0ZWd5KHtcbiAgICAgIHR5cGU6ICdSZWNyZWF0ZScsXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIHJvbGxpbmdVcGRhdGUob3B0aW9uczogRGVwbG95bWVudFN0cmF0ZWd5Um9sbGluZ1VwZGF0ZU9wdGlvbnMgPSB7fSk6IERlcGxveW1lbnRTdHJhdGVneSB7XG5cbiAgICBjb25zdCBtYXhTdXJnZSA9IG9wdGlvbnMubWF4U3VyZ2UgPz8gUGVyY2VudE9yQWJzb2x1dGUucGVyY2VudCgyNSk7XG4gICAgY29uc3QgbWF4VW5hdmFpbGFibGUgPSBvcHRpb25zLm1heFVuYXZhaWxhYmxlID8/IFBlcmNlbnRPckFic29sdXRlLnBlcmNlbnQoMjUpO1xuXG4gICAgaWYgKG1heFN1cmdlLmlzWmVybygpICYmIG1heFVuYXZhaWxhYmxlLmlzWmVybygpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1xcJ21heFN1cmdlXFwnIGFuZCBcXCdtYXhVbmF2YWlsYWJsZVxcJyBjYW5ub3QgYmUgYm90aCB6ZXJvJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEZXBsb3ltZW50U3RyYXRlZ3koe1xuICAgICAgdHlwZTogJ1JvbGxpbmdVcGRhdGUnLFxuICAgICAgcm9sbGluZ1VwZGF0ZTogeyBtYXhTdXJnZSwgbWF4VW5hdmFpbGFibGUgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBzdHJhdGVneTogazhzLkRlcGxveW1lbnRTdHJhdGVneSkge31cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgX3RvS3ViZSgpOiBrOHMuRGVwbG95bWVudFN0cmF0ZWd5IHtcbiAgICByZXR1cm4gdGhpcy5zdHJhdGVneTtcbiAgfVxuXG59Il19

/***/ }),

/***/ 5383:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Handler = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const _action = __nccwpck_require__(4778);
/**
 * Defines a specific action that should be taken.
 */
class Handler {
    constructor(tcpSocketOptions, commandOptions, httpGetOptions) {
        this.tcpSocketOptions = tcpSocketOptions;
        this.commandOptions = commandOptions;
        this.httpGetOptions = httpGetOptions;
    }
    /**
     * Defines a handler based on an HTTP GET request to the IP address of the container.
     *
     * @param path The URL path to hit
     * @param options Options
     */
    static fromHttpGet(path, options = {}) {
        return new Handler(undefined, undefined, { path, ...options });
    }
    /**
     * Defines a handler based on a command which is executed within the container.
     *
     * @param command The command to execute
     */
    static fromCommand(command) {
        return new Handler(undefined, { command }, undefined);
    }
    /**
     * Defines a handler based opening a connection to a TCP socket on the container.
     *
     * @param options Options
     */
    static fromTcpSocket(options = {}) {
        return new Handler(options, undefined, undefined);
    }
    /**
     * @internal
     */
    _toKube(cont) {
        const exec = this.commandOptions ? _action.Action.fromCommand(this.commandOptions.command) : undefined;
        const httpGet = this.httpGetOptions ? _action.Action.fromHttpGet(cont, this.httpGetOptions.path, this.httpGetOptions) : undefined;
        const tcpSocket = this.tcpSocketOptions ? _action.Action.fromTcpSocket(cont, this.tcpSocketOptions) : undefined;
        return { exec, httpGet, tcpSocket };
    }
}
exports.Handler = Handler;
_a = JSII_RTTI_SYMBOL_1;
Handler[_a] = { fqn: "cdk8s-plus-22.Handler", version: "2.0.0-rc.2" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFuZGxlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9oYW5kbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEscUNBQXFDO0FBc0NyQzs7R0FFRztBQUNILE1BQWEsT0FBTztJQThCbEIsWUFDbUIsZ0JBQThDLEVBQzlDLGNBQXNDLEVBQ3RDLGNBQTZEO1FBRjdELHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBOEI7UUFDOUMsbUJBQWMsR0FBZCxjQUFjLENBQXdCO1FBQ3RDLG1CQUFjLEdBQWQsY0FBYyxDQUErQztJQUFHLENBQUM7SUEvQnBGOzs7OztPQUtHO0lBQ0ksTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFZLEVBQUUsVUFBcUMsRUFBRTtRQUM3RSxPQUFPLElBQUksT0FBTyxDQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsRUFBRSxJQUFJLEVBQUUsR0FBRyxPQUFPLEVBQUUsQ0FBQyxDQUFDO0lBQ2pFLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksTUFBTSxDQUFDLFdBQVcsQ0FBQyxPQUFpQjtRQUN6QyxPQUFPLElBQUksT0FBTyxDQUFDLFNBQVMsRUFBRSxFQUFFLE9BQU8sRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksTUFBTSxDQUFDLGFBQWEsQ0FBQyxVQUF1QyxFQUFFO1FBQ25FLE9BQU8sSUFBSSxPQUFPLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBT0Q7O09BRUc7SUFDSSxPQUFPLENBQUMsSUFBeUI7UUFFdEMsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO1FBQ3ZHLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztRQUNsSSxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO1FBRWhILE9BQU8sRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxDQUFDO0lBQ3RDLENBQUM7O0FBN0NILDBCQStDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIF9hY3Rpb24gZnJvbSAnLi9fYWN0aW9uJztcbmltcG9ydCAqIGFzIGNvbnRhaW5lciBmcm9tICcuL2NvbnRhaW5lcic7XG5pbXBvcnQgKiBhcyBrOHMgZnJvbSAnLi9pbXBvcnRzL2s4cyc7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYEhhbmRsZXIuZnJvbVRjcFNvY2tldGAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSGFuZGxlckZyb21UY3BTb2NrZXRPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBUQ1AgcG9ydCB0byBjb25uZWN0IHRvIG9uIHRoZSBjb250YWluZXIuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gZGVmYXVsdHMgdG8gYGNvbnRhaW5lci5wb3J0YC5cbiAgICovXG4gIHJlYWRvbmx5IHBvcnQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBob3N0IG5hbWUgdG8gY29ubmVjdCB0byBvbiB0aGUgY29udGFpbmVyLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGRlZmF1bHRzIHRvIHRoZSBwb2QgSVBcbiAgICovXG4gIHJlYWRvbmx5IGhvc3Q/OiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBgSGFuZGxlci5mcm9tSHR0cEdldGAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSGFuZGxlckZyb21IdHRwR2V0T3B0aW9ucyB7XG5cbiAgLyoqXG4gICAqIFRoZSBUQ1AgcG9ydCB0byB1c2Ugd2hlbiBzZW5kaW5nIHRoZSBHRVQgcmVxdWVzdC5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBkZWZhdWx0cyB0byBgY29udGFpbmVyLnBvcnRgLlxuICAgKi9cbiAgcmVhZG9ubHkgcG9ydD86IG51bWJlcjtcblxufVxuXG4vKipcbiAqIERlZmluZXMgYSBzcGVjaWZpYyBhY3Rpb24gdGhhdCBzaG91bGQgYmUgdGFrZW4uXG4gKi9cbmV4cG9ydCBjbGFzcyBIYW5kbGVyIHtcblxuICAvKipcbiAgICogRGVmaW5lcyBhIGhhbmRsZXIgYmFzZWQgb24gYW4gSFRUUCBHRVQgcmVxdWVzdCB0byB0aGUgSVAgYWRkcmVzcyBvZiB0aGUgY29udGFpbmVyLlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgVVJMIHBhdGggdG8gaGl0XG4gICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbUh0dHBHZXQocGF0aDogc3RyaW5nLCBvcHRpb25zOiBIYW5kbGVyRnJvbUh0dHBHZXRPcHRpb25zID0ge30pOiBIYW5kbGVyIHtcbiAgICByZXR1cm4gbmV3IEhhbmRsZXIodW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgcGF0aCwgLi4ub3B0aW9ucyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgaGFuZGxlciBiYXNlZCBvbiBhIGNvbW1hbmQgd2hpY2ggaXMgZXhlY3V0ZWQgd2l0aGluIHRoZSBjb250YWluZXIuXG4gICAqXG4gICAqIEBwYXJhbSBjb21tYW5kIFRoZSBjb21tYW5kIHRvIGV4ZWN1dGVcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbUNvbW1hbmQoY29tbWFuZDogc3RyaW5nW10pOiBIYW5kbGVyIHtcbiAgICByZXR1cm4gbmV3IEhhbmRsZXIodW5kZWZpbmVkLCB7IGNvbW1hbmQgfSwgdW5kZWZpbmVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgaGFuZGxlciBiYXNlZCBvcGVuaW5nIGEgY29ubmVjdGlvbiB0byBhIFRDUCBzb2NrZXQgb24gdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tVGNwU29ja2V0KG9wdGlvbnM6IEhhbmRsZXJGcm9tVGNwU29ja2V0T3B0aW9ucyA9IHt9KTogSGFuZGxlciB7XG4gICAgcmV0dXJuIG5ldyBIYW5kbGVyKG9wdGlvbnMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgfVxuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSB0Y3BTb2NrZXRPcHRpb25zPzogSGFuZGxlckZyb21UY3BTb2NrZXRPcHRpb25zLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY29tbWFuZE9wdGlvbnM/OiB7IGNvbW1hbmQ6IHN0cmluZ1tdIH0sXG4gICAgcHJpdmF0ZSByZWFkb25seSBodHRwR2V0T3B0aW9ucz86IHsgcGF0aDogc3RyaW5nIH0gJiBIYW5kbGVyRnJvbUh0dHBHZXRPcHRpb25zKSB7fVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHB1YmxpYyBfdG9LdWJlKGNvbnQ6IGNvbnRhaW5lci5Db250YWluZXIpOiBrOHMuSGFuZGxlciB7XG5cbiAgICBjb25zdCBleGVjID0gdGhpcy5jb21tYW5kT3B0aW9ucyA/IF9hY3Rpb24uQWN0aW9uLmZyb21Db21tYW5kKHRoaXMuY29tbWFuZE9wdGlvbnMuY29tbWFuZCkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgaHR0cEdldCA9IHRoaXMuaHR0cEdldE9wdGlvbnMgPyBfYWN0aW9uLkFjdGlvbi5mcm9tSHR0cEdldChjb250LCB0aGlzLmh0dHBHZXRPcHRpb25zLnBhdGgsIHRoaXMuaHR0cEdldE9wdGlvbnMpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHRjcFNvY2tldCA9IHRoaXMudGNwU29ja2V0T3B0aW9ucyA/IF9hY3Rpb24uQWN0aW9uLmZyb21UY3BTb2NrZXQoY29udCwgdGhpcy50Y3BTb2NrZXRPcHRpb25zKSA6IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiB7IGV4ZWMsIGh0dHBHZXQsIHRjcFNvY2tldCB9O1xuICB9XG5cbn0iXX0=

/***/ }),

/***/ 4879:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toJson_ExternalDocumentation = exports.toJson_ServiceAccountTokenProjection = exports.toJson_SecretProjection = exports.toJson_DownwardApiProjection = exports.toJson_ConfigMapProjection = exports.toJson_HttpHeader = exports.toJson_SecretKeySelector = exports.toJson_ResourceFieldSelector = exports.toJson_ObjectFieldSelector = exports.toJson_ConfigMapKeySelector = exports.toJson_NodeSelectorRequirement = exports.toJson_CustomResourceSubresourceScale = exports.toJson_JsonSchemaProps = exports.toJson_IpBlock = exports.toJson_HttpIngressPath = exports.toJson_ServiceBackendPort = exports.toJson_QueuingConfigurationV1Beta1 = exports.toJson_UserSubjectV1Beta1 = exports.toJson_ServiceAccountSubjectV1Beta1 = exports.toJson_GroupSubjectV1Beta1 = exports.toJson_VolumeProjection = exports.toJson_PersistentVolumeClaimTemplate = exports.toJson_DownwardApiVolumeFile = exports.toJson_KeyToPath = exports.toJson_Capabilities = exports.toJson_TcpSocketAction = exports.toJson_HttpGetAction = exports.toJson_ExecAction = exports.toJson_Handler = exports.toJson_SecretEnvSource = exports.toJson_ConfigMapEnvSource = exports.toJson_EnvVarSource = exports.toJson_PodAffinityTerm = exports.toJson_WeightedPodAffinityTerm = exports.toJson_PreferredSchedulingTerm = exports.toJson_NodeSelectorTerm = exports.toJson_MetricIdentifierV2Beta2 = exports.toJson_MetricTargetV2Beta2 = exports.toJson_HpaScalingPolicyV2Beta2 = exports.toJson_CustomResourceSubresources = exports.toJson_CustomResourceValidation = exports.toJson_CustomResourceColumnDefinition = exports.toJson_WebhookConversion = exports.toJson_VolumeNodeResources = exports.toJson_IdRangeV1Beta1 = exports.toJson_NetworkPolicyPeer = exports.toJson_NetworkPolicyPort = exports.toJson_HttpIngressRuleValue = exports.toJson_IngressServiceBackend = exports.toJson_LimitResponseV1Beta1 = exports.toJson_SubjectV1Beta1 = exports.toJson_ResourcePolicyRuleV1Beta1 = exports.toJson_NonResourcePolicyRuleV1Beta1 = exports.toJson_ForZoneV1Beta1 = exports.toJson_ForZone = exports.toJson_ClientIpConfig = exports.toJson_ScopedResourceSelectorRequirement = exports.toJson_StorageOsVolumeSource = exports.toJson_SecretVolumeSource = exports.toJson_ScaleIoVolumeSource = exports.toJson_RbdVolumeSource = exports.toJson_ProjectedVolumeSource = exports.toJson_PersistentVolumeClaimVolumeSource = exports.toJson_IscsiVolumeSource = exports.toJson_GlusterfsVolumeSource = exports.toJson_GitRepoVolumeSource = exports.toJson_FlexVolumeSource = exports.toJson_EphemeralVolumeSource = exports.toJson_EmptyDirVolumeSource = exports.toJson_DownwardApiVolumeSource = exports.toJson_CsiVolumeSource = exports.toJson_ConfigMapVolumeSource = exports.toJson_CinderVolumeSource = exports.toJson_CephFsVolumeSource = exports.toJson_AzureFileVolumeSource = exports.toJson_WindowsSecurityContextOptions = exports.toJson_Sysctl = exports.toJson_SeccompProfile = exports.toJson_SeLinuxOptions = exports.toJson_PodDnsConfigOption = exports.toJson_VolumeMount = exports.toJson_VolumeDevice = exports.toJson_SecurityContext = exports.toJson_ContainerPort = exports.toJson_Probe = exports.toJson_Lifecycle = exports.toJson_EnvFromSource = exports.toJson_EnvVar = exports.toJson_PodAntiAffinity = exports.toJson_PodAffinity = exports.toJson_NodeAffinity = exports.toJson_NodeSelector = exports.toJson_SecretReference = exports.toJson_ConfigMapNodeConfigSource = exports.toJson_ResourceMetricSourceV2Beta2 = exports.toJson_PodsMetricSourceV2Beta2 = exports.toJson_ObjectMetricSourceV2Beta2 = exports.toJson_ExternalMetricSourceV2Beta2 = exports.toJson_ContainerResourceMetricSourceV2Beta2 = exports.toJson_HpaScalingRulesV2Beta2 = exports.toJson_ResourceMetricSourceV2Beta1 = exports.toJson_PodsMetricSourceV2Beta1 = exports.toJson_ObjectMetricSourceV2Beta1 = exports.toJson_ExternalMetricSourceV2Beta1 = exports.toJson_ContainerResourceMetricSourceV2Beta1 = exports.toJson_RollingUpdateStatefulSetStrategy = exports.toJson_RollingUpdateDeployment = exports.toJson_RollingUpdateDaemonSet = exports.toJson_ServiceReference = exports.toJson_StatusCause = exports.toJson_CustomResourceDefinitionVersion = exports.toJson_CustomResourceDefinitionNames = exports.toJson_CustomResourceConversion = exports.toJson_VolumeAttachmentSourceV1Alpha1 = exports.toJson_LabelSelectorRequirement = exports.toJson_VolumeAttachmentSource = exports.toJson_TopologySelectorLabelRequirement = exports.toJson_CsiNodeDriver = exports.toJson_TokenRequest = exports.toJson_SupplementalGroupsStrategyOptionsV1Beta1 = exports.toJson_SeLinuxStrategyOptionsV1Beta1 = exports.toJson_RuntimeClassStrategyOptionsV1Beta1 = exports.toJson_RunAsUserStrategyOptionsV1Beta1 = exports.toJson_RunAsGroupStrategyOptionsV1Beta1 = exports.toJson_HostPortRangeV1Beta1 = exports.toJson_FsGroupStrategyOptionsV1Beta1 = exports.toJson_AllowedHostPathV1Beta1 = exports.toJson_AllowedFlexVolumeV1Beta1 = exports.toJson_AllowedCsiDriverV1Beta1 = exports.IntOrString = exports.toJson_Preconditions = exports.IoK8SApimachineryPkgApisMetaV1DeleteOptionsKind = exports.toJson_SchedulingV1Alpha1 = exports.toJson_OverheadV1Alpha1 = exports.toJson_NetworkPolicyIngressRule = exports.toJson_NetworkPolicyEgressRule = exports.toJson_IngressClassParametersReference = exports.toJson_IngressTls = exports.toJson_IngressRule = exports.toJson_IngressBackend = exports.toJson_LimitedPriorityLevelConfigurationV1Beta1 = exports.toJson_PolicyRulesWithSubjectsV1Beta1 = exports.toJson_PriorityLevelConfigurationReferenceV1Beta1 = exports.toJson_FlowDistinguisherMethodV1Beta1 = exports.toJson_EndpointHintsV1Beta1 = exports.toJson_EndpointConditionsV1Beta1 = exports.toJson_EndpointHints = exports.toJson_EndpointConditions = exports.toJson_SessionAffinityConfig = exports.toJson_ServicePort = exports.toJson_ScopeSelector = exports.toJson_Volume = exports.toJson_TopologySpreadConstraint = exports.toJson_Toleration = exports.toJson_PodSecurityContext = exports.toJson_PodReadinessGate = exports.toJson_HostAlias = exports.toJson_EphemeralContainer = exports.toJson_PodDnsConfig = exports.toJson_Container = exports.toJson_Affinity = exports.toJson_ResourceRequirements = exports.toJson_TypedLocalObjectReference = exports.toJson_VsphereVirtualDiskVolumeSource = exports.toJson_StorageOsPersistentVolumeSource = exports.toJson_ScaleIoPersistentVolumeSource = exports.toJson_RbdPersistentVolumeSource = exports.toJson_QuobyteVolumeSource = exports.toJson_PortworxVolumeSource = exports.toJson_PhotonPersistentDiskVolumeSource = exports.toJson_VolumeNodeAffinity = exports.toJson_NfsVolumeSource = exports.toJson_LocalVolumeSource = exports.toJson_IscsiPersistentVolumeSource = exports.toJson_HostPathVolumeSource = exports.toJson_GlusterfsPersistentVolumeSource = exports.toJson_GcePersistentDiskVolumeSource = exports.toJson_FlockerVolumeSource = exports.toJson_FlexPersistentVolumeSource = exports.toJson_FcVolumeSource = exports.toJson_CsiPersistentVolumeSource = exports.toJson_CinderPersistentVolumeSource = exports.toJson_CephFsPersistentVolumeSource = exports.toJson_AzureFilePersistentVolumeSource = exports.toJson_AzureDiskVolumeSource = exports.toJson_AwsElasticBlockStoreVolumeSource = exports.toJson_Taint = exports.toJson_NodeConfigSource = exports.toJson_LimitRangeItem = exports.toJson_EndpointAddress = exports.toJson_JobTemplateSpecV1Beta1 = exports.toJson_JobTemplateSpec = exports.toJson_CrossVersionObjectReferenceV2Beta2 = exports.toJson_MetricSpecV2Beta2 = exports.toJson_HorizontalPodAutoscalerBehaviorV2Beta2 = exports.toJson_CrossVersionObjectReferenceV2Beta1 = exports.toJson_MetricSpecV2Beta1 = exports.toJson_CrossVersionObjectReference = exports.toJson_ResourceAttributes = exports.toJson_NonResourceAttributes = exports.toJson_BoundObjectReference = exports.toJson_StatefulSetUpdateStrategy = exports.toJson_DeploymentStrategy = exports.toJson_DaemonSetUpdateStrategy = exports.toJson_RuleWithOperations = exports.toJson_WebhookClientConfig = exports.toJson_OwnerReference = exports.toJson_ManagedFieldsEntry = exports.toJson_ApiServiceSpec = exports.toJson_StatusDetails = exports.toJson_CustomResourceDefinitionSpec = exports.toJson_VolumeAttachmentSpecV1Alpha1 = exports.toJson_LabelSelector = exports.Quantity = exports.toJson_VolumeAttachmentSpec = exports.toJson_TopologySelectorTerm = exports.toJson_CsiNodeSpec = exports.toJson_CsiDriverSpec = exports.toJson_SubjectV1Alpha1 = exports.toJson_RoleRefV1Alpha1 = exports.toJson_PolicyRuleV1Alpha1 = exports.toJson_AggregationRuleV1Alpha1 = exports.toJson_Subject = exports.toJson_RoleRef = exports.toJson_PolicyRule = exports.toJson_AggregationRule = exports.toJson_PodSecurityPolicySpecV1Beta1 = exports.toJson_PodDisruptionBudgetSpecV1Beta1 = exports.toJson_PodDisruptionBudgetSpec = exports.toJson_DeleteOptions = exports.toJson_SchedulingV1Beta1 = exports.toJson_OverheadV1Beta1 = exports.toJson_RuntimeClassSpecV1Alpha1 = exports.toJson_Scheduling = exports.toJson_Overhead = exports.toJson_NetworkPolicySpec = exports.toJson_IngressClassSpec = exports.toJson_IngressSpec = exports.toJson_PriorityLevelConfigurationSpecV1Beta1 = exports.toJson_FlowSchemaSpecV1Beta1 = exports.toJson_EventSeriesV1Beta1 = exports.toJson_EndpointPortV1Beta1 = exports.toJson_EndpointV1Beta1 = exports.toJson_EndpointPort = exports.toJson_Endpoint = exports.toJson_LocalObjectReference = exports.toJson_ServiceSpec = exports.toJson_ResourceQuotaSpec = exports.toJson_ReplicationControllerSpec = exports.toJson_PodTemplateSpec = exports.toJson_PodSpec = exports.toJson_PersistentVolumeClaimSpec = exports.toJson_PersistentVolumeSpec = exports.toJson_NodeSpec = exports.toJson_NamespaceSpec = exports.toJson_LimitRangeSpec = exports.toJson_EventSeries = exports.toJson_EventSource = exports.toJson_EndpointSubset = exports.toJson_ComponentCondition = exports.toJson_ObjectReference = exports.toJson_LeaseSpec = exports.toJson_CertificateSigningRequestSpec = exports.toJson_CronJobSpecV1Beta1 = exports.toJson_JobSpec = exports.toJson_CronJobSpec = exports.toJson_HorizontalPodAutoscalerSpecV2Beta2 = exports.toJson_HorizontalPodAutoscalerSpecV2Beta1 = exports.toJson_ScaleSpec = exports.toJson_HorizontalPodAutoscalerSpec = exports.toJson_SelfSubjectRulesReviewSpec = exports.toJson_SelfSubjectAccessReviewSpec = exports.toJson_SubjectAccessReviewSpec = exports.toJson_TokenReviewSpec = exports.toJson_TokenRequestSpec = exports.toJson_StatefulSetSpec = exports.toJson_ReplicaSetSpec = exports.toJson_DeploymentSpec = exports.toJson_DaemonSetSpec = exports.toJson_ValidatingWebhook = exports.toJson_ListMeta = exports.toJson_MutatingWebhook = exports.toJson_ObjectMeta = exports.toJson_KubeApiServiceListProps = exports.toJson_KubeApiServiceProps = exports.toJson_KubeStatusProps = exports.toJson_KubeCustomResourceDefinitionListProps = exports.toJson_KubeCustomResourceDefinitionProps = exports.toJson_KubeCsiStorageCapacityListV1Beta1Props = exports.toJson_KubeCsiStorageCapacityV1Beta1Props = exports.toJson_KubeVolumeAttachmentListV1Alpha1Props = exports.toJson_KubeVolumeAttachmentV1Alpha1Props = exports.toJson_KubeCsiStorageCapacityListV1Alpha1Props = exports.toJson_KubeCsiStorageCapacityV1Alpha1Props = exports.toJson_KubeVolumeAttachmentListProps = exports.toJson_KubeVolumeAttachmentProps = exports.toJson_KubeStorageClassListProps = exports.toJson_KubeStorageClassProps = exports.toJson_KubeCsiNodeListProps = exports.toJson_KubeCsiNodeProps = exports.toJson_KubeCsiDriverListProps = exports.toJson_KubeCsiDriverProps = exports.toJson_KubePriorityClassListV1Alpha1Props = exports.toJson_KubePriorityClassV1Alpha1Props = exports.toJson_KubePriorityClassListProps = exports.toJson_KubePriorityClassProps = exports.toJson_KubeRoleListV1Alpha1Props = exports.toJson_KubeRoleBindingListV1Alpha1Props = exports.toJson_KubeRoleBindingV1Alpha1Props = exports.toJson_KubeRoleV1Alpha1Props = exports.toJson_KubeClusterRoleListV1Alpha1Props = exports.toJson_KubeClusterRoleBindingListV1Alpha1Props = exports.toJson_KubeClusterRoleBindingV1Alpha1Props = exports.toJson_KubeClusterRoleV1Alpha1Props = exports.toJson_KubeRoleListProps = exports.toJson_KubeRoleBindingListProps = exports.toJson_KubeRoleBindingProps = exports.toJson_KubeRoleProps = exports.toJson_KubeClusterRoleListProps = exports.toJson_KubeClusterRoleBindingListProps = exports.toJson_KubeClusterRoleBindingProps = exports.toJson_KubeClusterRoleProps = exports.toJson_KubePodSecurityPolicyListV1Beta1Props = exports.toJson_KubePodSecurityPolicyV1Beta1Props = exports.toJson_KubePodDisruptionBudgetListV1Beta1Props = exports.toJson_KubePodDisruptionBudgetV1Beta1Props = exports.toJson_KubePodDisruptionBudgetListProps = exports.toJson_KubePodDisruptionBudgetProps = exports.toJson_KubeEvictionProps = exports.toJson_KubeRuntimeClassListV1Beta1Props = exports.toJson_KubeRuntimeClassV1Beta1Props = exports.toJson_KubeRuntimeClassListV1Alpha1Props = exports.toJson_KubeRuntimeClassV1Alpha1Props = exports.toJson_KubeRuntimeClassListProps = exports.toJson_KubeRuntimeClassProps = exports.toJson_KubeNetworkPolicyListProps = exports.toJson_KubeNetworkPolicyProps = exports.toJson_KubeIngressListProps = exports.toJson_KubeIngressClassListProps = exports.toJson_KubeIngressClassProps = exports.toJson_KubeIngressProps = exports.toJson_KubePriorityLevelConfigurationListV1Beta1Props = exports.toJson_KubePriorityLevelConfigurationV1Beta1Props = exports.toJson_KubeFlowSchemaListV1Beta1Props = exports.toJson_KubeFlowSchemaV1Beta1Props = exports.toJson_KubeEventListV1Beta1Props = exports.toJson_KubeEventV1Beta1Props = exports.toJson_KubeEndpointSliceListV1Beta1Props = exports.toJson_KubeEndpointSliceV1Beta1Props = exports.toJson_KubeEndpointSliceListProps = exports.toJson_KubeEndpointSliceProps = exports.toJson_KubeServiceListProps = exports.toJson_KubeServiceAccountListProps = exports.toJson_KubeServiceAccountProps = exports.toJson_KubeServiceProps = exports.toJson_KubeSecretListProps = exports.toJson_KubeSecretProps = exports.toJson_KubeResourceQuotaListProps = exports.toJson_KubeResourceQuotaProps = exports.toJson_KubeReplicationControllerListProps = exports.toJson_KubeReplicationControllerProps = exports.toJson_KubePodTemplateListProps = exports.toJson_KubePodTemplateProps = exports.toJson_KubePodListProps = exports.toJson_KubePodProps = exports.toJson_KubePersistentVolumeListProps = exports.toJson_KubePersistentVolumeClaimListProps = exports.toJson_KubePersistentVolumeClaimProps = exports.toJson_KubePersistentVolumeProps = exports.toJson_KubeNodeListProps = exports.toJson_KubeNodeProps = exports.toJson_KubeNamespaceListProps = exports.toJson_KubeNamespaceProps = exports.toJson_KubeLimitRangeListProps = exports.toJson_KubeLimitRangeProps = exports.toJson_KubeEventListProps = exports.toJson_KubeEventProps = exports.toJson_KubeEndpointsListProps = exports.toJson_KubeEndpointsProps = exports.toJson_KubeConfigMapListProps = exports.toJson_KubeConfigMapProps = exports.toJson_KubeComponentStatusListProps = exports.toJson_KubeComponentStatusProps = exports.toJson_KubeBindingProps = exports.toJson_KubeLeaseListProps = exports.toJson_KubeLeaseProps = exports.toJson_KubeCertificateSigningRequestListProps = exports.toJson_KubeCertificateSigningRequestProps = exports.toJson_KubeCronJobListV1Beta1Props = exports.toJson_KubeCronJobV1Beta1Props = exports.toJson_KubeJobListProps = exports.toJson_KubeJobProps = exports.toJson_KubeCronJobListProps = exports.toJson_KubeCronJobProps = exports.toJson_KubeHorizontalPodAutoscalerListV2Beta2Props = exports.toJson_KubeHorizontalPodAutoscalerV2Beta2Props = exports.toJson_KubeHorizontalPodAutoscalerListV2Beta1Props = exports.toJson_KubeHorizontalPodAutoscalerV2Beta1Props = exports.toJson_KubeScaleProps = exports.toJson_KubeHorizontalPodAutoscalerListProps = exports.toJson_KubeHorizontalPodAutoscalerProps = exports.toJson_KubeSubjectAccessReviewProps = exports.toJson_KubeSelfSubjectRulesReviewProps = exports.toJson_KubeSelfSubjectAccessReviewProps = exports.toJson_KubeLocalSubjectAccessReviewProps = exports.toJson_KubeTokenReviewProps = exports.toJson_KubeTokenRequestProps = exports.toJson_KubeStatefulSetListProps = exports.toJson_KubeStatefulSetProps = exports.toJson_KubeReplicaSetListProps = exports.toJson_KubeReplicaSetProps = exports.toJson_KubeDeploymentListProps = exports.toJson_KubeDeploymentProps = exports.toJson_KubeDaemonSetListProps = exports.toJson_KubeDaemonSetProps = exports.toJson_KubeControllerRevisionListProps = exports.toJson_KubeControllerRevisionProps = exports.toJson_KubeStorageVersionListV1Alpha1Props = exports.toJson_KubeStorageVersionV1Alpha1Props = exports.toJson_KubeValidatingWebhookConfigurationListProps = exports.toJson_KubeValidatingWebhookConfigurationProps = exports.toJson_KubeMutatingWebhookConfigurationListProps = exports.toJson_KubeMutatingWebhookConfigurationProps = exports.KubeApiServiceList = exports.KubeApiService = exports.KubeStatus = exports.KubeCustomResourceDefinitionList = exports.KubeCustomResourceDefinition = exports.KubeCsiStorageCapacityListV1Beta1 = exports.KubeCsiStorageCapacityV1Beta1 = exports.KubeVolumeAttachmentListV1Alpha1 = exports.KubeVolumeAttachmentV1Alpha1 = exports.KubeCsiStorageCapacityListV1Alpha1 = exports.KubeCsiStorageCapacityV1Alpha1 = exports.KubeVolumeAttachmentList = exports.KubeVolumeAttachment = exports.KubeStorageClassList = exports.KubeStorageClass = exports.KubeCsiNodeList = exports.KubeCsiNode = exports.KubeCsiDriverList = exports.KubeCsiDriver = exports.KubePriorityClassListV1Alpha1 = exports.KubePriorityClassV1Alpha1 = exports.KubePriorityClassList = exports.KubePriorityClass = exports.KubeRoleListV1Alpha1 = exports.KubeRoleBindingListV1Alpha1 = exports.KubeRoleBindingV1Alpha1 = exports.KubeRoleV1Alpha1 = exports.KubeClusterRoleListV1Alpha1 = exports.KubeClusterRoleBindingListV1Alpha1 = exports.KubeClusterRoleBindingV1Alpha1 = exports.KubeClusterRoleV1Alpha1 = exports.KubeRoleList = exports.KubeRoleBindingList = exports.KubeRoleBinding = exports.KubeRole = exports.KubeClusterRoleList = exports.KubeClusterRoleBindingList = exports.KubeClusterRoleBinding = exports.KubeClusterRole = exports.KubePodSecurityPolicyListV1Beta1 = exports.KubePodSecurityPolicyV1Beta1 = exports.KubePodDisruptionBudgetListV1Beta1 = exports.KubePodDisruptionBudgetV1Beta1 = exports.KubePodDisruptionBudgetList = exports.KubePodDisruptionBudget = exports.KubeEviction = exports.KubeRuntimeClassListV1Beta1 = exports.KubeRuntimeClassV1Beta1 = exports.KubeRuntimeClassListV1Alpha1 = exports.KubeRuntimeClassV1Alpha1 = exports.KubeRuntimeClassList = exports.KubeRuntimeClass = exports.KubeNetworkPolicyList = exports.KubeNetworkPolicy = exports.KubeIngressList = exports.KubeIngressClassList = exports.KubeIngressClass = exports.KubeIngress = exports.KubePriorityLevelConfigurationListV1Beta1 = exports.KubePriorityLevelConfigurationV1Beta1 = exports.KubeFlowSchemaListV1Beta1 = exports.KubeFlowSchemaV1Beta1 = exports.KubeEventListV1Beta1 = exports.KubeEventV1Beta1 = exports.KubeEndpointSliceListV1Beta1 = exports.KubeEndpointSliceV1Beta1 = exports.KubeEndpointSliceList = exports.KubeEndpointSlice = exports.KubeServiceList = exports.KubeServiceAccountList = exports.KubeServiceAccount = exports.KubeService = exports.KubeSecretList = exports.KubeSecret = exports.KubeResourceQuotaList = exports.KubeResourceQuota = exports.KubeReplicationControllerList = exports.KubeReplicationController = exports.KubePodTemplateList = exports.KubePodTemplate = exports.KubePodList = exports.KubePod = exports.KubePersistentVolumeList = exports.KubePersistentVolumeClaimList = exports.KubePersistentVolumeClaim = exports.KubePersistentVolume = exports.KubeNodeList = exports.KubeNode = exports.KubeNamespaceList = exports.KubeNamespace = exports.KubeLimitRangeList = exports.KubeLimitRange = exports.KubeEventList = exports.KubeEvent = exports.KubeEndpointsList = exports.KubeEndpoints = exports.KubeConfigMapList = exports.KubeConfigMap = exports.KubeComponentStatusList = exports.KubeComponentStatus = exports.KubeBinding = exports.KubeLeaseList = exports.KubeLease = exports.KubeCertificateSigningRequestList = exports.KubeCertificateSigningRequest = exports.KubeCronJobListV1Beta1 = exports.KubeCronJobV1Beta1 = exports.KubeJobList = exports.KubeJob = exports.KubeCronJobList = exports.KubeCronJob = exports.KubeHorizontalPodAutoscalerListV2Beta2 = exports.KubeHorizontalPodAutoscalerV2Beta2 = exports.KubeHorizontalPodAutoscalerListV2Beta1 = exports.KubeHorizontalPodAutoscalerV2Beta1 = exports.KubeScale = exports.KubeHorizontalPodAutoscalerList = exports.KubeHorizontalPodAutoscaler = exports.KubeSubjectAccessReview = exports.KubeSelfSubjectRulesReview = exports.KubeSelfSubjectAccessReview = exports.KubeLocalSubjectAccessReview = exports.KubeTokenReview = exports.KubeTokenRequest = exports.KubeStatefulSetList = exports.KubeStatefulSet = exports.KubeReplicaSetList = exports.KubeReplicaSet = exports.KubeDeploymentList = exports.KubeDeployment = exports.KubeDaemonSetList = exports.KubeDaemonSet = exports.KubeControllerRevisionList = exports.KubeControllerRevision = exports.KubeStorageVersionListV1Alpha1 = exports.KubeStorageVersionV1Alpha1 = exports.KubeValidatingWebhookConfigurationList = exports.KubeValidatingWebhookConfiguration = exports.KubeMutatingWebhookConfigurationList = exports.KubeMutatingWebhookConfiguration = void 0;
// generated by cdk8s
const cdk8s_1 = __nccwpck_require__(1227);
/**
 * MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object.
 *
 * @schema io.k8s.api.admissionregistration.v1.MutatingWebhookConfiguration
 */
class KubeMutatingWebhookConfiguration extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.admissionregistration.v1.MutatingWebhookConfiguration" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeMutatingWebhookConfiguration.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.admissionregistration.v1.MutatingWebhookConfiguration".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeMutatingWebhookConfiguration.GVK,
            ...toJson_KubeMutatingWebhookConfigurationProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeMutatingWebhookConfiguration.GVK,
            ...toJson_KubeMutatingWebhookConfigurationProps(resolved),
        };
    }
}
exports.KubeMutatingWebhookConfiguration = KubeMutatingWebhookConfiguration;
/**
 * Returns the apiVersion and kind for "io.k8s.api.admissionregistration.v1.MutatingWebhookConfiguration"
 */
KubeMutatingWebhookConfiguration.GVK = {
    apiVersion: 'admissionregistration.k8s.io/v1',
    kind: 'MutatingWebhookConfiguration',
};
/**
 * MutatingWebhookConfigurationList is a list of MutatingWebhookConfiguration.
 *
 * @schema io.k8s.api.admissionregistration.v1.MutatingWebhookConfigurationList
 */
class KubeMutatingWebhookConfigurationList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.admissionregistration.v1.MutatingWebhookConfigurationList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeMutatingWebhookConfigurationList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.admissionregistration.v1.MutatingWebhookConfigurationList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeMutatingWebhookConfigurationList.GVK,
            ...toJson_KubeMutatingWebhookConfigurationListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeMutatingWebhookConfigurationList.GVK,
            ...toJson_KubeMutatingWebhookConfigurationListProps(resolved),
        };
    }
}
exports.KubeMutatingWebhookConfigurationList = KubeMutatingWebhookConfigurationList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.admissionregistration.v1.MutatingWebhookConfigurationList"
 */
KubeMutatingWebhookConfigurationList.GVK = {
    apiVersion: 'admissionregistration.k8s.io/v1',
    kind: 'MutatingWebhookConfigurationList',
};
/**
 * ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it.
 *
 * @schema io.k8s.api.admissionregistration.v1.ValidatingWebhookConfiguration
 */
class KubeValidatingWebhookConfiguration extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.admissionregistration.v1.ValidatingWebhookConfiguration" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeValidatingWebhookConfiguration.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.admissionregistration.v1.ValidatingWebhookConfiguration".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeValidatingWebhookConfiguration.GVK,
            ...toJson_KubeValidatingWebhookConfigurationProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeValidatingWebhookConfiguration.GVK,
            ...toJson_KubeValidatingWebhookConfigurationProps(resolved),
        };
    }
}
exports.KubeValidatingWebhookConfiguration = KubeValidatingWebhookConfiguration;
/**
 * Returns the apiVersion and kind for "io.k8s.api.admissionregistration.v1.ValidatingWebhookConfiguration"
 */
KubeValidatingWebhookConfiguration.GVK = {
    apiVersion: 'admissionregistration.k8s.io/v1',
    kind: 'ValidatingWebhookConfiguration',
};
/**
 * ValidatingWebhookConfigurationList is a list of ValidatingWebhookConfiguration.
 *
 * @schema io.k8s.api.admissionregistration.v1.ValidatingWebhookConfigurationList
 */
class KubeValidatingWebhookConfigurationList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.admissionregistration.v1.ValidatingWebhookConfigurationList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeValidatingWebhookConfigurationList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.admissionregistration.v1.ValidatingWebhookConfigurationList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeValidatingWebhookConfigurationList.GVK,
            ...toJson_KubeValidatingWebhookConfigurationListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeValidatingWebhookConfigurationList.GVK,
            ...toJson_KubeValidatingWebhookConfigurationListProps(resolved),
        };
    }
}
exports.KubeValidatingWebhookConfigurationList = KubeValidatingWebhookConfigurationList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.admissionregistration.v1.ValidatingWebhookConfigurationList"
 */
KubeValidatingWebhookConfigurationList.GVK = {
    apiVersion: 'admissionregistration.k8s.io/v1',
    kind: 'ValidatingWebhookConfigurationList',
};
/**
 *
 Storage version of a specific resource.
 *
 * @schema io.k8s.api.apiserverinternal.v1alpha1.StorageVersion
 */
class KubeStorageVersionV1Alpha1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.apiserverinternal.v1alpha1.StorageVersion" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeStorageVersionV1Alpha1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.apiserverinternal.v1alpha1.StorageVersion".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeStorageVersionV1Alpha1.GVK,
            ...toJson_KubeStorageVersionV1Alpha1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeStorageVersionV1Alpha1.GVK,
            ...toJson_KubeStorageVersionV1Alpha1Props(resolved),
        };
    }
}
exports.KubeStorageVersionV1Alpha1 = KubeStorageVersionV1Alpha1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.apiserverinternal.v1alpha1.StorageVersion"
 */
KubeStorageVersionV1Alpha1.GVK = {
    apiVersion: 'internal.apiserver.k8s.io/v1alpha1',
    kind: 'StorageVersion',
};
/**
 * A list of StorageVersions.
 *
 * @schema io.k8s.api.apiserverinternal.v1alpha1.StorageVersionList
 */
class KubeStorageVersionListV1Alpha1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.apiserverinternal.v1alpha1.StorageVersionList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeStorageVersionListV1Alpha1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.apiserverinternal.v1alpha1.StorageVersionList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeStorageVersionListV1Alpha1.GVK,
            ...toJson_KubeStorageVersionListV1Alpha1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeStorageVersionListV1Alpha1.GVK,
            ...toJson_KubeStorageVersionListV1Alpha1Props(resolved),
        };
    }
}
exports.KubeStorageVersionListV1Alpha1 = KubeStorageVersionListV1Alpha1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.apiserverinternal.v1alpha1.StorageVersionList"
 */
KubeStorageVersionListV1Alpha1.GVK = {
    apiVersion: 'internal.apiserver.k8s.io/v1alpha1',
    kind: 'StorageVersionList',
};
/**
 * ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers.
 *
 * @schema io.k8s.api.apps.v1.ControllerRevision
 */
class KubeControllerRevision extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.apps.v1.ControllerRevision" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeControllerRevision.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.apps.v1.ControllerRevision".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeControllerRevision.GVK,
            ...toJson_KubeControllerRevisionProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeControllerRevision.GVK,
            ...toJson_KubeControllerRevisionProps(resolved),
        };
    }
}
exports.KubeControllerRevision = KubeControllerRevision;
/**
 * Returns the apiVersion and kind for "io.k8s.api.apps.v1.ControllerRevision"
 */
KubeControllerRevision.GVK = {
    apiVersion: 'apps/v1',
    kind: 'ControllerRevision',
};
/**
 * ControllerRevisionList is a resource containing a list of ControllerRevision objects.
 *
 * @schema io.k8s.api.apps.v1.ControllerRevisionList
 */
class KubeControllerRevisionList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.apps.v1.ControllerRevisionList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeControllerRevisionList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.apps.v1.ControllerRevisionList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeControllerRevisionList.GVK,
            ...toJson_KubeControllerRevisionListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeControllerRevisionList.GVK,
            ...toJson_KubeControllerRevisionListProps(resolved),
        };
    }
}
exports.KubeControllerRevisionList = KubeControllerRevisionList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.apps.v1.ControllerRevisionList"
 */
KubeControllerRevisionList.GVK = {
    apiVersion: 'apps/v1',
    kind: 'ControllerRevisionList',
};
/**
 * DaemonSet represents the configuration of a daemon set.
 *
 * @schema io.k8s.api.apps.v1.DaemonSet
 */
class KubeDaemonSet extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.apps.v1.DaemonSet" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeDaemonSet.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.apps.v1.DaemonSet".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeDaemonSet.GVK,
            ...toJson_KubeDaemonSetProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeDaemonSet.GVK,
            ...toJson_KubeDaemonSetProps(resolved),
        };
    }
}
exports.KubeDaemonSet = KubeDaemonSet;
/**
 * Returns the apiVersion and kind for "io.k8s.api.apps.v1.DaemonSet"
 */
KubeDaemonSet.GVK = {
    apiVersion: 'apps/v1',
    kind: 'DaemonSet',
};
/**
 * DaemonSetList is a collection of daemon sets.
 *
 * @schema io.k8s.api.apps.v1.DaemonSetList
 */
class KubeDaemonSetList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.apps.v1.DaemonSetList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeDaemonSetList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.apps.v1.DaemonSetList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeDaemonSetList.GVK,
            ...toJson_KubeDaemonSetListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeDaemonSetList.GVK,
            ...toJson_KubeDaemonSetListProps(resolved),
        };
    }
}
exports.KubeDaemonSetList = KubeDaemonSetList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.apps.v1.DaemonSetList"
 */
KubeDaemonSetList.GVK = {
    apiVersion: 'apps/v1',
    kind: 'DaemonSetList',
};
/**
 * Deployment enables declarative updates for Pods and ReplicaSets.
 *
 * @schema io.k8s.api.apps.v1.Deployment
 */
class KubeDeployment extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.apps.v1.Deployment" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeDeployment.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.apps.v1.Deployment".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeDeployment.GVK,
            ...toJson_KubeDeploymentProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeDeployment.GVK,
            ...toJson_KubeDeploymentProps(resolved),
        };
    }
}
exports.KubeDeployment = KubeDeployment;
/**
 * Returns the apiVersion and kind for "io.k8s.api.apps.v1.Deployment"
 */
KubeDeployment.GVK = {
    apiVersion: 'apps/v1',
    kind: 'Deployment',
};
/**
 * DeploymentList is a list of Deployments.
 *
 * @schema io.k8s.api.apps.v1.DeploymentList
 */
class KubeDeploymentList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.apps.v1.DeploymentList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeDeploymentList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.apps.v1.DeploymentList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeDeploymentList.GVK,
            ...toJson_KubeDeploymentListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeDeploymentList.GVK,
            ...toJson_KubeDeploymentListProps(resolved),
        };
    }
}
exports.KubeDeploymentList = KubeDeploymentList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.apps.v1.DeploymentList"
 */
KubeDeploymentList.GVK = {
    apiVersion: 'apps/v1',
    kind: 'DeploymentList',
};
/**
 * ReplicaSet ensures that a specified number of pod replicas are running at any given time.
 *
 * @schema io.k8s.api.apps.v1.ReplicaSet
 */
class KubeReplicaSet extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.apps.v1.ReplicaSet" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeReplicaSet.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.apps.v1.ReplicaSet".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeReplicaSet.GVK,
            ...toJson_KubeReplicaSetProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeReplicaSet.GVK,
            ...toJson_KubeReplicaSetProps(resolved),
        };
    }
}
exports.KubeReplicaSet = KubeReplicaSet;
/**
 * Returns the apiVersion and kind for "io.k8s.api.apps.v1.ReplicaSet"
 */
KubeReplicaSet.GVK = {
    apiVersion: 'apps/v1',
    kind: 'ReplicaSet',
};
/**
 * ReplicaSetList is a collection of ReplicaSets.
 *
 * @schema io.k8s.api.apps.v1.ReplicaSetList
 */
class KubeReplicaSetList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.apps.v1.ReplicaSetList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeReplicaSetList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.apps.v1.ReplicaSetList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeReplicaSetList.GVK,
            ...toJson_KubeReplicaSetListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeReplicaSetList.GVK,
            ...toJson_KubeReplicaSetListProps(resolved),
        };
    }
}
exports.KubeReplicaSetList = KubeReplicaSetList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.apps.v1.ReplicaSetList"
 */
KubeReplicaSetList.GVK = {
    apiVersion: 'apps/v1',
    kind: 'ReplicaSetList',
};
/**
 * StatefulSet represents a set of pods with consistent identities. Identities are defined as:
 - Network: A single stable DNS and hostname.
 - Storage: As many VolumeClaims as requested.
The StatefulSet guarantees that a given network identity will always map to the same storage identity.
 *
 * @schema io.k8s.api.apps.v1.StatefulSet
 */
class KubeStatefulSet extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.apps.v1.StatefulSet" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeStatefulSet.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.apps.v1.StatefulSet".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeStatefulSet.GVK,
            ...toJson_KubeStatefulSetProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeStatefulSet.GVK,
            ...toJson_KubeStatefulSetProps(resolved),
        };
    }
}
exports.KubeStatefulSet = KubeStatefulSet;
/**
 * Returns the apiVersion and kind for "io.k8s.api.apps.v1.StatefulSet"
 */
KubeStatefulSet.GVK = {
    apiVersion: 'apps/v1',
    kind: 'StatefulSet',
};
/**
 * StatefulSetList is a collection of StatefulSets.
 *
 * @schema io.k8s.api.apps.v1.StatefulSetList
 */
class KubeStatefulSetList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.apps.v1.StatefulSetList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeStatefulSetList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.apps.v1.StatefulSetList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeStatefulSetList.GVK,
            ...toJson_KubeStatefulSetListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeStatefulSetList.GVK,
            ...toJson_KubeStatefulSetListProps(resolved),
        };
    }
}
exports.KubeStatefulSetList = KubeStatefulSetList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.apps.v1.StatefulSetList"
 */
KubeStatefulSetList.GVK = {
    apiVersion: 'apps/v1',
    kind: 'StatefulSetList',
};
/**
 * TokenRequest requests a token for a given service account.
 *
 * @schema io.k8s.api.authentication.v1.TokenRequest
 */
class KubeTokenRequest extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.authentication.v1.TokenRequest" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeTokenRequest.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.authentication.v1.TokenRequest".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeTokenRequest.GVK,
            ...toJson_KubeTokenRequestProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeTokenRequest.GVK,
            ...toJson_KubeTokenRequestProps(resolved),
        };
    }
}
exports.KubeTokenRequest = KubeTokenRequest;
/**
 * Returns the apiVersion and kind for "io.k8s.api.authentication.v1.TokenRequest"
 */
KubeTokenRequest.GVK = {
    apiVersion: 'authentication.k8s.io/v1',
    kind: 'TokenRequest',
};
/**
 * TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver.
 *
 * @schema io.k8s.api.authentication.v1.TokenReview
 */
class KubeTokenReview extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.authentication.v1.TokenReview" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeTokenReview.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.authentication.v1.TokenReview".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeTokenReview.GVK,
            ...toJson_KubeTokenReviewProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeTokenReview.GVK,
            ...toJson_KubeTokenReviewProps(resolved),
        };
    }
}
exports.KubeTokenReview = KubeTokenReview;
/**
 * Returns the apiVersion and kind for "io.k8s.api.authentication.v1.TokenReview"
 */
KubeTokenReview.GVK = {
    apiVersion: 'authentication.k8s.io/v1',
    kind: 'TokenReview',
};
/**
 * LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace. Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions checking.
 *
 * @schema io.k8s.api.authorization.v1.LocalSubjectAccessReview
 */
class KubeLocalSubjectAccessReview extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.authorization.v1.LocalSubjectAccessReview" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeLocalSubjectAccessReview.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.authorization.v1.LocalSubjectAccessReview".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeLocalSubjectAccessReview.GVK,
            ...toJson_KubeLocalSubjectAccessReviewProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeLocalSubjectAccessReview.GVK,
            ...toJson_KubeLocalSubjectAccessReviewProps(resolved),
        };
    }
}
exports.KubeLocalSubjectAccessReview = KubeLocalSubjectAccessReview;
/**
 * Returns the apiVersion and kind for "io.k8s.api.authorization.v1.LocalSubjectAccessReview"
 */
KubeLocalSubjectAccessReview.GVK = {
    apiVersion: 'authorization.k8s.io/v1',
    kind: 'LocalSubjectAccessReview',
};
/**
 * SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a spec.namespace means "in all namespaces".  Self is a special case, because users should always be able to check whether they can perform an action
 *
 * @schema io.k8s.api.authorization.v1.SelfSubjectAccessReview
 */
class KubeSelfSubjectAccessReview extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.authorization.v1.SelfSubjectAccessReview" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeSelfSubjectAccessReview.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.authorization.v1.SelfSubjectAccessReview".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeSelfSubjectAccessReview.GVK,
            ...toJson_KubeSelfSubjectAccessReviewProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeSelfSubjectAccessReview.GVK,
            ...toJson_KubeSelfSubjectAccessReviewProps(resolved),
        };
    }
}
exports.KubeSelfSubjectAccessReview = KubeSelfSubjectAccessReview;
/**
 * Returns the apiVersion and kind for "io.k8s.api.authorization.v1.SelfSubjectAccessReview"
 */
KubeSelfSubjectAccessReview.GVK = {
    apiVersion: 'authorization.k8s.io/v1',
    kind: 'SelfSubjectAccessReview',
};
/**
 * SelfSubjectRulesReview enumerates the set of actions the current user can perform within a namespace. The returned list of actions may be incomplete depending on the server's authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview should be used by UIs to show/hide actions, or to quickly let an end user reason about their permissions. It should NOT Be used by external systems to drive authorization decisions as this raises confused deputy, cache lifetime/revocation, and correctness concerns. SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization decisions to the API server.
 *
 * @schema io.k8s.api.authorization.v1.SelfSubjectRulesReview
 */
class KubeSelfSubjectRulesReview extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.authorization.v1.SelfSubjectRulesReview" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeSelfSubjectRulesReview.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.authorization.v1.SelfSubjectRulesReview".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeSelfSubjectRulesReview.GVK,
            ...toJson_KubeSelfSubjectRulesReviewProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeSelfSubjectRulesReview.GVK,
            ...toJson_KubeSelfSubjectRulesReviewProps(resolved),
        };
    }
}
exports.KubeSelfSubjectRulesReview = KubeSelfSubjectRulesReview;
/**
 * Returns the apiVersion and kind for "io.k8s.api.authorization.v1.SelfSubjectRulesReview"
 */
KubeSelfSubjectRulesReview.GVK = {
    apiVersion: 'authorization.k8s.io/v1',
    kind: 'SelfSubjectRulesReview',
};
/**
 * SubjectAccessReview checks whether or not a user or group can perform an action.
 *
 * @schema io.k8s.api.authorization.v1.SubjectAccessReview
 */
class KubeSubjectAccessReview extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.authorization.v1.SubjectAccessReview" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeSubjectAccessReview.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.authorization.v1.SubjectAccessReview".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeSubjectAccessReview.GVK,
            ...toJson_KubeSubjectAccessReviewProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeSubjectAccessReview.GVK,
            ...toJson_KubeSubjectAccessReviewProps(resolved),
        };
    }
}
exports.KubeSubjectAccessReview = KubeSubjectAccessReview;
/**
 * Returns the apiVersion and kind for "io.k8s.api.authorization.v1.SubjectAccessReview"
 */
KubeSubjectAccessReview.GVK = {
    apiVersion: 'authorization.k8s.io/v1',
    kind: 'SubjectAccessReview',
};
/**
 * configuration of a horizontal pod autoscaler.
 *
 * @schema io.k8s.api.autoscaling.v1.HorizontalPodAutoscaler
 */
class KubeHorizontalPodAutoscaler extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.autoscaling.v1.HorizontalPodAutoscaler" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeHorizontalPodAutoscaler.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.autoscaling.v1.HorizontalPodAutoscaler".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeHorizontalPodAutoscaler.GVK,
            ...toJson_KubeHorizontalPodAutoscalerProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeHorizontalPodAutoscaler.GVK,
            ...toJson_KubeHorizontalPodAutoscalerProps(resolved),
        };
    }
}
exports.KubeHorizontalPodAutoscaler = KubeHorizontalPodAutoscaler;
/**
 * Returns the apiVersion and kind for "io.k8s.api.autoscaling.v1.HorizontalPodAutoscaler"
 */
KubeHorizontalPodAutoscaler.GVK = {
    apiVersion: 'autoscaling/v1',
    kind: 'HorizontalPodAutoscaler',
};
/**
 * list of horizontal pod autoscaler objects.
 *
 * @schema io.k8s.api.autoscaling.v1.HorizontalPodAutoscalerList
 */
class KubeHorizontalPodAutoscalerList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.autoscaling.v1.HorizontalPodAutoscalerList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeHorizontalPodAutoscalerList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.autoscaling.v1.HorizontalPodAutoscalerList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeHorizontalPodAutoscalerList.GVK,
            ...toJson_KubeHorizontalPodAutoscalerListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeHorizontalPodAutoscalerList.GVK,
            ...toJson_KubeHorizontalPodAutoscalerListProps(resolved),
        };
    }
}
exports.KubeHorizontalPodAutoscalerList = KubeHorizontalPodAutoscalerList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.autoscaling.v1.HorizontalPodAutoscalerList"
 */
KubeHorizontalPodAutoscalerList.GVK = {
    apiVersion: 'autoscaling/v1',
    kind: 'HorizontalPodAutoscalerList',
};
/**
 * Scale represents a scaling request for a resource.
 *
 * @schema io.k8s.api.autoscaling.v1.Scale
 */
class KubeScale extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.autoscaling.v1.Scale" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeScale.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.autoscaling.v1.Scale".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeScale.GVK,
            ...toJson_KubeScaleProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeScale.GVK,
            ...toJson_KubeScaleProps(resolved),
        };
    }
}
exports.KubeScale = KubeScale;
/**
 * Returns the apiVersion and kind for "io.k8s.api.autoscaling.v1.Scale"
 */
KubeScale.GVK = {
    apiVersion: 'autoscaling/v1',
    kind: 'Scale',
};
/**
 * HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified.
 *
 * @schema io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscaler
 */
class KubeHorizontalPodAutoscalerV2Beta1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscaler" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeHorizontalPodAutoscalerV2Beta1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscaler".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeHorizontalPodAutoscalerV2Beta1.GVK,
            ...toJson_KubeHorizontalPodAutoscalerV2Beta1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeHorizontalPodAutoscalerV2Beta1.GVK,
            ...toJson_KubeHorizontalPodAutoscalerV2Beta1Props(resolved),
        };
    }
}
exports.KubeHorizontalPodAutoscalerV2Beta1 = KubeHorizontalPodAutoscalerV2Beta1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscaler"
 */
KubeHorizontalPodAutoscalerV2Beta1.GVK = {
    apiVersion: 'autoscaling/v2beta1',
    kind: 'HorizontalPodAutoscaler',
};
/**
 * HorizontalPodAutoscaler is a list of horizontal pod autoscaler objects.
 *
 * @schema io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscalerList
 */
class KubeHorizontalPodAutoscalerListV2Beta1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscalerList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeHorizontalPodAutoscalerListV2Beta1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscalerList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeHorizontalPodAutoscalerListV2Beta1.GVK,
            ...toJson_KubeHorizontalPodAutoscalerListV2Beta1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeHorizontalPodAutoscalerListV2Beta1.GVK,
            ...toJson_KubeHorizontalPodAutoscalerListV2Beta1Props(resolved),
        };
    }
}
exports.KubeHorizontalPodAutoscalerListV2Beta1 = KubeHorizontalPodAutoscalerListV2Beta1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscalerList"
 */
KubeHorizontalPodAutoscalerListV2Beta1.GVK = {
    apiVersion: 'autoscaling/v2beta1',
    kind: 'HorizontalPodAutoscalerList',
};
/**
 * HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified.
 *
 * @schema io.k8s.api.autoscaling.v2beta2.HorizontalPodAutoscaler
 */
class KubeHorizontalPodAutoscalerV2Beta2 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.autoscaling.v2beta2.HorizontalPodAutoscaler" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeHorizontalPodAutoscalerV2Beta2.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.autoscaling.v2beta2.HorizontalPodAutoscaler".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeHorizontalPodAutoscalerV2Beta2.GVK,
            ...toJson_KubeHorizontalPodAutoscalerV2Beta2Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeHorizontalPodAutoscalerV2Beta2.GVK,
            ...toJson_KubeHorizontalPodAutoscalerV2Beta2Props(resolved),
        };
    }
}
exports.KubeHorizontalPodAutoscalerV2Beta2 = KubeHorizontalPodAutoscalerV2Beta2;
/**
 * Returns the apiVersion and kind for "io.k8s.api.autoscaling.v2beta2.HorizontalPodAutoscaler"
 */
KubeHorizontalPodAutoscalerV2Beta2.GVK = {
    apiVersion: 'autoscaling/v2beta2',
    kind: 'HorizontalPodAutoscaler',
};
/**
 * HorizontalPodAutoscalerList is a list of horizontal pod autoscaler objects.
 *
 * @schema io.k8s.api.autoscaling.v2beta2.HorizontalPodAutoscalerList
 */
class KubeHorizontalPodAutoscalerListV2Beta2 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.autoscaling.v2beta2.HorizontalPodAutoscalerList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeHorizontalPodAutoscalerListV2Beta2.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.autoscaling.v2beta2.HorizontalPodAutoscalerList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeHorizontalPodAutoscalerListV2Beta2.GVK,
            ...toJson_KubeHorizontalPodAutoscalerListV2Beta2Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeHorizontalPodAutoscalerListV2Beta2.GVK,
            ...toJson_KubeHorizontalPodAutoscalerListV2Beta2Props(resolved),
        };
    }
}
exports.KubeHorizontalPodAutoscalerListV2Beta2 = KubeHorizontalPodAutoscalerListV2Beta2;
/**
 * Returns the apiVersion and kind for "io.k8s.api.autoscaling.v2beta2.HorizontalPodAutoscalerList"
 */
KubeHorizontalPodAutoscalerListV2Beta2.GVK = {
    apiVersion: 'autoscaling/v2beta2',
    kind: 'HorizontalPodAutoscalerList',
};
/**
 * CronJob represents the configuration of a single cron job.
 *
 * @schema io.k8s.api.batch.v1.CronJob
 */
class KubeCronJob extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.batch.v1.CronJob" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeCronJob.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.batch.v1.CronJob".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeCronJob.GVK,
            ...toJson_KubeCronJobProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeCronJob.GVK,
            ...toJson_KubeCronJobProps(resolved),
        };
    }
}
exports.KubeCronJob = KubeCronJob;
/**
 * Returns the apiVersion and kind for "io.k8s.api.batch.v1.CronJob"
 */
KubeCronJob.GVK = {
    apiVersion: 'batch/v1',
    kind: 'CronJob',
};
/**
 * CronJobList is a collection of cron jobs.
 *
 * @schema io.k8s.api.batch.v1.CronJobList
 */
class KubeCronJobList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.batch.v1.CronJobList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeCronJobList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.batch.v1.CronJobList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeCronJobList.GVK,
            ...toJson_KubeCronJobListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeCronJobList.GVK,
            ...toJson_KubeCronJobListProps(resolved),
        };
    }
}
exports.KubeCronJobList = KubeCronJobList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.batch.v1.CronJobList"
 */
KubeCronJobList.GVK = {
    apiVersion: 'batch/v1',
    kind: 'CronJobList',
};
/**
 * Job represents the configuration of a single job.
 *
 * @schema io.k8s.api.batch.v1.Job
 */
class KubeJob extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.batch.v1.Job" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeJob.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.batch.v1.Job".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeJob.GVK,
            ...toJson_KubeJobProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeJob.GVK,
            ...toJson_KubeJobProps(resolved),
        };
    }
}
exports.KubeJob = KubeJob;
/**
 * Returns the apiVersion and kind for "io.k8s.api.batch.v1.Job"
 */
KubeJob.GVK = {
    apiVersion: 'batch/v1',
    kind: 'Job',
};
/**
 * JobList is a collection of jobs.
 *
 * @schema io.k8s.api.batch.v1.JobList
 */
class KubeJobList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.batch.v1.JobList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeJobList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.batch.v1.JobList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeJobList.GVK,
            ...toJson_KubeJobListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeJobList.GVK,
            ...toJson_KubeJobListProps(resolved),
        };
    }
}
exports.KubeJobList = KubeJobList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.batch.v1.JobList"
 */
KubeJobList.GVK = {
    apiVersion: 'batch/v1',
    kind: 'JobList',
};
/**
 * CronJob represents the configuration of a single cron job.
 *
 * @schema io.k8s.api.batch.v1beta1.CronJob
 */
class KubeCronJobV1Beta1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.batch.v1beta1.CronJob" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeCronJobV1Beta1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.batch.v1beta1.CronJob".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeCronJobV1Beta1.GVK,
            ...toJson_KubeCronJobV1Beta1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeCronJobV1Beta1.GVK,
            ...toJson_KubeCronJobV1Beta1Props(resolved),
        };
    }
}
exports.KubeCronJobV1Beta1 = KubeCronJobV1Beta1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.batch.v1beta1.CronJob"
 */
KubeCronJobV1Beta1.GVK = {
    apiVersion: 'batch/v1beta1',
    kind: 'CronJob',
};
/**
 * CronJobList is a collection of cron jobs.
 *
 * @schema io.k8s.api.batch.v1beta1.CronJobList
 */
class KubeCronJobListV1Beta1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.batch.v1beta1.CronJobList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeCronJobListV1Beta1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.batch.v1beta1.CronJobList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeCronJobListV1Beta1.GVK,
            ...toJson_KubeCronJobListV1Beta1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeCronJobListV1Beta1.GVK,
            ...toJson_KubeCronJobListV1Beta1Props(resolved),
        };
    }
}
exports.KubeCronJobListV1Beta1 = KubeCronJobListV1Beta1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.batch.v1beta1.CronJobList"
 */
KubeCronJobListV1Beta1.GVK = {
    apiVersion: 'batch/v1beta1',
    kind: 'CronJobList',
};
/**
 * CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.

Kubelets use this API to obtain:
 1. client certificates to authenticate to kube-apiserver (with the "kubernetes.io/kube-apiserver-client-kubelet" signerName).
 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the "kubernetes.io/kubelet-serving" signerName).

This API can be used to request client certificates to authenticate to kube-apiserver (with the "kubernetes.io/kube-apiserver-client" signerName), or to obtain certificates from custom non-Kubernetes signers.
 *
 * @schema io.k8s.api.certificates.v1.CertificateSigningRequest
 */
class KubeCertificateSigningRequest extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.certificates.v1.CertificateSigningRequest" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeCertificateSigningRequest.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.certificates.v1.CertificateSigningRequest".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeCertificateSigningRequest.GVK,
            ...toJson_KubeCertificateSigningRequestProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeCertificateSigningRequest.GVK,
            ...toJson_KubeCertificateSigningRequestProps(resolved),
        };
    }
}
exports.KubeCertificateSigningRequest = KubeCertificateSigningRequest;
/**
 * Returns the apiVersion and kind for "io.k8s.api.certificates.v1.CertificateSigningRequest"
 */
KubeCertificateSigningRequest.GVK = {
    apiVersion: 'certificates.k8s.io/v1',
    kind: 'CertificateSigningRequest',
};
/**
 * CertificateSigningRequestList is a collection of CertificateSigningRequest objects
 *
 * @schema io.k8s.api.certificates.v1.CertificateSigningRequestList
 */
class KubeCertificateSigningRequestList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.certificates.v1.CertificateSigningRequestList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeCertificateSigningRequestList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.certificates.v1.CertificateSigningRequestList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeCertificateSigningRequestList.GVK,
            ...toJson_KubeCertificateSigningRequestListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeCertificateSigningRequestList.GVK,
            ...toJson_KubeCertificateSigningRequestListProps(resolved),
        };
    }
}
exports.KubeCertificateSigningRequestList = KubeCertificateSigningRequestList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.certificates.v1.CertificateSigningRequestList"
 */
KubeCertificateSigningRequestList.GVK = {
    apiVersion: 'certificates.k8s.io/v1',
    kind: 'CertificateSigningRequestList',
};
/**
 * Lease defines a lease concept.
 *
 * @schema io.k8s.api.coordination.v1.Lease
 */
class KubeLease extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.coordination.v1.Lease" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeLease.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.coordination.v1.Lease".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeLease.GVK,
            ...toJson_KubeLeaseProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeLease.GVK,
            ...toJson_KubeLeaseProps(resolved),
        };
    }
}
exports.KubeLease = KubeLease;
/**
 * Returns the apiVersion and kind for "io.k8s.api.coordination.v1.Lease"
 */
KubeLease.GVK = {
    apiVersion: 'coordination.k8s.io/v1',
    kind: 'Lease',
};
/**
 * LeaseList is a list of Lease objects.
 *
 * @schema io.k8s.api.coordination.v1.LeaseList
 */
class KubeLeaseList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.coordination.v1.LeaseList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeLeaseList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.coordination.v1.LeaseList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeLeaseList.GVK,
            ...toJson_KubeLeaseListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeLeaseList.GVK,
            ...toJson_KubeLeaseListProps(resolved),
        };
    }
}
exports.KubeLeaseList = KubeLeaseList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.coordination.v1.LeaseList"
 */
KubeLeaseList.GVK = {
    apiVersion: 'coordination.k8s.io/v1',
    kind: 'LeaseList',
};
/**
 * Binding ties one object to another; for example, a pod is bound to a node by a scheduler. Deprecated in 1.7, please use the bindings subresource of pods instead.
 *
 * @schema io.k8s.api.core.v1.Binding
 */
class KubeBinding extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.Binding" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeBinding.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.Binding".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeBinding.GVK,
            ...toJson_KubeBindingProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeBinding.GVK,
            ...toJson_KubeBindingProps(resolved),
        };
    }
}
exports.KubeBinding = KubeBinding;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.Binding"
 */
KubeBinding.GVK = {
    apiVersion: 'v1',
    kind: 'Binding',
};
/**
 * ComponentStatus (and ComponentStatusList) holds the cluster validation info. Deprecated: This API is deprecated in v1.19+
 *
 * @schema io.k8s.api.core.v1.ComponentStatus
 */
class KubeComponentStatus extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.ComponentStatus" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeComponentStatus.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.ComponentStatus".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeComponentStatus.GVK,
            ...toJson_KubeComponentStatusProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeComponentStatus.GVK,
            ...toJson_KubeComponentStatusProps(resolved),
        };
    }
}
exports.KubeComponentStatus = KubeComponentStatus;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.ComponentStatus"
 */
KubeComponentStatus.GVK = {
    apiVersion: 'v1',
    kind: 'ComponentStatus',
};
/**
 * Status of all the conditions for the component as a list of ComponentStatus objects. Deprecated: This API is deprecated in v1.19+
 *
 * @schema io.k8s.api.core.v1.ComponentStatusList
 */
class KubeComponentStatusList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.ComponentStatusList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeComponentStatusList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.ComponentStatusList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeComponentStatusList.GVK,
            ...toJson_KubeComponentStatusListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeComponentStatusList.GVK,
            ...toJson_KubeComponentStatusListProps(resolved),
        };
    }
}
exports.KubeComponentStatusList = KubeComponentStatusList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.ComponentStatusList"
 */
KubeComponentStatusList.GVK = {
    apiVersion: 'v1',
    kind: 'ComponentStatusList',
};
/**
 * ConfigMap holds configuration data for pods to consume.
 *
 * @schema io.k8s.api.core.v1.ConfigMap
 */
class KubeConfigMap extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.ConfigMap" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeConfigMap.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.ConfigMap".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeConfigMap.GVK,
            ...toJson_KubeConfigMapProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeConfigMap.GVK,
            ...toJson_KubeConfigMapProps(resolved),
        };
    }
}
exports.KubeConfigMap = KubeConfigMap;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.ConfigMap"
 */
KubeConfigMap.GVK = {
    apiVersion: 'v1',
    kind: 'ConfigMap',
};
/**
 * ConfigMapList is a resource containing a list of ConfigMap objects.
 *
 * @schema io.k8s.api.core.v1.ConfigMapList
 */
class KubeConfigMapList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.ConfigMapList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeConfigMapList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.ConfigMapList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeConfigMapList.GVK,
            ...toJson_KubeConfigMapListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeConfigMapList.GVK,
            ...toJson_KubeConfigMapListProps(resolved),
        };
    }
}
exports.KubeConfigMapList = KubeConfigMapList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.ConfigMapList"
 */
KubeConfigMapList.GVK = {
    apiVersion: 'v1',
    kind: 'ConfigMapList',
};
/**
 * Endpoints is a collection of endpoints that implement the actual service. Example:
  Name: "mysvc",
  Subsets: [
    {
      Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
      Ports: [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
    },
    {
      Addresses: [{"ip": "10.10.3.3"}],
      Ports: [{"name": "a", "port": 93}, {"name": "b", "port": 76}]
    },
 ]
 *
 * @schema io.k8s.api.core.v1.Endpoints
 */
class KubeEndpoints extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.Endpoints" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeEndpoints.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.Endpoints".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeEndpoints.GVK,
            ...toJson_KubeEndpointsProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeEndpoints.GVK,
            ...toJson_KubeEndpointsProps(resolved),
        };
    }
}
exports.KubeEndpoints = KubeEndpoints;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.Endpoints"
 */
KubeEndpoints.GVK = {
    apiVersion: 'v1',
    kind: 'Endpoints',
};
/**
 * EndpointsList is a list of endpoints.
 *
 * @schema io.k8s.api.core.v1.EndpointsList
 */
class KubeEndpointsList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.EndpointsList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeEndpointsList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.EndpointsList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeEndpointsList.GVK,
            ...toJson_KubeEndpointsListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeEndpointsList.GVK,
            ...toJson_KubeEndpointsListProps(resolved),
        };
    }
}
exports.KubeEndpointsList = KubeEndpointsList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.EndpointsList"
 */
KubeEndpointsList.GVK = {
    apiVersion: 'v1',
    kind: 'EndpointsList',
};
/**
 * Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system. Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data.
 *
 * @schema io.k8s.api.events.v1.Event
 */
class KubeEvent extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.events.v1.Event" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeEvent.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.events.v1.Event".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeEvent.GVK,
            ...toJson_KubeEventProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeEvent.GVK,
            ...toJson_KubeEventProps(resolved),
        };
    }
}
exports.KubeEvent = KubeEvent;
/**
 * Returns the apiVersion and kind for "io.k8s.api.events.v1.Event"
 */
KubeEvent.GVK = {
    apiVersion: 'events.k8s.io/v1',
    kind: 'Event',
};
/**
 * EventList is a list of Event objects.
 *
 * @schema io.k8s.api.events.v1.EventList
 */
class KubeEventList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.events.v1.EventList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeEventList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.events.v1.EventList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeEventList.GVK,
            ...toJson_KubeEventListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeEventList.GVK,
            ...toJson_KubeEventListProps(resolved),
        };
    }
}
exports.KubeEventList = KubeEventList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.events.v1.EventList"
 */
KubeEventList.GVK = {
    apiVersion: 'events.k8s.io/v1',
    kind: 'EventList',
};
/**
 * LimitRange sets resource usage limits for each kind of resource in a Namespace.
 *
 * @schema io.k8s.api.core.v1.LimitRange
 */
class KubeLimitRange extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.LimitRange" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeLimitRange.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.LimitRange".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeLimitRange.GVK,
            ...toJson_KubeLimitRangeProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeLimitRange.GVK,
            ...toJson_KubeLimitRangeProps(resolved),
        };
    }
}
exports.KubeLimitRange = KubeLimitRange;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.LimitRange"
 */
KubeLimitRange.GVK = {
    apiVersion: 'v1',
    kind: 'LimitRange',
};
/**
 * LimitRangeList is a list of LimitRange items.
 *
 * @schema io.k8s.api.core.v1.LimitRangeList
 */
class KubeLimitRangeList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.LimitRangeList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeLimitRangeList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.LimitRangeList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeLimitRangeList.GVK,
            ...toJson_KubeLimitRangeListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeLimitRangeList.GVK,
            ...toJson_KubeLimitRangeListProps(resolved),
        };
    }
}
exports.KubeLimitRangeList = KubeLimitRangeList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.LimitRangeList"
 */
KubeLimitRangeList.GVK = {
    apiVersion: 'v1',
    kind: 'LimitRangeList',
};
/**
 * Namespace provides a scope for Names. Use of multiple namespaces is optional.
 *
 * @schema io.k8s.api.core.v1.Namespace
 */
class KubeNamespace extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.Namespace" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeNamespace.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.Namespace".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeNamespace.GVK,
            ...toJson_KubeNamespaceProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeNamespace.GVK,
            ...toJson_KubeNamespaceProps(resolved),
        };
    }
}
exports.KubeNamespace = KubeNamespace;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.Namespace"
 */
KubeNamespace.GVK = {
    apiVersion: 'v1',
    kind: 'Namespace',
};
/**
 * NamespaceList is a list of Namespaces.
 *
 * @schema io.k8s.api.core.v1.NamespaceList
 */
class KubeNamespaceList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.NamespaceList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeNamespaceList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.NamespaceList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeNamespaceList.GVK,
            ...toJson_KubeNamespaceListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeNamespaceList.GVK,
            ...toJson_KubeNamespaceListProps(resolved),
        };
    }
}
exports.KubeNamespaceList = KubeNamespaceList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.NamespaceList"
 */
KubeNamespaceList.GVK = {
    apiVersion: 'v1',
    kind: 'NamespaceList',
};
/**
 * Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd).
 *
 * @schema io.k8s.api.core.v1.Node
 */
class KubeNode extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.Node" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeNode.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.Node".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeNode.GVK,
            ...toJson_KubeNodeProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeNode.GVK,
            ...toJson_KubeNodeProps(resolved),
        };
    }
}
exports.KubeNode = KubeNode;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.Node"
 */
KubeNode.GVK = {
    apiVersion: 'v1',
    kind: 'Node',
};
/**
 * NodeList is the whole list of all Nodes which have been registered with master.
 *
 * @schema io.k8s.api.core.v1.NodeList
 */
class KubeNodeList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.NodeList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeNodeList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.NodeList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeNodeList.GVK,
            ...toJson_KubeNodeListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeNodeList.GVK,
            ...toJson_KubeNodeListProps(resolved),
        };
    }
}
exports.KubeNodeList = KubeNodeList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.NodeList"
 */
KubeNodeList.GVK = {
    apiVersion: 'v1',
    kind: 'NodeList',
};
/**
 * PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
 *
 * @schema io.k8s.api.core.v1.PersistentVolume
 */
class KubePersistentVolume extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.PersistentVolume" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubePersistentVolume.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.PersistentVolume".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubePersistentVolume.GVK,
            ...toJson_KubePersistentVolumeProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubePersistentVolume.GVK,
            ...toJson_KubePersistentVolumeProps(resolved),
        };
    }
}
exports.KubePersistentVolume = KubePersistentVolume;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.PersistentVolume"
 */
KubePersistentVolume.GVK = {
    apiVersion: 'v1',
    kind: 'PersistentVolume',
};
/**
 * PersistentVolumeClaim is a user's request for and claim to a persistent volume
 *
 * @schema io.k8s.api.core.v1.PersistentVolumeClaim
 */
class KubePersistentVolumeClaim extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.PersistentVolumeClaim" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubePersistentVolumeClaim.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.PersistentVolumeClaim".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubePersistentVolumeClaim.GVK,
            ...toJson_KubePersistentVolumeClaimProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubePersistentVolumeClaim.GVK,
            ...toJson_KubePersistentVolumeClaimProps(resolved),
        };
    }
}
exports.KubePersistentVolumeClaim = KubePersistentVolumeClaim;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.PersistentVolumeClaim"
 */
KubePersistentVolumeClaim.GVK = {
    apiVersion: 'v1',
    kind: 'PersistentVolumeClaim',
};
/**
 * PersistentVolumeClaimList is a list of PersistentVolumeClaim items.
 *
 * @schema io.k8s.api.core.v1.PersistentVolumeClaimList
 */
class KubePersistentVolumeClaimList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.PersistentVolumeClaimList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubePersistentVolumeClaimList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.PersistentVolumeClaimList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubePersistentVolumeClaimList.GVK,
            ...toJson_KubePersistentVolumeClaimListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubePersistentVolumeClaimList.GVK,
            ...toJson_KubePersistentVolumeClaimListProps(resolved),
        };
    }
}
exports.KubePersistentVolumeClaimList = KubePersistentVolumeClaimList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.PersistentVolumeClaimList"
 */
KubePersistentVolumeClaimList.GVK = {
    apiVersion: 'v1',
    kind: 'PersistentVolumeClaimList',
};
/**
 * PersistentVolumeList is a list of PersistentVolume items.
 *
 * @schema io.k8s.api.core.v1.PersistentVolumeList
 */
class KubePersistentVolumeList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.PersistentVolumeList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubePersistentVolumeList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.PersistentVolumeList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubePersistentVolumeList.GVK,
            ...toJson_KubePersistentVolumeListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubePersistentVolumeList.GVK,
            ...toJson_KubePersistentVolumeListProps(resolved),
        };
    }
}
exports.KubePersistentVolumeList = KubePersistentVolumeList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.PersistentVolumeList"
 */
KubePersistentVolumeList.GVK = {
    apiVersion: 'v1',
    kind: 'PersistentVolumeList',
};
/**
 * Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.
 *
 * @schema io.k8s.api.core.v1.Pod
 */
class KubePod extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.Pod" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubePod.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.Pod".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubePod.GVK,
            ...toJson_KubePodProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubePod.GVK,
            ...toJson_KubePodProps(resolved),
        };
    }
}
exports.KubePod = KubePod;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.Pod"
 */
KubePod.GVK = {
    apiVersion: 'v1',
    kind: 'Pod',
};
/**
 * PodList is a list of Pods.
 *
 * @schema io.k8s.api.core.v1.PodList
 */
class KubePodList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.PodList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubePodList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.PodList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubePodList.GVK,
            ...toJson_KubePodListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubePodList.GVK,
            ...toJson_KubePodListProps(resolved),
        };
    }
}
exports.KubePodList = KubePodList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.PodList"
 */
KubePodList.GVK = {
    apiVersion: 'v1',
    kind: 'PodList',
};
/**
 * PodTemplate describes a template for creating copies of a predefined pod.
 *
 * @schema io.k8s.api.core.v1.PodTemplate
 */
class KubePodTemplate extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.PodTemplate" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubePodTemplate.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.PodTemplate".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubePodTemplate.GVK,
            ...toJson_KubePodTemplateProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubePodTemplate.GVK,
            ...toJson_KubePodTemplateProps(resolved),
        };
    }
}
exports.KubePodTemplate = KubePodTemplate;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.PodTemplate"
 */
KubePodTemplate.GVK = {
    apiVersion: 'v1',
    kind: 'PodTemplate',
};
/**
 * PodTemplateList is a list of PodTemplates.
 *
 * @schema io.k8s.api.core.v1.PodTemplateList
 */
class KubePodTemplateList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.PodTemplateList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubePodTemplateList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.PodTemplateList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubePodTemplateList.GVK,
            ...toJson_KubePodTemplateListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubePodTemplateList.GVK,
            ...toJson_KubePodTemplateListProps(resolved),
        };
    }
}
exports.KubePodTemplateList = KubePodTemplateList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.PodTemplateList"
 */
KubePodTemplateList.GVK = {
    apiVersion: 'v1',
    kind: 'PodTemplateList',
};
/**
 * ReplicationController represents the configuration of a replication controller.
 *
 * @schema io.k8s.api.core.v1.ReplicationController
 */
class KubeReplicationController extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.ReplicationController" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeReplicationController.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.ReplicationController".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeReplicationController.GVK,
            ...toJson_KubeReplicationControllerProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeReplicationController.GVK,
            ...toJson_KubeReplicationControllerProps(resolved),
        };
    }
}
exports.KubeReplicationController = KubeReplicationController;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.ReplicationController"
 */
KubeReplicationController.GVK = {
    apiVersion: 'v1',
    kind: 'ReplicationController',
};
/**
 * ReplicationControllerList is a collection of replication controllers.
 *
 * @schema io.k8s.api.core.v1.ReplicationControllerList
 */
class KubeReplicationControllerList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.ReplicationControllerList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeReplicationControllerList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.ReplicationControllerList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeReplicationControllerList.GVK,
            ...toJson_KubeReplicationControllerListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeReplicationControllerList.GVK,
            ...toJson_KubeReplicationControllerListProps(resolved),
        };
    }
}
exports.KubeReplicationControllerList = KubeReplicationControllerList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.ReplicationControllerList"
 */
KubeReplicationControllerList.GVK = {
    apiVersion: 'v1',
    kind: 'ReplicationControllerList',
};
/**
 * ResourceQuota sets aggregate quota restrictions enforced per namespace
 *
 * @schema io.k8s.api.core.v1.ResourceQuota
 */
class KubeResourceQuota extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.ResourceQuota" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeResourceQuota.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.ResourceQuota".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeResourceQuota.GVK,
            ...toJson_KubeResourceQuotaProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeResourceQuota.GVK,
            ...toJson_KubeResourceQuotaProps(resolved),
        };
    }
}
exports.KubeResourceQuota = KubeResourceQuota;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.ResourceQuota"
 */
KubeResourceQuota.GVK = {
    apiVersion: 'v1',
    kind: 'ResourceQuota',
};
/**
 * ResourceQuotaList is a list of ResourceQuota items.
 *
 * @schema io.k8s.api.core.v1.ResourceQuotaList
 */
class KubeResourceQuotaList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.ResourceQuotaList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeResourceQuotaList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.ResourceQuotaList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeResourceQuotaList.GVK,
            ...toJson_KubeResourceQuotaListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeResourceQuotaList.GVK,
            ...toJson_KubeResourceQuotaListProps(resolved),
        };
    }
}
exports.KubeResourceQuotaList = KubeResourceQuotaList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.ResourceQuotaList"
 */
KubeResourceQuotaList.GVK = {
    apiVersion: 'v1',
    kind: 'ResourceQuotaList',
};
/**
 * Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes.
 *
 * @schema io.k8s.api.core.v1.Secret
 */
class KubeSecret extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.Secret" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeSecret.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.Secret".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeSecret.GVK,
            ...toJson_KubeSecretProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeSecret.GVK,
            ...toJson_KubeSecretProps(resolved),
        };
    }
}
exports.KubeSecret = KubeSecret;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.Secret"
 */
KubeSecret.GVK = {
    apiVersion: 'v1',
    kind: 'Secret',
};
/**
 * SecretList is a list of Secret.
 *
 * @schema io.k8s.api.core.v1.SecretList
 */
class KubeSecretList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.SecretList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeSecretList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.SecretList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeSecretList.GVK,
            ...toJson_KubeSecretListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeSecretList.GVK,
            ...toJson_KubeSecretListProps(resolved),
        };
    }
}
exports.KubeSecretList = KubeSecretList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.SecretList"
 */
KubeSecretList.GVK = {
    apiVersion: 'v1',
    kind: 'SecretList',
};
/**
 * Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy.
 *
 * @schema io.k8s.api.core.v1.Service
 */
class KubeService extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.Service" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeService.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.Service".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeService.GVK,
            ...toJson_KubeServiceProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeService.GVK,
            ...toJson_KubeServiceProps(resolved),
        };
    }
}
exports.KubeService = KubeService;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.Service"
 */
KubeService.GVK = {
    apiVersion: 'v1',
    kind: 'Service',
};
/**
 * ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets
 *
 * @schema io.k8s.api.core.v1.ServiceAccount
 */
class KubeServiceAccount extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.ServiceAccount" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeServiceAccount.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.ServiceAccount".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeServiceAccount.GVK,
            ...toJson_KubeServiceAccountProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeServiceAccount.GVK,
            ...toJson_KubeServiceAccountProps(resolved),
        };
    }
}
exports.KubeServiceAccount = KubeServiceAccount;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.ServiceAccount"
 */
KubeServiceAccount.GVK = {
    apiVersion: 'v1',
    kind: 'ServiceAccount',
};
/**
 * ServiceAccountList is a list of ServiceAccount objects
 *
 * @schema io.k8s.api.core.v1.ServiceAccountList
 */
class KubeServiceAccountList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.ServiceAccountList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeServiceAccountList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.ServiceAccountList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeServiceAccountList.GVK,
            ...toJson_KubeServiceAccountListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeServiceAccountList.GVK,
            ...toJson_KubeServiceAccountListProps(resolved),
        };
    }
}
exports.KubeServiceAccountList = KubeServiceAccountList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.ServiceAccountList"
 */
KubeServiceAccountList.GVK = {
    apiVersion: 'v1',
    kind: 'ServiceAccountList',
};
/**
 * ServiceList holds a list of services.
 *
 * @schema io.k8s.api.core.v1.ServiceList
 */
class KubeServiceList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.core.v1.ServiceList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeServiceList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.core.v1.ServiceList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeServiceList.GVK,
            ...toJson_KubeServiceListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeServiceList.GVK,
            ...toJson_KubeServiceListProps(resolved),
        };
    }
}
exports.KubeServiceList = KubeServiceList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.core.v1.ServiceList"
 */
KubeServiceList.GVK = {
    apiVersion: 'v1',
    kind: 'ServiceList',
};
/**
 * EndpointSlice represents a subset of the endpoints that implement a service. For a given service there may be multiple EndpointSlice objects, selected by labels, which must be joined to produce the full set of endpoints.
 *
 * @schema io.k8s.api.discovery.v1.EndpointSlice
 */
class KubeEndpointSlice extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.discovery.v1.EndpointSlice" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeEndpointSlice.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.discovery.v1.EndpointSlice".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeEndpointSlice.GVK,
            ...toJson_KubeEndpointSliceProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeEndpointSlice.GVK,
            ...toJson_KubeEndpointSliceProps(resolved),
        };
    }
}
exports.KubeEndpointSlice = KubeEndpointSlice;
/**
 * Returns the apiVersion and kind for "io.k8s.api.discovery.v1.EndpointSlice"
 */
KubeEndpointSlice.GVK = {
    apiVersion: 'discovery.k8s.io/v1',
    kind: 'EndpointSlice',
};
/**
 * EndpointSliceList represents a list of endpoint slices
 *
 * @schema io.k8s.api.discovery.v1.EndpointSliceList
 */
class KubeEndpointSliceList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.discovery.v1.EndpointSliceList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeEndpointSliceList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.discovery.v1.EndpointSliceList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeEndpointSliceList.GVK,
            ...toJson_KubeEndpointSliceListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeEndpointSliceList.GVK,
            ...toJson_KubeEndpointSliceListProps(resolved),
        };
    }
}
exports.KubeEndpointSliceList = KubeEndpointSliceList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.discovery.v1.EndpointSliceList"
 */
KubeEndpointSliceList.GVK = {
    apiVersion: 'discovery.k8s.io/v1',
    kind: 'EndpointSliceList',
};
/**
 * EndpointSlice represents a subset of the endpoints that implement a service. For a given service there may be multiple EndpointSlice objects, selected by labels, which must be joined to produce the full set of endpoints.
 *
 * @schema io.k8s.api.discovery.v1beta1.EndpointSlice
 */
class KubeEndpointSliceV1Beta1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.discovery.v1beta1.EndpointSlice" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeEndpointSliceV1Beta1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.discovery.v1beta1.EndpointSlice".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeEndpointSliceV1Beta1.GVK,
            ...toJson_KubeEndpointSliceV1Beta1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeEndpointSliceV1Beta1.GVK,
            ...toJson_KubeEndpointSliceV1Beta1Props(resolved),
        };
    }
}
exports.KubeEndpointSliceV1Beta1 = KubeEndpointSliceV1Beta1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.discovery.v1beta1.EndpointSlice"
 */
KubeEndpointSliceV1Beta1.GVK = {
    apiVersion: 'discovery.k8s.io/v1beta1',
    kind: 'EndpointSlice',
};
/**
 * EndpointSliceList represents a list of endpoint slices
 *
 * @schema io.k8s.api.discovery.v1beta1.EndpointSliceList
 */
class KubeEndpointSliceListV1Beta1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.discovery.v1beta1.EndpointSliceList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeEndpointSliceListV1Beta1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.discovery.v1beta1.EndpointSliceList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeEndpointSliceListV1Beta1.GVK,
            ...toJson_KubeEndpointSliceListV1Beta1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeEndpointSliceListV1Beta1.GVK,
            ...toJson_KubeEndpointSliceListV1Beta1Props(resolved),
        };
    }
}
exports.KubeEndpointSliceListV1Beta1 = KubeEndpointSliceListV1Beta1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.discovery.v1beta1.EndpointSliceList"
 */
KubeEndpointSliceListV1Beta1.GVK = {
    apiVersion: 'discovery.k8s.io/v1beta1',
    kind: 'EndpointSliceList',
};
/**
 * Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system. Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data.
 *
 * @schema io.k8s.api.events.v1beta1.Event
 */
class KubeEventV1Beta1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.events.v1beta1.Event" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeEventV1Beta1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.events.v1beta1.Event".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeEventV1Beta1.GVK,
            ...toJson_KubeEventV1Beta1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeEventV1Beta1.GVK,
            ...toJson_KubeEventV1Beta1Props(resolved),
        };
    }
}
exports.KubeEventV1Beta1 = KubeEventV1Beta1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.events.v1beta1.Event"
 */
KubeEventV1Beta1.GVK = {
    apiVersion: 'events.k8s.io/v1beta1',
    kind: 'Event',
};
/**
 * EventList is a list of Event objects.
 *
 * @schema io.k8s.api.events.v1beta1.EventList
 */
class KubeEventListV1Beta1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.events.v1beta1.EventList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeEventListV1Beta1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.events.v1beta1.EventList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeEventListV1Beta1.GVK,
            ...toJson_KubeEventListV1Beta1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeEventListV1Beta1.GVK,
            ...toJson_KubeEventListV1Beta1Props(resolved),
        };
    }
}
exports.KubeEventListV1Beta1 = KubeEventListV1Beta1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.events.v1beta1.EventList"
 */
KubeEventListV1Beta1.GVK = {
    apiVersion: 'events.k8s.io/v1beta1',
    kind: 'EventList',
};
/**
 * FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a "flow distinguisher".
 *
 * @schema io.k8s.api.flowcontrol.v1beta1.FlowSchema
 */
class KubeFlowSchemaV1Beta1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.flowcontrol.v1beta1.FlowSchema" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeFlowSchemaV1Beta1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.flowcontrol.v1beta1.FlowSchema".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeFlowSchemaV1Beta1.GVK,
            ...toJson_KubeFlowSchemaV1Beta1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeFlowSchemaV1Beta1.GVK,
            ...toJson_KubeFlowSchemaV1Beta1Props(resolved),
        };
    }
}
exports.KubeFlowSchemaV1Beta1 = KubeFlowSchemaV1Beta1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.flowcontrol.v1beta1.FlowSchema"
 */
KubeFlowSchemaV1Beta1.GVK = {
    apiVersion: 'flowcontrol.apiserver.k8s.io/v1beta1',
    kind: 'FlowSchema',
};
/**
 * FlowSchemaList is a list of FlowSchema objects.
 *
 * @schema io.k8s.api.flowcontrol.v1beta1.FlowSchemaList
 */
class KubeFlowSchemaListV1Beta1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.flowcontrol.v1beta1.FlowSchemaList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeFlowSchemaListV1Beta1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.flowcontrol.v1beta1.FlowSchemaList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeFlowSchemaListV1Beta1.GVK,
            ...toJson_KubeFlowSchemaListV1Beta1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeFlowSchemaListV1Beta1.GVK,
            ...toJson_KubeFlowSchemaListV1Beta1Props(resolved),
        };
    }
}
exports.KubeFlowSchemaListV1Beta1 = KubeFlowSchemaListV1Beta1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.flowcontrol.v1beta1.FlowSchemaList"
 */
KubeFlowSchemaListV1Beta1.GVK = {
    apiVersion: 'flowcontrol.apiserver.k8s.io/v1beta1',
    kind: 'FlowSchemaList',
};
/**
 * PriorityLevelConfiguration represents the configuration of a priority level.
 *
 * @schema io.k8s.api.flowcontrol.v1beta1.PriorityLevelConfiguration
 */
class KubePriorityLevelConfigurationV1Beta1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.flowcontrol.v1beta1.PriorityLevelConfiguration" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubePriorityLevelConfigurationV1Beta1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.flowcontrol.v1beta1.PriorityLevelConfiguration".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubePriorityLevelConfigurationV1Beta1.GVK,
            ...toJson_KubePriorityLevelConfigurationV1Beta1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubePriorityLevelConfigurationV1Beta1.GVK,
            ...toJson_KubePriorityLevelConfigurationV1Beta1Props(resolved),
        };
    }
}
exports.KubePriorityLevelConfigurationV1Beta1 = KubePriorityLevelConfigurationV1Beta1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.flowcontrol.v1beta1.PriorityLevelConfiguration"
 */
KubePriorityLevelConfigurationV1Beta1.GVK = {
    apiVersion: 'flowcontrol.apiserver.k8s.io/v1beta1',
    kind: 'PriorityLevelConfiguration',
};
/**
 * PriorityLevelConfigurationList is a list of PriorityLevelConfiguration objects.
 *
 * @schema io.k8s.api.flowcontrol.v1beta1.PriorityLevelConfigurationList
 */
class KubePriorityLevelConfigurationListV1Beta1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.flowcontrol.v1beta1.PriorityLevelConfigurationList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubePriorityLevelConfigurationListV1Beta1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.flowcontrol.v1beta1.PriorityLevelConfigurationList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubePriorityLevelConfigurationListV1Beta1.GVK,
            ...toJson_KubePriorityLevelConfigurationListV1Beta1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubePriorityLevelConfigurationListV1Beta1.GVK,
            ...toJson_KubePriorityLevelConfigurationListV1Beta1Props(resolved),
        };
    }
}
exports.KubePriorityLevelConfigurationListV1Beta1 = KubePriorityLevelConfigurationListV1Beta1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.flowcontrol.v1beta1.PriorityLevelConfigurationList"
 */
KubePriorityLevelConfigurationListV1Beta1.GVK = {
    apiVersion: 'flowcontrol.apiserver.k8s.io/v1beta1',
    kind: 'PriorityLevelConfigurationList',
};
/**
 * Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.
 *
 * @schema io.k8s.api.networking.v1.Ingress
 */
class KubeIngress extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.networking.v1.Ingress" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeIngress.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.networking.v1.Ingress".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeIngress.GVK,
            ...toJson_KubeIngressProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeIngress.GVK,
            ...toJson_KubeIngressProps(resolved),
        };
    }
}
exports.KubeIngress = KubeIngress;
/**
 * Returns the apiVersion and kind for "io.k8s.api.networking.v1.Ingress"
 */
KubeIngress.GVK = {
    apiVersion: 'networking.k8s.io/v1',
    kind: 'Ingress',
};
/**
 * IngressClass represents the class of the Ingress, referenced by the Ingress Spec. The `ingressclass.kubernetes.io/is-default-class` annotation can be used to indicate that an IngressClass should be considered default. When a single IngressClass resource has this annotation set to true, new Ingress resources without a class specified will be assigned this default class.
 *
 * @schema io.k8s.api.networking.v1.IngressClass
 */
class KubeIngressClass extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.networking.v1.IngressClass" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeIngressClass.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.networking.v1.IngressClass".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeIngressClass.GVK,
            ...toJson_KubeIngressClassProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeIngressClass.GVK,
            ...toJson_KubeIngressClassProps(resolved),
        };
    }
}
exports.KubeIngressClass = KubeIngressClass;
/**
 * Returns the apiVersion and kind for "io.k8s.api.networking.v1.IngressClass"
 */
KubeIngressClass.GVK = {
    apiVersion: 'networking.k8s.io/v1',
    kind: 'IngressClass',
};
/**
 * IngressClassList is a collection of IngressClasses.
 *
 * @schema io.k8s.api.networking.v1.IngressClassList
 */
class KubeIngressClassList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.networking.v1.IngressClassList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeIngressClassList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.networking.v1.IngressClassList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeIngressClassList.GVK,
            ...toJson_KubeIngressClassListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeIngressClassList.GVK,
            ...toJson_KubeIngressClassListProps(resolved),
        };
    }
}
exports.KubeIngressClassList = KubeIngressClassList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.networking.v1.IngressClassList"
 */
KubeIngressClassList.GVK = {
    apiVersion: 'networking.k8s.io/v1',
    kind: 'IngressClassList',
};
/**
 * IngressList is a collection of Ingress.
 *
 * @schema io.k8s.api.networking.v1.IngressList
 */
class KubeIngressList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.networking.v1.IngressList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeIngressList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.networking.v1.IngressList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeIngressList.GVK,
            ...toJson_KubeIngressListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeIngressList.GVK,
            ...toJson_KubeIngressListProps(resolved),
        };
    }
}
exports.KubeIngressList = KubeIngressList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.networking.v1.IngressList"
 */
KubeIngressList.GVK = {
    apiVersion: 'networking.k8s.io/v1',
    kind: 'IngressList',
};
/**
 * NetworkPolicy describes what network traffic is allowed for a set of Pods
 *
 * @schema io.k8s.api.networking.v1.NetworkPolicy
 */
class KubeNetworkPolicy extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.networking.v1.NetworkPolicy" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeNetworkPolicy.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.networking.v1.NetworkPolicy".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeNetworkPolicy.GVK,
            ...toJson_KubeNetworkPolicyProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeNetworkPolicy.GVK,
            ...toJson_KubeNetworkPolicyProps(resolved),
        };
    }
}
exports.KubeNetworkPolicy = KubeNetworkPolicy;
/**
 * Returns the apiVersion and kind for "io.k8s.api.networking.v1.NetworkPolicy"
 */
KubeNetworkPolicy.GVK = {
    apiVersion: 'networking.k8s.io/v1',
    kind: 'NetworkPolicy',
};
/**
 * NetworkPolicyList is a list of NetworkPolicy objects.
 *
 * @schema io.k8s.api.networking.v1.NetworkPolicyList
 */
class KubeNetworkPolicyList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.networking.v1.NetworkPolicyList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeNetworkPolicyList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.networking.v1.NetworkPolicyList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeNetworkPolicyList.GVK,
            ...toJson_KubeNetworkPolicyListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeNetworkPolicyList.GVK,
            ...toJson_KubeNetworkPolicyListProps(resolved),
        };
    }
}
exports.KubeNetworkPolicyList = KubeNetworkPolicyList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.networking.v1.NetworkPolicyList"
 */
KubeNetworkPolicyList.GVK = {
    apiVersion: 'networking.k8s.io/v1',
    kind: 'NetworkPolicyList',
};
/**
 * RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass is used to determine which container runtime is used to run all containers in a pod. RuntimeClasses are manually defined by a user or cluster provisioner, and referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName reference before running the pod.  For more details, see https://kubernetes.io/docs/concepts/containers/runtime-class/
 *
 * @schema io.k8s.api.node.v1.RuntimeClass
 */
class KubeRuntimeClass extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.node.v1.RuntimeClass" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeRuntimeClass.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.node.v1.RuntimeClass".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeRuntimeClass.GVK,
            ...toJson_KubeRuntimeClassProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeRuntimeClass.GVK,
            ...toJson_KubeRuntimeClassProps(resolved),
        };
    }
}
exports.KubeRuntimeClass = KubeRuntimeClass;
/**
 * Returns the apiVersion and kind for "io.k8s.api.node.v1.RuntimeClass"
 */
KubeRuntimeClass.GVK = {
    apiVersion: 'node.k8s.io/v1',
    kind: 'RuntimeClass',
};
/**
 * RuntimeClassList is a list of RuntimeClass objects.
 *
 * @schema io.k8s.api.node.v1.RuntimeClassList
 */
class KubeRuntimeClassList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.node.v1.RuntimeClassList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeRuntimeClassList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.node.v1.RuntimeClassList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeRuntimeClassList.GVK,
            ...toJson_KubeRuntimeClassListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeRuntimeClassList.GVK,
            ...toJson_KubeRuntimeClassListProps(resolved),
        };
    }
}
exports.KubeRuntimeClassList = KubeRuntimeClassList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.node.v1.RuntimeClassList"
 */
KubeRuntimeClassList.GVK = {
    apiVersion: 'node.k8s.io/v1',
    kind: 'RuntimeClassList',
};
/**
 * RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass is used to determine which container runtime is used to run all containers in a pod. RuntimeClasses are (currently) manually defined by a user or cluster provisioner, and referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName reference before running the pod.  For more details, see https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
 *
 * @schema io.k8s.api.node.v1alpha1.RuntimeClass
 */
class KubeRuntimeClassV1Alpha1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.node.v1alpha1.RuntimeClass" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeRuntimeClassV1Alpha1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.node.v1alpha1.RuntimeClass".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeRuntimeClassV1Alpha1.GVK,
            ...toJson_KubeRuntimeClassV1Alpha1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeRuntimeClassV1Alpha1.GVK,
            ...toJson_KubeRuntimeClassV1Alpha1Props(resolved),
        };
    }
}
exports.KubeRuntimeClassV1Alpha1 = KubeRuntimeClassV1Alpha1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.node.v1alpha1.RuntimeClass"
 */
KubeRuntimeClassV1Alpha1.GVK = {
    apiVersion: 'node.k8s.io/v1alpha1',
    kind: 'RuntimeClass',
};
/**
 * RuntimeClassList is a list of RuntimeClass objects.
 *
 * @schema io.k8s.api.node.v1alpha1.RuntimeClassList
 */
class KubeRuntimeClassListV1Alpha1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.node.v1alpha1.RuntimeClassList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeRuntimeClassListV1Alpha1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.node.v1alpha1.RuntimeClassList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeRuntimeClassListV1Alpha1.GVK,
            ...toJson_KubeRuntimeClassListV1Alpha1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeRuntimeClassListV1Alpha1.GVK,
            ...toJson_KubeRuntimeClassListV1Alpha1Props(resolved),
        };
    }
}
exports.KubeRuntimeClassListV1Alpha1 = KubeRuntimeClassListV1Alpha1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.node.v1alpha1.RuntimeClassList"
 */
KubeRuntimeClassListV1Alpha1.GVK = {
    apiVersion: 'node.k8s.io/v1alpha1',
    kind: 'RuntimeClassList',
};
/**
 * RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass is used to determine which container runtime is used to run all containers in a pod. RuntimeClasses are (currently) manually defined by a user or cluster provisioner, and referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName reference before running the pod.  For more details, see https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
 *
 * @schema io.k8s.api.node.v1beta1.RuntimeClass
 */
class KubeRuntimeClassV1Beta1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.node.v1beta1.RuntimeClass" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeRuntimeClassV1Beta1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.node.v1beta1.RuntimeClass".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeRuntimeClassV1Beta1.GVK,
            ...toJson_KubeRuntimeClassV1Beta1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeRuntimeClassV1Beta1.GVK,
            ...toJson_KubeRuntimeClassV1Beta1Props(resolved),
        };
    }
}
exports.KubeRuntimeClassV1Beta1 = KubeRuntimeClassV1Beta1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.node.v1beta1.RuntimeClass"
 */
KubeRuntimeClassV1Beta1.GVK = {
    apiVersion: 'node.k8s.io/v1beta1',
    kind: 'RuntimeClass',
};
/**
 * RuntimeClassList is a list of RuntimeClass objects.
 *
 * @schema io.k8s.api.node.v1beta1.RuntimeClassList
 */
class KubeRuntimeClassListV1Beta1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.node.v1beta1.RuntimeClassList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeRuntimeClassListV1Beta1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.node.v1beta1.RuntimeClassList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeRuntimeClassListV1Beta1.GVK,
            ...toJson_KubeRuntimeClassListV1Beta1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeRuntimeClassListV1Beta1.GVK,
            ...toJson_KubeRuntimeClassListV1Beta1Props(resolved),
        };
    }
}
exports.KubeRuntimeClassListV1Beta1 = KubeRuntimeClassListV1Beta1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.node.v1beta1.RuntimeClassList"
 */
KubeRuntimeClassListV1Beta1.GVK = {
    apiVersion: 'node.k8s.io/v1beta1',
    kind: 'RuntimeClassList',
};
/**
 * Eviction evicts a pod from its node subject to certain policies and safety constraints. This is a subresource of Pod.  A request to cause such an eviction is created by POSTing to .../pods/<pod name>/evictions.
 *
 * @schema io.k8s.api.policy.v1.Eviction
 */
class KubeEviction extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.policy.v1.Eviction" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeEviction.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.policy.v1.Eviction".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeEviction.GVK,
            ...toJson_KubeEvictionProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeEviction.GVK,
            ...toJson_KubeEvictionProps(resolved),
        };
    }
}
exports.KubeEviction = KubeEviction;
/**
 * Returns the apiVersion and kind for "io.k8s.api.policy.v1.Eviction"
 */
KubeEviction.GVK = {
    apiVersion: 'policy/v1',
    kind: 'Eviction',
};
/**
 * PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods
 *
 * @schema io.k8s.api.policy.v1.PodDisruptionBudget
 */
class KubePodDisruptionBudget extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.policy.v1.PodDisruptionBudget" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubePodDisruptionBudget.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.policy.v1.PodDisruptionBudget".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubePodDisruptionBudget.GVK,
            ...toJson_KubePodDisruptionBudgetProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubePodDisruptionBudget.GVK,
            ...toJson_KubePodDisruptionBudgetProps(resolved),
        };
    }
}
exports.KubePodDisruptionBudget = KubePodDisruptionBudget;
/**
 * Returns the apiVersion and kind for "io.k8s.api.policy.v1.PodDisruptionBudget"
 */
KubePodDisruptionBudget.GVK = {
    apiVersion: 'policy/v1',
    kind: 'PodDisruptionBudget',
};
/**
 * PodDisruptionBudgetList is a collection of PodDisruptionBudgets.
 *
 * @schema io.k8s.api.policy.v1.PodDisruptionBudgetList
 */
class KubePodDisruptionBudgetList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.policy.v1.PodDisruptionBudgetList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubePodDisruptionBudgetList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.policy.v1.PodDisruptionBudgetList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubePodDisruptionBudgetList.GVK,
            ...toJson_KubePodDisruptionBudgetListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubePodDisruptionBudgetList.GVK,
            ...toJson_KubePodDisruptionBudgetListProps(resolved),
        };
    }
}
exports.KubePodDisruptionBudgetList = KubePodDisruptionBudgetList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.policy.v1.PodDisruptionBudgetList"
 */
KubePodDisruptionBudgetList.GVK = {
    apiVersion: 'policy/v1',
    kind: 'PodDisruptionBudgetList',
};
/**
 * PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods
 *
 * @schema io.k8s.api.policy.v1beta1.PodDisruptionBudget
 */
class KubePodDisruptionBudgetV1Beta1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.policy.v1beta1.PodDisruptionBudget" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubePodDisruptionBudgetV1Beta1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.policy.v1beta1.PodDisruptionBudget".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubePodDisruptionBudgetV1Beta1.GVK,
            ...toJson_KubePodDisruptionBudgetV1Beta1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubePodDisruptionBudgetV1Beta1.GVK,
            ...toJson_KubePodDisruptionBudgetV1Beta1Props(resolved),
        };
    }
}
exports.KubePodDisruptionBudgetV1Beta1 = KubePodDisruptionBudgetV1Beta1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.policy.v1beta1.PodDisruptionBudget"
 */
KubePodDisruptionBudgetV1Beta1.GVK = {
    apiVersion: 'policy/v1beta1',
    kind: 'PodDisruptionBudget',
};
/**
 * PodDisruptionBudgetList is a collection of PodDisruptionBudgets.
 *
 * @schema io.k8s.api.policy.v1beta1.PodDisruptionBudgetList
 */
class KubePodDisruptionBudgetListV1Beta1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.policy.v1beta1.PodDisruptionBudgetList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubePodDisruptionBudgetListV1Beta1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.policy.v1beta1.PodDisruptionBudgetList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubePodDisruptionBudgetListV1Beta1.GVK,
            ...toJson_KubePodDisruptionBudgetListV1Beta1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubePodDisruptionBudgetListV1Beta1.GVK,
            ...toJson_KubePodDisruptionBudgetListV1Beta1Props(resolved),
        };
    }
}
exports.KubePodDisruptionBudgetListV1Beta1 = KubePodDisruptionBudgetListV1Beta1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.policy.v1beta1.PodDisruptionBudgetList"
 */
KubePodDisruptionBudgetListV1Beta1.GVK = {
    apiVersion: 'policy/v1beta1',
    kind: 'PodDisruptionBudgetList',
};
/**
 * PodSecurityPolicy governs the ability to make requests that affect the Security Context that will be applied to a pod and container. Deprecated in 1.21.
 *
 * @schema io.k8s.api.policy.v1beta1.PodSecurityPolicy
 */
class KubePodSecurityPolicyV1Beta1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.policy.v1beta1.PodSecurityPolicy" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubePodSecurityPolicyV1Beta1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.policy.v1beta1.PodSecurityPolicy".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubePodSecurityPolicyV1Beta1.GVK,
            ...toJson_KubePodSecurityPolicyV1Beta1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubePodSecurityPolicyV1Beta1.GVK,
            ...toJson_KubePodSecurityPolicyV1Beta1Props(resolved),
        };
    }
}
exports.KubePodSecurityPolicyV1Beta1 = KubePodSecurityPolicyV1Beta1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.policy.v1beta1.PodSecurityPolicy"
 */
KubePodSecurityPolicyV1Beta1.GVK = {
    apiVersion: 'policy/v1beta1',
    kind: 'PodSecurityPolicy',
};
/**
 * PodSecurityPolicyList is a list of PodSecurityPolicy objects.
 *
 * @schema io.k8s.api.policy.v1beta1.PodSecurityPolicyList
 */
class KubePodSecurityPolicyListV1Beta1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.policy.v1beta1.PodSecurityPolicyList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubePodSecurityPolicyListV1Beta1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.policy.v1beta1.PodSecurityPolicyList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubePodSecurityPolicyListV1Beta1.GVK,
            ...toJson_KubePodSecurityPolicyListV1Beta1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubePodSecurityPolicyListV1Beta1.GVK,
            ...toJson_KubePodSecurityPolicyListV1Beta1Props(resolved),
        };
    }
}
exports.KubePodSecurityPolicyListV1Beta1 = KubePodSecurityPolicyListV1Beta1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.policy.v1beta1.PodSecurityPolicyList"
 */
KubePodSecurityPolicyListV1Beta1.GVK = {
    apiVersion: 'policy/v1beta1',
    kind: 'PodSecurityPolicyList',
};
/**
 * ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.
 *
 * @schema io.k8s.api.rbac.v1.ClusterRole
 */
class KubeClusterRole extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.rbac.v1.ClusterRole" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeClusterRole.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.rbac.v1.ClusterRole".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeClusterRole.GVK,
            ...toJson_KubeClusterRoleProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeClusterRole.GVK,
            ...toJson_KubeClusterRoleProps(resolved),
        };
    }
}
exports.KubeClusterRole = KubeClusterRole;
/**
 * Returns the apiVersion and kind for "io.k8s.api.rbac.v1.ClusterRole"
 */
KubeClusterRole.GVK = {
    apiVersion: 'rbac.authorization.k8s.io/v1',
    kind: 'ClusterRole',
};
/**
 * ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject.
 *
 * @schema io.k8s.api.rbac.v1.ClusterRoleBinding
 */
class KubeClusterRoleBinding extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.rbac.v1.ClusterRoleBinding" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeClusterRoleBinding.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.rbac.v1.ClusterRoleBinding".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeClusterRoleBinding.GVK,
            ...toJson_KubeClusterRoleBindingProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeClusterRoleBinding.GVK,
            ...toJson_KubeClusterRoleBindingProps(resolved),
        };
    }
}
exports.KubeClusterRoleBinding = KubeClusterRoleBinding;
/**
 * Returns the apiVersion and kind for "io.k8s.api.rbac.v1.ClusterRoleBinding"
 */
KubeClusterRoleBinding.GVK = {
    apiVersion: 'rbac.authorization.k8s.io/v1',
    kind: 'ClusterRoleBinding',
};
/**
 * ClusterRoleBindingList is a collection of ClusterRoleBindings
 *
 * @schema io.k8s.api.rbac.v1.ClusterRoleBindingList
 */
class KubeClusterRoleBindingList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.rbac.v1.ClusterRoleBindingList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeClusterRoleBindingList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.rbac.v1.ClusterRoleBindingList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeClusterRoleBindingList.GVK,
            ...toJson_KubeClusterRoleBindingListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeClusterRoleBindingList.GVK,
            ...toJson_KubeClusterRoleBindingListProps(resolved),
        };
    }
}
exports.KubeClusterRoleBindingList = KubeClusterRoleBindingList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.rbac.v1.ClusterRoleBindingList"
 */
KubeClusterRoleBindingList.GVK = {
    apiVersion: 'rbac.authorization.k8s.io/v1',
    kind: 'ClusterRoleBindingList',
};
/**
 * ClusterRoleList is a collection of ClusterRoles
 *
 * @schema io.k8s.api.rbac.v1.ClusterRoleList
 */
class KubeClusterRoleList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.rbac.v1.ClusterRoleList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeClusterRoleList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.rbac.v1.ClusterRoleList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeClusterRoleList.GVK,
            ...toJson_KubeClusterRoleListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeClusterRoleList.GVK,
            ...toJson_KubeClusterRoleListProps(resolved),
        };
    }
}
exports.KubeClusterRoleList = KubeClusterRoleList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.rbac.v1.ClusterRoleList"
 */
KubeClusterRoleList.GVK = {
    apiVersion: 'rbac.authorization.k8s.io/v1',
    kind: 'ClusterRoleList',
};
/**
 * Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.
 *
 * @schema io.k8s.api.rbac.v1.Role
 */
class KubeRole extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.rbac.v1.Role" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeRole.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.rbac.v1.Role".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeRole.GVK,
            ...toJson_KubeRoleProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeRole.GVK,
            ...toJson_KubeRoleProps(resolved),
        };
    }
}
exports.KubeRole = KubeRole;
/**
 * Returns the apiVersion and kind for "io.k8s.api.rbac.v1.Role"
 */
KubeRole.GVK = {
    apiVersion: 'rbac.authorization.k8s.io/v1',
    kind: 'Role',
};
/**
 * RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace.
 *
 * @schema io.k8s.api.rbac.v1.RoleBinding
 */
class KubeRoleBinding extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.rbac.v1.RoleBinding" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeRoleBinding.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.rbac.v1.RoleBinding".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeRoleBinding.GVK,
            ...toJson_KubeRoleBindingProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeRoleBinding.GVK,
            ...toJson_KubeRoleBindingProps(resolved),
        };
    }
}
exports.KubeRoleBinding = KubeRoleBinding;
/**
 * Returns the apiVersion and kind for "io.k8s.api.rbac.v1.RoleBinding"
 */
KubeRoleBinding.GVK = {
    apiVersion: 'rbac.authorization.k8s.io/v1',
    kind: 'RoleBinding',
};
/**
 * RoleBindingList is a collection of RoleBindings
 *
 * @schema io.k8s.api.rbac.v1.RoleBindingList
 */
class KubeRoleBindingList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.rbac.v1.RoleBindingList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeRoleBindingList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.rbac.v1.RoleBindingList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeRoleBindingList.GVK,
            ...toJson_KubeRoleBindingListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeRoleBindingList.GVK,
            ...toJson_KubeRoleBindingListProps(resolved),
        };
    }
}
exports.KubeRoleBindingList = KubeRoleBindingList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.rbac.v1.RoleBindingList"
 */
KubeRoleBindingList.GVK = {
    apiVersion: 'rbac.authorization.k8s.io/v1',
    kind: 'RoleBindingList',
};
/**
 * RoleList is a collection of Roles
 *
 * @schema io.k8s.api.rbac.v1.RoleList
 */
class KubeRoleList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.rbac.v1.RoleList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeRoleList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.rbac.v1.RoleList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeRoleList.GVK,
            ...toJson_KubeRoleListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeRoleList.GVK,
            ...toJson_KubeRoleListProps(resolved),
        };
    }
}
exports.KubeRoleList = KubeRoleList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.rbac.v1.RoleList"
 */
KubeRoleList.GVK = {
    apiVersion: 'rbac.authorization.k8s.io/v1',
    kind: 'RoleList',
};
/**
 * ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding. Deprecated in v1.17 in favor of rbac.authorization.k8s.io/v1 ClusterRole, and will no longer be served in v1.22.
 *
 * @schema io.k8s.api.rbac.v1alpha1.ClusterRole
 */
class KubeClusterRoleV1Alpha1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.rbac.v1alpha1.ClusterRole" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeClusterRoleV1Alpha1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.rbac.v1alpha1.ClusterRole".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeClusterRoleV1Alpha1.GVK,
            ...toJson_KubeClusterRoleV1Alpha1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeClusterRoleV1Alpha1.GVK,
            ...toJson_KubeClusterRoleV1Alpha1Props(resolved),
        };
    }
}
exports.KubeClusterRoleV1Alpha1 = KubeClusterRoleV1Alpha1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.rbac.v1alpha1.ClusterRole"
 */
KubeClusterRoleV1Alpha1.GVK = {
    apiVersion: 'rbac.authorization.k8s.io/v1alpha1',
    kind: 'ClusterRole',
};
/**
 * ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject. Deprecated in v1.17 in favor of rbac.authorization.k8s.io/v1 ClusterRoleBinding, and will no longer be served in v1.22.
 *
 * @schema io.k8s.api.rbac.v1alpha1.ClusterRoleBinding
 */
class KubeClusterRoleBindingV1Alpha1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.rbac.v1alpha1.ClusterRoleBinding" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeClusterRoleBindingV1Alpha1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.rbac.v1alpha1.ClusterRoleBinding".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeClusterRoleBindingV1Alpha1.GVK,
            ...toJson_KubeClusterRoleBindingV1Alpha1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeClusterRoleBindingV1Alpha1.GVK,
            ...toJson_KubeClusterRoleBindingV1Alpha1Props(resolved),
        };
    }
}
exports.KubeClusterRoleBindingV1Alpha1 = KubeClusterRoleBindingV1Alpha1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.rbac.v1alpha1.ClusterRoleBinding"
 */
KubeClusterRoleBindingV1Alpha1.GVK = {
    apiVersion: 'rbac.authorization.k8s.io/v1alpha1',
    kind: 'ClusterRoleBinding',
};
/**
 * ClusterRoleBindingList is a collection of ClusterRoleBindings. Deprecated in v1.17 in favor of rbac.authorization.k8s.io/v1 ClusterRoleBindings, and will no longer be served in v1.22.
 *
 * @schema io.k8s.api.rbac.v1alpha1.ClusterRoleBindingList
 */
class KubeClusterRoleBindingListV1Alpha1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.rbac.v1alpha1.ClusterRoleBindingList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeClusterRoleBindingListV1Alpha1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.rbac.v1alpha1.ClusterRoleBindingList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeClusterRoleBindingListV1Alpha1.GVK,
            ...toJson_KubeClusterRoleBindingListV1Alpha1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeClusterRoleBindingListV1Alpha1.GVK,
            ...toJson_KubeClusterRoleBindingListV1Alpha1Props(resolved),
        };
    }
}
exports.KubeClusterRoleBindingListV1Alpha1 = KubeClusterRoleBindingListV1Alpha1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.rbac.v1alpha1.ClusterRoleBindingList"
 */
KubeClusterRoleBindingListV1Alpha1.GVK = {
    apiVersion: 'rbac.authorization.k8s.io/v1alpha1',
    kind: 'ClusterRoleBindingList',
};
/**
 * ClusterRoleList is a collection of ClusterRoles. Deprecated in v1.17 in favor of rbac.authorization.k8s.io/v1 ClusterRoles, and will no longer be served in v1.22.
 *
 * @schema io.k8s.api.rbac.v1alpha1.ClusterRoleList
 */
class KubeClusterRoleListV1Alpha1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.rbac.v1alpha1.ClusterRoleList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeClusterRoleListV1Alpha1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.rbac.v1alpha1.ClusterRoleList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeClusterRoleListV1Alpha1.GVK,
            ...toJson_KubeClusterRoleListV1Alpha1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeClusterRoleListV1Alpha1.GVK,
            ...toJson_KubeClusterRoleListV1Alpha1Props(resolved),
        };
    }
}
exports.KubeClusterRoleListV1Alpha1 = KubeClusterRoleListV1Alpha1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.rbac.v1alpha1.ClusterRoleList"
 */
KubeClusterRoleListV1Alpha1.GVK = {
    apiVersion: 'rbac.authorization.k8s.io/v1alpha1',
    kind: 'ClusterRoleList',
};
/**
 * Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding. Deprecated in v1.17 in favor of rbac.authorization.k8s.io/v1 Role, and will no longer be served in v1.22.
 *
 * @schema io.k8s.api.rbac.v1alpha1.Role
 */
class KubeRoleV1Alpha1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.rbac.v1alpha1.Role" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeRoleV1Alpha1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.rbac.v1alpha1.Role".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeRoleV1Alpha1.GVK,
            ...toJson_KubeRoleV1Alpha1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeRoleV1Alpha1.GVK,
            ...toJson_KubeRoleV1Alpha1Props(resolved),
        };
    }
}
exports.KubeRoleV1Alpha1 = KubeRoleV1Alpha1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.rbac.v1alpha1.Role"
 */
KubeRoleV1Alpha1.GVK = {
    apiVersion: 'rbac.authorization.k8s.io/v1alpha1',
    kind: 'Role',
};
/**
 * RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace. Deprecated in v1.17 in favor of rbac.authorization.k8s.io/v1 RoleBinding, and will no longer be served in v1.22.
 *
 * @schema io.k8s.api.rbac.v1alpha1.RoleBinding
 */
class KubeRoleBindingV1Alpha1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.rbac.v1alpha1.RoleBinding" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeRoleBindingV1Alpha1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.rbac.v1alpha1.RoleBinding".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeRoleBindingV1Alpha1.GVK,
            ...toJson_KubeRoleBindingV1Alpha1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeRoleBindingV1Alpha1.GVK,
            ...toJson_KubeRoleBindingV1Alpha1Props(resolved),
        };
    }
}
exports.KubeRoleBindingV1Alpha1 = KubeRoleBindingV1Alpha1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.rbac.v1alpha1.RoleBinding"
 */
KubeRoleBindingV1Alpha1.GVK = {
    apiVersion: 'rbac.authorization.k8s.io/v1alpha1',
    kind: 'RoleBinding',
};
/**
 * RoleBindingList is a collection of RoleBindings Deprecated in v1.17 in favor of rbac.authorization.k8s.io/v1 RoleBindingList, and will no longer be served in v1.22.
 *
 * @schema io.k8s.api.rbac.v1alpha1.RoleBindingList
 */
class KubeRoleBindingListV1Alpha1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.rbac.v1alpha1.RoleBindingList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeRoleBindingListV1Alpha1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.rbac.v1alpha1.RoleBindingList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeRoleBindingListV1Alpha1.GVK,
            ...toJson_KubeRoleBindingListV1Alpha1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeRoleBindingListV1Alpha1.GVK,
            ...toJson_KubeRoleBindingListV1Alpha1Props(resolved),
        };
    }
}
exports.KubeRoleBindingListV1Alpha1 = KubeRoleBindingListV1Alpha1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.rbac.v1alpha1.RoleBindingList"
 */
KubeRoleBindingListV1Alpha1.GVK = {
    apiVersion: 'rbac.authorization.k8s.io/v1alpha1',
    kind: 'RoleBindingList',
};
/**
 * RoleList is a collection of Roles. Deprecated in v1.17 in favor of rbac.authorization.k8s.io/v1 RoleList, and will no longer be served in v1.22.
 *
 * @schema io.k8s.api.rbac.v1alpha1.RoleList
 */
class KubeRoleListV1Alpha1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.rbac.v1alpha1.RoleList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeRoleListV1Alpha1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.rbac.v1alpha1.RoleList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeRoleListV1Alpha1.GVK,
            ...toJson_KubeRoleListV1Alpha1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeRoleListV1Alpha1.GVK,
            ...toJson_KubeRoleListV1Alpha1Props(resolved),
        };
    }
}
exports.KubeRoleListV1Alpha1 = KubeRoleListV1Alpha1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.rbac.v1alpha1.RoleList"
 */
KubeRoleListV1Alpha1.GVK = {
    apiVersion: 'rbac.authorization.k8s.io/v1alpha1',
    kind: 'RoleList',
};
/**
 * PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer.
 *
 * @schema io.k8s.api.scheduling.v1.PriorityClass
 */
class KubePriorityClass extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.scheduling.v1.PriorityClass" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubePriorityClass.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.scheduling.v1.PriorityClass".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubePriorityClass.GVK,
            ...toJson_KubePriorityClassProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubePriorityClass.GVK,
            ...toJson_KubePriorityClassProps(resolved),
        };
    }
}
exports.KubePriorityClass = KubePriorityClass;
/**
 * Returns the apiVersion and kind for "io.k8s.api.scheduling.v1.PriorityClass"
 */
KubePriorityClass.GVK = {
    apiVersion: 'scheduling.k8s.io/v1',
    kind: 'PriorityClass',
};
/**
 * PriorityClassList is a collection of priority classes.
 *
 * @schema io.k8s.api.scheduling.v1.PriorityClassList
 */
class KubePriorityClassList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.scheduling.v1.PriorityClassList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubePriorityClassList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.scheduling.v1.PriorityClassList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubePriorityClassList.GVK,
            ...toJson_KubePriorityClassListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubePriorityClassList.GVK,
            ...toJson_KubePriorityClassListProps(resolved),
        };
    }
}
exports.KubePriorityClassList = KubePriorityClassList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.scheduling.v1.PriorityClassList"
 */
KubePriorityClassList.GVK = {
    apiVersion: 'scheduling.k8s.io/v1',
    kind: 'PriorityClassList',
};
/**
 * DEPRECATED - This group version of PriorityClass is deprecated by scheduling.k8s.io/v1/PriorityClass. PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer.
 *
 * @schema io.k8s.api.scheduling.v1alpha1.PriorityClass
 */
class KubePriorityClassV1Alpha1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.scheduling.v1alpha1.PriorityClass" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubePriorityClassV1Alpha1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.scheduling.v1alpha1.PriorityClass".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubePriorityClassV1Alpha1.GVK,
            ...toJson_KubePriorityClassV1Alpha1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubePriorityClassV1Alpha1.GVK,
            ...toJson_KubePriorityClassV1Alpha1Props(resolved),
        };
    }
}
exports.KubePriorityClassV1Alpha1 = KubePriorityClassV1Alpha1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.scheduling.v1alpha1.PriorityClass"
 */
KubePriorityClassV1Alpha1.GVK = {
    apiVersion: 'scheduling.k8s.io/v1alpha1',
    kind: 'PriorityClass',
};
/**
 * PriorityClassList is a collection of priority classes.
 *
 * @schema io.k8s.api.scheduling.v1alpha1.PriorityClassList
 */
class KubePriorityClassListV1Alpha1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.scheduling.v1alpha1.PriorityClassList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubePriorityClassListV1Alpha1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.scheduling.v1alpha1.PriorityClassList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubePriorityClassListV1Alpha1.GVK,
            ...toJson_KubePriorityClassListV1Alpha1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubePriorityClassListV1Alpha1.GVK,
            ...toJson_KubePriorityClassListV1Alpha1Props(resolved),
        };
    }
}
exports.KubePriorityClassListV1Alpha1 = KubePriorityClassListV1Alpha1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.scheduling.v1alpha1.PriorityClassList"
 */
KubePriorityClassListV1Alpha1.GVK = {
    apiVersion: 'scheduling.k8s.io/v1alpha1',
    kind: 'PriorityClassList',
};
/**
 * CSIDriver captures information about a Container Storage Interface (CSI) volume driver deployed on the cluster. Kubernetes attach detach controller uses this object to determine whether attach is required. Kubelet uses this object to determine whether pod information needs to be passed on mount. CSIDriver objects are non-namespaced.
 *
 * @schema io.k8s.api.storage.v1.CSIDriver
 */
class KubeCsiDriver extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.storage.v1.CSIDriver" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeCsiDriver.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.storage.v1.CSIDriver".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeCsiDriver.GVK,
            ...toJson_KubeCsiDriverProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeCsiDriver.GVK,
            ...toJson_KubeCsiDriverProps(resolved),
        };
    }
}
exports.KubeCsiDriver = KubeCsiDriver;
/**
 * Returns the apiVersion and kind for "io.k8s.api.storage.v1.CSIDriver"
 */
KubeCsiDriver.GVK = {
    apiVersion: 'storage.k8s.io/v1',
    kind: 'CSIDriver',
};
/**
 * CSIDriverList is a collection of CSIDriver objects.
 *
 * @schema io.k8s.api.storage.v1.CSIDriverList
 */
class KubeCsiDriverList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.storage.v1.CSIDriverList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeCsiDriverList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.storage.v1.CSIDriverList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeCsiDriverList.GVK,
            ...toJson_KubeCsiDriverListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeCsiDriverList.GVK,
            ...toJson_KubeCsiDriverListProps(resolved),
        };
    }
}
exports.KubeCsiDriverList = KubeCsiDriverList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.storage.v1.CSIDriverList"
 */
KubeCsiDriverList.GVK = {
    apiVersion: 'storage.k8s.io/v1',
    kind: 'CSIDriverList',
};
/**
 * CSINode holds information about all CSI drivers installed on a node. CSI drivers do not need to create the CSINode object directly. As long as they use the node-driver-registrar sidecar container, the kubelet will automatically populate the CSINode object for the CSI driver as part of kubelet plugin registration. CSINode has the same name as a node. If the object is missing, it means either there are no CSI Drivers available on the node, or the Kubelet version is low enough that it doesn't create this object. CSINode has an OwnerReference that points to the corresponding node object.
 *
 * @schema io.k8s.api.storage.v1.CSINode
 */
class KubeCsiNode extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.storage.v1.CSINode" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeCsiNode.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.storage.v1.CSINode".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeCsiNode.GVK,
            ...toJson_KubeCsiNodeProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeCsiNode.GVK,
            ...toJson_KubeCsiNodeProps(resolved),
        };
    }
}
exports.KubeCsiNode = KubeCsiNode;
/**
 * Returns the apiVersion and kind for "io.k8s.api.storage.v1.CSINode"
 */
KubeCsiNode.GVK = {
    apiVersion: 'storage.k8s.io/v1',
    kind: 'CSINode',
};
/**
 * CSINodeList is a collection of CSINode objects.
 *
 * @schema io.k8s.api.storage.v1.CSINodeList
 */
class KubeCsiNodeList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.storage.v1.CSINodeList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeCsiNodeList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.storage.v1.CSINodeList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeCsiNodeList.GVK,
            ...toJson_KubeCsiNodeListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeCsiNodeList.GVK,
            ...toJson_KubeCsiNodeListProps(resolved),
        };
    }
}
exports.KubeCsiNodeList = KubeCsiNodeList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.storage.v1.CSINodeList"
 */
KubeCsiNodeList.GVK = {
    apiVersion: 'storage.k8s.io/v1',
    kind: 'CSINodeList',
};
/**
 * StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.

StorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name.
 *
 * @schema io.k8s.api.storage.v1.StorageClass
 */
class KubeStorageClass extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.storage.v1.StorageClass" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeStorageClass.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.storage.v1.StorageClass".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeStorageClass.GVK,
            ...toJson_KubeStorageClassProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeStorageClass.GVK,
            ...toJson_KubeStorageClassProps(resolved),
        };
    }
}
exports.KubeStorageClass = KubeStorageClass;
/**
 * Returns the apiVersion and kind for "io.k8s.api.storage.v1.StorageClass"
 */
KubeStorageClass.GVK = {
    apiVersion: 'storage.k8s.io/v1',
    kind: 'StorageClass',
};
/**
 * StorageClassList is a collection of storage classes.
 *
 * @schema io.k8s.api.storage.v1.StorageClassList
 */
class KubeStorageClassList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.storage.v1.StorageClassList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeStorageClassList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.storage.v1.StorageClassList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeStorageClassList.GVK,
            ...toJson_KubeStorageClassListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeStorageClassList.GVK,
            ...toJson_KubeStorageClassListProps(resolved),
        };
    }
}
exports.KubeStorageClassList = KubeStorageClassList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.storage.v1.StorageClassList"
 */
KubeStorageClassList.GVK = {
    apiVersion: 'storage.k8s.io/v1',
    kind: 'StorageClassList',
};
/**
 * VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.

VolumeAttachment objects are non-namespaced.
 *
 * @schema io.k8s.api.storage.v1.VolumeAttachment
 */
class KubeVolumeAttachment extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.storage.v1.VolumeAttachment" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeVolumeAttachment.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.storage.v1.VolumeAttachment".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeVolumeAttachment.GVK,
            ...toJson_KubeVolumeAttachmentProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeVolumeAttachment.GVK,
            ...toJson_KubeVolumeAttachmentProps(resolved),
        };
    }
}
exports.KubeVolumeAttachment = KubeVolumeAttachment;
/**
 * Returns the apiVersion and kind for "io.k8s.api.storage.v1.VolumeAttachment"
 */
KubeVolumeAttachment.GVK = {
    apiVersion: 'storage.k8s.io/v1',
    kind: 'VolumeAttachment',
};
/**
 * VolumeAttachmentList is a collection of VolumeAttachment objects.
 *
 * @schema io.k8s.api.storage.v1.VolumeAttachmentList
 */
class KubeVolumeAttachmentList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.storage.v1.VolumeAttachmentList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeVolumeAttachmentList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.storage.v1.VolumeAttachmentList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeVolumeAttachmentList.GVK,
            ...toJson_KubeVolumeAttachmentListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeVolumeAttachmentList.GVK,
            ...toJson_KubeVolumeAttachmentListProps(resolved),
        };
    }
}
exports.KubeVolumeAttachmentList = KubeVolumeAttachmentList;
/**
 * Returns the apiVersion and kind for "io.k8s.api.storage.v1.VolumeAttachmentList"
 */
KubeVolumeAttachmentList.GVK = {
    apiVersion: 'storage.k8s.io/v1',
    kind: 'VolumeAttachmentList',
};
/**
 * CSIStorageCapacity stores the result of one CSI GetCapacity call. For a given StorageClass, this describes the available capacity in a particular topology segment.  This can be used when considering where to instantiate new PersistentVolumes.

For example this can express things like: - StorageClass "standard" has "1234 GiB" available in "topology.kubernetes.io/zone=us-east1" - StorageClass "localssd" has "10 GiB" available in "kubernetes.io/hostname=knode-abc123"

The following three cases all imply that no capacity is available for a certain combination: - no object exists with suitable topology and storage class name - such an object exists, but the capacity is unset - such an object exists, but the capacity is zero

The producer of these objects can decide which approach is more suitable.

They are consumed by the kube-scheduler if the CSIStorageCapacity beta feature gate is enabled there and a CSI driver opts into capacity-aware scheduling with CSIDriver.StorageCapacity.
 *
 * @schema io.k8s.api.storage.v1alpha1.CSIStorageCapacity
 */
class KubeCsiStorageCapacityV1Alpha1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.storage.v1alpha1.CSIStorageCapacity" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeCsiStorageCapacityV1Alpha1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.storage.v1alpha1.CSIStorageCapacity".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeCsiStorageCapacityV1Alpha1.GVK,
            ...toJson_KubeCsiStorageCapacityV1Alpha1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeCsiStorageCapacityV1Alpha1.GVK,
            ...toJson_KubeCsiStorageCapacityV1Alpha1Props(resolved),
        };
    }
}
exports.KubeCsiStorageCapacityV1Alpha1 = KubeCsiStorageCapacityV1Alpha1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.storage.v1alpha1.CSIStorageCapacity"
 */
KubeCsiStorageCapacityV1Alpha1.GVK = {
    apiVersion: 'storage.k8s.io/v1alpha1',
    kind: 'CSIStorageCapacity',
};
/**
 * CSIStorageCapacityList is a collection of CSIStorageCapacity objects.
 *
 * @schema io.k8s.api.storage.v1alpha1.CSIStorageCapacityList
 */
class KubeCsiStorageCapacityListV1Alpha1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.storage.v1alpha1.CSIStorageCapacityList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeCsiStorageCapacityListV1Alpha1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.storage.v1alpha1.CSIStorageCapacityList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeCsiStorageCapacityListV1Alpha1.GVK,
            ...toJson_KubeCsiStorageCapacityListV1Alpha1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeCsiStorageCapacityListV1Alpha1.GVK,
            ...toJson_KubeCsiStorageCapacityListV1Alpha1Props(resolved),
        };
    }
}
exports.KubeCsiStorageCapacityListV1Alpha1 = KubeCsiStorageCapacityListV1Alpha1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.storage.v1alpha1.CSIStorageCapacityList"
 */
KubeCsiStorageCapacityListV1Alpha1.GVK = {
    apiVersion: 'storage.k8s.io/v1alpha1',
    kind: 'CSIStorageCapacityList',
};
/**
 * VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.

VolumeAttachment objects are non-namespaced.
 *
 * @schema io.k8s.api.storage.v1alpha1.VolumeAttachment
 */
class KubeVolumeAttachmentV1Alpha1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.storage.v1alpha1.VolumeAttachment" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeVolumeAttachmentV1Alpha1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.storage.v1alpha1.VolumeAttachment".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeVolumeAttachmentV1Alpha1.GVK,
            ...toJson_KubeVolumeAttachmentV1Alpha1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeVolumeAttachmentV1Alpha1.GVK,
            ...toJson_KubeVolumeAttachmentV1Alpha1Props(resolved),
        };
    }
}
exports.KubeVolumeAttachmentV1Alpha1 = KubeVolumeAttachmentV1Alpha1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.storage.v1alpha1.VolumeAttachment"
 */
KubeVolumeAttachmentV1Alpha1.GVK = {
    apiVersion: 'storage.k8s.io/v1alpha1',
    kind: 'VolumeAttachment',
};
/**
 * VolumeAttachmentList is a collection of VolumeAttachment objects.
 *
 * @schema io.k8s.api.storage.v1alpha1.VolumeAttachmentList
 */
class KubeVolumeAttachmentListV1Alpha1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.storage.v1alpha1.VolumeAttachmentList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeVolumeAttachmentListV1Alpha1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.storage.v1alpha1.VolumeAttachmentList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeVolumeAttachmentListV1Alpha1.GVK,
            ...toJson_KubeVolumeAttachmentListV1Alpha1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeVolumeAttachmentListV1Alpha1.GVK,
            ...toJson_KubeVolumeAttachmentListV1Alpha1Props(resolved),
        };
    }
}
exports.KubeVolumeAttachmentListV1Alpha1 = KubeVolumeAttachmentListV1Alpha1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.storage.v1alpha1.VolumeAttachmentList"
 */
KubeVolumeAttachmentListV1Alpha1.GVK = {
    apiVersion: 'storage.k8s.io/v1alpha1',
    kind: 'VolumeAttachmentList',
};
/**
 * CSIStorageCapacity stores the result of one CSI GetCapacity call. For a given StorageClass, this describes the available capacity in a particular topology segment.  This can be used when considering where to instantiate new PersistentVolumes.

For example this can express things like: - StorageClass "standard" has "1234 GiB" available in "topology.kubernetes.io/zone=us-east1" - StorageClass "localssd" has "10 GiB" available in "kubernetes.io/hostname=knode-abc123"

The following three cases all imply that no capacity is available for a certain combination: - no object exists with suitable topology and storage class name - such an object exists, but the capacity is unset - such an object exists, but the capacity is zero

The producer of these objects can decide which approach is more suitable.

They are consumed by the kube-scheduler if the CSIStorageCapacity beta feature gate is enabled there and a CSI driver opts into capacity-aware scheduling with CSIDriver.StorageCapacity.
 *
 * @schema io.k8s.api.storage.v1beta1.CSIStorageCapacity
 */
class KubeCsiStorageCapacityV1Beta1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.storage.v1beta1.CSIStorageCapacity" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeCsiStorageCapacityV1Beta1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.storage.v1beta1.CSIStorageCapacity".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeCsiStorageCapacityV1Beta1.GVK,
            ...toJson_KubeCsiStorageCapacityV1Beta1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeCsiStorageCapacityV1Beta1.GVK,
            ...toJson_KubeCsiStorageCapacityV1Beta1Props(resolved),
        };
    }
}
exports.KubeCsiStorageCapacityV1Beta1 = KubeCsiStorageCapacityV1Beta1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.storage.v1beta1.CSIStorageCapacity"
 */
KubeCsiStorageCapacityV1Beta1.GVK = {
    apiVersion: 'storage.k8s.io/v1beta1',
    kind: 'CSIStorageCapacity',
};
/**
 * CSIStorageCapacityList is a collection of CSIStorageCapacity objects.
 *
 * @schema io.k8s.api.storage.v1beta1.CSIStorageCapacityList
 */
class KubeCsiStorageCapacityListV1Beta1 extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.api.storage.v1beta1.CSIStorageCapacityList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeCsiStorageCapacityListV1Beta1.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.api.storage.v1beta1.CSIStorageCapacityList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeCsiStorageCapacityListV1Beta1.GVK,
            ...toJson_KubeCsiStorageCapacityListV1Beta1Props(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeCsiStorageCapacityListV1Beta1.GVK,
            ...toJson_KubeCsiStorageCapacityListV1Beta1Props(resolved),
        };
    }
}
exports.KubeCsiStorageCapacityListV1Beta1 = KubeCsiStorageCapacityListV1Beta1;
/**
 * Returns the apiVersion and kind for "io.k8s.api.storage.v1beta1.CSIStorageCapacityList"
 */
KubeCsiStorageCapacityListV1Beta1.GVK = {
    apiVersion: 'storage.k8s.io/v1beta1',
    kind: 'CSIStorageCapacityList',
};
/**
 * CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>.
 *
 * @schema io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinition
 */
class KubeCustomResourceDefinition extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinition" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeCustomResourceDefinition.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinition".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeCustomResourceDefinition.GVK,
            ...toJson_KubeCustomResourceDefinitionProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeCustomResourceDefinition.GVK,
            ...toJson_KubeCustomResourceDefinitionProps(resolved),
        };
    }
}
exports.KubeCustomResourceDefinition = KubeCustomResourceDefinition;
/**
 * Returns the apiVersion and kind for "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinition"
 */
KubeCustomResourceDefinition.GVK = {
    apiVersion: 'apiextensions.k8s.io/v1',
    kind: 'CustomResourceDefinition',
};
/**
 * CustomResourceDefinitionList is a list of CustomResourceDefinition objects.
 *
 * @schema io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionList
 */
class KubeCustomResourceDefinitionList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeCustomResourceDefinitionList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeCustomResourceDefinitionList.GVK,
            ...toJson_KubeCustomResourceDefinitionListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeCustomResourceDefinitionList.GVK,
            ...toJson_KubeCustomResourceDefinitionListProps(resolved),
        };
    }
}
exports.KubeCustomResourceDefinitionList = KubeCustomResourceDefinitionList;
/**
 * Returns the apiVersion and kind for "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionList"
 */
KubeCustomResourceDefinitionList.GVK = {
    apiVersion: 'apiextensions.k8s.io/v1',
    kind: 'CustomResourceDefinitionList',
};
/**
 * Status is a return value for calls that don't return other objects.
 *
 * @schema io.k8s.apimachinery.pkg.apis.meta.v1.Status
 */
class KubeStatus extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.apimachinery.pkg.apis.meta.v1.Status" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeStatus.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.apimachinery.pkg.apis.meta.v1.Status".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeStatus.GVK,
            ...toJson_KubeStatusProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeStatus.GVK,
            ...toJson_KubeStatusProps(resolved),
        };
    }
}
exports.KubeStatus = KubeStatus;
/**
 * Returns the apiVersion and kind for "io.k8s.apimachinery.pkg.apis.meta.v1.Status"
 */
KubeStatus.GVK = {
    apiVersion: 'v1',
    kind: 'Status',
};
/**
 * APIService represents a server for a particular GroupVersion. Name must be "version.group".
 *
 * @schema io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIService
 */
class KubeApiService extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIService" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...KubeApiService.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIService".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...KubeApiService.GVK,
            ...toJson_KubeApiServiceProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeApiService.GVK,
            ...toJson_KubeApiServiceProps(resolved),
        };
    }
}
exports.KubeApiService = KubeApiService;
/**
 * Returns the apiVersion and kind for "io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIService"
 */
KubeApiService.GVK = {
    apiVersion: 'apiregistration.k8s.io/v1',
    kind: 'APIService',
};
/**
 * APIServiceList is a list of APIService objects.
 *
 * @schema io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIServiceList
 */
class KubeApiServiceList extends cdk8s_1.ApiObject {
    /**
     * Defines a "io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIServiceList" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...KubeApiServiceList.GVK,
            ...props,
        });
    }
    /**
     * Renders a Kubernetes manifest for "io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIServiceList".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...KubeApiServiceList.GVK,
            ...toJson_KubeApiServiceListProps(props),
        };
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...KubeApiServiceList.GVK,
            ...toJson_KubeApiServiceListProps(resolved),
        };
    }
}
exports.KubeApiServiceList = KubeApiServiceList;
/**
 * Returns the apiVersion and kind for "io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIServiceList"
 */
KubeApiServiceList.GVK = {
    apiVersion: 'apiregistration.k8s.io/v1',
    kind: 'APIServiceList',
};
/**
 * Converts an object of type 'KubeMutatingWebhookConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeMutatingWebhookConfigurationProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'webhooks': (_a = obj.webhooks) === null || _a === void 0 ? void 0 : _a.map(y => toJson_MutatingWebhook(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeMutatingWebhookConfigurationProps = toJson_KubeMutatingWebhookConfigurationProps;
/**
 * Converts an object of type 'KubeMutatingWebhookConfigurationListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeMutatingWebhookConfigurationListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeMutatingWebhookConfigurationProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeMutatingWebhookConfigurationListProps = toJson_KubeMutatingWebhookConfigurationListProps;
/**
 * Converts an object of type 'KubeValidatingWebhookConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeValidatingWebhookConfigurationProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'webhooks': (_a = obj.webhooks) === null || _a === void 0 ? void 0 : _a.map(y => toJson_ValidatingWebhook(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeValidatingWebhookConfigurationProps = toJson_KubeValidatingWebhookConfigurationProps;
/**
 * Converts an object of type 'KubeValidatingWebhookConfigurationListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeValidatingWebhookConfigurationListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeValidatingWebhookConfigurationProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeValidatingWebhookConfigurationListProps = toJson_KubeValidatingWebhookConfigurationListProps;
/**
 * Converts an object of type 'KubeStorageVersionV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeStorageVersionV1Alpha1Props(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': obj.spec,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeStorageVersionV1Alpha1Props = toJson_KubeStorageVersionV1Alpha1Props;
/**
 * Converts an object of type 'KubeStorageVersionListV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeStorageVersionListV1Alpha1Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeStorageVersionV1Alpha1Props(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeStorageVersionListV1Alpha1Props = toJson_KubeStorageVersionListV1Alpha1Props;
/**
 * Converts an object of type 'KubeControllerRevisionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeControllerRevisionProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'data': obj.data,
        'metadata': toJson_ObjectMeta(obj.metadata),
        'revision': obj.revision,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeControllerRevisionProps = toJson_KubeControllerRevisionProps;
/**
 * Converts an object of type 'KubeControllerRevisionListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeControllerRevisionListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeControllerRevisionProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeControllerRevisionListProps = toJson_KubeControllerRevisionListProps;
/**
 * Converts an object of type 'KubeDaemonSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeDaemonSetProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_DaemonSetSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeDaemonSetProps = toJson_KubeDaemonSetProps;
/**
 * Converts an object of type 'KubeDaemonSetListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeDaemonSetListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeDaemonSetProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeDaemonSetListProps = toJson_KubeDaemonSetListProps;
/**
 * Converts an object of type 'KubeDeploymentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeDeploymentProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_DeploymentSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeDeploymentProps = toJson_KubeDeploymentProps;
/**
 * Converts an object of type 'KubeDeploymentListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeDeploymentListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeDeploymentProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeDeploymentListProps = toJson_KubeDeploymentListProps;
/**
 * Converts an object of type 'KubeReplicaSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeReplicaSetProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_ReplicaSetSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeReplicaSetProps = toJson_KubeReplicaSetProps;
/**
 * Converts an object of type 'KubeReplicaSetListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeReplicaSetListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeReplicaSetProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeReplicaSetListProps = toJson_KubeReplicaSetListProps;
/**
 * Converts an object of type 'KubeStatefulSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeStatefulSetProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_StatefulSetSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeStatefulSetProps = toJson_KubeStatefulSetProps;
/**
 * Converts an object of type 'KubeStatefulSetListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeStatefulSetListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeStatefulSetProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeStatefulSetListProps = toJson_KubeStatefulSetListProps;
/**
 * Converts an object of type 'KubeTokenRequestProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeTokenRequestProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_TokenRequestSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeTokenRequestProps = toJson_KubeTokenRequestProps;
/**
 * Converts an object of type 'KubeTokenReviewProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeTokenReviewProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_TokenReviewSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeTokenReviewProps = toJson_KubeTokenReviewProps;
/**
 * Converts an object of type 'KubeLocalSubjectAccessReviewProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeLocalSubjectAccessReviewProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_SubjectAccessReviewSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeLocalSubjectAccessReviewProps = toJson_KubeLocalSubjectAccessReviewProps;
/**
 * Converts an object of type 'KubeSelfSubjectAccessReviewProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeSelfSubjectAccessReviewProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_SelfSubjectAccessReviewSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeSelfSubjectAccessReviewProps = toJson_KubeSelfSubjectAccessReviewProps;
/**
 * Converts an object of type 'KubeSelfSubjectRulesReviewProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeSelfSubjectRulesReviewProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_SelfSubjectRulesReviewSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeSelfSubjectRulesReviewProps = toJson_KubeSelfSubjectRulesReviewProps;
/**
 * Converts an object of type 'KubeSubjectAccessReviewProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeSubjectAccessReviewProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_SubjectAccessReviewSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeSubjectAccessReviewProps = toJson_KubeSubjectAccessReviewProps;
/**
 * Converts an object of type 'KubeHorizontalPodAutoscalerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeHorizontalPodAutoscalerProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_HorizontalPodAutoscalerSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeHorizontalPodAutoscalerProps = toJson_KubeHorizontalPodAutoscalerProps;
/**
 * Converts an object of type 'KubeHorizontalPodAutoscalerListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeHorizontalPodAutoscalerListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeHorizontalPodAutoscalerProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeHorizontalPodAutoscalerListProps = toJson_KubeHorizontalPodAutoscalerListProps;
/**
 * Converts an object of type 'KubeScaleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeScaleProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_ScaleSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeScaleProps = toJson_KubeScaleProps;
/**
 * Converts an object of type 'KubeHorizontalPodAutoscalerV2Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeHorizontalPodAutoscalerV2Beta1Props(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_HorizontalPodAutoscalerSpecV2Beta1(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeHorizontalPodAutoscalerV2Beta1Props = toJson_KubeHorizontalPodAutoscalerV2Beta1Props;
/**
 * Converts an object of type 'KubeHorizontalPodAutoscalerListV2Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeHorizontalPodAutoscalerListV2Beta1Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeHorizontalPodAutoscalerV2Beta1Props(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeHorizontalPodAutoscalerListV2Beta1Props = toJson_KubeHorizontalPodAutoscalerListV2Beta1Props;
/**
 * Converts an object of type 'KubeHorizontalPodAutoscalerV2Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeHorizontalPodAutoscalerV2Beta2Props(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_HorizontalPodAutoscalerSpecV2Beta2(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeHorizontalPodAutoscalerV2Beta2Props = toJson_KubeHorizontalPodAutoscalerV2Beta2Props;
/**
 * Converts an object of type 'KubeHorizontalPodAutoscalerListV2Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeHorizontalPodAutoscalerListV2Beta2Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeHorizontalPodAutoscalerV2Beta2Props(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeHorizontalPodAutoscalerListV2Beta2Props = toJson_KubeHorizontalPodAutoscalerListV2Beta2Props;
/**
 * Converts an object of type 'KubeCronJobProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeCronJobProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_CronJobSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeCronJobProps = toJson_KubeCronJobProps;
/**
 * Converts an object of type 'KubeCronJobListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeCronJobListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeCronJobProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeCronJobListProps = toJson_KubeCronJobListProps;
/**
 * Converts an object of type 'KubeJobProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeJobProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_JobSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeJobProps = toJson_KubeJobProps;
/**
 * Converts an object of type 'KubeJobListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeJobListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeJobProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeJobListProps = toJson_KubeJobListProps;
/**
 * Converts an object of type 'KubeCronJobV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeCronJobV1Beta1Props(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_CronJobSpecV1Beta1(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeCronJobV1Beta1Props = toJson_KubeCronJobV1Beta1Props;
/**
 * Converts an object of type 'KubeCronJobListV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeCronJobListV1Beta1Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeCronJobV1Beta1Props(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeCronJobListV1Beta1Props = toJson_KubeCronJobListV1Beta1Props;
/**
 * Converts an object of type 'KubeCertificateSigningRequestProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeCertificateSigningRequestProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_CertificateSigningRequestSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeCertificateSigningRequestProps = toJson_KubeCertificateSigningRequestProps;
/**
 * Converts an object of type 'KubeCertificateSigningRequestListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeCertificateSigningRequestListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeCertificateSigningRequestProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeCertificateSigningRequestListProps = toJson_KubeCertificateSigningRequestListProps;
/**
 * Converts an object of type 'KubeLeaseProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeLeaseProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_LeaseSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeLeaseProps = toJson_KubeLeaseProps;
/**
 * Converts an object of type 'KubeLeaseListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeLeaseListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeLeaseProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeLeaseListProps = toJson_KubeLeaseListProps;
/**
 * Converts an object of type 'KubeBindingProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeBindingProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'target': toJson_ObjectReference(obj.target),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeBindingProps = toJson_KubeBindingProps;
/**
 * Converts an object of type 'KubeComponentStatusProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeComponentStatusProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'conditions': (_a = obj.conditions) === null || _a === void 0 ? void 0 : _a.map(y => toJson_ComponentCondition(y)),
        'metadata': toJson_ObjectMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeComponentStatusProps = toJson_KubeComponentStatusProps;
/**
 * Converts an object of type 'KubeComponentStatusListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeComponentStatusListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeComponentStatusProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeComponentStatusListProps = toJson_KubeComponentStatusListProps;
/**
 * Converts an object of type 'KubeConfigMapProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeConfigMapProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'binaryData': ((obj.binaryData) === undefined) ? undefined : (Object.entries(obj.binaryData).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'data': ((obj.data) === undefined) ? undefined : (Object.entries(obj.data).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'immutable': obj.immutable,
        'metadata': toJson_ObjectMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeConfigMapProps = toJson_KubeConfigMapProps;
/**
 * Converts an object of type 'KubeConfigMapListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeConfigMapListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeConfigMapProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeConfigMapListProps = toJson_KubeConfigMapListProps;
/**
 * Converts an object of type 'KubeEndpointsProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeEndpointsProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'subsets': (_a = obj.subsets) === null || _a === void 0 ? void 0 : _a.map(y => toJson_EndpointSubset(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeEndpointsProps = toJson_KubeEndpointsProps;
/**
 * Converts an object of type 'KubeEndpointsListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeEndpointsListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeEndpointsProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeEndpointsListProps = toJson_KubeEndpointsListProps;
/**
 * Converts an object of type 'KubeEventProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeEventProps(obj) {
    var _a, _b, _c;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'action': obj.action,
        'deprecatedCount': obj.deprecatedCount,
        'deprecatedFirstTimestamp': (_a = obj.deprecatedFirstTimestamp) === null || _a === void 0 ? void 0 : _a.toISOString(),
        'deprecatedLastTimestamp': (_b = obj.deprecatedLastTimestamp) === null || _b === void 0 ? void 0 : _b.toISOString(),
        'deprecatedSource': toJson_EventSource(obj.deprecatedSource),
        'eventTime': (_c = obj.eventTime) === null || _c === void 0 ? void 0 : _c.toISOString(),
        'metadata': toJson_ObjectMeta(obj.metadata),
        'note': obj.note,
        'reason': obj.reason,
        'regarding': toJson_ObjectReference(obj.regarding),
        'related': toJson_ObjectReference(obj.related),
        'reportingController': obj.reportingController,
        'reportingInstance': obj.reportingInstance,
        'series': toJson_EventSeries(obj.series),
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeEventProps = toJson_KubeEventProps;
/**
 * Converts an object of type 'KubeEventListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeEventListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeEventProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeEventListProps = toJson_KubeEventListProps;
/**
 * Converts an object of type 'KubeLimitRangeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeLimitRangeProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_LimitRangeSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeLimitRangeProps = toJson_KubeLimitRangeProps;
/**
 * Converts an object of type 'KubeLimitRangeListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeLimitRangeListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeLimitRangeProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeLimitRangeListProps = toJson_KubeLimitRangeListProps;
/**
 * Converts an object of type 'KubeNamespaceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeNamespaceProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_NamespaceSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeNamespaceProps = toJson_KubeNamespaceProps;
/**
 * Converts an object of type 'KubeNamespaceListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeNamespaceListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeNamespaceProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeNamespaceListProps = toJson_KubeNamespaceListProps;
/**
 * Converts an object of type 'KubeNodeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeNodeProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_NodeSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeNodeProps = toJson_KubeNodeProps;
/**
 * Converts an object of type 'KubeNodeListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeNodeListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeNodeProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeNodeListProps = toJson_KubeNodeListProps;
/**
 * Converts an object of type 'KubePersistentVolumeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubePersistentVolumeProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_PersistentVolumeSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubePersistentVolumeProps = toJson_KubePersistentVolumeProps;
/**
 * Converts an object of type 'KubePersistentVolumeClaimProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubePersistentVolumeClaimProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_PersistentVolumeClaimSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubePersistentVolumeClaimProps = toJson_KubePersistentVolumeClaimProps;
/**
 * Converts an object of type 'KubePersistentVolumeClaimListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubePersistentVolumeClaimListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubePersistentVolumeClaimProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubePersistentVolumeClaimListProps = toJson_KubePersistentVolumeClaimListProps;
/**
 * Converts an object of type 'KubePersistentVolumeListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubePersistentVolumeListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubePersistentVolumeProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubePersistentVolumeListProps = toJson_KubePersistentVolumeListProps;
/**
 * Converts an object of type 'KubePodProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubePodProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_PodSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubePodProps = toJson_KubePodProps;
/**
 * Converts an object of type 'KubePodListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubePodListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubePodProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubePodListProps = toJson_KubePodListProps;
/**
 * Converts an object of type 'KubePodTemplateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubePodTemplateProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'template': toJson_PodTemplateSpec(obj.template),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubePodTemplateProps = toJson_KubePodTemplateProps;
/**
 * Converts an object of type 'KubePodTemplateListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubePodTemplateListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubePodTemplateProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubePodTemplateListProps = toJson_KubePodTemplateListProps;
/**
 * Converts an object of type 'KubeReplicationControllerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeReplicationControllerProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_ReplicationControllerSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeReplicationControllerProps = toJson_KubeReplicationControllerProps;
/**
 * Converts an object of type 'KubeReplicationControllerListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeReplicationControllerListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeReplicationControllerProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeReplicationControllerListProps = toJson_KubeReplicationControllerListProps;
/**
 * Converts an object of type 'KubeResourceQuotaProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeResourceQuotaProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_ResourceQuotaSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeResourceQuotaProps = toJson_KubeResourceQuotaProps;
/**
 * Converts an object of type 'KubeResourceQuotaListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeResourceQuotaListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeResourceQuotaProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeResourceQuotaListProps = toJson_KubeResourceQuotaListProps;
/**
 * Converts an object of type 'KubeSecretProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeSecretProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'data': ((obj.data) === undefined) ? undefined : (Object.entries(obj.data).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'immutable': obj.immutable,
        'metadata': toJson_ObjectMeta(obj.metadata),
        'stringData': ((obj.stringData) === undefined) ? undefined : (Object.entries(obj.stringData).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeSecretProps = toJson_KubeSecretProps;
/**
 * Converts an object of type 'KubeSecretListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeSecretListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeSecretProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeSecretListProps = toJson_KubeSecretListProps;
/**
 * Converts an object of type 'KubeServiceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeServiceProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_ServiceSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeServiceProps = toJson_KubeServiceProps;
/**
 * Converts an object of type 'KubeServiceAccountProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeServiceAccountProps(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'automountServiceAccountToken': obj.automountServiceAccountToken,
        'imagePullSecrets': (_a = obj.imagePullSecrets) === null || _a === void 0 ? void 0 : _a.map(y => toJson_LocalObjectReference(y)),
        'metadata': toJson_ObjectMeta(obj.metadata),
        'secrets': (_b = obj.secrets) === null || _b === void 0 ? void 0 : _b.map(y => toJson_ObjectReference(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeServiceAccountProps = toJson_KubeServiceAccountProps;
/**
 * Converts an object of type 'KubeServiceAccountListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeServiceAccountListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeServiceAccountProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeServiceAccountListProps = toJson_KubeServiceAccountListProps;
/**
 * Converts an object of type 'KubeServiceListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeServiceListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeServiceProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeServiceListProps = toJson_KubeServiceListProps;
/**
 * Converts an object of type 'KubeEndpointSliceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeEndpointSliceProps(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'addressType': obj.addressType,
        'endpoints': (_a = obj.endpoints) === null || _a === void 0 ? void 0 : _a.map(y => toJson_Endpoint(y)),
        'metadata': toJson_ObjectMeta(obj.metadata),
        'ports': (_b = obj.ports) === null || _b === void 0 ? void 0 : _b.map(y => toJson_EndpointPort(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeEndpointSliceProps = toJson_KubeEndpointSliceProps;
/**
 * Converts an object of type 'KubeEndpointSliceListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeEndpointSliceListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeEndpointSliceProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeEndpointSliceListProps = toJson_KubeEndpointSliceListProps;
/**
 * Converts an object of type 'KubeEndpointSliceV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeEndpointSliceV1Beta1Props(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'addressType': obj.addressType,
        'endpoints': (_a = obj.endpoints) === null || _a === void 0 ? void 0 : _a.map(y => toJson_EndpointV1Beta1(y)),
        'metadata': toJson_ObjectMeta(obj.metadata),
        'ports': (_b = obj.ports) === null || _b === void 0 ? void 0 : _b.map(y => toJson_EndpointPortV1Beta1(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeEndpointSliceV1Beta1Props = toJson_KubeEndpointSliceV1Beta1Props;
/**
 * Converts an object of type 'KubeEndpointSliceListV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeEndpointSliceListV1Beta1Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeEndpointSliceV1Beta1Props(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeEndpointSliceListV1Beta1Props = toJson_KubeEndpointSliceListV1Beta1Props;
/**
 * Converts an object of type 'KubeEventV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeEventV1Beta1Props(obj) {
    var _a, _b, _c;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'action': obj.action,
        'deprecatedCount': obj.deprecatedCount,
        'deprecatedFirstTimestamp': (_a = obj.deprecatedFirstTimestamp) === null || _a === void 0 ? void 0 : _a.toISOString(),
        'deprecatedLastTimestamp': (_b = obj.deprecatedLastTimestamp) === null || _b === void 0 ? void 0 : _b.toISOString(),
        'deprecatedSource': toJson_EventSource(obj.deprecatedSource),
        'eventTime': (_c = obj.eventTime) === null || _c === void 0 ? void 0 : _c.toISOString(),
        'metadata': toJson_ObjectMeta(obj.metadata),
        'note': obj.note,
        'reason': obj.reason,
        'regarding': toJson_ObjectReference(obj.regarding),
        'related': toJson_ObjectReference(obj.related),
        'reportingController': obj.reportingController,
        'reportingInstance': obj.reportingInstance,
        'series': toJson_EventSeriesV1Beta1(obj.series),
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeEventV1Beta1Props = toJson_KubeEventV1Beta1Props;
/**
 * Converts an object of type 'KubeEventListV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeEventListV1Beta1Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeEventV1Beta1Props(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeEventListV1Beta1Props = toJson_KubeEventListV1Beta1Props;
/**
 * Converts an object of type 'KubeFlowSchemaV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeFlowSchemaV1Beta1Props(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_FlowSchemaSpecV1Beta1(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeFlowSchemaV1Beta1Props = toJson_KubeFlowSchemaV1Beta1Props;
/**
 * Converts an object of type 'KubeFlowSchemaListV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeFlowSchemaListV1Beta1Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeFlowSchemaV1Beta1Props(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeFlowSchemaListV1Beta1Props = toJson_KubeFlowSchemaListV1Beta1Props;
/**
 * Converts an object of type 'KubePriorityLevelConfigurationV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubePriorityLevelConfigurationV1Beta1Props(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_PriorityLevelConfigurationSpecV1Beta1(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubePriorityLevelConfigurationV1Beta1Props = toJson_KubePriorityLevelConfigurationV1Beta1Props;
/**
 * Converts an object of type 'KubePriorityLevelConfigurationListV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubePriorityLevelConfigurationListV1Beta1Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubePriorityLevelConfigurationV1Beta1Props(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubePriorityLevelConfigurationListV1Beta1Props = toJson_KubePriorityLevelConfigurationListV1Beta1Props;
/**
 * Converts an object of type 'KubeIngressProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeIngressProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_IngressSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeIngressProps = toJson_KubeIngressProps;
/**
 * Converts an object of type 'KubeIngressClassProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeIngressClassProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_IngressClassSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeIngressClassProps = toJson_KubeIngressClassProps;
/**
 * Converts an object of type 'KubeIngressClassListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeIngressClassListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeIngressClassProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeIngressClassListProps = toJson_KubeIngressClassListProps;
/**
 * Converts an object of type 'KubeIngressListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeIngressListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeIngressProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeIngressListProps = toJson_KubeIngressListProps;
/**
 * Converts an object of type 'KubeNetworkPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeNetworkPolicyProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_NetworkPolicySpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeNetworkPolicyProps = toJson_KubeNetworkPolicyProps;
/**
 * Converts an object of type 'KubeNetworkPolicyListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeNetworkPolicyListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeNetworkPolicyProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeNetworkPolicyListProps = toJson_KubeNetworkPolicyListProps;
/**
 * Converts an object of type 'KubeRuntimeClassProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeRuntimeClassProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'handler': obj.handler,
        'metadata': toJson_ObjectMeta(obj.metadata),
        'overhead': toJson_Overhead(obj.overhead),
        'scheduling': toJson_Scheduling(obj.scheduling),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeRuntimeClassProps = toJson_KubeRuntimeClassProps;
/**
 * Converts an object of type 'KubeRuntimeClassListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeRuntimeClassListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeRuntimeClassProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeRuntimeClassListProps = toJson_KubeRuntimeClassListProps;
/**
 * Converts an object of type 'KubeRuntimeClassV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeRuntimeClassV1Alpha1Props(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_RuntimeClassSpecV1Alpha1(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeRuntimeClassV1Alpha1Props = toJson_KubeRuntimeClassV1Alpha1Props;
/**
 * Converts an object of type 'KubeRuntimeClassListV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeRuntimeClassListV1Alpha1Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeRuntimeClassV1Alpha1Props(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeRuntimeClassListV1Alpha1Props = toJson_KubeRuntimeClassListV1Alpha1Props;
/**
 * Converts an object of type 'KubeRuntimeClassV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeRuntimeClassV1Beta1Props(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'handler': obj.handler,
        'metadata': toJson_ObjectMeta(obj.metadata),
        'overhead': toJson_OverheadV1Beta1(obj.overhead),
        'scheduling': toJson_SchedulingV1Beta1(obj.scheduling),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeRuntimeClassV1Beta1Props = toJson_KubeRuntimeClassV1Beta1Props;
/**
 * Converts an object of type 'KubeRuntimeClassListV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeRuntimeClassListV1Beta1Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeRuntimeClassV1Beta1Props(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeRuntimeClassListV1Beta1Props = toJson_KubeRuntimeClassListV1Beta1Props;
/**
 * Converts an object of type 'KubeEvictionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeEvictionProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'deleteOptions': toJson_DeleteOptions(obj.deleteOptions),
        'metadata': toJson_ObjectMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeEvictionProps = toJson_KubeEvictionProps;
/**
 * Converts an object of type 'KubePodDisruptionBudgetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubePodDisruptionBudgetProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_PodDisruptionBudgetSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubePodDisruptionBudgetProps = toJson_KubePodDisruptionBudgetProps;
/**
 * Converts an object of type 'KubePodDisruptionBudgetListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubePodDisruptionBudgetListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubePodDisruptionBudgetProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubePodDisruptionBudgetListProps = toJson_KubePodDisruptionBudgetListProps;
/**
 * Converts an object of type 'KubePodDisruptionBudgetV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubePodDisruptionBudgetV1Beta1Props(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_PodDisruptionBudgetSpecV1Beta1(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubePodDisruptionBudgetV1Beta1Props = toJson_KubePodDisruptionBudgetV1Beta1Props;
/**
 * Converts an object of type 'KubePodDisruptionBudgetListV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubePodDisruptionBudgetListV1Beta1Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubePodDisruptionBudgetV1Beta1Props(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubePodDisruptionBudgetListV1Beta1Props = toJson_KubePodDisruptionBudgetListV1Beta1Props;
/**
 * Converts an object of type 'KubePodSecurityPolicyV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubePodSecurityPolicyV1Beta1Props(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_PodSecurityPolicySpecV1Beta1(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubePodSecurityPolicyV1Beta1Props = toJson_KubePodSecurityPolicyV1Beta1Props;
/**
 * Converts an object of type 'KubePodSecurityPolicyListV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubePodSecurityPolicyListV1Beta1Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubePodSecurityPolicyV1Beta1Props(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubePodSecurityPolicyListV1Beta1Props = toJson_KubePodSecurityPolicyListV1Beta1Props;
/**
 * Converts an object of type 'KubeClusterRoleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeClusterRoleProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'aggregationRule': toJson_AggregationRule(obj.aggregationRule),
        'metadata': toJson_ObjectMeta(obj.metadata),
        'rules': (_a = obj.rules) === null || _a === void 0 ? void 0 : _a.map(y => toJson_PolicyRule(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeClusterRoleProps = toJson_KubeClusterRoleProps;
/**
 * Converts an object of type 'KubeClusterRoleBindingProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeClusterRoleBindingProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'roleRef': toJson_RoleRef(obj.roleRef),
        'subjects': (_a = obj.subjects) === null || _a === void 0 ? void 0 : _a.map(y => toJson_Subject(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeClusterRoleBindingProps = toJson_KubeClusterRoleBindingProps;
/**
 * Converts an object of type 'KubeClusterRoleBindingListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeClusterRoleBindingListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeClusterRoleBindingProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeClusterRoleBindingListProps = toJson_KubeClusterRoleBindingListProps;
/**
 * Converts an object of type 'KubeClusterRoleListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeClusterRoleListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeClusterRoleProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeClusterRoleListProps = toJson_KubeClusterRoleListProps;
/**
 * Converts an object of type 'KubeRoleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeRoleProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'rules': (_a = obj.rules) === null || _a === void 0 ? void 0 : _a.map(y => toJson_PolicyRule(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeRoleProps = toJson_KubeRoleProps;
/**
 * Converts an object of type 'KubeRoleBindingProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeRoleBindingProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'roleRef': toJson_RoleRef(obj.roleRef),
        'subjects': (_a = obj.subjects) === null || _a === void 0 ? void 0 : _a.map(y => toJson_Subject(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeRoleBindingProps = toJson_KubeRoleBindingProps;
/**
 * Converts an object of type 'KubeRoleBindingListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeRoleBindingListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeRoleBindingProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeRoleBindingListProps = toJson_KubeRoleBindingListProps;
/**
 * Converts an object of type 'KubeRoleListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeRoleListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeRoleProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeRoleListProps = toJson_KubeRoleListProps;
/**
 * Converts an object of type 'KubeClusterRoleV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeClusterRoleV1Alpha1Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'aggregationRule': toJson_AggregationRuleV1Alpha1(obj.aggregationRule),
        'metadata': toJson_ObjectMeta(obj.metadata),
        'rules': (_a = obj.rules) === null || _a === void 0 ? void 0 : _a.map(y => toJson_PolicyRuleV1Alpha1(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeClusterRoleV1Alpha1Props = toJson_KubeClusterRoleV1Alpha1Props;
/**
 * Converts an object of type 'KubeClusterRoleBindingV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeClusterRoleBindingV1Alpha1Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'roleRef': toJson_RoleRefV1Alpha1(obj.roleRef),
        'subjects': (_a = obj.subjects) === null || _a === void 0 ? void 0 : _a.map(y => toJson_SubjectV1Alpha1(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeClusterRoleBindingV1Alpha1Props = toJson_KubeClusterRoleBindingV1Alpha1Props;
/**
 * Converts an object of type 'KubeClusterRoleBindingListV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeClusterRoleBindingListV1Alpha1Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeClusterRoleBindingV1Alpha1Props(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeClusterRoleBindingListV1Alpha1Props = toJson_KubeClusterRoleBindingListV1Alpha1Props;
/**
 * Converts an object of type 'KubeClusterRoleListV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeClusterRoleListV1Alpha1Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeClusterRoleV1Alpha1Props(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeClusterRoleListV1Alpha1Props = toJson_KubeClusterRoleListV1Alpha1Props;
/**
 * Converts an object of type 'KubeRoleV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeRoleV1Alpha1Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'rules': (_a = obj.rules) === null || _a === void 0 ? void 0 : _a.map(y => toJson_PolicyRuleV1Alpha1(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeRoleV1Alpha1Props = toJson_KubeRoleV1Alpha1Props;
/**
 * Converts an object of type 'KubeRoleBindingV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeRoleBindingV1Alpha1Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'roleRef': toJson_RoleRefV1Alpha1(obj.roleRef),
        'subjects': (_a = obj.subjects) === null || _a === void 0 ? void 0 : _a.map(y => toJson_SubjectV1Alpha1(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeRoleBindingV1Alpha1Props = toJson_KubeRoleBindingV1Alpha1Props;
/**
 * Converts an object of type 'KubeRoleBindingListV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeRoleBindingListV1Alpha1Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeRoleBindingV1Alpha1Props(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeRoleBindingListV1Alpha1Props = toJson_KubeRoleBindingListV1Alpha1Props;
/**
 * Converts an object of type 'KubeRoleListV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeRoleListV1Alpha1Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeRoleV1Alpha1Props(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeRoleListV1Alpha1Props = toJson_KubeRoleListV1Alpha1Props;
/**
 * Converts an object of type 'KubePriorityClassProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubePriorityClassProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'description': obj.description,
        'globalDefault': obj.globalDefault,
        'metadata': toJson_ObjectMeta(obj.metadata),
        'preemptionPolicy': obj.preemptionPolicy,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubePriorityClassProps = toJson_KubePriorityClassProps;
/**
 * Converts an object of type 'KubePriorityClassListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubePriorityClassListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubePriorityClassProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubePriorityClassListProps = toJson_KubePriorityClassListProps;
/**
 * Converts an object of type 'KubePriorityClassV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubePriorityClassV1Alpha1Props(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'description': obj.description,
        'globalDefault': obj.globalDefault,
        'metadata': toJson_ObjectMeta(obj.metadata),
        'preemptionPolicy': obj.preemptionPolicy,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubePriorityClassV1Alpha1Props = toJson_KubePriorityClassV1Alpha1Props;
/**
 * Converts an object of type 'KubePriorityClassListV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubePriorityClassListV1Alpha1Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubePriorityClassV1Alpha1Props(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubePriorityClassListV1Alpha1Props = toJson_KubePriorityClassListV1Alpha1Props;
/**
 * Converts an object of type 'KubeCsiDriverProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeCsiDriverProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_CsiDriverSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeCsiDriverProps = toJson_KubeCsiDriverProps;
/**
 * Converts an object of type 'KubeCsiDriverListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeCsiDriverListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeCsiDriverProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeCsiDriverListProps = toJson_KubeCsiDriverListProps;
/**
 * Converts an object of type 'KubeCsiNodeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeCsiNodeProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_CsiNodeSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeCsiNodeProps = toJson_KubeCsiNodeProps;
/**
 * Converts an object of type 'KubeCsiNodeListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeCsiNodeListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeCsiNodeProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeCsiNodeListProps = toJson_KubeCsiNodeListProps;
/**
 * Converts an object of type 'KubeStorageClassProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeStorageClassProps(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'allowVolumeExpansion': obj.allowVolumeExpansion,
        'allowedTopologies': (_a = obj.allowedTopologies) === null || _a === void 0 ? void 0 : _a.map(y => toJson_TopologySelectorTerm(y)),
        'metadata': toJson_ObjectMeta(obj.metadata),
        'mountOptions': (_b = obj.mountOptions) === null || _b === void 0 ? void 0 : _b.map(y => y),
        'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'provisioner': obj.provisioner,
        'reclaimPolicy': obj.reclaimPolicy,
        'volumeBindingMode': obj.volumeBindingMode,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeStorageClassProps = toJson_KubeStorageClassProps;
/**
 * Converts an object of type 'KubeStorageClassListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeStorageClassListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeStorageClassProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeStorageClassListProps = toJson_KubeStorageClassListProps;
/**
 * Converts an object of type 'KubeVolumeAttachmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeVolumeAttachmentProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_VolumeAttachmentSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeVolumeAttachmentProps = toJson_KubeVolumeAttachmentProps;
/**
 * Converts an object of type 'KubeVolumeAttachmentListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeVolumeAttachmentListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeVolumeAttachmentProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeVolumeAttachmentListProps = toJson_KubeVolumeAttachmentListProps;
/**
 * Converts an object of type 'KubeCsiStorageCapacityV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeCsiStorageCapacityV1Alpha1Props(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'capacity': (_a = obj.capacity) === null || _a === void 0 ? void 0 : _a.value,
        'maximumVolumeSize': (_b = obj.maximumVolumeSize) === null || _b === void 0 ? void 0 : _b.value,
        'metadata': toJson_ObjectMeta(obj.metadata),
        'nodeTopology': toJson_LabelSelector(obj.nodeTopology),
        'storageClassName': obj.storageClassName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeCsiStorageCapacityV1Alpha1Props = toJson_KubeCsiStorageCapacityV1Alpha1Props;
/**
 * Converts an object of type 'KubeCsiStorageCapacityListV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeCsiStorageCapacityListV1Alpha1Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeCsiStorageCapacityV1Alpha1Props(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeCsiStorageCapacityListV1Alpha1Props = toJson_KubeCsiStorageCapacityListV1Alpha1Props;
/**
 * Converts an object of type 'KubeVolumeAttachmentV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeVolumeAttachmentV1Alpha1Props(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_VolumeAttachmentSpecV1Alpha1(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeVolumeAttachmentV1Alpha1Props = toJson_KubeVolumeAttachmentV1Alpha1Props;
/**
 * Converts an object of type 'KubeVolumeAttachmentListV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeVolumeAttachmentListV1Alpha1Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeVolumeAttachmentV1Alpha1Props(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeVolumeAttachmentListV1Alpha1Props = toJson_KubeVolumeAttachmentListV1Alpha1Props;
/**
 * Converts an object of type 'KubeCsiStorageCapacityV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeCsiStorageCapacityV1Beta1Props(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'capacity': (_a = obj.capacity) === null || _a === void 0 ? void 0 : _a.value,
        'maximumVolumeSize': (_b = obj.maximumVolumeSize) === null || _b === void 0 ? void 0 : _b.value,
        'metadata': toJson_ObjectMeta(obj.metadata),
        'nodeTopology': toJson_LabelSelector(obj.nodeTopology),
        'storageClassName': obj.storageClassName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeCsiStorageCapacityV1Beta1Props = toJson_KubeCsiStorageCapacityV1Beta1Props;
/**
 * Converts an object of type 'KubeCsiStorageCapacityListV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeCsiStorageCapacityListV1Beta1Props(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeCsiStorageCapacityV1Beta1Props(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeCsiStorageCapacityListV1Beta1Props = toJson_KubeCsiStorageCapacityListV1Beta1Props;
/**
 * Converts an object of type 'KubeCustomResourceDefinitionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeCustomResourceDefinitionProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_CustomResourceDefinitionSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeCustomResourceDefinitionProps = toJson_KubeCustomResourceDefinitionProps;
/**
 * Converts an object of type 'KubeCustomResourceDefinitionListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeCustomResourceDefinitionListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeCustomResourceDefinitionProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeCustomResourceDefinitionListProps = toJson_KubeCustomResourceDefinitionListProps;
/**
 * Converts an object of type 'KubeStatusProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeStatusProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'code': obj.code,
        'details': toJson_StatusDetails(obj.details),
        'message': obj.message,
        'metadata': toJson_ListMeta(obj.metadata),
        'reason': obj.reason,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeStatusProps = toJson_KubeStatusProps;
/**
 * Converts an object of type 'KubeApiServiceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeApiServiceProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_ApiServiceSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeApiServiceProps = toJson_KubeApiServiceProps;
/**
 * Converts an object of type 'KubeApiServiceListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KubeApiServiceListProps(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubeApiServiceProps(y)),
        'metadata': toJson_ListMeta(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KubeApiServiceListProps = toJson_KubeApiServiceListProps;
/**
 * Converts an object of type 'ObjectMeta' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ObjectMeta(obj) {
    var _a, _b, _c, _d, _e;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'clusterName': obj.clusterName,
        'creationTimestamp': (_a = obj.creationTimestamp) === null || _a === void 0 ? void 0 : _a.toISOString(),
        'deletionGracePeriodSeconds': obj.deletionGracePeriodSeconds,
        'deletionTimestamp': (_b = obj.deletionTimestamp) === null || _b === void 0 ? void 0 : _b.toISOString(),
        'finalizers': (_c = obj.finalizers) === null || _c === void 0 ? void 0 : _c.map(y => y),
        'generateName': obj.generateName,
        'generation': obj.generation,
        'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'managedFields': (_d = obj.managedFields) === null || _d === void 0 ? void 0 : _d.map(y => toJson_ManagedFieldsEntry(y)),
        'name': obj.name,
        'namespace': obj.namespace,
        'ownerReferences': (_e = obj.ownerReferences) === null || _e === void 0 ? void 0 : _e.map(y => toJson_OwnerReference(y)),
        'resourceVersion': obj.resourceVersion,
        'selfLink': obj.selfLink,
        'uid': obj.uid,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ObjectMeta = toJson_ObjectMeta;
/**
 * Converts an object of type 'MutatingWebhook' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_MutatingWebhook(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'admissionReviewVersions': (_a = obj.admissionReviewVersions) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'clientConfig': toJson_WebhookClientConfig(obj.clientConfig),
        'failurePolicy': obj.failurePolicy,
        'matchPolicy': obj.matchPolicy,
        'name': obj.name,
        'namespaceSelector': toJson_LabelSelector(obj.namespaceSelector),
        'objectSelector': toJson_LabelSelector(obj.objectSelector),
        'reinvocationPolicy': obj.reinvocationPolicy,
        'rules': (_b = obj.rules) === null || _b === void 0 ? void 0 : _b.map(y => toJson_RuleWithOperations(y)),
        'sideEffects': obj.sideEffects,
        'timeoutSeconds': obj.timeoutSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_MutatingWebhook = toJson_MutatingWebhook;
/**
 * Converts an object of type 'ListMeta' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ListMeta(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'continue': obj.continue,
        'remainingItemCount': obj.remainingItemCount,
        'resourceVersion': obj.resourceVersion,
        'selfLink': obj.selfLink,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ListMeta = toJson_ListMeta;
/**
 * Converts an object of type 'ValidatingWebhook' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ValidatingWebhook(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'admissionReviewVersions': (_a = obj.admissionReviewVersions) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'clientConfig': toJson_WebhookClientConfig(obj.clientConfig),
        'failurePolicy': obj.failurePolicy,
        'matchPolicy': obj.matchPolicy,
        'name': obj.name,
        'namespaceSelector': toJson_LabelSelector(obj.namespaceSelector),
        'objectSelector': toJson_LabelSelector(obj.objectSelector),
        'rules': (_b = obj.rules) === null || _b === void 0 ? void 0 : _b.map(y => toJson_RuleWithOperations(y)),
        'sideEffects': obj.sideEffects,
        'timeoutSeconds': obj.timeoutSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ValidatingWebhook = toJson_ValidatingWebhook;
/**
 * Converts an object of type 'DaemonSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_DaemonSetSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'minReadySeconds': obj.minReadySeconds,
        'revisionHistoryLimit': obj.revisionHistoryLimit,
        'selector': toJson_LabelSelector(obj.selector),
        'template': toJson_PodTemplateSpec(obj.template),
        'updateStrategy': toJson_DaemonSetUpdateStrategy(obj.updateStrategy),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_DaemonSetSpec = toJson_DaemonSetSpec;
/**
 * Converts an object of type 'DeploymentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_DeploymentSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'minReadySeconds': obj.minReadySeconds,
        'paused': obj.paused,
        'progressDeadlineSeconds': obj.progressDeadlineSeconds,
        'replicas': obj.replicas,
        'revisionHistoryLimit': obj.revisionHistoryLimit,
        'selector': toJson_LabelSelector(obj.selector),
        'strategy': toJson_DeploymentStrategy(obj.strategy),
        'template': toJson_PodTemplateSpec(obj.template),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_DeploymentSpec = toJson_DeploymentSpec;
/**
 * Converts an object of type 'ReplicaSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ReplicaSetSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'minReadySeconds': obj.minReadySeconds,
        'replicas': obj.replicas,
        'selector': toJson_LabelSelector(obj.selector),
        'template': toJson_PodTemplateSpec(obj.template),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ReplicaSetSpec = toJson_ReplicaSetSpec;
/**
 * Converts an object of type 'StatefulSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_StatefulSetSpec(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'minReadySeconds': obj.minReadySeconds,
        'podManagementPolicy': obj.podManagementPolicy,
        'replicas': obj.replicas,
        'revisionHistoryLimit': obj.revisionHistoryLimit,
        'selector': toJson_LabelSelector(obj.selector),
        'serviceName': obj.serviceName,
        'template': toJson_PodTemplateSpec(obj.template),
        'updateStrategy': toJson_StatefulSetUpdateStrategy(obj.updateStrategy),
        'volumeClaimTemplates': (_a = obj.volumeClaimTemplates) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KubePersistentVolumeClaimProps(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_StatefulSetSpec = toJson_StatefulSetSpec;
/**
 * Converts an object of type 'TokenRequestSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_TokenRequestSpec(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'audiences': (_a = obj.audiences) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'boundObjectRef': toJson_BoundObjectReference(obj.boundObjectRef),
        'expirationSeconds': obj.expirationSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_TokenRequestSpec = toJson_TokenRequestSpec;
/**
 * Converts an object of type 'TokenReviewSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_TokenReviewSpec(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'audiences': (_a = obj.audiences) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'token': obj.token,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_TokenReviewSpec = toJson_TokenReviewSpec;
/**
 * Converts an object of type 'SubjectAccessReviewSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_SubjectAccessReviewSpec(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'extra': ((obj.extra) === undefined) ? undefined : (Object.entries(obj.extra).reduce((r, i) => { var _a; return (i[1] === undefined) ? r : ({ ...r, [i[0]]: (_a = i[1]) === null || _a === void 0 ? void 0 : _a.map(y => y) }); }, {})),
        'groups': (_a = obj.groups) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'nonResourceAttributes': toJson_NonResourceAttributes(obj.nonResourceAttributes),
        'resourceAttributes': toJson_ResourceAttributes(obj.resourceAttributes),
        'uid': obj.uid,
        'user': obj.user,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_SubjectAccessReviewSpec = toJson_SubjectAccessReviewSpec;
/**
 * Converts an object of type 'SelfSubjectAccessReviewSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_SelfSubjectAccessReviewSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'nonResourceAttributes': toJson_NonResourceAttributes(obj.nonResourceAttributes),
        'resourceAttributes': toJson_ResourceAttributes(obj.resourceAttributes),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_SelfSubjectAccessReviewSpec = toJson_SelfSubjectAccessReviewSpec;
/**
 * Converts an object of type 'SelfSubjectRulesReviewSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_SelfSubjectRulesReviewSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'namespace': obj.namespace,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_SelfSubjectRulesReviewSpec = toJson_SelfSubjectRulesReviewSpec;
/**
 * Converts an object of type 'HorizontalPodAutoscalerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_HorizontalPodAutoscalerSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'maxReplicas': obj.maxReplicas,
        'minReplicas': obj.minReplicas,
        'scaleTargetRef': toJson_CrossVersionObjectReference(obj.scaleTargetRef),
        'targetCPUUtilizationPercentage': obj.targetCpuUtilizationPercentage,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_HorizontalPodAutoscalerSpec = toJson_HorizontalPodAutoscalerSpec;
/**
 * Converts an object of type 'ScaleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ScaleSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'replicas': obj.replicas,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ScaleSpec = toJson_ScaleSpec;
/**
 * Converts an object of type 'HorizontalPodAutoscalerSpecV2Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_HorizontalPodAutoscalerSpecV2Beta1(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'maxReplicas': obj.maxReplicas,
        'metrics': (_a = obj.metrics) === null || _a === void 0 ? void 0 : _a.map(y => toJson_MetricSpecV2Beta1(y)),
        'minReplicas': obj.minReplicas,
        'scaleTargetRef': toJson_CrossVersionObjectReferenceV2Beta1(obj.scaleTargetRef),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_HorizontalPodAutoscalerSpecV2Beta1 = toJson_HorizontalPodAutoscalerSpecV2Beta1;
/**
 * Converts an object of type 'HorizontalPodAutoscalerSpecV2Beta2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_HorizontalPodAutoscalerSpecV2Beta2(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'behavior': toJson_HorizontalPodAutoscalerBehaviorV2Beta2(obj.behavior),
        'maxReplicas': obj.maxReplicas,
        'metrics': (_a = obj.metrics) === null || _a === void 0 ? void 0 : _a.map(y => toJson_MetricSpecV2Beta2(y)),
        'minReplicas': obj.minReplicas,
        'scaleTargetRef': toJson_CrossVersionObjectReferenceV2Beta2(obj.scaleTargetRef),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_HorizontalPodAutoscalerSpecV2Beta2 = toJson_HorizontalPodAutoscalerSpecV2Beta2;
/**
 * Converts an object of type 'CronJobSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_CronJobSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'concurrencyPolicy': obj.concurrencyPolicy,
        'failedJobsHistoryLimit': obj.failedJobsHistoryLimit,
        'jobTemplate': toJson_JobTemplateSpec(obj.jobTemplate),
        'schedule': obj.schedule,
        'startingDeadlineSeconds': obj.startingDeadlineSeconds,
        'successfulJobsHistoryLimit': obj.successfulJobsHistoryLimit,
        'suspend': obj.suspend,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_CronJobSpec = toJson_CronJobSpec;
/**
 * Converts an object of type 'JobSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_JobSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'activeDeadlineSeconds': obj.activeDeadlineSeconds,
        'backoffLimit': obj.backoffLimit,
        'completionMode': obj.completionMode,
        'completions': obj.completions,
        'manualSelector': obj.manualSelector,
        'parallelism': obj.parallelism,
        'selector': toJson_LabelSelector(obj.selector),
        'suspend': obj.suspend,
        'template': toJson_PodTemplateSpec(obj.template),
        'ttlSecondsAfterFinished': obj.ttlSecondsAfterFinished,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_JobSpec = toJson_JobSpec;
/**
 * Converts an object of type 'CronJobSpecV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_CronJobSpecV1Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'concurrencyPolicy': obj.concurrencyPolicy,
        'failedJobsHistoryLimit': obj.failedJobsHistoryLimit,
        'jobTemplate': toJson_JobTemplateSpecV1Beta1(obj.jobTemplate),
        'schedule': obj.schedule,
        'startingDeadlineSeconds': obj.startingDeadlineSeconds,
        'successfulJobsHistoryLimit': obj.successfulJobsHistoryLimit,
        'suspend': obj.suspend,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_CronJobSpecV1Beta1 = toJson_CronJobSpecV1Beta1;
/**
 * Converts an object of type 'CertificateSigningRequestSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_CertificateSigningRequestSpec(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'expirationSeconds': obj.expirationSeconds,
        'extra': ((obj.extra) === undefined) ? undefined : (Object.entries(obj.extra).reduce((r, i) => { var _a; return (i[1] === undefined) ? r : ({ ...r, [i[0]]: (_a = i[1]) === null || _a === void 0 ? void 0 : _a.map(y => y) }); }, {})),
        'groups': (_a = obj.groups) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'request': obj.request,
        'signerName': obj.signerName,
        'uid': obj.uid,
        'usages': (_b = obj.usages) === null || _b === void 0 ? void 0 : _b.map(y => y),
        'username': obj.username,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_CertificateSigningRequestSpec = toJson_CertificateSigningRequestSpec;
/**
 * Converts an object of type 'LeaseSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_LeaseSpec(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'acquireTime': (_a = obj.acquireTime) === null || _a === void 0 ? void 0 : _a.toISOString(),
        'holderIdentity': obj.holderIdentity,
        'leaseDurationSeconds': obj.leaseDurationSeconds,
        'leaseTransitions': obj.leaseTransitions,
        'renewTime': (_b = obj.renewTime) === null || _b === void 0 ? void 0 : _b.toISOString(),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_LeaseSpec = toJson_LeaseSpec;
/**
 * Converts an object of type 'ObjectReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ObjectReference(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'apiVersion': obj.apiVersion,
        'fieldPath': obj.fieldPath,
        'kind': obj.kind,
        'name': obj.name,
        'namespace': obj.namespace,
        'resourceVersion': obj.resourceVersion,
        'uid': obj.uid,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ObjectReference = toJson_ObjectReference;
/**
 * Converts an object of type 'ComponentCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ComponentCondition(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'error': obj.error,
        'message': obj.message,
        'status': obj.status,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ComponentCondition = toJson_ComponentCondition;
/**
 * Converts an object of type 'EndpointSubset' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_EndpointSubset(obj) {
    var _a, _b, _c;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'addresses': (_a = obj.addresses) === null || _a === void 0 ? void 0 : _a.map(y => toJson_EndpointAddress(y)),
        'notReadyAddresses': (_b = obj.notReadyAddresses) === null || _b === void 0 ? void 0 : _b.map(y => toJson_EndpointAddress(y)),
        'ports': (_c = obj.ports) === null || _c === void 0 ? void 0 : _c.map(y => toJson_EndpointPort(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_EndpointSubset = toJson_EndpointSubset;
/**
 * Converts an object of type 'EventSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_EventSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'component': obj.component,
        'host': obj.host,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_EventSource = toJson_EventSource;
/**
 * Converts an object of type 'EventSeries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_EventSeries(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'count': obj.count,
        'lastObservedTime': (_a = obj.lastObservedTime) === null || _a === void 0 ? void 0 : _a.toISOString(),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_EventSeries = toJson_EventSeries;
/**
 * Converts an object of type 'LimitRangeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_LimitRangeSpec(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'limits': (_a = obj.limits) === null || _a === void 0 ? void 0 : _a.map(y => toJson_LimitRangeItem(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_LimitRangeSpec = toJson_LimitRangeSpec;
/**
 * Converts an object of type 'NamespaceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_NamespaceSpec(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'finalizers': (_a = obj.finalizers) === null || _a === void 0 ? void 0 : _a.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_NamespaceSpec = toJson_NamespaceSpec;
/**
 * Converts an object of type 'NodeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_NodeSpec(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'configSource': toJson_NodeConfigSource(obj.configSource),
        'externalID': obj.externalId,
        'podCIDR': obj.podCidr,
        'podCIDRs': (_a = obj.podCidRs) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'providerID': obj.providerId,
        'taints': (_b = obj.taints) === null || _b === void 0 ? void 0 : _b.map(y => toJson_Taint(y)),
        'unschedulable': obj.unschedulable,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_NodeSpec = toJson_NodeSpec;
/**
 * Converts an object of type 'PersistentVolumeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PersistentVolumeSpec(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'accessModes': (_a = obj.accessModes) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'awsElasticBlockStore': toJson_AwsElasticBlockStoreVolumeSource(obj.awsElasticBlockStore),
        'azureDisk': toJson_AzureDiskVolumeSource(obj.azureDisk),
        'azureFile': toJson_AzureFilePersistentVolumeSource(obj.azureFile),
        'capacity': ((obj.capacity) === undefined) ? undefined : (Object.entries(obj.capacity).reduce((r, i) => { var _a; return (i[1] === undefined) ? r : ({ ...r, [i[0]]: (_a = i[1]) === null || _a === void 0 ? void 0 : _a.value }); }, {})),
        'cephfs': toJson_CephFsPersistentVolumeSource(obj.cephfs),
        'cinder': toJson_CinderPersistentVolumeSource(obj.cinder),
        'claimRef': toJson_ObjectReference(obj.claimRef),
        'csi': toJson_CsiPersistentVolumeSource(obj.csi),
        'fc': toJson_FcVolumeSource(obj.fc),
        'flexVolume': toJson_FlexPersistentVolumeSource(obj.flexVolume),
        'flocker': toJson_FlockerVolumeSource(obj.flocker),
        'gcePersistentDisk': toJson_GcePersistentDiskVolumeSource(obj.gcePersistentDisk),
        'glusterfs': toJson_GlusterfsPersistentVolumeSource(obj.glusterfs),
        'hostPath': toJson_HostPathVolumeSource(obj.hostPath),
        'iscsi': toJson_IscsiPersistentVolumeSource(obj.iscsi),
        'local': toJson_LocalVolumeSource(obj.local),
        'mountOptions': (_b = obj.mountOptions) === null || _b === void 0 ? void 0 : _b.map(y => y),
        'nfs': toJson_NfsVolumeSource(obj.nfs),
        'nodeAffinity': toJson_VolumeNodeAffinity(obj.nodeAffinity),
        'persistentVolumeReclaimPolicy': obj.persistentVolumeReclaimPolicy,
        'photonPersistentDisk': toJson_PhotonPersistentDiskVolumeSource(obj.photonPersistentDisk),
        'portworxVolume': toJson_PortworxVolumeSource(obj.portworxVolume),
        'quobyte': toJson_QuobyteVolumeSource(obj.quobyte),
        'rbd': toJson_RbdPersistentVolumeSource(obj.rbd),
        'scaleIO': toJson_ScaleIoPersistentVolumeSource(obj.scaleIo),
        'storageClassName': obj.storageClassName,
        'storageos': toJson_StorageOsPersistentVolumeSource(obj.storageos),
        'volumeMode': obj.volumeMode,
        'vsphereVolume': toJson_VsphereVirtualDiskVolumeSource(obj.vsphereVolume),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PersistentVolumeSpec = toJson_PersistentVolumeSpec;
/**
 * Converts an object of type 'PersistentVolumeClaimSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PersistentVolumeClaimSpec(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'accessModes': (_a = obj.accessModes) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'dataSource': toJson_TypedLocalObjectReference(obj.dataSource),
        'dataSourceRef': toJson_TypedLocalObjectReference(obj.dataSourceRef),
        'resources': toJson_ResourceRequirements(obj.resources),
        'selector': toJson_LabelSelector(obj.selector),
        'storageClassName': obj.storageClassName,
        'volumeMode': obj.volumeMode,
        'volumeName': obj.volumeName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PersistentVolumeClaimSpec = toJson_PersistentVolumeClaimSpec;
/**
 * Converts an object of type 'PodSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PodSpec(obj) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'activeDeadlineSeconds': obj.activeDeadlineSeconds,
        'affinity': toJson_Affinity(obj.affinity),
        'automountServiceAccountToken': obj.automountServiceAccountToken,
        'containers': (_a = obj.containers) === null || _a === void 0 ? void 0 : _a.map(y => toJson_Container(y)),
        'dnsConfig': toJson_PodDnsConfig(obj.dnsConfig),
        'dnsPolicy': obj.dnsPolicy,
        'enableServiceLinks': obj.enableServiceLinks,
        'ephemeralContainers': (_b = obj.ephemeralContainers) === null || _b === void 0 ? void 0 : _b.map(y => toJson_EphemeralContainer(y)),
        'hostAliases': (_c = obj.hostAliases) === null || _c === void 0 ? void 0 : _c.map(y => toJson_HostAlias(y)),
        'hostIPC': obj.hostIpc,
        'hostNetwork': obj.hostNetwork,
        'hostPID': obj.hostPid,
        'hostname': obj.hostname,
        'imagePullSecrets': (_d = obj.imagePullSecrets) === null || _d === void 0 ? void 0 : _d.map(y => toJson_LocalObjectReference(y)),
        'initContainers': (_e = obj.initContainers) === null || _e === void 0 ? void 0 : _e.map(y => toJson_Container(y)),
        'nodeName': obj.nodeName,
        'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'overhead': ((obj.overhead) === undefined) ? undefined : (Object.entries(obj.overhead).reduce((r, i) => { var _a; return (i[1] === undefined) ? r : ({ ...r, [i[0]]: (_a = i[1]) === null || _a === void 0 ? void 0 : _a.value }); }, {})),
        'preemptionPolicy': obj.preemptionPolicy,
        'priority': obj.priority,
        'priorityClassName': obj.priorityClassName,
        'readinessGates': (_f = obj.readinessGates) === null || _f === void 0 ? void 0 : _f.map(y => toJson_PodReadinessGate(y)),
        'restartPolicy': obj.restartPolicy,
        'runtimeClassName': obj.runtimeClassName,
        'schedulerName': obj.schedulerName,
        'securityContext': toJson_PodSecurityContext(obj.securityContext),
        'serviceAccount': obj.serviceAccount,
        'serviceAccountName': obj.serviceAccountName,
        'setHostnameAsFQDN': obj.setHostnameAsFqdn,
        'shareProcessNamespace': obj.shareProcessNamespace,
        'subdomain': obj.subdomain,
        'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
        'tolerations': (_g = obj.tolerations) === null || _g === void 0 ? void 0 : _g.map(y => toJson_Toleration(y)),
        'topologySpreadConstraints': (_h = obj.topologySpreadConstraints) === null || _h === void 0 ? void 0 : _h.map(y => toJson_TopologySpreadConstraint(y)),
        'volumes': (_j = obj.volumes) === null || _j === void 0 ? void 0 : _j.map(y => toJson_Volume(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PodSpec = toJson_PodSpec;
/**
 * Converts an object of type 'PodTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PodTemplateSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_PodSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PodTemplateSpec = toJson_PodTemplateSpec;
/**
 * Converts an object of type 'ReplicationControllerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ReplicationControllerSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'minReadySeconds': obj.minReadySeconds,
        'replicas': obj.replicas,
        'selector': ((obj.selector) === undefined) ? undefined : (Object.entries(obj.selector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'template': toJson_PodTemplateSpec(obj.template),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ReplicationControllerSpec = toJson_ReplicationControllerSpec;
/**
 * Converts an object of type 'ResourceQuotaSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ResourceQuotaSpec(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'hard': ((obj.hard) === undefined) ? undefined : (Object.entries(obj.hard).reduce((r, i) => { var _a; return (i[1] === undefined) ? r : ({ ...r, [i[0]]: (_a = i[1]) === null || _a === void 0 ? void 0 : _a.value }); }, {})),
        'scopeSelector': toJson_ScopeSelector(obj.scopeSelector),
        'scopes': (_a = obj.scopes) === null || _a === void 0 ? void 0 : _a.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ResourceQuotaSpec = toJson_ResourceQuotaSpec;
/**
 * Converts an object of type 'ServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ServiceSpec(obj) {
    var _a, _b, _c, _d, _e;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'allocateLoadBalancerNodePorts': obj.allocateLoadBalancerNodePorts,
        'clusterIP': obj.clusterIp,
        'clusterIPs': (_a = obj.clusterIPs) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'externalIPs': (_b = obj.externalIPs) === null || _b === void 0 ? void 0 : _b.map(y => y),
        'externalName': obj.externalName,
        'externalTrafficPolicy': obj.externalTrafficPolicy,
        'healthCheckNodePort': obj.healthCheckNodePort,
        'internalTrafficPolicy': obj.internalTrafficPolicy,
        'ipFamilies': (_c = obj.ipFamilies) === null || _c === void 0 ? void 0 : _c.map(y => y),
        'ipFamilyPolicy': obj.ipFamilyPolicy,
        'loadBalancerClass': obj.loadBalancerClass,
        'loadBalancerIP': obj.loadBalancerIp,
        'loadBalancerSourceRanges': (_d = obj.loadBalancerSourceRanges) === null || _d === void 0 ? void 0 : _d.map(y => y),
        'ports': (_e = obj.ports) === null || _e === void 0 ? void 0 : _e.map(y => toJson_ServicePort(y)),
        'publishNotReadyAddresses': obj.publishNotReadyAddresses,
        'selector': ((obj.selector) === undefined) ? undefined : (Object.entries(obj.selector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'sessionAffinity': obj.sessionAffinity,
        'sessionAffinityConfig': toJson_SessionAffinityConfig(obj.sessionAffinityConfig),
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ServiceSpec = toJson_ServiceSpec;
/**
 * Converts an object of type 'LocalObjectReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_LocalObjectReference(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_LocalObjectReference = toJson_LocalObjectReference;
/**
 * Converts an object of type 'Endpoint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_Endpoint(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'addresses': (_a = obj.addresses) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'conditions': toJson_EndpointConditions(obj.conditions),
        'deprecatedTopology': ((obj.deprecatedTopology) === undefined) ? undefined : (Object.entries(obj.deprecatedTopology).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'hints': toJson_EndpointHints(obj.hints),
        'hostname': obj.hostname,
        'nodeName': obj.nodeName,
        'targetRef': toJson_ObjectReference(obj.targetRef),
        'zone': obj.zone,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_Endpoint = toJson_Endpoint;
/**
 * Converts an object of type 'EndpointPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_EndpointPort(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'appProtocol': obj.appProtocol,
        'name': obj.name,
        'port': obj.port,
        'protocol': obj.protocol,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_EndpointPort = toJson_EndpointPort;
/**
 * Converts an object of type 'EndpointV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_EndpointV1Beta1(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'addresses': (_a = obj.addresses) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'conditions': toJson_EndpointConditionsV1Beta1(obj.conditions),
        'hints': toJson_EndpointHintsV1Beta1(obj.hints),
        'hostname': obj.hostname,
        'nodeName': obj.nodeName,
        'targetRef': toJson_ObjectReference(obj.targetRef),
        'topology': ((obj.topology) === undefined) ? undefined : (Object.entries(obj.topology).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_EndpointV1Beta1 = toJson_EndpointV1Beta1;
/**
 * Converts an object of type 'EndpointPortV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_EndpointPortV1Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'appProtocol': obj.appProtocol,
        'name': obj.name,
        'port': obj.port,
        'protocol': obj.protocol,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_EndpointPortV1Beta1 = toJson_EndpointPortV1Beta1;
/**
 * Converts an object of type 'EventSeriesV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_EventSeriesV1Beta1(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'count': obj.count,
        'lastObservedTime': (_a = obj.lastObservedTime) === null || _a === void 0 ? void 0 : _a.toISOString(),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_EventSeriesV1Beta1 = toJson_EventSeriesV1Beta1;
/**
 * Converts an object of type 'FlowSchemaSpecV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_FlowSchemaSpecV1Beta1(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'distinguisherMethod': toJson_FlowDistinguisherMethodV1Beta1(obj.distinguisherMethod),
        'matchingPrecedence': obj.matchingPrecedence,
        'priorityLevelConfiguration': toJson_PriorityLevelConfigurationReferenceV1Beta1(obj.priorityLevelConfiguration),
        'rules': (_a = obj.rules) === null || _a === void 0 ? void 0 : _a.map(y => toJson_PolicyRulesWithSubjectsV1Beta1(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_FlowSchemaSpecV1Beta1 = toJson_FlowSchemaSpecV1Beta1;
/**
 * Converts an object of type 'PriorityLevelConfigurationSpecV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PriorityLevelConfigurationSpecV1Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'limited': toJson_LimitedPriorityLevelConfigurationV1Beta1(obj.limited),
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PriorityLevelConfigurationSpecV1Beta1 = toJson_PriorityLevelConfigurationSpecV1Beta1;
/**
 * Converts an object of type 'IngressSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_IngressSpec(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'defaultBackend': toJson_IngressBackend(obj.defaultBackend),
        'ingressClassName': obj.ingressClassName,
        'rules': (_a = obj.rules) === null || _a === void 0 ? void 0 : _a.map(y => toJson_IngressRule(y)),
        'tls': (_b = obj.tls) === null || _b === void 0 ? void 0 : _b.map(y => toJson_IngressTls(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_IngressSpec = toJson_IngressSpec;
/**
 * Converts an object of type 'IngressClassSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_IngressClassSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'controller': obj.controller,
        'parameters': toJson_IngressClassParametersReference(obj.parameters),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_IngressClassSpec = toJson_IngressClassSpec;
/**
 * Converts an object of type 'NetworkPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_NetworkPolicySpec(obj) {
    var _a, _b, _c;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'egress': (_a = obj.egress) === null || _a === void 0 ? void 0 : _a.map(y => toJson_NetworkPolicyEgressRule(y)),
        'ingress': (_b = obj.ingress) === null || _b === void 0 ? void 0 : _b.map(y => toJson_NetworkPolicyIngressRule(y)),
        'podSelector': toJson_LabelSelector(obj.podSelector),
        'policyTypes': (_c = obj.policyTypes) === null || _c === void 0 ? void 0 : _c.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_NetworkPolicySpec = toJson_NetworkPolicySpec;
/**
 * Converts an object of type 'Overhead' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_Overhead(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'podFixed': ((obj.podFixed) === undefined) ? undefined : (Object.entries(obj.podFixed).reduce((r, i) => { var _a; return (i[1] === undefined) ? r : ({ ...r, [i[0]]: (_a = i[1]) === null || _a === void 0 ? void 0 : _a.value }); }, {})),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_Overhead = toJson_Overhead;
/**
 * Converts an object of type 'Scheduling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_Scheduling(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'tolerations': (_a = obj.tolerations) === null || _a === void 0 ? void 0 : _a.map(y => toJson_Toleration(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_Scheduling = toJson_Scheduling;
/**
 * Converts an object of type 'RuntimeClassSpecV1Alpha1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_RuntimeClassSpecV1Alpha1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'overhead': toJson_OverheadV1Alpha1(obj.overhead),
        'runtimeHandler': obj.runtimeHandler,
        'scheduling': toJson_SchedulingV1Alpha1(obj.scheduling),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_RuntimeClassSpecV1Alpha1 = toJson_RuntimeClassSpecV1Alpha1;
/**
 * Converts an object of type 'OverheadV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_OverheadV1Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'podFixed': ((obj.podFixed) === undefined) ? undefined : (Object.entries(obj.podFixed).reduce((r, i) => { var _a; return (i[1] === undefined) ? r : ({ ...r, [i[0]]: (_a = i[1]) === null || _a === void 0 ? void 0 : _a.value }); }, {})),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_OverheadV1Beta1 = toJson_OverheadV1Beta1;
/**
 * Converts an object of type 'SchedulingV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_SchedulingV1Beta1(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'tolerations': (_a = obj.tolerations) === null || _a === void 0 ? void 0 : _a.map(y => toJson_Toleration(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_SchedulingV1Beta1 = toJson_SchedulingV1Beta1;
/**
 * Converts an object of type 'DeleteOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_DeleteOptions(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'apiVersion': obj.apiVersion,
        'dryRun': (_a = obj.dryRun) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'gracePeriodSeconds': obj.gracePeriodSeconds,
        'kind': obj.kind,
        'orphanDependents': obj.orphanDependents,
        'preconditions': toJson_Preconditions(obj.preconditions),
        'propagationPolicy': obj.propagationPolicy,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_DeleteOptions = toJson_DeleteOptions;
/**
 * Converts an object of type 'PodDisruptionBudgetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PodDisruptionBudgetSpec(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'maxUnavailable': (_a = obj.maxUnavailable) === null || _a === void 0 ? void 0 : _a.value,
        'minAvailable': (_b = obj.minAvailable) === null || _b === void 0 ? void 0 : _b.value,
        'selector': toJson_LabelSelector(obj.selector),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PodDisruptionBudgetSpec = toJson_PodDisruptionBudgetSpec;
/**
 * Converts an object of type 'PodDisruptionBudgetSpecV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PodDisruptionBudgetSpecV1Beta1(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'maxUnavailable': (_a = obj.maxUnavailable) === null || _a === void 0 ? void 0 : _a.value,
        'minAvailable': (_b = obj.minAvailable) === null || _b === void 0 ? void 0 : _b.value,
        'selector': toJson_LabelSelector(obj.selector),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PodDisruptionBudgetSpecV1Beta1 = toJson_PodDisruptionBudgetSpecV1Beta1;
/**
 * Converts an object of type 'PodSecurityPolicySpecV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PodSecurityPolicySpecV1Beta1(obj) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
        'allowedCSIDrivers': (_a = obj.allowedCsiDrivers) === null || _a === void 0 ? void 0 : _a.map(y => toJson_AllowedCsiDriverV1Beta1(y)),
        'allowedCapabilities': (_b = obj.allowedCapabilities) === null || _b === void 0 ? void 0 : _b.map(y => y),
        'allowedFlexVolumes': (_c = obj.allowedFlexVolumes) === null || _c === void 0 ? void 0 : _c.map(y => toJson_AllowedFlexVolumeV1Beta1(y)),
        'allowedHostPaths': (_d = obj.allowedHostPaths) === null || _d === void 0 ? void 0 : _d.map(y => toJson_AllowedHostPathV1Beta1(y)),
        'allowedProcMountTypes': (_e = obj.allowedProcMountTypes) === null || _e === void 0 ? void 0 : _e.map(y => y),
        'allowedUnsafeSysctls': (_f = obj.allowedUnsafeSysctls) === null || _f === void 0 ? void 0 : _f.map(y => y),
        'defaultAddCapabilities': (_g = obj.defaultAddCapabilities) === null || _g === void 0 ? void 0 : _g.map(y => y),
        'defaultAllowPrivilegeEscalation': obj.defaultAllowPrivilegeEscalation,
        'forbiddenSysctls': (_h = obj.forbiddenSysctls) === null || _h === void 0 ? void 0 : _h.map(y => y),
        'fsGroup': toJson_FsGroupStrategyOptionsV1Beta1(obj.fsGroup),
        'hostIPC': obj.hostIpc,
        'hostNetwork': obj.hostNetwork,
        'hostPID': obj.hostPid,
        'hostPorts': (_j = obj.hostPorts) === null || _j === void 0 ? void 0 : _j.map(y => toJson_HostPortRangeV1Beta1(y)),
        'privileged': obj.privileged,
        'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
        'requiredDropCapabilities': (_k = obj.requiredDropCapabilities) === null || _k === void 0 ? void 0 : _k.map(y => y),
        'runAsGroup': toJson_RunAsGroupStrategyOptionsV1Beta1(obj.runAsGroup),
        'runAsUser': toJson_RunAsUserStrategyOptionsV1Beta1(obj.runAsUser),
        'runtimeClass': toJson_RuntimeClassStrategyOptionsV1Beta1(obj.runtimeClass),
        'seLinux': toJson_SeLinuxStrategyOptionsV1Beta1(obj.seLinux),
        'supplementalGroups': toJson_SupplementalGroupsStrategyOptionsV1Beta1(obj.supplementalGroups),
        'volumes': (_l = obj.volumes) === null || _l === void 0 ? void 0 : _l.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PodSecurityPolicySpecV1Beta1 = toJson_PodSecurityPolicySpecV1Beta1;
/**
 * Converts an object of type 'AggregationRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_AggregationRule(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'clusterRoleSelectors': (_a = obj.clusterRoleSelectors) === null || _a === void 0 ? void 0 : _a.map(y => toJson_LabelSelector(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_AggregationRule = toJson_AggregationRule;
/**
 * Converts an object of type 'PolicyRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PolicyRule(obj) {
    var _a, _b, _c, _d, _e;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'apiGroups': (_a = obj.apiGroups) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'nonResourceURLs': (_b = obj.nonResourceUrLs) === null || _b === void 0 ? void 0 : _b.map(y => y),
        'resourceNames': (_c = obj.resourceNames) === null || _c === void 0 ? void 0 : _c.map(y => y),
        'resources': (_d = obj.resources) === null || _d === void 0 ? void 0 : _d.map(y => y),
        'verbs': (_e = obj.verbs) === null || _e === void 0 ? void 0 : _e.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PolicyRule = toJson_PolicyRule;
/**
 * Converts an object of type 'RoleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_RoleRef(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'apiGroup': obj.apiGroup,
        'kind': obj.kind,
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_RoleRef = toJson_RoleRef;
/**
 * Converts an object of type 'Subject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_Subject(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'apiGroup': obj.apiGroup,
        'kind': obj.kind,
        'name': obj.name,
        'namespace': obj.namespace,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_Subject = toJson_Subject;
/**
 * Converts an object of type 'AggregationRuleV1Alpha1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_AggregationRuleV1Alpha1(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'clusterRoleSelectors': (_a = obj.clusterRoleSelectors) === null || _a === void 0 ? void 0 : _a.map(y => toJson_LabelSelector(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_AggregationRuleV1Alpha1 = toJson_AggregationRuleV1Alpha1;
/**
 * Converts an object of type 'PolicyRuleV1Alpha1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PolicyRuleV1Alpha1(obj) {
    var _a, _b, _c, _d, _e;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'apiGroups': (_a = obj.apiGroups) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'nonResourceURLs': (_b = obj.nonResourceUrLs) === null || _b === void 0 ? void 0 : _b.map(y => y),
        'resourceNames': (_c = obj.resourceNames) === null || _c === void 0 ? void 0 : _c.map(y => y),
        'resources': (_d = obj.resources) === null || _d === void 0 ? void 0 : _d.map(y => y),
        'verbs': (_e = obj.verbs) === null || _e === void 0 ? void 0 : _e.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PolicyRuleV1Alpha1 = toJson_PolicyRuleV1Alpha1;
/**
 * Converts an object of type 'RoleRefV1Alpha1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_RoleRefV1Alpha1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'apiGroup': obj.apiGroup,
        'kind': obj.kind,
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_RoleRefV1Alpha1 = toJson_RoleRefV1Alpha1;
/**
 * Converts an object of type 'SubjectV1Alpha1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_SubjectV1Alpha1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'apiVersion': obj.apiVersion,
        'kind': obj.kind,
        'name': obj.name,
        'namespace': obj.namespace,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_SubjectV1Alpha1 = toJson_SubjectV1Alpha1;
/**
 * Converts an object of type 'CsiDriverSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_CsiDriverSpec(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'attachRequired': obj.attachRequired,
        'fsGroupPolicy': obj.fsGroupPolicy,
        'podInfoOnMount': obj.podInfoOnMount,
        'requiresRepublish': obj.requiresRepublish,
        'storageCapacity': obj.storageCapacity,
        'tokenRequests': (_a = obj.tokenRequests) === null || _a === void 0 ? void 0 : _a.map(y => toJson_TokenRequest(y)),
        'volumeLifecycleModes': (_b = obj.volumeLifecycleModes) === null || _b === void 0 ? void 0 : _b.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_CsiDriverSpec = toJson_CsiDriverSpec;
/**
 * Converts an object of type 'CsiNodeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_CsiNodeSpec(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'drivers': (_a = obj.drivers) === null || _a === void 0 ? void 0 : _a.map(y => toJson_CsiNodeDriver(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_CsiNodeSpec = toJson_CsiNodeSpec;
/**
 * Converts an object of type 'TopologySelectorTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_TopologySelectorTerm(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchLabelExpressions': (_a = obj.matchLabelExpressions) === null || _a === void 0 ? void 0 : _a.map(y => toJson_TopologySelectorLabelRequirement(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_TopologySelectorTerm = toJson_TopologySelectorTerm;
/**
 * Converts an object of type 'VolumeAttachmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_VolumeAttachmentSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'attacher': obj.attacher,
        'nodeName': obj.nodeName,
        'source': toJson_VolumeAttachmentSource(obj.source),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_VolumeAttachmentSpec = toJson_VolumeAttachmentSpec;
/* eslint-enable max-len, quote-props */
/**
 * @schema io.k8s.apimachinery.pkg.api.resource.Quantity
 */
class Quantity {
    constructor(value) {
        this.value = value;
    }
    static fromString(value) {
        return new Quantity(value);
    }
    static fromNumber(value) {
        return new Quantity(value);
    }
}
exports.Quantity = Quantity;
/**
 * Converts an object of type 'LabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_LabelSelector(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': (_a = obj.matchExpressions) === null || _a === void 0 ? void 0 : _a.map(y => toJson_LabelSelectorRequirement(y)),
        'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_LabelSelector = toJson_LabelSelector;
/**
 * Converts an object of type 'VolumeAttachmentSpecV1Alpha1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_VolumeAttachmentSpecV1Alpha1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'attacher': obj.attacher,
        'nodeName': obj.nodeName,
        'source': toJson_VolumeAttachmentSourceV1Alpha1(obj.source),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_VolumeAttachmentSpecV1Alpha1 = toJson_VolumeAttachmentSpecV1Alpha1;
/**
 * Converts an object of type 'CustomResourceDefinitionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_CustomResourceDefinitionSpec(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'conversion': toJson_CustomResourceConversion(obj.conversion),
        'group': obj.group,
        'names': toJson_CustomResourceDefinitionNames(obj.names),
        'preserveUnknownFields': obj.preserveUnknownFields,
        'scope': obj.scope,
        'versions': (_a = obj.versions) === null || _a === void 0 ? void 0 : _a.map(y => toJson_CustomResourceDefinitionVersion(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_CustomResourceDefinitionSpec = toJson_CustomResourceDefinitionSpec;
/**
 * Converts an object of type 'StatusDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_StatusDetails(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'causes': (_a = obj.causes) === null || _a === void 0 ? void 0 : _a.map(y => toJson_StatusCause(y)),
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
        'retryAfterSeconds': obj.retryAfterSeconds,
        'uid': obj.uid,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_StatusDetails = toJson_StatusDetails;
/**
 * Converts an object of type 'ApiServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ApiServiceSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'caBundle': obj.caBundle,
        'group': obj.group,
        'groupPriorityMinimum': obj.groupPriorityMinimum,
        'insecureSkipTLSVerify': obj.insecureSkipTlsVerify,
        'service': toJson_ServiceReference(obj.service),
        'version': obj.version,
        'versionPriority': obj.versionPriority,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ApiServiceSpec = toJson_ApiServiceSpec;
/**
 * Converts an object of type 'ManagedFieldsEntry' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ManagedFieldsEntry(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'apiVersion': obj.apiVersion,
        'fieldsType': obj.fieldsType,
        'fieldsV1': obj.fieldsV1,
        'manager': obj.manager,
        'operation': obj.operation,
        'subresource': obj.subresource,
        'time': (_a = obj.time) === null || _a === void 0 ? void 0 : _a.toISOString(),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ManagedFieldsEntry = toJson_ManagedFieldsEntry;
/**
 * Converts an object of type 'OwnerReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_OwnerReference(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'apiVersion': obj.apiVersion,
        'blockOwnerDeletion': obj.blockOwnerDeletion,
        'controller': obj.controller,
        'kind': obj.kind,
        'name': obj.name,
        'uid': obj.uid,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_OwnerReference = toJson_OwnerReference;
/**
 * Converts an object of type 'WebhookClientConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_WebhookClientConfig(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'caBundle': obj.caBundle,
        'service': toJson_ServiceReference(obj.service),
        'url': obj.url,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_WebhookClientConfig = toJson_WebhookClientConfig;
/**
 * Converts an object of type 'RuleWithOperations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_RuleWithOperations(obj) {
    var _a, _b, _c, _d;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'apiGroups': (_a = obj.apiGroups) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'apiVersions': (_b = obj.apiVersions) === null || _b === void 0 ? void 0 : _b.map(y => y),
        'operations': (_c = obj.operations) === null || _c === void 0 ? void 0 : _c.map(y => y),
        'resources': (_d = obj.resources) === null || _d === void 0 ? void 0 : _d.map(y => y),
        'scope': obj.scope,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_RuleWithOperations = toJson_RuleWithOperations;
/**
 * Converts an object of type 'DaemonSetUpdateStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_DaemonSetUpdateStrategy(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'rollingUpdate': toJson_RollingUpdateDaemonSet(obj.rollingUpdate),
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_DaemonSetUpdateStrategy = toJson_DaemonSetUpdateStrategy;
/**
 * Converts an object of type 'DeploymentStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_DeploymentStrategy(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'rollingUpdate': toJson_RollingUpdateDeployment(obj.rollingUpdate),
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_DeploymentStrategy = toJson_DeploymentStrategy;
/**
 * Converts an object of type 'StatefulSetUpdateStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_StatefulSetUpdateStrategy(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'rollingUpdate': toJson_RollingUpdateStatefulSetStrategy(obj.rollingUpdate),
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_StatefulSetUpdateStrategy = toJson_StatefulSetUpdateStrategy;
/**
 * Converts an object of type 'BoundObjectReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_BoundObjectReference(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'apiVersion': obj.apiVersion,
        'kind': obj.kind,
        'name': obj.name,
        'uid': obj.uid,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_BoundObjectReference = toJson_BoundObjectReference;
/**
 * Converts an object of type 'NonResourceAttributes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_NonResourceAttributes(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'path': obj.path,
        'verb': obj.verb,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_NonResourceAttributes = toJson_NonResourceAttributes;
/**
 * Converts an object of type 'ResourceAttributes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ResourceAttributes(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'name': obj.name,
        'namespace': obj.namespace,
        'resource': obj.resource,
        'subresource': obj.subresource,
        'verb': obj.verb,
        'version': obj.version,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ResourceAttributes = toJson_ResourceAttributes;
/**
 * Converts an object of type 'CrossVersionObjectReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_CrossVersionObjectReference(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'apiVersion': obj.apiVersion,
        'kind': obj.kind,
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_CrossVersionObjectReference = toJson_CrossVersionObjectReference;
/**
 * Converts an object of type 'MetricSpecV2Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_MetricSpecV2Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'containerResource': toJson_ContainerResourceMetricSourceV2Beta1(obj.containerResource),
        'external': toJson_ExternalMetricSourceV2Beta1(obj.external),
        'object': toJson_ObjectMetricSourceV2Beta1(obj.object),
        'pods': toJson_PodsMetricSourceV2Beta1(obj.pods),
        'resource': toJson_ResourceMetricSourceV2Beta1(obj.resource),
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_MetricSpecV2Beta1 = toJson_MetricSpecV2Beta1;
/**
 * Converts an object of type 'CrossVersionObjectReferenceV2Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_CrossVersionObjectReferenceV2Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'apiVersion': obj.apiVersion,
        'kind': obj.kind,
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_CrossVersionObjectReferenceV2Beta1 = toJson_CrossVersionObjectReferenceV2Beta1;
/**
 * Converts an object of type 'HorizontalPodAutoscalerBehaviorV2Beta2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_HorizontalPodAutoscalerBehaviorV2Beta2(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'scaleDown': toJson_HpaScalingRulesV2Beta2(obj.scaleDown),
        'scaleUp': toJson_HpaScalingRulesV2Beta2(obj.scaleUp),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_HorizontalPodAutoscalerBehaviorV2Beta2 = toJson_HorizontalPodAutoscalerBehaviorV2Beta2;
/**
 * Converts an object of type 'MetricSpecV2Beta2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_MetricSpecV2Beta2(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'containerResource': toJson_ContainerResourceMetricSourceV2Beta2(obj.containerResource),
        'external': toJson_ExternalMetricSourceV2Beta2(obj.external),
        'object': toJson_ObjectMetricSourceV2Beta2(obj.object),
        'pods': toJson_PodsMetricSourceV2Beta2(obj.pods),
        'resource': toJson_ResourceMetricSourceV2Beta2(obj.resource),
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_MetricSpecV2Beta2 = toJson_MetricSpecV2Beta2;
/**
 * Converts an object of type 'CrossVersionObjectReferenceV2Beta2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_CrossVersionObjectReferenceV2Beta2(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'apiVersion': obj.apiVersion,
        'kind': obj.kind,
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_CrossVersionObjectReferenceV2Beta2 = toJson_CrossVersionObjectReferenceV2Beta2;
/**
 * Converts an object of type 'JobTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_JobTemplateSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_JobSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_JobTemplateSpec = toJson_JobTemplateSpec;
/**
 * Converts an object of type 'JobTemplateSpecV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_JobTemplateSpecV1Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_JobSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_JobTemplateSpecV1Beta1 = toJson_JobTemplateSpecV1Beta1;
/**
 * Converts an object of type 'EndpointAddress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_EndpointAddress(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'hostname': obj.hostname,
        'ip': obj.ip,
        'nodeName': obj.nodeName,
        'targetRef': toJson_ObjectReference(obj.targetRef),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_EndpointAddress = toJson_EndpointAddress;
/**
 * Converts an object of type 'LimitRangeItem' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_LimitRangeItem(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'default': ((obj.default) === undefined) ? undefined : (Object.entries(obj.default).reduce((r, i) => { var _a; return (i[1] === undefined) ? r : ({ ...r, [i[0]]: (_a = i[1]) === null || _a === void 0 ? void 0 : _a.value }); }, {})),
        'defaultRequest': ((obj.defaultRequest) === undefined) ? undefined : (Object.entries(obj.defaultRequest).reduce((r, i) => { var _a; return (i[1] === undefined) ? r : ({ ...r, [i[0]]: (_a = i[1]) === null || _a === void 0 ? void 0 : _a.value }); }, {})),
        'max': ((obj.max) === undefined) ? undefined : (Object.entries(obj.max).reduce((r, i) => { var _a; return (i[1] === undefined) ? r : ({ ...r, [i[0]]: (_a = i[1]) === null || _a === void 0 ? void 0 : _a.value }); }, {})),
        'maxLimitRequestRatio': ((obj.maxLimitRequestRatio) === undefined) ? undefined : (Object.entries(obj.maxLimitRequestRatio).reduce((r, i) => { var _a; return (i[1] === undefined) ? r : ({ ...r, [i[0]]: (_a = i[1]) === null || _a === void 0 ? void 0 : _a.value }); }, {})),
        'min': ((obj.min) === undefined) ? undefined : (Object.entries(obj.min).reduce((r, i) => { var _a; return (i[1] === undefined) ? r : ({ ...r, [i[0]]: (_a = i[1]) === null || _a === void 0 ? void 0 : _a.value }); }, {})),
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_LimitRangeItem = toJson_LimitRangeItem;
/**
 * Converts an object of type 'NodeConfigSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_NodeConfigSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'configMap': toJson_ConfigMapNodeConfigSource(obj.configMap),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_NodeConfigSource = toJson_NodeConfigSource;
/**
 * Converts an object of type 'Taint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_Taint(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'effect': obj.effect,
        'key': obj.key,
        'timeAdded': (_a = obj.timeAdded) === null || _a === void 0 ? void 0 : _a.toISOString(),
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_Taint = toJson_Taint;
/**
 * Converts an object of type 'AwsElasticBlockStoreVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_AwsElasticBlockStoreVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'fsType': obj.fsType,
        'partition': obj.partition,
        'readOnly': obj.readOnly,
        'volumeID': obj.volumeId,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_AwsElasticBlockStoreVolumeSource = toJson_AwsElasticBlockStoreVolumeSource;
/**
 * Converts an object of type 'AzureDiskVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_AzureDiskVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'cachingMode': obj.cachingMode,
        'diskName': obj.diskName,
        'diskURI': obj.diskUri,
        'fsType': obj.fsType,
        'kind': obj.kind,
        'readOnly': obj.readOnly,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_AzureDiskVolumeSource = toJson_AzureDiskVolumeSource;
/**
 * Converts an object of type 'AzureFilePersistentVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_AzureFilePersistentVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'readOnly': obj.readOnly,
        'secretName': obj.secretName,
        'secretNamespace': obj.secretNamespace,
        'shareName': obj.shareName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_AzureFilePersistentVolumeSource = toJson_AzureFilePersistentVolumeSource;
/**
 * Converts an object of type 'CephFsPersistentVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_CephFsPersistentVolumeSource(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'monitors': (_a = obj.monitors) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'path': obj.path,
        'readOnly': obj.readOnly,
        'secretFile': obj.secretFile,
        'secretRef': toJson_SecretReference(obj.secretRef),
        'user': obj.user,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_CephFsPersistentVolumeSource = toJson_CephFsPersistentVolumeSource;
/**
 * Converts an object of type 'CinderPersistentVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_CinderPersistentVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'fsType': obj.fsType,
        'readOnly': obj.readOnly,
        'secretRef': toJson_SecretReference(obj.secretRef),
        'volumeID': obj.volumeId,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_CinderPersistentVolumeSource = toJson_CinderPersistentVolumeSource;
/**
 * Converts an object of type 'CsiPersistentVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_CsiPersistentVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'controllerExpandSecretRef': toJson_SecretReference(obj.controllerExpandSecretRef),
        'controllerPublishSecretRef': toJson_SecretReference(obj.controllerPublishSecretRef),
        'driver': obj.driver,
        'fsType': obj.fsType,
        'nodePublishSecretRef': toJson_SecretReference(obj.nodePublishSecretRef),
        'nodeStageSecretRef': toJson_SecretReference(obj.nodeStageSecretRef),
        'readOnly': obj.readOnly,
        'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'volumeHandle': obj.volumeHandle,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_CsiPersistentVolumeSource = toJson_CsiPersistentVolumeSource;
/**
 * Converts an object of type 'FcVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_FcVolumeSource(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'fsType': obj.fsType,
        'lun': obj.lun,
        'readOnly': obj.readOnly,
        'targetWWNs': (_a = obj.targetWwNs) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'wwids': (_b = obj.wwids) === null || _b === void 0 ? void 0 : _b.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_FcVolumeSource = toJson_FcVolumeSource;
/**
 * Converts an object of type 'FlexPersistentVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_FlexPersistentVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'driver': obj.driver,
        'fsType': obj.fsType,
        'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'readOnly': obj.readOnly,
        'secretRef': toJson_SecretReference(obj.secretRef),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_FlexPersistentVolumeSource = toJson_FlexPersistentVolumeSource;
/**
 * Converts an object of type 'FlockerVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_FlockerVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'datasetName': obj.datasetName,
        'datasetUUID': obj.datasetUuid,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_FlockerVolumeSource = toJson_FlockerVolumeSource;
/**
 * Converts an object of type 'GcePersistentDiskVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_GcePersistentDiskVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'fsType': obj.fsType,
        'partition': obj.partition,
        'pdName': obj.pdName,
        'readOnly': obj.readOnly,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_GcePersistentDiskVolumeSource = toJson_GcePersistentDiskVolumeSource;
/**
 * Converts an object of type 'GlusterfsPersistentVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_GlusterfsPersistentVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'endpoints': obj.endpoints,
        'endpointsNamespace': obj.endpointsNamespace,
        'path': obj.path,
        'readOnly': obj.readOnly,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_GlusterfsPersistentVolumeSource = toJson_GlusterfsPersistentVolumeSource;
/**
 * Converts an object of type 'HostPathVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_HostPathVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'path': obj.path,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_HostPathVolumeSource = toJson_HostPathVolumeSource;
/**
 * Converts an object of type 'IscsiPersistentVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_IscsiPersistentVolumeSource(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'chapAuthDiscovery': obj.chapAuthDiscovery,
        'chapAuthSession': obj.chapAuthSession,
        'fsType': obj.fsType,
        'initiatorName': obj.initiatorName,
        'iqn': obj.iqn,
        'iscsiInterface': obj.iscsiInterface,
        'lun': obj.lun,
        'portals': (_a = obj.portals) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'readOnly': obj.readOnly,
        'secretRef': toJson_SecretReference(obj.secretRef),
        'targetPortal': obj.targetPortal,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_IscsiPersistentVolumeSource = toJson_IscsiPersistentVolumeSource;
/**
 * Converts an object of type 'LocalVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_LocalVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'fsType': obj.fsType,
        'path': obj.path,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_LocalVolumeSource = toJson_LocalVolumeSource;
/**
 * Converts an object of type 'NfsVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_NfsVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'path': obj.path,
        'readOnly': obj.readOnly,
        'server': obj.server,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_NfsVolumeSource = toJson_NfsVolumeSource;
/**
 * Converts an object of type 'VolumeNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_VolumeNodeAffinity(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'required': toJson_NodeSelector(obj.required),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_VolumeNodeAffinity = toJson_VolumeNodeAffinity;
/**
 * Converts an object of type 'PhotonPersistentDiskVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PhotonPersistentDiskVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'fsType': obj.fsType,
        'pdID': obj.pdId,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PhotonPersistentDiskVolumeSource = toJson_PhotonPersistentDiskVolumeSource;
/**
 * Converts an object of type 'PortworxVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PortworxVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'fsType': obj.fsType,
        'readOnly': obj.readOnly,
        'volumeID': obj.volumeId,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PortworxVolumeSource = toJson_PortworxVolumeSource;
/**
 * Converts an object of type 'QuobyteVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_QuobyteVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'readOnly': obj.readOnly,
        'registry': obj.registry,
        'tenant': obj.tenant,
        'user': obj.user,
        'volume': obj.volume,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_QuobyteVolumeSource = toJson_QuobyteVolumeSource;
/**
 * Converts an object of type 'RbdPersistentVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_RbdPersistentVolumeSource(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'fsType': obj.fsType,
        'image': obj.image,
        'keyring': obj.keyring,
        'monitors': (_a = obj.monitors) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'pool': obj.pool,
        'readOnly': obj.readOnly,
        'secretRef': toJson_SecretReference(obj.secretRef),
        'user': obj.user,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_RbdPersistentVolumeSource = toJson_RbdPersistentVolumeSource;
/**
 * Converts an object of type 'ScaleIoPersistentVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ScaleIoPersistentVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'fsType': obj.fsType,
        'gateway': obj.gateway,
        'protectionDomain': obj.protectionDomain,
        'readOnly': obj.readOnly,
        'secretRef': toJson_SecretReference(obj.secretRef),
        'sslEnabled': obj.sslEnabled,
        'storageMode': obj.storageMode,
        'storagePool': obj.storagePool,
        'system': obj.system,
        'volumeName': obj.volumeName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ScaleIoPersistentVolumeSource = toJson_ScaleIoPersistentVolumeSource;
/**
 * Converts an object of type 'StorageOsPersistentVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_StorageOsPersistentVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'fsType': obj.fsType,
        'readOnly': obj.readOnly,
        'secretRef': toJson_ObjectReference(obj.secretRef),
        'volumeName': obj.volumeName,
        'volumeNamespace': obj.volumeNamespace,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_StorageOsPersistentVolumeSource = toJson_StorageOsPersistentVolumeSource;
/**
 * Converts an object of type 'VsphereVirtualDiskVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_VsphereVirtualDiskVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'fsType': obj.fsType,
        'storagePolicyID': obj.storagePolicyId,
        'storagePolicyName': obj.storagePolicyName,
        'volumePath': obj.volumePath,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_VsphereVirtualDiskVolumeSource = toJson_VsphereVirtualDiskVolumeSource;
/**
 * Converts an object of type 'TypedLocalObjectReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_TypedLocalObjectReference(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'apiGroup': obj.apiGroup,
        'kind': obj.kind,
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_TypedLocalObjectReference = toJson_TypedLocalObjectReference;
/**
 * Converts an object of type 'ResourceRequirements' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ResourceRequirements(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => { var _a; return (i[1] === undefined) ? r : ({ ...r, [i[0]]: (_a = i[1]) === null || _a === void 0 ? void 0 : _a.value }); }, {})),
        'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => { var _a; return (i[1] === undefined) ? r : ({ ...r, [i[0]]: (_a = i[1]) === null || _a === void 0 ? void 0 : _a.value }); }, {})),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ResourceRequirements = toJson_ResourceRequirements;
/**
 * Converts an object of type 'Affinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_Affinity(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'nodeAffinity': toJson_NodeAffinity(obj.nodeAffinity),
        'podAffinity': toJson_PodAffinity(obj.podAffinity),
        'podAntiAffinity': toJson_PodAntiAffinity(obj.podAntiAffinity),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_Affinity = toJson_Affinity;
/**
 * Converts an object of type 'Container' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_Container(obj) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'args': (_a = obj.args) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'command': (_b = obj.command) === null || _b === void 0 ? void 0 : _b.map(y => y),
        'env': (_c = obj.env) === null || _c === void 0 ? void 0 : _c.map(y => toJson_EnvVar(y)),
        'envFrom': (_d = obj.envFrom) === null || _d === void 0 ? void 0 : _d.map(y => toJson_EnvFromSource(y)),
        'image': obj.image,
        'imagePullPolicy': obj.imagePullPolicy,
        'lifecycle': toJson_Lifecycle(obj.lifecycle),
        'livenessProbe': toJson_Probe(obj.livenessProbe),
        'name': obj.name,
        'ports': (_e = obj.ports) === null || _e === void 0 ? void 0 : _e.map(y => toJson_ContainerPort(y)),
        'readinessProbe': toJson_Probe(obj.readinessProbe),
        'resources': toJson_ResourceRequirements(obj.resources),
        'securityContext': toJson_SecurityContext(obj.securityContext),
        'startupProbe': toJson_Probe(obj.startupProbe),
        'stdin': obj.stdin,
        'stdinOnce': obj.stdinOnce,
        'terminationMessagePath': obj.terminationMessagePath,
        'terminationMessagePolicy': obj.terminationMessagePolicy,
        'tty': obj.tty,
        'volumeDevices': (_f = obj.volumeDevices) === null || _f === void 0 ? void 0 : _f.map(y => toJson_VolumeDevice(y)),
        'volumeMounts': (_g = obj.volumeMounts) === null || _g === void 0 ? void 0 : _g.map(y => toJson_VolumeMount(y)),
        'workingDir': obj.workingDir,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_Container = toJson_Container;
/**
 * Converts an object of type 'PodDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PodDnsConfig(obj) {
    var _a, _b, _c;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'nameservers': (_a = obj.nameservers) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'options': (_b = obj.options) === null || _b === void 0 ? void 0 : _b.map(y => toJson_PodDnsConfigOption(y)),
        'searches': (_c = obj.searches) === null || _c === void 0 ? void 0 : _c.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PodDnsConfig = toJson_PodDnsConfig;
/**
 * Converts an object of type 'EphemeralContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_EphemeralContainer(obj) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'args': (_a = obj.args) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'command': (_b = obj.command) === null || _b === void 0 ? void 0 : _b.map(y => y),
        'env': (_c = obj.env) === null || _c === void 0 ? void 0 : _c.map(y => toJson_EnvVar(y)),
        'envFrom': (_d = obj.envFrom) === null || _d === void 0 ? void 0 : _d.map(y => toJson_EnvFromSource(y)),
        'image': obj.image,
        'imagePullPolicy': obj.imagePullPolicy,
        'lifecycle': toJson_Lifecycle(obj.lifecycle),
        'livenessProbe': toJson_Probe(obj.livenessProbe),
        'name': obj.name,
        'ports': (_e = obj.ports) === null || _e === void 0 ? void 0 : _e.map(y => toJson_ContainerPort(y)),
        'readinessProbe': toJson_Probe(obj.readinessProbe),
        'resources': toJson_ResourceRequirements(obj.resources),
        'securityContext': toJson_SecurityContext(obj.securityContext),
        'startupProbe': toJson_Probe(obj.startupProbe),
        'stdin': obj.stdin,
        'stdinOnce': obj.stdinOnce,
        'targetContainerName': obj.targetContainerName,
        'terminationMessagePath': obj.terminationMessagePath,
        'terminationMessagePolicy': obj.terminationMessagePolicy,
        'tty': obj.tty,
        'volumeDevices': (_f = obj.volumeDevices) === null || _f === void 0 ? void 0 : _f.map(y => toJson_VolumeDevice(y)),
        'volumeMounts': (_g = obj.volumeMounts) === null || _g === void 0 ? void 0 : _g.map(y => toJson_VolumeMount(y)),
        'workingDir': obj.workingDir,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_EphemeralContainer = toJson_EphemeralContainer;
/**
 * Converts an object of type 'HostAlias' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_HostAlias(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'hostnames': (_a = obj.hostnames) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'ip': obj.ip,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_HostAlias = toJson_HostAlias;
/**
 * Converts an object of type 'PodReadinessGate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PodReadinessGate(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'conditionType': obj.conditionType,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PodReadinessGate = toJson_PodReadinessGate;
/**
 * Converts an object of type 'PodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PodSecurityContext(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'fsGroup': obj.fsGroup,
        'fsGroupChangePolicy': obj.fsGroupChangePolicy,
        'runAsGroup': obj.runAsGroup,
        'runAsNonRoot': obj.runAsNonRoot,
        'runAsUser': obj.runAsUser,
        'seLinuxOptions': toJson_SeLinuxOptions(obj.seLinuxOptions),
        'seccompProfile': toJson_SeccompProfile(obj.seccompProfile),
        'supplementalGroups': (_a = obj.supplementalGroups) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'sysctls': (_b = obj.sysctls) === null || _b === void 0 ? void 0 : _b.map(y => toJson_Sysctl(y)),
        'windowsOptions': toJson_WindowsSecurityContextOptions(obj.windowsOptions),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PodSecurityContext = toJson_PodSecurityContext;
/**
 * Converts an object of type 'Toleration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_Toleration(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'effect': obj.effect,
        'key': obj.key,
        'operator': obj.operator,
        'tolerationSeconds': obj.tolerationSeconds,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_Toleration = toJson_Toleration;
/**
 * Converts an object of type 'TopologySpreadConstraint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_TopologySpreadConstraint(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_LabelSelector(obj.labelSelector),
        'maxSkew': obj.maxSkew,
        'topologyKey': obj.topologyKey,
        'whenUnsatisfiable': obj.whenUnsatisfiable,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_TopologySpreadConstraint = toJson_TopologySpreadConstraint;
/**
 * Converts an object of type 'Volume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_Volume(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'awsElasticBlockStore': toJson_AwsElasticBlockStoreVolumeSource(obj.awsElasticBlockStore),
        'azureDisk': toJson_AzureDiskVolumeSource(obj.azureDisk),
        'azureFile': toJson_AzureFileVolumeSource(obj.azureFile),
        'cephfs': toJson_CephFsVolumeSource(obj.cephfs),
        'cinder': toJson_CinderVolumeSource(obj.cinder),
        'configMap': toJson_ConfigMapVolumeSource(obj.configMap),
        'csi': toJson_CsiVolumeSource(obj.csi),
        'downwardAPI': toJson_DownwardApiVolumeSource(obj.downwardApi),
        'emptyDir': toJson_EmptyDirVolumeSource(obj.emptyDir),
        'ephemeral': toJson_EphemeralVolumeSource(obj.ephemeral),
        'fc': toJson_FcVolumeSource(obj.fc),
        'flexVolume': toJson_FlexVolumeSource(obj.flexVolume),
        'flocker': toJson_FlockerVolumeSource(obj.flocker),
        'gcePersistentDisk': toJson_GcePersistentDiskVolumeSource(obj.gcePersistentDisk),
        'gitRepo': toJson_GitRepoVolumeSource(obj.gitRepo),
        'glusterfs': toJson_GlusterfsVolumeSource(obj.glusterfs),
        'hostPath': toJson_HostPathVolumeSource(obj.hostPath),
        'iscsi': toJson_IscsiVolumeSource(obj.iscsi),
        'name': obj.name,
        'nfs': toJson_NfsVolumeSource(obj.nfs),
        'persistentVolumeClaim': toJson_PersistentVolumeClaimVolumeSource(obj.persistentVolumeClaim),
        'photonPersistentDisk': toJson_PhotonPersistentDiskVolumeSource(obj.photonPersistentDisk),
        'portworxVolume': toJson_PortworxVolumeSource(obj.portworxVolume),
        'projected': toJson_ProjectedVolumeSource(obj.projected),
        'quobyte': toJson_QuobyteVolumeSource(obj.quobyte),
        'rbd': toJson_RbdVolumeSource(obj.rbd),
        'scaleIO': toJson_ScaleIoVolumeSource(obj.scaleIo),
        'secret': toJson_SecretVolumeSource(obj.secret),
        'storageos': toJson_StorageOsVolumeSource(obj.storageos),
        'vsphereVolume': toJson_VsphereVirtualDiskVolumeSource(obj.vsphereVolume),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_Volume = toJson_Volume;
/**
 * Converts an object of type 'ScopeSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ScopeSelector(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': (_a = obj.matchExpressions) === null || _a === void 0 ? void 0 : _a.map(y => toJson_ScopedResourceSelectorRequirement(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ScopeSelector = toJson_ScopeSelector;
/**
 * Converts an object of type 'ServicePort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ServicePort(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'appProtocol': obj.appProtocol,
        'name': obj.name,
        'nodePort': obj.nodePort,
        'port': obj.port,
        'protocol': obj.protocol,
        'targetPort': (_a = obj.targetPort) === null || _a === void 0 ? void 0 : _a.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ServicePort = toJson_ServicePort;
/**
 * Converts an object of type 'SessionAffinityConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_SessionAffinityConfig(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'clientIP': toJson_ClientIpConfig(obj.clientIp),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_SessionAffinityConfig = toJson_SessionAffinityConfig;
/**
 * Converts an object of type 'EndpointConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_EndpointConditions(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'ready': obj.ready,
        'serving': obj.serving,
        'terminating': obj.terminating,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_EndpointConditions = toJson_EndpointConditions;
/**
 * Converts an object of type 'EndpointHints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_EndpointHints(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'forZones': (_a = obj.forZones) === null || _a === void 0 ? void 0 : _a.map(y => toJson_ForZone(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_EndpointHints = toJson_EndpointHints;
/**
 * Converts an object of type 'EndpointConditionsV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_EndpointConditionsV1Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'ready': obj.ready,
        'serving': obj.serving,
        'terminating': obj.terminating,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_EndpointConditionsV1Beta1 = toJson_EndpointConditionsV1Beta1;
/**
 * Converts an object of type 'EndpointHintsV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_EndpointHintsV1Beta1(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'forZones': (_a = obj.forZones) === null || _a === void 0 ? void 0 : _a.map(y => toJson_ForZoneV1Beta1(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_EndpointHintsV1Beta1 = toJson_EndpointHintsV1Beta1;
/**
 * Converts an object of type 'FlowDistinguisherMethodV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_FlowDistinguisherMethodV1Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_FlowDistinguisherMethodV1Beta1 = toJson_FlowDistinguisherMethodV1Beta1;
/**
 * Converts an object of type 'PriorityLevelConfigurationReferenceV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PriorityLevelConfigurationReferenceV1Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PriorityLevelConfigurationReferenceV1Beta1 = toJson_PriorityLevelConfigurationReferenceV1Beta1;
/**
 * Converts an object of type 'PolicyRulesWithSubjectsV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PolicyRulesWithSubjectsV1Beta1(obj) {
    var _a, _b, _c;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'nonResourceRules': (_a = obj.nonResourceRules) === null || _a === void 0 ? void 0 : _a.map(y => toJson_NonResourcePolicyRuleV1Beta1(y)),
        'resourceRules': (_b = obj.resourceRules) === null || _b === void 0 ? void 0 : _b.map(y => toJson_ResourcePolicyRuleV1Beta1(y)),
        'subjects': (_c = obj.subjects) === null || _c === void 0 ? void 0 : _c.map(y => toJson_SubjectV1Beta1(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PolicyRulesWithSubjectsV1Beta1 = toJson_PolicyRulesWithSubjectsV1Beta1;
/**
 * Converts an object of type 'LimitedPriorityLevelConfigurationV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_LimitedPriorityLevelConfigurationV1Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'assuredConcurrencyShares': obj.assuredConcurrencyShares,
        'limitResponse': toJson_LimitResponseV1Beta1(obj.limitResponse),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_LimitedPriorityLevelConfigurationV1Beta1 = toJson_LimitedPriorityLevelConfigurationV1Beta1;
/**
 * Converts an object of type 'IngressBackend' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_IngressBackend(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'resource': toJson_TypedLocalObjectReference(obj.resource),
        'service': toJson_IngressServiceBackend(obj.service),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_IngressBackend = toJson_IngressBackend;
/**
 * Converts an object of type 'IngressRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_IngressRule(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'host': obj.host,
        'http': toJson_HttpIngressRuleValue(obj.http),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_IngressRule = toJson_IngressRule;
/**
 * Converts an object of type 'IngressTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_IngressTls(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'hosts': (_a = obj.hosts) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'secretName': obj.secretName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_IngressTls = toJson_IngressTls;
/**
 * Converts an object of type 'IngressClassParametersReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_IngressClassParametersReference(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'apiGroup': obj.apiGroup,
        'kind': obj.kind,
        'name': obj.name,
        'namespace': obj.namespace,
        'scope': obj.scope,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_IngressClassParametersReference = toJson_IngressClassParametersReference;
/**
 * Converts an object of type 'NetworkPolicyEgressRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_NetworkPolicyEgressRule(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'ports': (_a = obj.ports) === null || _a === void 0 ? void 0 : _a.map(y => toJson_NetworkPolicyPort(y)),
        'to': (_b = obj.to) === null || _b === void 0 ? void 0 : _b.map(y => toJson_NetworkPolicyPeer(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_NetworkPolicyEgressRule = toJson_NetworkPolicyEgressRule;
/**
 * Converts an object of type 'NetworkPolicyIngressRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_NetworkPolicyIngressRule(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'from': (_a = obj.from) === null || _a === void 0 ? void 0 : _a.map(y => toJson_NetworkPolicyPeer(y)),
        'ports': (_b = obj.ports) === null || _b === void 0 ? void 0 : _b.map(y => toJson_NetworkPolicyPort(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_NetworkPolicyIngressRule = toJson_NetworkPolicyIngressRule;
/**
 * Converts an object of type 'OverheadV1Alpha1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_OverheadV1Alpha1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'podFixed': ((obj.podFixed) === undefined) ? undefined : (Object.entries(obj.podFixed).reduce((r, i) => { var _a; return (i[1] === undefined) ? r : ({ ...r, [i[0]]: (_a = i[1]) === null || _a === void 0 ? void 0 : _a.value }); }, {})),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_OverheadV1Alpha1 = toJson_OverheadV1Alpha1;
/**
 * Converts an object of type 'SchedulingV1Alpha1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_SchedulingV1Alpha1(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'tolerations': (_a = obj.tolerations) === null || _a === void 0 ? void 0 : _a.map(y => toJson_Toleration(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_SchedulingV1Alpha1 = toJson_SchedulingV1Alpha1;
/* eslint-enable max-len, quote-props */
/**
 * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
 *
 * @schema IoK8SApimachineryPkgApisMetaV1DeleteOptionsKind
 */
var IoK8SApimachineryPkgApisMetaV1DeleteOptionsKind;
(function (IoK8SApimachineryPkgApisMetaV1DeleteOptionsKind) {
    /** DeleteOptions */
    IoK8SApimachineryPkgApisMetaV1DeleteOptionsKind["DELETE_OPTIONS"] = "DeleteOptions";
})(IoK8SApimachineryPkgApisMetaV1DeleteOptionsKind = exports.IoK8SApimachineryPkgApisMetaV1DeleteOptionsKind || (exports.IoK8SApimachineryPkgApisMetaV1DeleteOptionsKind = {}));
/**
 * Converts an object of type 'Preconditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_Preconditions(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'resourceVersion': obj.resourceVersion,
        'uid': obj.uid,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_Preconditions = toJson_Preconditions;
/* eslint-enable max-len, quote-props */
/**
 * @schema io.k8s.apimachinery.pkg.util.intstr.IntOrString
 */
class IntOrString {
    constructor(value) {
        this.value = value;
    }
    static fromString(value) {
        return new IntOrString(value);
    }
    static fromNumber(value) {
        return new IntOrString(value);
    }
}
exports.IntOrString = IntOrString;
/**
 * Converts an object of type 'AllowedCsiDriverV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_AllowedCsiDriverV1Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_AllowedCsiDriverV1Beta1 = toJson_AllowedCsiDriverV1Beta1;
/**
 * Converts an object of type 'AllowedFlexVolumeV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_AllowedFlexVolumeV1Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'driver': obj.driver,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_AllowedFlexVolumeV1Beta1 = toJson_AllowedFlexVolumeV1Beta1;
/**
 * Converts an object of type 'AllowedHostPathV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_AllowedHostPathV1Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'pathPrefix': obj.pathPrefix,
        'readOnly': obj.readOnly,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_AllowedHostPathV1Beta1 = toJson_AllowedHostPathV1Beta1;
/**
 * Converts an object of type 'FsGroupStrategyOptionsV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_FsGroupStrategyOptionsV1Beta1(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'ranges': (_a = obj.ranges) === null || _a === void 0 ? void 0 : _a.map(y => toJson_IdRangeV1Beta1(y)),
        'rule': obj.rule,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_FsGroupStrategyOptionsV1Beta1 = toJson_FsGroupStrategyOptionsV1Beta1;
/**
 * Converts an object of type 'HostPortRangeV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_HostPortRangeV1Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'max': obj.max,
        'min': obj.min,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_HostPortRangeV1Beta1 = toJson_HostPortRangeV1Beta1;
/**
 * Converts an object of type 'RunAsGroupStrategyOptionsV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_RunAsGroupStrategyOptionsV1Beta1(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'ranges': (_a = obj.ranges) === null || _a === void 0 ? void 0 : _a.map(y => toJson_IdRangeV1Beta1(y)),
        'rule': obj.rule,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_RunAsGroupStrategyOptionsV1Beta1 = toJson_RunAsGroupStrategyOptionsV1Beta1;
/**
 * Converts an object of type 'RunAsUserStrategyOptionsV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_RunAsUserStrategyOptionsV1Beta1(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'ranges': (_a = obj.ranges) === null || _a === void 0 ? void 0 : _a.map(y => toJson_IdRangeV1Beta1(y)),
        'rule': obj.rule,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_RunAsUserStrategyOptionsV1Beta1 = toJson_RunAsUserStrategyOptionsV1Beta1;
/**
 * Converts an object of type 'RuntimeClassStrategyOptionsV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_RuntimeClassStrategyOptionsV1Beta1(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'allowedRuntimeClassNames': (_a = obj.allowedRuntimeClassNames) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'defaultRuntimeClassName': obj.defaultRuntimeClassName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_RuntimeClassStrategyOptionsV1Beta1 = toJson_RuntimeClassStrategyOptionsV1Beta1;
/**
 * Converts an object of type 'SeLinuxStrategyOptionsV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_SeLinuxStrategyOptionsV1Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'rule': obj.rule,
        'seLinuxOptions': toJson_SeLinuxOptions(obj.seLinuxOptions),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_SeLinuxStrategyOptionsV1Beta1 = toJson_SeLinuxStrategyOptionsV1Beta1;
/**
 * Converts an object of type 'SupplementalGroupsStrategyOptionsV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_SupplementalGroupsStrategyOptionsV1Beta1(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'ranges': (_a = obj.ranges) === null || _a === void 0 ? void 0 : _a.map(y => toJson_IdRangeV1Beta1(y)),
        'rule': obj.rule,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_SupplementalGroupsStrategyOptionsV1Beta1 = toJson_SupplementalGroupsStrategyOptionsV1Beta1;
/**
 * Converts an object of type 'TokenRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_TokenRequest(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'audience': obj.audience,
        'expirationSeconds': obj.expirationSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_TokenRequest = toJson_TokenRequest;
/**
 * Converts an object of type 'CsiNodeDriver' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_CsiNodeDriver(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'allocatable': toJson_VolumeNodeResources(obj.allocatable),
        'name': obj.name,
        'nodeID': obj.nodeId,
        'topologyKeys': (_a = obj.topologyKeys) === null || _a === void 0 ? void 0 : _a.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_CsiNodeDriver = toJson_CsiNodeDriver;
/**
 * Converts an object of type 'TopologySelectorLabelRequirement' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_TopologySelectorLabelRequirement(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'values': (_a = obj.values) === null || _a === void 0 ? void 0 : _a.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_TopologySelectorLabelRequirement = toJson_TopologySelectorLabelRequirement;
/**
 * Converts an object of type 'VolumeAttachmentSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_VolumeAttachmentSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'inlineVolumeSpec': toJson_PersistentVolumeSpec(obj.inlineVolumeSpec),
        'persistentVolumeName': obj.persistentVolumeName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_VolumeAttachmentSource = toJson_VolumeAttachmentSource;
/**
 * Converts an object of type 'LabelSelectorRequirement' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_LabelSelectorRequirement(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': (_a = obj.values) === null || _a === void 0 ? void 0 : _a.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_LabelSelectorRequirement = toJson_LabelSelectorRequirement;
/**
 * Converts an object of type 'VolumeAttachmentSourceV1Alpha1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_VolumeAttachmentSourceV1Alpha1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'inlineVolumeSpec': toJson_PersistentVolumeSpec(obj.inlineVolumeSpec),
        'persistentVolumeName': obj.persistentVolumeName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_VolumeAttachmentSourceV1Alpha1 = toJson_VolumeAttachmentSourceV1Alpha1;
/**
 * Converts an object of type 'CustomResourceConversion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_CustomResourceConversion(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'strategy': obj.strategy,
        'webhook': toJson_WebhookConversion(obj.webhook),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_CustomResourceConversion = toJson_CustomResourceConversion;
/**
 * Converts an object of type 'CustomResourceDefinitionNames' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_CustomResourceDefinitionNames(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'categories': (_a = obj.categories) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'kind': obj.kind,
        'listKind': obj.listKind,
        'plural': obj.plural,
        'shortNames': (_b = obj.shortNames) === null || _b === void 0 ? void 0 : _b.map(y => y),
        'singular': obj.singular,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_CustomResourceDefinitionNames = toJson_CustomResourceDefinitionNames;
/**
 * Converts an object of type 'CustomResourceDefinitionVersion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_CustomResourceDefinitionVersion(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'additionalPrinterColumns': (_a = obj.additionalPrinterColumns) === null || _a === void 0 ? void 0 : _a.map(y => toJson_CustomResourceColumnDefinition(y)),
        'deprecated': obj.deprecated,
        'deprecationWarning': obj.deprecationWarning,
        'name': obj.name,
        'schema': toJson_CustomResourceValidation(obj.schema),
        'served': obj.served,
        'storage': obj.storage,
        'subresources': toJson_CustomResourceSubresources(obj.subresources),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_CustomResourceDefinitionVersion = toJson_CustomResourceDefinitionVersion;
/**
 * Converts an object of type 'StatusCause' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_StatusCause(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'field': obj.field,
        'message': obj.message,
        'reason': obj.reason,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_StatusCause = toJson_StatusCause;
/**
 * Converts an object of type 'ServiceReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ServiceReference(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'namespace': obj.namespace,
        'path': obj.path,
        'port': obj.port,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ServiceReference = toJson_ServiceReference;
/**
 * Converts an object of type 'RollingUpdateDaemonSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_RollingUpdateDaemonSet(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'maxSurge': (_a = obj.maxSurge) === null || _a === void 0 ? void 0 : _a.value,
        'maxUnavailable': (_b = obj.maxUnavailable) === null || _b === void 0 ? void 0 : _b.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_RollingUpdateDaemonSet = toJson_RollingUpdateDaemonSet;
/**
 * Converts an object of type 'RollingUpdateDeployment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_RollingUpdateDeployment(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'maxSurge': (_a = obj.maxSurge) === null || _a === void 0 ? void 0 : _a.value,
        'maxUnavailable': (_b = obj.maxUnavailable) === null || _b === void 0 ? void 0 : _b.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_RollingUpdateDeployment = toJson_RollingUpdateDeployment;
/**
 * Converts an object of type 'RollingUpdateStatefulSetStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_RollingUpdateStatefulSetStrategy(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'partition': obj.partition,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_RollingUpdateStatefulSetStrategy = toJson_RollingUpdateStatefulSetStrategy;
/**
 * Converts an object of type 'ContainerResourceMetricSourceV2Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ContainerResourceMetricSourceV2Beta1(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'container': obj.container,
        'name': obj.name,
        'targetAverageUtilization': obj.targetAverageUtilization,
        'targetAverageValue': (_a = obj.targetAverageValue) === null || _a === void 0 ? void 0 : _a.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ContainerResourceMetricSourceV2Beta1 = toJson_ContainerResourceMetricSourceV2Beta1;
/**
 * Converts an object of type 'ExternalMetricSourceV2Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ExternalMetricSourceV2Beta1(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metricName': obj.metricName,
        'metricSelector': toJson_LabelSelector(obj.metricSelector),
        'targetAverageValue': (_a = obj.targetAverageValue) === null || _a === void 0 ? void 0 : _a.value,
        'targetValue': (_b = obj.targetValue) === null || _b === void 0 ? void 0 : _b.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ExternalMetricSourceV2Beta1 = toJson_ExternalMetricSourceV2Beta1;
/**
 * Converts an object of type 'ObjectMetricSourceV2Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ObjectMetricSourceV2Beta1(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'averageValue': (_a = obj.averageValue) === null || _a === void 0 ? void 0 : _a.value,
        'metricName': obj.metricName,
        'selector': toJson_LabelSelector(obj.selector),
        'target': toJson_CrossVersionObjectReferenceV2Beta1(obj.target),
        'targetValue': (_b = obj.targetValue) === null || _b === void 0 ? void 0 : _b.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ObjectMetricSourceV2Beta1 = toJson_ObjectMetricSourceV2Beta1;
/**
 * Converts an object of type 'PodsMetricSourceV2Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PodsMetricSourceV2Beta1(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metricName': obj.metricName,
        'selector': toJson_LabelSelector(obj.selector),
        'targetAverageValue': (_a = obj.targetAverageValue) === null || _a === void 0 ? void 0 : _a.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PodsMetricSourceV2Beta1 = toJson_PodsMetricSourceV2Beta1;
/**
 * Converts an object of type 'ResourceMetricSourceV2Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ResourceMetricSourceV2Beta1(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'targetAverageUtilization': obj.targetAverageUtilization,
        'targetAverageValue': (_a = obj.targetAverageValue) === null || _a === void 0 ? void 0 : _a.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ResourceMetricSourceV2Beta1 = toJson_ResourceMetricSourceV2Beta1;
/**
 * Converts an object of type 'HpaScalingRulesV2Beta2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_HpaScalingRulesV2Beta2(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'policies': (_a = obj.policies) === null || _a === void 0 ? void 0 : _a.map(y => toJson_HpaScalingPolicyV2Beta2(y)),
        'selectPolicy': obj.selectPolicy,
        'stabilizationWindowSeconds': obj.stabilizationWindowSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_HpaScalingRulesV2Beta2 = toJson_HpaScalingRulesV2Beta2;
/**
 * Converts an object of type 'ContainerResourceMetricSourceV2Beta2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ContainerResourceMetricSourceV2Beta2(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'container': obj.container,
        'name': obj.name,
        'target': toJson_MetricTargetV2Beta2(obj.target),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ContainerResourceMetricSourceV2Beta2 = toJson_ContainerResourceMetricSourceV2Beta2;
/**
 * Converts an object of type 'ExternalMetricSourceV2Beta2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ExternalMetricSourceV2Beta2(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metric': toJson_MetricIdentifierV2Beta2(obj.metric),
        'target': toJson_MetricTargetV2Beta2(obj.target),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ExternalMetricSourceV2Beta2 = toJson_ExternalMetricSourceV2Beta2;
/**
 * Converts an object of type 'ObjectMetricSourceV2Beta2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ObjectMetricSourceV2Beta2(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'describedObject': toJson_CrossVersionObjectReferenceV2Beta2(obj.describedObject),
        'metric': toJson_MetricIdentifierV2Beta2(obj.metric),
        'target': toJson_MetricTargetV2Beta2(obj.target),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ObjectMetricSourceV2Beta2 = toJson_ObjectMetricSourceV2Beta2;
/**
 * Converts an object of type 'PodsMetricSourceV2Beta2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PodsMetricSourceV2Beta2(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metric': toJson_MetricIdentifierV2Beta2(obj.metric),
        'target': toJson_MetricTargetV2Beta2(obj.target),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PodsMetricSourceV2Beta2 = toJson_PodsMetricSourceV2Beta2;
/**
 * Converts an object of type 'ResourceMetricSourceV2Beta2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ResourceMetricSourceV2Beta2(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'target': toJson_MetricTargetV2Beta2(obj.target),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ResourceMetricSourceV2Beta2 = toJson_ResourceMetricSourceV2Beta2;
/**
 * Converts an object of type 'ConfigMapNodeConfigSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ConfigMapNodeConfigSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'kubeletConfigKey': obj.kubeletConfigKey,
        'name': obj.name,
        'namespace': obj.namespace,
        'resourceVersion': obj.resourceVersion,
        'uid': obj.uid,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ConfigMapNodeConfigSource = toJson_ConfigMapNodeConfigSource;
/**
 * Converts an object of type 'SecretReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_SecretReference(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'namespace': obj.namespace,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_SecretReference = toJson_SecretReference;
/**
 * Converts an object of type 'NodeSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_NodeSelector(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'nodeSelectorTerms': (_a = obj.nodeSelectorTerms) === null || _a === void 0 ? void 0 : _a.map(y => toJson_NodeSelectorTerm(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_NodeSelector = toJson_NodeSelector;
/**
 * Converts an object of type 'NodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_NodeAffinity(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preferredDuringSchedulingIgnoredDuringExecution': (_a = obj.preferredDuringSchedulingIgnoredDuringExecution) === null || _a === void 0 ? void 0 : _a.map(y => toJson_PreferredSchedulingTerm(y)),
        'requiredDuringSchedulingIgnoredDuringExecution': toJson_NodeSelector(obj.requiredDuringSchedulingIgnoredDuringExecution),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_NodeAffinity = toJson_NodeAffinity;
/**
 * Converts an object of type 'PodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PodAffinity(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preferredDuringSchedulingIgnoredDuringExecution': (_a = obj.preferredDuringSchedulingIgnoredDuringExecution) === null || _a === void 0 ? void 0 : _a.map(y => toJson_WeightedPodAffinityTerm(y)),
        'requiredDuringSchedulingIgnoredDuringExecution': (_b = obj.requiredDuringSchedulingIgnoredDuringExecution) === null || _b === void 0 ? void 0 : _b.map(y => toJson_PodAffinityTerm(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PodAffinity = toJson_PodAffinity;
/**
 * Converts an object of type 'PodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PodAntiAffinity(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preferredDuringSchedulingIgnoredDuringExecution': (_a = obj.preferredDuringSchedulingIgnoredDuringExecution) === null || _a === void 0 ? void 0 : _a.map(y => toJson_WeightedPodAffinityTerm(y)),
        'requiredDuringSchedulingIgnoredDuringExecution': (_b = obj.requiredDuringSchedulingIgnoredDuringExecution) === null || _b === void 0 ? void 0 : _b.map(y => toJson_PodAffinityTerm(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PodAntiAffinity = toJson_PodAntiAffinity;
/**
 * Converts an object of type 'EnvVar' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_EnvVar(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
        'valueFrom': toJson_EnvVarSource(obj.valueFrom),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_EnvVar = toJson_EnvVar;
/**
 * Converts an object of type 'EnvFromSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_EnvFromSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'configMapRef': toJson_ConfigMapEnvSource(obj.configMapRef),
        'prefix': obj.prefix,
        'secretRef': toJson_SecretEnvSource(obj.secretRef),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_EnvFromSource = toJson_EnvFromSource;
/**
 * Converts an object of type 'Lifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_Lifecycle(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'postStart': toJson_Handler(obj.postStart),
        'preStop': toJson_Handler(obj.preStop),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_Lifecycle = toJson_Lifecycle;
/**
 * Converts an object of type 'Probe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_Probe(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'exec': toJson_ExecAction(obj.exec),
        'failureThreshold': obj.failureThreshold,
        'httpGet': toJson_HttpGetAction(obj.httpGet),
        'initialDelaySeconds': obj.initialDelaySeconds,
        'periodSeconds': obj.periodSeconds,
        'successThreshold': obj.successThreshold,
        'tcpSocket': toJson_TcpSocketAction(obj.tcpSocket),
        'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
        'timeoutSeconds': obj.timeoutSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_Probe = toJson_Probe;
/**
 * Converts an object of type 'ContainerPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ContainerPort(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'containerPort': obj.containerPort,
        'hostIP': obj.hostIp,
        'hostPort': obj.hostPort,
        'name': obj.name,
        'protocol': obj.protocol,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ContainerPort = toJson_ContainerPort;
/**
 * Converts an object of type 'SecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_SecurityContext(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
        'capabilities': toJson_Capabilities(obj.capabilities),
        'privileged': obj.privileged,
        'procMount': obj.procMount,
        'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
        'runAsGroup': obj.runAsGroup,
        'runAsNonRoot': obj.runAsNonRoot,
        'runAsUser': obj.runAsUser,
        'seLinuxOptions': toJson_SeLinuxOptions(obj.seLinuxOptions),
        'seccompProfile': toJson_SeccompProfile(obj.seccompProfile),
        'windowsOptions': toJson_WindowsSecurityContextOptions(obj.windowsOptions),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_SecurityContext = toJson_SecurityContext;
/**
 * Converts an object of type 'VolumeDevice' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_VolumeDevice(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'devicePath': obj.devicePath,
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_VolumeDevice = toJson_VolumeDevice;
/**
 * Converts an object of type 'VolumeMount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_VolumeMount(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'mountPath': obj.mountPath,
        'mountPropagation': obj.mountPropagation,
        'name': obj.name,
        'readOnly': obj.readOnly,
        'subPath': obj.subPath,
        'subPathExpr': obj.subPathExpr,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_VolumeMount = toJson_VolumeMount;
/**
 * Converts an object of type 'PodDnsConfigOption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PodDnsConfigOption(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PodDnsConfigOption = toJson_PodDnsConfigOption;
/**
 * Converts an object of type 'SeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_SeLinuxOptions(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'level': obj.level,
        'role': obj.role,
        'type': obj.type,
        'user': obj.user,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_SeLinuxOptions = toJson_SeLinuxOptions;
/**
 * Converts an object of type 'SeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_SeccompProfile(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'localhostProfile': obj.localhostProfile,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_SeccompProfile = toJson_SeccompProfile;
/**
 * Converts an object of type 'Sysctl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_Sysctl(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_Sysctl = toJson_Sysctl;
/**
 * Converts an object of type 'WindowsSecurityContextOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_WindowsSecurityContextOptions(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'gmsaCredentialSpec': obj.gmsaCredentialSpec,
        'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
        'hostProcess': obj.hostProcess,
        'runAsUserName': obj.runAsUserName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_WindowsSecurityContextOptions = toJson_WindowsSecurityContextOptions;
/**
 * Converts an object of type 'AzureFileVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_AzureFileVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'readOnly': obj.readOnly,
        'secretName': obj.secretName,
        'shareName': obj.shareName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_AzureFileVolumeSource = toJson_AzureFileVolumeSource;
/**
 * Converts an object of type 'CephFsVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_CephFsVolumeSource(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'monitors': (_a = obj.monitors) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'path': obj.path,
        'readOnly': obj.readOnly,
        'secretFile': obj.secretFile,
        'secretRef': toJson_LocalObjectReference(obj.secretRef),
        'user': obj.user,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_CephFsVolumeSource = toJson_CephFsVolumeSource;
/**
 * Converts an object of type 'CinderVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_CinderVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'fsType': obj.fsType,
        'readOnly': obj.readOnly,
        'secretRef': toJson_LocalObjectReference(obj.secretRef),
        'volumeID': obj.volumeId,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_CinderVolumeSource = toJson_CinderVolumeSource;
/**
 * Converts an object of type 'ConfigMapVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ConfigMapVolumeSource(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'defaultMode': obj.defaultMode,
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KeyToPath(y)),
        'name': obj.name,
        'optional': obj.optional,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ConfigMapVolumeSource = toJson_ConfigMapVolumeSource;
/**
 * Converts an object of type 'CsiVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_CsiVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'driver': obj.driver,
        'fsType': obj.fsType,
        'nodePublishSecretRef': toJson_LocalObjectReference(obj.nodePublishSecretRef),
        'readOnly': obj.readOnly,
        'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_CsiVolumeSource = toJson_CsiVolumeSource;
/**
 * Converts an object of type 'DownwardApiVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_DownwardApiVolumeSource(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'defaultMode': obj.defaultMode,
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_DownwardApiVolumeFile(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_DownwardApiVolumeSource = toJson_DownwardApiVolumeSource;
/**
 * Converts an object of type 'EmptyDirVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_EmptyDirVolumeSource(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'medium': obj.medium,
        'sizeLimit': (_a = obj.sizeLimit) === null || _a === void 0 ? void 0 : _a.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_EmptyDirVolumeSource = toJson_EmptyDirVolumeSource;
/**
 * Converts an object of type 'EphemeralVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_EphemeralVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'volumeClaimTemplate': toJson_PersistentVolumeClaimTemplate(obj.volumeClaimTemplate),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_EphemeralVolumeSource = toJson_EphemeralVolumeSource;
/**
 * Converts an object of type 'FlexVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_FlexVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'driver': obj.driver,
        'fsType': obj.fsType,
        'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'readOnly': obj.readOnly,
        'secretRef': toJson_LocalObjectReference(obj.secretRef),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_FlexVolumeSource = toJson_FlexVolumeSource;
/**
 * Converts an object of type 'GitRepoVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_GitRepoVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'directory': obj.directory,
        'repository': obj.repository,
        'revision': obj.revision,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_GitRepoVolumeSource = toJson_GitRepoVolumeSource;
/**
 * Converts an object of type 'GlusterfsVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_GlusterfsVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'endpoints': obj.endpoints,
        'path': obj.path,
        'readOnly': obj.readOnly,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_GlusterfsVolumeSource = toJson_GlusterfsVolumeSource;
/**
 * Converts an object of type 'IscsiVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_IscsiVolumeSource(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'chapAuthDiscovery': obj.chapAuthDiscovery,
        'chapAuthSession': obj.chapAuthSession,
        'fsType': obj.fsType,
        'initiatorName': obj.initiatorName,
        'iqn': obj.iqn,
        'iscsiInterface': obj.iscsiInterface,
        'lun': obj.lun,
        'portals': (_a = obj.portals) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'readOnly': obj.readOnly,
        'secretRef': toJson_LocalObjectReference(obj.secretRef),
        'targetPortal': obj.targetPortal,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_IscsiVolumeSource = toJson_IscsiVolumeSource;
/**
 * Converts an object of type 'PersistentVolumeClaimVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PersistentVolumeClaimVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'claimName': obj.claimName,
        'readOnly': obj.readOnly,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PersistentVolumeClaimVolumeSource = toJson_PersistentVolumeClaimVolumeSource;
/**
 * Converts an object of type 'ProjectedVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ProjectedVolumeSource(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'defaultMode': obj.defaultMode,
        'sources': (_a = obj.sources) === null || _a === void 0 ? void 0 : _a.map(y => toJson_VolumeProjection(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ProjectedVolumeSource = toJson_ProjectedVolumeSource;
/**
 * Converts an object of type 'RbdVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_RbdVolumeSource(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'fsType': obj.fsType,
        'image': obj.image,
        'keyring': obj.keyring,
        'monitors': (_a = obj.monitors) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'pool': obj.pool,
        'readOnly': obj.readOnly,
        'secretRef': toJson_LocalObjectReference(obj.secretRef),
        'user': obj.user,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_RbdVolumeSource = toJson_RbdVolumeSource;
/**
 * Converts an object of type 'ScaleIoVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ScaleIoVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'fsType': obj.fsType,
        'gateway': obj.gateway,
        'protectionDomain': obj.protectionDomain,
        'readOnly': obj.readOnly,
        'secretRef': toJson_LocalObjectReference(obj.secretRef),
        'sslEnabled': obj.sslEnabled,
        'storageMode': obj.storageMode,
        'storagePool': obj.storagePool,
        'system': obj.system,
        'volumeName': obj.volumeName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ScaleIoVolumeSource = toJson_ScaleIoVolumeSource;
/**
 * Converts an object of type 'SecretVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_SecretVolumeSource(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'defaultMode': obj.defaultMode,
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KeyToPath(y)),
        'optional': obj.optional,
        'secretName': obj.secretName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_SecretVolumeSource = toJson_SecretVolumeSource;
/**
 * Converts an object of type 'StorageOsVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_StorageOsVolumeSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'fsType': obj.fsType,
        'readOnly': obj.readOnly,
        'secretRef': toJson_LocalObjectReference(obj.secretRef),
        'volumeName': obj.volumeName,
        'volumeNamespace': obj.volumeNamespace,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_StorageOsVolumeSource = toJson_StorageOsVolumeSource;
/**
 * Converts an object of type 'ScopedResourceSelectorRequirement' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ScopedResourceSelectorRequirement(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'operator': obj.operator,
        'scopeName': obj.scopeName,
        'values': (_a = obj.values) === null || _a === void 0 ? void 0 : _a.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ScopedResourceSelectorRequirement = toJson_ScopedResourceSelectorRequirement;
/**
 * Converts an object of type 'ClientIpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ClientIpConfig(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'timeoutSeconds': obj.timeoutSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ClientIpConfig = toJson_ClientIpConfig;
/**
 * Converts an object of type 'ForZone' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ForZone(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ForZone = toJson_ForZone;
/**
 * Converts an object of type 'ForZoneV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ForZoneV1Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ForZoneV1Beta1 = toJson_ForZoneV1Beta1;
/**
 * Converts an object of type 'NonResourcePolicyRuleV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_NonResourcePolicyRuleV1Beta1(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'nonResourceURLs': (_a = obj.nonResourceUrLs) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'verbs': (_b = obj.verbs) === null || _b === void 0 ? void 0 : _b.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_NonResourcePolicyRuleV1Beta1 = toJson_NonResourcePolicyRuleV1Beta1;
/**
 * Converts an object of type 'ResourcePolicyRuleV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ResourcePolicyRuleV1Beta1(obj) {
    var _a, _b, _c, _d;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'apiGroups': (_a = obj.apiGroups) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'clusterScope': obj.clusterScope,
        'namespaces': (_b = obj.namespaces) === null || _b === void 0 ? void 0 : _b.map(y => y),
        'resources': (_c = obj.resources) === null || _c === void 0 ? void 0 : _c.map(y => y),
        'verbs': (_d = obj.verbs) === null || _d === void 0 ? void 0 : _d.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ResourcePolicyRuleV1Beta1 = toJson_ResourcePolicyRuleV1Beta1;
/**
 * Converts an object of type 'SubjectV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_SubjectV1Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': toJson_GroupSubjectV1Beta1(obj.group),
        'kind': obj.kind,
        'serviceAccount': toJson_ServiceAccountSubjectV1Beta1(obj.serviceAccount),
        'user': toJson_UserSubjectV1Beta1(obj.user),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_SubjectV1Beta1 = toJson_SubjectV1Beta1;
/**
 * Converts an object of type 'LimitResponseV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_LimitResponseV1Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'queuing': toJson_QueuingConfigurationV1Beta1(obj.queuing),
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_LimitResponseV1Beta1 = toJson_LimitResponseV1Beta1;
/**
 * Converts an object of type 'IngressServiceBackend' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_IngressServiceBackend(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'port': toJson_ServiceBackendPort(obj.port),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_IngressServiceBackend = toJson_IngressServiceBackend;
/**
 * Converts an object of type 'HttpIngressRuleValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_HttpIngressRuleValue(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'paths': (_a = obj.paths) === null || _a === void 0 ? void 0 : _a.map(y => toJson_HttpIngressPath(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_HttpIngressRuleValue = toJson_HttpIngressRuleValue;
/**
 * Converts an object of type 'NetworkPolicyPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_NetworkPolicyPort(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'endPort': obj.endPort,
        'port': (_a = obj.port) === null || _a === void 0 ? void 0 : _a.value,
        'protocol': obj.protocol,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_NetworkPolicyPort = toJson_NetworkPolicyPort;
/**
 * Converts an object of type 'NetworkPolicyPeer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_NetworkPolicyPeer(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'ipBlock': toJson_IpBlock(obj.ipBlock),
        'namespaceSelector': toJson_LabelSelector(obj.namespaceSelector),
        'podSelector': toJson_LabelSelector(obj.podSelector),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_NetworkPolicyPeer = toJson_NetworkPolicyPeer;
/**
 * Converts an object of type 'IdRangeV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_IdRangeV1Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'max': obj.max,
        'min': obj.min,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_IdRangeV1Beta1 = toJson_IdRangeV1Beta1;
/**
 * Converts an object of type 'VolumeNodeResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_VolumeNodeResources(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'count': obj.count,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_VolumeNodeResources = toJson_VolumeNodeResources;
/**
 * Converts an object of type 'WebhookConversion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_WebhookConversion(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'clientConfig': toJson_WebhookClientConfig(obj.clientConfig),
        'conversionReviewVersions': (_a = obj.conversionReviewVersions) === null || _a === void 0 ? void 0 : _a.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_WebhookConversion = toJson_WebhookConversion;
/**
 * Converts an object of type 'CustomResourceColumnDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_CustomResourceColumnDefinition(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'description': obj.description,
        'format': obj.format,
        'jsonPath': obj.jsonPath,
        'name': obj.name,
        'priority': obj.priority,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_CustomResourceColumnDefinition = toJson_CustomResourceColumnDefinition;
/**
 * Converts an object of type 'CustomResourceValidation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_CustomResourceValidation(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'openAPIV3Schema': toJson_JsonSchemaProps(obj.openApiv3Schema),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_CustomResourceValidation = toJson_CustomResourceValidation;
/**
 * Converts an object of type 'CustomResourceSubresources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_CustomResourceSubresources(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'scale': toJson_CustomResourceSubresourceScale(obj.scale),
        'status': obj.status,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_CustomResourceSubresources = toJson_CustomResourceSubresources;
/**
 * Converts an object of type 'HpaScalingPolicyV2Beta2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_HpaScalingPolicyV2Beta2(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'periodSeconds': obj.periodSeconds,
        'type': obj.type,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_HpaScalingPolicyV2Beta2 = toJson_HpaScalingPolicyV2Beta2;
/**
 * Converts an object of type 'MetricTargetV2Beta2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_MetricTargetV2Beta2(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'averageUtilization': obj.averageUtilization,
        'averageValue': (_a = obj.averageValue) === null || _a === void 0 ? void 0 : _a.value,
        'type': obj.type,
        'value': (_b = obj.value) === null || _b === void 0 ? void 0 : _b.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_MetricTargetV2Beta2 = toJson_MetricTargetV2Beta2;
/**
 * Converts an object of type 'MetricIdentifierV2Beta2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_MetricIdentifierV2Beta2(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'selector': toJson_LabelSelector(obj.selector),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_MetricIdentifierV2Beta2 = toJson_MetricIdentifierV2Beta2;
/**
 * Converts an object of type 'NodeSelectorTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_NodeSelectorTerm(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': (_a = obj.matchExpressions) === null || _a === void 0 ? void 0 : _a.map(y => toJson_NodeSelectorRequirement(y)),
        'matchFields': (_b = obj.matchFields) === null || _b === void 0 ? void 0 : _b.map(y => toJson_NodeSelectorRequirement(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_NodeSelectorTerm = toJson_NodeSelectorTerm;
/**
 * Converts an object of type 'PreferredSchedulingTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PreferredSchedulingTerm(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preference': toJson_NodeSelectorTerm(obj.preference),
        'weight': obj.weight,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PreferredSchedulingTerm = toJson_PreferredSchedulingTerm;
/**
 * Converts an object of type 'WeightedPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_WeightedPodAffinityTerm(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'podAffinityTerm': toJson_PodAffinityTerm(obj.podAffinityTerm),
        'weight': obj.weight,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_WeightedPodAffinityTerm = toJson_WeightedPodAffinityTerm;
/**
 * Converts an object of type 'PodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PodAffinityTerm(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_LabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_LabelSelector(obj.namespaceSelector),
        'namespaces': (_a = obj.namespaces) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PodAffinityTerm = toJson_PodAffinityTerm;
/**
 * Converts an object of type 'EnvVarSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_EnvVarSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'configMapKeyRef': toJson_ConfigMapKeySelector(obj.configMapKeyRef),
        'fieldRef': toJson_ObjectFieldSelector(obj.fieldRef),
        'resourceFieldRef': toJson_ResourceFieldSelector(obj.resourceFieldRef),
        'secretKeyRef': toJson_SecretKeySelector(obj.secretKeyRef),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_EnvVarSource = toJson_EnvVarSource;
/**
 * Converts an object of type 'ConfigMapEnvSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ConfigMapEnvSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'optional': obj.optional,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ConfigMapEnvSource = toJson_ConfigMapEnvSource;
/**
 * Converts an object of type 'SecretEnvSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_SecretEnvSource(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'optional': obj.optional,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_SecretEnvSource = toJson_SecretEnvSource;
/**
 * Converts an object of type 'Handler' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_Handler(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'exec': toJson_ExecAction(obj.exec),
        'httpGet': toJson_HttpGetAction(obj.httpGet),
        'tcpSocket': toJson_TcpSocketAction(obj.tcpSocket),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_Handler = toJson_Handler;
/**
 * Converts an object of type 'ExecAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ExecAction(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'command': (_a = obj.command) === null || _a === void 0 ? void 0 : _a.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ExecAction = toJson_ExecAction;
/**
 * Converts an object of type 'HttpGetAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_HttpGetAction(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'host': obj.host,
        'httpHeaders': (_a = obj.httpHeaders) === null || _a === void 0 ? void 0 : _a.map(y => toJson_HttpHeader(y)),
        'path': obj.path,
        'port': (_b = obj.port) === null || _b === void 0 ? void 0 : _b.value,
        'scheme': obj.scheme,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_HttpGetAction = toJson_HttpGetAction;
/**
 * Converts an object of type 'TcpSocketAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_TcpSocketAction(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'host': obj.host,
        'port': (_a = obj.port) === null || _a === void 0 ? void 0 : _a.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_TcpSocketAction = toJson_TcpSocketAction;
/**
 * Converts an object of type 'Capabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_Capabilities(obj) {
    var _a, _b;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'add': (_a = obj.add) === null || _a === void 0 ? void 0 : _a.map(y => y),
        'drop': (_b = obj.drop) === null || _b === void 0 ? void 0 : _b.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_Capabilities = toJson_Capabilities;
/**
 * Converts an object of type 'KeyToPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_KeyToPath(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'mode': obj.mode,
        'path': obj.path,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_KeyToPath = toJson_KeyToPath;
/**
 * Converts an object of type 'DownwardApiVolumeFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_DownwardApiVolumeFile(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'fieldRef': toJson_ObjectFieldSelector(obj.fieldRef),
        'mode': obj.mode,
        'path': obj.path,
        'resourceFieldRef': toJson_ResourceFieldSelector(obj.resourceFieldRef),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_DownwardApiVolumeFile = toJson_DownwardApiVolumeFile;
/**
 * Converts an object of type 'PersistentVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_PersistentVolumeClaimTemplate(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_ObjectMeta(obj.metadata),
        'spec': toJson_PersistentVolumeClaimSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_PersistentVolumeClaimTemplate = toJson_PersistentVolumeClaimTemplate;
/**
 * Converts an object of type 'VolumeProjection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_VolumeProjection(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'configMap': toJson_ConfigMapProjection(obj.configMap),
        'downwardAPI': toJson_DownwardApiProjection(obj.downwardApi),
        'secret': toJson_SecretProjection(obj.secret),
        'serviceAccountToken': toJson_ServiceAccountTokenProjection(obj.serviceAccountToken),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_VolumeProjection = toJson_VolumeProjection;
/**
 * Converts an object of type 'GroupSubjectV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_GroupSubjectV1Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_GroupSubjectV1Beta1 = toJson_GroupSubjectV1Beta1;
/**
 * Converts an object of type 'ServiceAccountSubjectV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ServiceAccountSubjectV1Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'namespace': obj.namespace,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ServiceAccountSubjectV1Beta1 = toJson_ServiceAccountSubjectV1Beta1;
/**
 * Converts an object of type 'UserSubjectV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_UserSubjectV1Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_UserSubjectV1Beta1 = toJson_UserSubjectV1Beta1;
/**
 * Converts an object of type 'QueuingConfigurationV1Beta1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_QueuingConfigurationV1Beta1(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'handSize': obj.handSize,
        'queueLengthLimit': obj.queueLengthLimit,
        'queues': obj.queues,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_QueuingConfigurationV1Beta1 = toJson_QueuingConfigurationV1Beta1;
/**
 * Converts an object of type 'ServiceBackendPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ServiceBackendPort(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'number': obj.number,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ServiceBackendPort = toJson_ServiceBackendPort;
/**
 * Converts an object of type 'HttpIngressPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_HttpIngressPath(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'backend': toJson_IngressBackend(obj.backend),
        'path': obj.path,
        'pathType': obj.pathType,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_HttpIngressPath = toJson_HttpIngressPath;
/**
 * Converts an object of type 'IpBlock' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_IpBlock(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'cidr': obj.cidr,
        'except': (_a = obj.except) === null || _a === void 0 ? void 0 : _a.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_IpBlock = toJson_IpBlock;
/**
 * Converts an object of type 'JsonSchemaProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_JsonSchemaProps(obj) {
    var _a, _b, _c, _d, _e, _f;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        '$ref': obj.ref,
        '$schema': obj.schema,
        'additionalItems': obj.additionalItems,
        'additionalProperties': obj.additionalProperties,
        'allOf': (_a = obj.allOf) === null || _a === void 0 ? void 0 : _a.map(y => toJson_JsonSchemaProps(y)),
        'anyOf': (_b = obj.anyOf) === null || _b === void 0 ? void 0 : _b.map(y => toJson_JsonSchemaProps(y)),
        'default': obj.default,
        'definitions': ((obj.definitions) === undefined) ? undefined : (Object.entries(obj.definitions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_JsonSchemaProps(i[1]) }), {})),
        'dependencies': ((obj.dependencies) === undefined) ? undefined : (Object.entries(obj.dependencies).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'description': obj.description,
        'enum': (_c = obj.enum) === null || _c === void 0 ? void 0 : _c.map(y => y),
        'example': obj.example,
        'exclusiveMaximum': obj.exclusiveMaximum,
        'exclusiveMinimum': obj.exclusiveMinimum,
        'externalDocs': toJson_ExternalDocumentation(obj.externalDocs),
        'format': obj.format,
        'id': obj.id,
        'items': obj.items,
        'maxItems': obj.maxItems,
        'maxLength': obj.maxLength,
        'maxProperties': obj.maxProperties,
        'maximum': obj.maximum,
        'minItems': obj.minItems,
        'minLength': obj.minLength,
        'minProperties': obj.minProperties,
        'minimum': obj.minimum,
        'multipleOf': obj.multipleOf,
        'not': toJson_JsonSchemaProps(obj.not),
        'nullable': obj.nullable,
        'oneOf': (_d = obj.oneOf) === null || _d === void 0 ? void 0 : _d.map(y => toJson_JsonSchemaProps(y)),
        'pattern': obj.pattern,
        'patternProperties': ((obj.patternProperties) === undefined) ? undefined : (Object.entries(obj.patternProperties).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_JsonSchemaProps(i[1]) }), {})),
        'properties': ((obj.properties) === undefined) ? undefined : (Object.entries(obj.properties).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_JsonSchemaProps(i[1]) }), {})),
        'required': (_e = obj.required) === null || _e === void 0 ? void 0 : _e.map(y => y),
        'title': obj.title,
        'type': obj.type,
        'uniqueItems': obj.uniqueItems,
        'x-kubernetes-embedded-resource': obj.xKubernetesEmbeddedResource,
        'x-kubernetes-int-or-string': obj.xKubernetesIntOrString,
        'x-kubernetes-list-map-keys': (_f = obj.xKubernetesListMapKeys) === null || _f === void 0 ? void 0 : _f.map(y => y),
        'x-kubernetes-list-type': obj.xKubernetesListType,
        'x-kubernetes-map-type': obj.xKubernetesMapType,
        'x-kubernetes-preserve-unknown-fields': obj.xKubernetesPreserveUnknownFields,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_JsonSchemaProps = toJson_JsonSchemaProps;
/**
 * Converts an object of type 'CustomResourceSubresourceScale' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_CustomResourceSubresourceScale(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelectorPath': obj.labelSelectorPath,
        'specReplicasPath': obj.specReplicasPath,
        'statusReplicasPath': obj.statusReplicasPath,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_CustomResourceSubresourceScale = toJson_CustomResourceSubresourceScale;
/**
 * Converts an object of type 'NodeSelectorRequirement' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_NodeSelectorRequirement(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': (_a = obj.values) === null || _a === void 0 ? void 0 : _a.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_NodeSelectorRequirement = toJson_NodeSelectorRequirement;
/**
 * Converts an object of type 'ConfigMapKeySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ConfigMapKeySelector(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'name': obj.name,
        'optional': obj.optional,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ConfigMapKeySelector = toJson_ConfigMapKeySelector;
/**
 * Converts an object of type 'ObjectFieldSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ObjectFieldSelector(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'apiVersion': obj.apiVersion,
        'fieldPath': obj.fieldPath,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ObjectFieldSelector = toJson_ObjectFieldSelector;
/**
 * Converts an object of type 'ResourceFieldSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ResourceFieldSelector(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'containerName': obj.containerName,
        'divisor': (_a = obj.divisor) === null || _a === void 0 ? void 0 : _a.value,
        'resource': obj.resource,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ResourceFieldSelector = toJson_ResourceFieldSelector;
/**
 * Converts an object of type 'SecretKeySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_SecretKeySelector(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'name': obj.name,
        'optional': obj.optional,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_SecretKeySelector = toJson_SecretKeySelector;
/**
 * Converts an object of type 'HttpHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_HttpHeader(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_HttpHeader = toJson_HttpHeader;
/**
 * Converts an object of type 'ConfigMapProjection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ConfigMapProjection(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KeyToPath(y)),
        'name': obj.name,
        'optional': obj.optional,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ConfigMapProjection = toJson_ConfigMapProjection;
/**
 * Converts an object of type 'DownwardApiProjection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_DownwardApiProjection(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_DownwardApiVolumeFile(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_DownwardApiProjection = toJson_DownwardApiProjection;
/**
 * Converts an object of type 'SecretProjection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_SecretProjection(obj) {
    var _a;
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'items': (_a = obj.items) === null || _a === void 0 ? void 0 : _a.map(y => toJson_KeyToPath(y)),
        'name': obj.name,
        'optional': obj.optional,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_SecretProjection = toJson_SecretProjection;
/**
 * Converts an object of type 'ServiceAccountTokenProjection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ServiceAccountTokenProjection(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'audience': obj.audience,
        'expirationSeconds': obj.expirationSeconds,
        'path': obj.path,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ServiceAccountTokenProjection = toJson_ServiceAccountTokenProjection;
/**
 * Converts an object of type 'ExternalDocumentation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ExternalDocumentation(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'description': obj.description,
        'url': obj.url,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
exports.toJson_ExternalDocumentation = toJson_ExternalDocumentation;
/* eslint-enable max-len, quote-props */
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiazhzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2ltcG9ydHMvazhzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHFCQUFxQjtBQUNyQixpQ0FBb0Q7QUFHcEQ7Ozs7R0FJRztBQUNILE1BQWEsZ0NBQWlDLFNBQVEsaUJBQVM7SUF1QjdEOzs7OztPQUtHO0lBQ0gsWUFBbUIsS0FBZ0IsRUFBRSxFQUFVLEVBQUUsUUFBK0MsRUFBRTtRQUNoRyxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRTtZQUNmLEdBQUcsZ0NBQWdDLENBQUMsR0FBRztZQUN2QyxHQUFHLEtBQUs7U0FDVCxDQUFDLENBQUM7SUFDTCxDQUFDO0lBekJEOzs7Ozs7T0FNRztJQUNJLE1BQU0sQ0FBQyxRQUFRLENBQUMsUUFBK0MsRUFBRTtRQUN0RSxPQUFPO1lBQ0wsR0FBRyxnQ0FBZ0MsQ0FBQyxHQUFHO1lBQ3ZDLEdBQUcsNENBQTRDLENBQUMsS0FBSyxDQUFDO1NBQ3ZELENBQUM7SUFDSixDQUFDO0lBZUQ7O09BRUc7SUFDSSxNQUFNO1FBQ1gsTUFBTSxRQUFRLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBRWhDLE9BQU87WUFDTCxHQUFHLGdDQUFnQyxDQUFDLEdBQUc7WUFDdkMsR0FBRyw0Q0FBNEMsQ0FBQyxRQUFRLENBQUM7U0FDMUQsQ0FBQztJQUNKLENBQUM7O0FBOUNILDRFQStDQztBQTlDQzs7R0FFRztBQUNvQixvQ0FBRyxHQUFxQjtJQUM3QyxVQUFVLEVBQUUsaUNBQWlDO0lBQzdDLElBQUksRUFBRSw4QkFBOEI7Q0FDckMsQ0FBQTtBQTBDSDs7OztHQUlHO0FBQ0gsTUFBYSxvQ0FBcUMsU0FBUSxpQkFBUztJQXVCakU7Ozs7O09BS0c7SUFDSCxZQUFtQixLQUFnQixFQUFFLEVBQVUsRUFBRSxLQUFnRDtRQUMvRixLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRTtZQUNmLEdBQUcsb0NBQW9DLENBQUMsR0FB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Q0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDdkssTUFBTSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3JKLFdBQVcsRUFBRSxHQUFHLENBQUMsU0FBUztRQUMxQixVQUFVLEVBQUUsaUJBQWlCLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQztLQUM1QyxDQUFDO0lBQ0YsMEJBQTBCO0lBQzFCLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQzFHLENBQUM7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Q0FBQyxDQUFDO1FBQ2xGLGdCQUFnQixRQUFFLEdBQUcsQ0FBQyxjQUFjLDBDQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ25FLFVBQVUsRUFBRSxHQUFHLENBQUMsUUFBUTtRQUN4QixjQUFjLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDN0ssVUFBVSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsV0FBQyxPQUFBLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsMENBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQSxFQUFBLEVBQUUs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QUUsQ0FBQyxDQUFDLENBQUMsQ0FBQywwQ0FBRSxLQUFLLEVBQUUsQ0FBQyxDQUFBLEVBQUEsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNySyxnQkFBZ0IsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLFdBQUMsT0FBQSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLDBDQUFFLEtBQUssRUFBRSxDQUFDLENBQUEsRUFBQSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzFMLEtBQUssRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLFdBQUMsT0FBQSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLDBDQUFFLEtBQUssRUFBRSxDQUFDLENBQUEsRUFBQSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3pKLHNCQUFzQixFQUFFLENB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Q0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxXQUFDLE9BQUEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQywwQ0FBRSxLQUFLLEVBQUUsQ0FBQyxDQUFBLEVBQUEsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNsSyxVQUFVLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxXQUFDLE9BQUEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQywwQ0FBRSxLQUFLLEVBQUUsQ0FBQyxDQUFBLEVBQUEsRUFBRSxFQUFFLENBQUMsQ0FBQztLQUN6SyxDQUFDO0lBQ0YsMEJBQTBCO0lBQzFCLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FB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QUFDO0tBQUU7SUFDNUMsTUFBTSxNQUFNLEdBQUc7UUFDYixhQUFhLEVBQUUsR0FBRyxDQUFDLFdBQVc7UUFDOUIsS0FBSyxFQUFFLEdBQUcsQ0FBQyxHQUFHO0tBQ2YsQ0FBQztJQUNGLDBCQUEwQjtJQUMxQixPQUFPLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUMxRyxDQUFDO0FBUkQsb0VBUUM7QUFDRCx3Q0FBd0MiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBnZW5lcmF0ZWQgYnkgY2RrOHNcbmltcG9ydCB7IEFwaU9iamVjdCwgR3JvdXBWZXJzaW9uS2luZCB9IGZyb20gJ2NkazhzJztcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xuXG4vKipcbiAqIE11dGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb24gZGVzY3JpYmVzIHRoZSBjb25maWd1cmF0aW9uIG9mIGFuZCBhZG1pc3Npb24gd2ViaG9vayB0aGF0IGFjY2VwdCBvciByZWplY3QgYW5kIG1heSBjaGFuZ2UgdGhlIG9iamVjdC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYWRtaXNzaW9ucmVnaXN0cmF0aW9uLnYxLk11dGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVNdXRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uIGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuTXV0YXRpbmdXZWJob29rQ29uZmlndXJhdGlvblwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnYWRtaXNzaW9ucmVnaXN0cmF0aW9uLms4cy5pby92MScsXG4gICAga2luZDogJ011dGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb24nLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuYWRtaXNzaW9ucmVnaXN0cmF0aW9uLnYxLk11dGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb25cIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZU11dGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb25Qcm9wcyA9IHt9KTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZU11dGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb24uR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVNdXRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uUHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuTXV0YXRpbmdXZWJob29rQ29uZmlndXJhdGlvblwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZU11dGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb25Qcm9wcyA9IHt9KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlTXV0YXRpbmdXZWJob29rQ29uZmlndXJhdGlvbi5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZU11dGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb24uR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVNdXRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uUHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBNdXRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uTGlzdCBpcyBhIGxpc3Qgb2YgTXV0YXRpbmdXZWJob29rQ29uZmlndXJhdGlvbi5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYWRtaXNzaW9ucmVnaXN0cmF0aW9uLnYxLk11dGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb25MaXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlTXV0YXRpbmdXZWJob29rQ29uZmlndXJhdGlvbkxpc3QgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLmFkbWlzc2lvbnJlZ2lzdHJhdGlvbi52MS5NdXRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uTGlzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnYWRtaXNzaW9ucmVnaXN0cmF0aW9uLms4cy5pby92MScsXG4gICAga2luZDogJ011dGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb25MaXN0JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmFkbWlzc2lvbnJlZ2lzdHJhdGlvbi52MS5NdXRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uTGlzdFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlTXV0YXRpbmdXZWJob29rQ29uZmlndXJhdGlvbkxpc3RQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVNdXRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZU11dGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb25MaXN0UHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuTXV0YXRpbmdXZWJob29rQ29uZmlndXJhdGlvbkxpc3RcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVNdXRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uTGlzdFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlTXV0YXRpbmdXZWJob29rQ29uZmlndXJhdGlvbkxpc3QuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVNdXRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZU11dGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb25MaXN0UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb24gZGVzY3JpYmVzIHRoZSBjb25maWd1cmF0aW9uIG9mIGFuZCBhZG1pc3Npb24gd2ViaG9vayB0aGF0IGFjY2VwdCBvciByZWplY3QgYW5kIG9iamVjdCB3aXRob3V0IGNoYW5naW5nIGl0LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uIGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uXCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdhZG1pc3Npb25yZWdpc3RyYXRpb24uazhzLmlvL3YxJyxcbiAgICBraW5kOiAnVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uJyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmFkbWlzc2lvbnJlZ2lzdHJhdGlvbi52MS5WYWxpZGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb25cIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVZhbGlkYXRpbmdXZWJob29rQ29uZmlndXJhdGlvblByb3BzID0ge30pOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uUHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uXCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uUHJvcHMgPSB7fSkge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVZhbGlkYXRpbmdXZWJob29rQ29uZmlndXJhdGlvbi5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVZhbGlkYXRpbmdXZWJob29rQ29uZmlndXJhdGlvbi5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVZhbGlkYXRpbmdXZWJob29rQ29uZmlndXJhdGlvblByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uTGlzdCBpcyBhIGxpc3Qgb2YgVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uTGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZVZhbGlkYXRpbmdXZWJob29rQ29uZmlndXJhdGlvbkxpc3QgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLmFkbWlzc2lvbnJlZ2lzdHJhdGlvbi52MS5WYWxpZGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb25MaXN0XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdhZG1pc3Npb25yZWdpc3RyYXRpb24uazhzLmlvL3YxJyxcbiAgICBraW5kOiAnVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uTGlzdFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uTGlzdFByb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVZhbGlkYXRpbmdXZWJob29rQ29uZmlndXJhdGlvbkxpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVWYWxpZGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb25MaXN0UHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uTGlzdFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVZhbGlkYXRpbmdXZWJob29rQ29uZmlndXJhdGlvbkxpc3RQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVZhbGlkYXRpbmdXZWJob29rQ29uZmlndXJhdGlvbkxpc3QuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVWYWxpZGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb25MaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uTGlzdFByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogXG4gU3RvcmFnZSB2ZXJzaW9uIG9mIGEgc3BlY2lmaWMgcmVzb3VyY2UuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmFwaXNlcnZlcmludGVybmFsLnYxYWxwaGExLlN0b3JhZ2VWZXJzaW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlU3RvcmFnZVZlcnNpb25WMUFscGhhMSBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuYXBpc2VydmVyaW50ZXJuYWwudjFhbHBoYTEuU3RvcmFnZVZlcnNpb25cIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ2ludGVybmFsLmFwaXNlcnZlci5rOHMuaW8vdjFhbHBoYTEnLFxuICAgIGtpbmQ6ICdTdG9yYWdlVmVyc2lvbicsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5hcGlzZXJ2ZXJpbnRlcm5hbC52MWFscGhhMS5TdG9yYWdlVmVyc2lvblwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlU3RvcmFnZVZlcnNpb25WMUFscGhhMVByb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVN0b3JhZ2VWZXJzaW9uVjFBbHBoYTEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVTdG9yYWdlVmVyc2lvblYxQWxwaGExUHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5hcGlzZXJ2ZXJpbnRlcm5hbC52MWFscGhhMS5TdG9yYWdlVmVyc2lvblwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVN0b3JhZ2VWZXJzaW9uVjFBbHBoYTFQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVN0b3JhZ2VWZXJzaW9uVjFBbHBoYTEuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVTdG9yYWdlVmVyc2lvblYxQWxwaGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlU3RvcmFnZVZlcnNpb25WMUFscGhhMVByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQSBsaXN0IG9mIFN0b3JhZ2VWZXJzaW9ucy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBpc2VydmVyaW50ZXJuYWwudjFhbHBoYTEuU3RvcmFnZVZlcnNpb25MaXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlU3RvcmFnZVZlcnNpb25MaXN0VjFBbHBoYTEgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLmFwaXNlcnZlcmludGVybmFsLnYxYWxwaGExLlN0b3JhZ2VWZXJzaW9uTGlzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnaW50ZXJuYWwuYXBpc2VydmVyLms4cy5pby92MWFscGhhMScsXG4gICAga2luZDogJ1N0b3JhZ2VWZXJzaW9uTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5hcGlzZXJ2ZXJpbnRlcm5hbC52MWFscGhhMS5TdG9yYWdlVmVyc2lvbkxpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVN0b3JhZ2VWZXJzaW9uTGlzdFYxQWxwaGExUHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlU3RvcmFnZVZlcnNpb25MaXN0VjFBbHBoYTEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVTdG9yYWdlVmVyc2lvbkxpc3RWMUFscGhhMVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuYXBpc2VydmVyaW50ZXJuYWwudjFhbHBoYTEuU3RvcmFnZVZlcnNpb25MaXN0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlU3RvcmFnZVZlcnNpb25MaXN0VjFBbHBoYTFQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVN0b3JhZ2VWZXJzaW9uTGlzdFYxQWxwaGExLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlU3RvcmFnZVZlcnNpb25MaXN0VjFBbHBoYTEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVTdG9yYWdlVmVyc2lvbkxpc3RWMUFscGhhMVByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQ29udHJvbGxlclJldmlzaW9uIGltcGxlbWVudHMgYW4gaW1tdXRhYmxlIHNuYXBzaG90IG9mIHN0YXRlIGRhdGEuIENsaWVudHMgYXJlIHJlc3BvbnNpYmxlIGZvciBzZXJpYWxpemluZyBhbmQgZGVzZXJpYWxpemluZyB0aGUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gdGhlaXIgaW50ZXJuYWwgc3RhdGUuIE9uY2UgYSBDb250cm9sbGVyUmV2aXNpb24gaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGNyZWF0ZWQsIGl0IGNhbiBub3QgYmUgdXBkYXRlZC4gVGhlIEFQSSBTZXJ2ZXIgd2lsbCBmYWlsIHZhbGlkYXRpb24gb2YgYWxsIHJlcXVlc3RzIHRoYXQgYXR0ZW1wdCB0byBtdXRhdGUgdGhlIERhdGEgZmllbGQuIENvbnRyb2xsZXJSZXZpc2lvbnMgbWF5LCBob3dldmVyLCBiZSBkZWxldGVkLiBOb3RlIHRoYXQsIGR1ZSB0byBpdHMgdXNlIGJ5IGJvdGggdGhlIERhZW1vblNldCBhbmQgU3RhdGVmdWxTZXQgY29udHJvbGxlcnMgZm9yIHVwZGF0ZSBhbmQgcm9sbGJhY2ssIHRoaXMgb2JqZWN0IGlzIGJldGEuIEhvd2V2ZXIsIGl0IG1heSBiZSBzdWJqZWN0IHRvIG5hbWUgYW5kIHJlcHJlc2VudGF0aW9uIGNoYW5nZXMgaW4gZnV0dXJlIHJlbGVhc2VzLCBhbmQgY2xpZW50cyBzaG91bGQgbm90IGRlcGVuZCBvbiBpdHMgc3RhYmlsaXR5LiBJdCBpcyBwcmltYXJpbHkgZm9yIGludGVybmFsIHVzZSBieSBjb250cm9sbGVycy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5Db250cm9sbGVyUmV2aXNpb25cbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVDb250cm9sbGVyUmV2aXNpb24gZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLmFwcHMudjEuQ29udHJvbGxlclJldmlzaW9uXCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdhcHBzL3YxJyxcbiAgICBraW5kOiAnQ29udHJvbGxlclJldmlzaW9uJyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmFwcHMudjEuQ29udHJvbGxlclJldmlzaW9uXCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVDb250cm9sbGVyUmV2aXNpb25Qcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVDb250cm9sbGVyUmV2aXNpb24uR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDb250cm9sbGVyUmV2aXNpb25Qcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmFwcHMudjEuQ29udHJvbGxlclJldmlzaW9uXCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlQ29udHJvbGxlclJldmlzaW9uUHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVDb250cm9sbGVyUmV2aXNpb24uR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVDb250cm9sbGVyUmV2aXNpb24uR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDb250cm9sbGVyUmV2aXNpb25Qcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnRyb2xsZXJSZXZpc2lvbkxpc3QgaXMgYSByZXNvdXJjZSBjb250YWluaW5nIGEgbGlzdCBvZiBDb250cm9sbGVyUmV2aXNpb24gb2JqZWN0cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5Db250cm9sbGVyUmV2aXNpb25MaXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlQ29udHJvbGxlclJldmlzaW9uTGlzdCBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuYXBwcy52MS5Db250cm9sbGVyUmV2aXNpb25MaXN0XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdhcHBzL3YxJyxcbiAgICBraW5kOiAnQ29udHJvbGxlclJldmlzaW9uTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5hcHBzLnYxLkNvbnRyb2xsZXJSZXZpc2lvbkxpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZUNvbnRyb2xsZXJSZXZpc2lvbkxpc3RQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVDb250cm9sbGVyUmV2aXNpb25MaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlQ29udHJvbGxlclJldmlzaW9uTGlzdFByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuYXBwcy52MS5Db250cm9sbGVyUmV2aXNpb25MaXN0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlQ29udHJvbGxlclJldmlzaW9uTGlzdFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlQ29udHJvbGxlclJldmlzaW9uTGlzdC5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUNvbnRyb2xsZXJSZXZpc2lvbkxpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDb250cm9sbGVyUmV2aXNpb25MaXN0UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBEYWVtb25TZXQgcmVwcmVzZW50cyB0aGUgY29uZmlndXJhdGlvbiBvZiBhIGRhZW1vbiBzZXQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuRGFlbW9uU2V0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlRGFlbW9uU2V0IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5hcHBzLnYxLkRhZW1vblNldFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnYXBwcy92MScsXG4gICAga2luZDogJ0RhZW1vblNldCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5hcHBzLnYxLkRhZW1vblNldFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlRGFlbW9uU2V0UHJvcHMgPSB7fSk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVEYWVtb25TZXQuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVEYWVtb25TZXRQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmFwcHMudjEuRGFlbW9uU2V0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlRGFlbW9uU2V0UHJvcHMgPSB7fSkge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZURhZW1vblNldC5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZURhZW1vblNldC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZURhZW1vblNldFByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogRGFlbW9uU2V0TGlzdCBpcyBhIGNvbGxlY3Rpb24gb2YgZGFlbW9uIHNldHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuRGFlbW9uU2V0TGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZURhZW1vblNldExpc3QgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLmFwcHMudjEuRGFlbW9uU2V0TGlzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnYXBwcy92MScsXG4gICAga2luZDogJ0RhZW1vblNldExpc3QnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuYXBwcy52MS5EYWVtb25TZXRMaXN0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVEYWVtb25TZXRMaXN0UHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlRGFlbW9uU2V0TGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZURhZW1vblNldExpc3RQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmFwcHMudjEuRGFlbW9uU2V0TGlzdFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZURhZW1vblNldExpc3RQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZURhZW1vblNldExpc3QuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVEYWVtb25TZXRMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlRGFlbW9uU2V0TGlzdFByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogRGVwbG95bWVudCBlbmFibGVzIGRlY2xhcmF0aXZlIHVwZGF0ZXMgZm9yIFBvZHMgYW5kIFJlcGxpY2FTZXRzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLkRlcGxveW1lbnRcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVEZXBsb3ltZW50IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5hcHBzLnYxLkRlcGxveW1lbnRcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ2FwcHMvdjEnLFxuICAgIGtpbmQ6ICdEZXBsb3ltZW50JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmFwcHMudjEuRGVwbG95bWVudFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlRGVwbG95bWVudFByb3BzID0ge30pOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlRGVwbG95bWVudC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZURlcGxveW1lbnRQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmFwcHMudjEuRGVwbG95bWVudFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZURlcGxveW1lbnRQcm9wcyA9IHt9KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlRGVwbG95bWVudC5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZURlcGxveW1lbnQuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVEZXBsb3ltZW50UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBEZXBsb3ltZW50TGlzdCBpcyBhIGxpc3Qgb2YgRGVwbG95bWVudHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuRGVwbG95bWVudExpc3RcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVEZXBsb3ltZW50TGlzdCBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuYXBwcy52MS5EZXBsb3ltZW50TGlzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnYXBwcy92MScsXG4gICAga2luZDogJ0RlcGxveW1lbnRMaXN0JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmFwcHMudjEuRGVwbG95bWVudExpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZURlcGxveW1lbnRMaXN0UHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlRGVwbG95bWVudExpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVEZXBsb3ltZW50TGlzdFByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuYXBwcy52MS5EZXBsb3ltZW50TGlzdFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZURlcGxveW1lbnRMaXN0UHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVEZXBsb3ltZW50TGlzdC5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZURlcGxveW1lbnRMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlRGVwbG95bWVudExpc3RQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFJlcGxpY2FTZXQgZW5zdXJlcyB0aGF0IGEgc3BlY2lmaWVkIG51bWJlciBvZiBwb2QgcmVwbGljYXMgYXJlIHJ1bm5pbmcgYXQgYW55IGdpdmVuIHRpbWUuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuUmVwbGljYVNldFxuICovXG5leHBvcnQgY2xhc3MgS3ViZVJlcGxpY2FTZXQgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLmFwcHMudjEuUmVwbGljYVNldFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnYXBwcy92MScsXG4gICAga2luZDogJ1JlcGxpY2FTZXQnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuYXBwcy52MS5SZXBsaWNhU2V0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVSZXBsaWNhU2V0UHJvcHMgPSB7fSk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVSZXBsaWNhU2V0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUmVwbGljYVNldFByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuYXBwcy52MS5SZXBsaWNhU2V0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlUmVwbGljYVNldFByb3BzID0ge30pIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVSZXBsaWNhU2V0LkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUmVwbGljYVNldC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVJlcGxpY2FTZXRQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFJlcGxpY2FTZXRMaXN0IGlzIGEgY29sbGVjdGlvbiBvZiBSZXBsaWNhU2V0cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5SZXBsaWNhU2V0TGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZVJlcGxpY2FTZXRMaXN0IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5hcHBzLnYxLlJlcGxpY2FTZXRMaXN0XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdhcHBzL3YxJyxcbiAgICBraW5kOiAnUmVwbGljYVNldExpc3QnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuYXBwcy52MS5SZXBsaWNhU2V0TGlzdFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlUmVwbGljYVNldExpc3RQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVSZXBsaWNhU2V0TGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVJlcGxpY2FTZXRMaXN0UHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5hcHBzLnYxLlJlcGxpY2FTZXRMaXN0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlUmVwbGljYVNldExpc3RQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVJlcGxpY2FTZXRMaXN0LkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUmVwbGljYVNldExpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVSZXBsaWNhU2V0TGlzdFByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogU3RhdGVmdWxTZXQgcmVwcmVzZW50cyBhIHNldCBvZiBwb2RzIHdpdGggY29uc2lzdGVudCBpZGVudGl0aWVzLiBJZGVudGl0aWVzIGFyZSBkZWZpbmVkIGFzOlxuIC0gTmV0d29yazogQSBzaW5nbGUgc3RhYmxlIEROUyBhbmQgaG9zdG5hbWUuXG4gLSBTdG9yYWdlOiBBcyBtYW55IFZvbHVtZUNsYWltcyBhcyByZXF1ZXN0ZWQuXG5UaGUgU3RhdGVmdWxTZXQgZ3VhcmFudGVlcyB0aGF0IGEgZ2l2ZW4gbmV0d29yayBpZGVudGl0eSB3aWxsIGFsd2F5cyBtYXAgdG8gdGhlIHNhbWUgc3RvcmFnZSBpZGVudGl0eS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5TdGF0ZWZ1bFNldFxuICovXG5leHBvcnQgY2xhc3MgS3ViZVN0YXRlZnVsU2V0IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5hcHBzLnYxLlN0YXRlZnVsU2V0XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdhcHBzL3YxJyxcbiAgICBraW5kOiAnU3RhdGVmdWxTZXQnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuYXBwcy52MS5TdGF0ZWZ1bFNldFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlU3RhdGVmdWxTZXRQcm9wcyA9IHt9KTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVN0YXRlZnVsU2V0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlU3RhdGVmdWxTZXRQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmFwcHMudjEuU3RhdGVmdWxTZXRcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVTdGF0ZWZ1bFNldFByb3BzID0ge30pIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVTdGF0ZWZ1bFNldC5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVN0YXRlZnVsU2V0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlU3RhdGVmdWxTZXRQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFN0YXRlZnVsU2V0TGlzdCBpcyBhIGNvbGxlY3Rpb24gb2YgU3RhdGVmdWxTZXRzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLlN0YXRlZnVsU2V0TGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZVN0YXRlZnVsU2V0TGlzdCBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuYXBwcy52MS5TdGF0ZWZ1bFNldExpc3RcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ2FwcHMvdjEnLFxuICAgIGtpbmQ6ICdTdGF0ZWZ1bFNldExpc3QnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuYXBwcy52MS5TdGF0ZWZ1bFNldExpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVN0YXRlZnVsU2V0TGlzdFByb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVN0YXRlZnVsU2V0TGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVN0YXRlZnVsU2V0TGlzdFByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuYXBwcy52MS5TdGF0ZWZ1bFNldExpc3RcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVTdGF0ZWZ1bFNldExpc3RQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVN0YXRlZnVsU2V0TGlzdC5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVN0YXRlZnVsU2V0TGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVN0YXRlZnVsU2V0TGlzdFByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogVG9rZW5SZXF1ZXN0IHJlcXVlc3RzIGEgdG9rZW4gZm9yIGEgZ2l2ZW4gc2VydmljZSBhY2NvdW50LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRoZW50aWNhdGlvbi52MS5Ub2tlblJlcXVlc3RcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVUb2tlblJlcXVlc3QgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLmF1dGhlbnRpY2F0aW9uLnYxLlRva2VuUmVxdWVzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnYXV0aGVudGljYXRpb24uazhzLmlvL3YxJyxcbiAgICBraW5kOiAnVG9rZW5SZXF1ZXN0JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmF1dGhlbnRpY2F0aW9uLnYxLlRva2VuUmVxdWVzdFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlVG9rZW5SZXF1ZXN0UHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlVG9rZW5SZXF1ZXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlVG9rZW5SZXF1ZXN0UHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5hdXRoZW50aWNhdGlvbi52MS5Ub2tlblJlcXVlc3RcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVUb2tlblJlcXVlc3RQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVRva2VuUmVxdWVzdC5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVRva2VuUmVxdWVzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVRva2VuUmVxdWVzdFByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogVG9rZW5SZXZpZXcgYXR0ZW1wdHMgdG8gYXV0aGVudGljYXRlIGEgdG9rZW4gdG8gYSBrbm93biB1c2VyLiBOb3RlOiBUb2tlblJldmlldyByZXF1ZXN0cyBtYXkgYmUgY2FjaGVkIGJ5IHRoZSB3ZWJob29rIHRva2VuIGF1dGhlbnRpY2F0b3IgcGx1Z2luIGluIHRoZSBrdWJlLWFwaXNlcnZlci5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0aGVudGljYXRpb24udjEuVG9rZW5SZXZpZXdcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVUb2tlblJldmlldyBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuYXV0aGVudGljYXRpb24udjEuVG9rZW5SZXZpZXdcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ2F1dGhlbnRpY2F0aW9uLms4cy5pby92MScsXG4gICAga2luZDogJ1Rva2VuUmV2aWV3JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmF1dGhlbnRpY2F0aW9uLnYxLlRva2VuUmV2aWV3XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVUb2tlblJldmlld1Byb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVRva2VuUmV2aWV3LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlVG9rZW5SZXZpZXdQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmF1dGhlbnRpY2F0aW9uLnYxLlRva2VuUmV2aWV3XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlVG9rZW5SZXZpZXdQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVRva2VuUmV2aWV3LkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlVG9rZW5SZXZpZXcuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVUb2tlblJldmlld1Byb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogTG9jYWxTdWJqZWN0QWNjZXNzUmV2aWV3IGNoZWNrcyB3aGV0aGVyIG9yIG5vdCBhIHVzZXIgb3IgZ3JvdXAgY2FuIHBlcmZvcm0gYW4gYWN0aW9uIGluIGEgZ2l2ZW4gbmFtZXNwYWNlLiBIYXZpbmcgYSBuYW1lc3BhY2Ugc2NvcGVkIHJlc291cmNlIG1ha2VzIGl0IG11Y2ggZWFzaWVyIHRvIGdyYW50IG5hbWVzcGFjZSBzY29wZWQgcG9saWN5IHRoYXQgaW5jbHVkZXMgcGVybWlzc2lvbnMgY2hlY2tpbmcuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dGhvcml6YXRpb24udjEuTG9jYWxTdWJqZWN0QWNjZXNzUmV2aWV3XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlTG9jYWxTdWJqZWN0QWNjZXNzUmV2aWV3IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5hdXRob3JpemF0aW9uLnYxLkxvY2FsU3ViamVjdEFjY2Vzc1Jldmlld1wiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnYXV0aG9yaXphdGlvbi5rOHMuaW8vdjEnLFxuICAgIGtpbmQ6ICdMb2NhbFN1YmplY3RBY2Nlc3NSZXZpZXcnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuYXV0aG9yaXphdGlvbi52MS5Mb2NhbFN1YmplY3RBY2Nlc3NSZXZpZXdcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZUxvY2FsU3ViamVjdEFjY2Vzc1Jldmlld1Byb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUxvY2FsU3ViamVjdEFjY2Vzc1Jldmlldy5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUxvY2FsU3ViamVjdEFjY2Vzc1Jldmlld1Byb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuYXV0aG9yaXphdGlvbi52MS5Mb2NhbFN1YmplY3RBY2Nlc3NSZXZpZXdcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVMb2NhbFN1YmplY3RBY2Nlc3NSZXZpZXdQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZUxvY2FsU3ViamVjdEFjY2Vzc1Jldmlldy5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUxvY2FsU3ViamVjdEFjY2Vzc1Jldmlldy5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUxvY2FsU3ViamVjdEFjY2Vzc1Jldmlld1Byb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogU2VsZlN1YmplY3RBY2Nlc3NSZXZpZXcgY2hlY2tzIHdoZXRoZXIgb3IgdGhlIGN1cnJlbnQgdXNlciBjYW4gcGVyZm9ybSBhbiBhY3Rpb24uICBOb3QgZmlsbGluZyBpbiBhIHNwZWMubmFtZXNwYWNlIG1lYW5zIFwiaW4gYWxsIG5hbWVzcGFjZXNcIi4gIFNlbGYgaXMgYSBzcGVjaWFsIGNhc2UsIGJlY2F1c2UgdXNlcnMgc2hvdWxkIGFsd2F5cyBiZSBhYmxlIHRvIGNoZWNrIHdoZXRoZXIgdGhleSBjYW4gcGVyZm9ybSBhbiBhY3Rpb25cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0aG9yaXphdGlvbi52MS5TZWxmU3ViamVjdEFjY2Vzc1Jldmlld1xuICovXG5leHBvcnQgY2xhc3MgS3ViZVNlbGZTdWJqZWN0QWNjZXNzUmV2aWV3IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5hdXRob3JpemF0aW9uLnYxLlNlbGZTdWJqZWN0QWNjZXNzUmV2aWV3XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdhdXRob3JpemF0aW9uLms4cy5pby92MScsXG4gICAga2luZDogJ1NlbGZTdWJqZWN0QWNjZXNzUmV2aWV3JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmF1dGhvcml6YXRpb24udjEuU2VsZlN1YmplY3RBY2Nlc3NSZXZpZXdcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVNlbGZTdWJqZWN0QWNjZXNzUmV2aWV3UHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlU2VsZlN1YmplY3RBY2Nlc3NSZXZpZXcuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVTZWxmU3ViamVjdEFjY2Vzc1Jldmlld1Byb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuYXV0aG9yaXphdGlvbi52MS5TZWxmU3ViamVjdEFjY2Vzc1Jldmlld1wiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVNlbGZTdWJqZWN0QWNjZXNzUmV2aWV3UHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVTZWxmU3ViamVjdEFjY2Vzc1Jldmlldy5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVNlbGZTdWJqZWN0QWNjZXNzUmV2aWV3LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlU2VsZlN1YmplY3RBY2Nlc3NSZXZpZXdQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFNlbGZTdWJqZWN0UnVsZXNSZXZpZXcgZW51bWVyYXRlcyB0aGUgc2V0IG9mIGFjdGlvbnMgdGhlIGN1cnJlbnQgdXNlciBjYW4gcGVyZm9ybSB3aXRoaW4gYSBuYW1lc3BhY2UuIFRoZSByZXR1cm5lZCBsaXN0IG9mIGFjdGlvbnMgbWF5IGJlIGluY29tcGxldGUgZGVwZW5kaW5nIG9uIHRoZSBzZXJ2ZXIncyBhdXRob3JpemF0aW9uIG1vZGUsIGFuZCBhbnkgZXJyb3JzIGV4cGVyaWVuY2VkIGR1cmluZyB0aGUgZXZhbHVhdGlvbi4gU2VsZlN1YmplY3RSdWxlc1JldmlldyBzaG91bGQgYmUgdXNlZCBieSBVSXMgdG8gc2hvdy9oaWRlIGFjdGlvbnMsIG9yIHRvIHF1aWNrbHkgbGV0IGFuIGVuZCB1c2VyIHJlYXNvbiBhYm91dCB0aGVpciBwZXJtaXNzaW9ucy4gSXQgc2hvdWxkIE5PVCBCZSB1c2VkIGJ5IGV4dGVybmFsIHN5c3RlbXMgdG8gZHJpdmUgYXV0aG9yaXphdGlvbiBkZWNpc2lvbnMgYXMgdGhpcyByYWlzZXMgY29uZnVzZWQgZGVwdXR5LCBjYWNoZSBsaWZldGltZS9yZXZvY2F0aW9uLCBhbmQgY29ycmVjdG5lc3MgY29uY2VybnMuIFN1YmplY3RBY2Nlc3NSZXZpZXcsIGFuZCBMb2NhbEFjY2Vzc1JldmlldyBhcmUgdGhlIGNvcnJlY3Qgd2F5IHRvIGRlZmVyIGF1dGhvcml6YXRpb24gZGVjaXNpb25zIHRvIHRoZSBBUEkgc2VydmVyLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRob3JpemF0aW9uLnYxLlNlbGZTdWJqZWN0UnVsZXNSZXZpZXdcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVTZWxmU3ViamVjdFJ1bGVzUmV2aWV3IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5hdXRob3JpemF0aW9uLnYxLlNlbGZTdWJqZWN0UnVsZXNSZXZpZXdcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ2F1dGhvcml6YXRpb24uazhzLmlvL3YxJyxcbiAgICBraW5kOiAnU2VsZlN1YmplY3RSdWxlc1JldmlldycsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5hdXRob3JpemF0aW9uLnYxLlNlbGZTdWJqZWN0UnVsZXNSZXZpZXdcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVNlbGZTdWJqZWN0UnVsZXNSZXZpZXdQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVTZWxmU3ViamVjdFJ1bGVzUmV2aWV3LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlU2VsZlN1YmplY3RSdWxlc1Jldmlld1Byb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuYXV0aG9yaXphdGlvbi52MS5TZWxmU3ViamVjdFJ1bGVzUmV2aWV3XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlU2VsZlN1YmplY3RSdWxlc1Jldmlld1Byb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlU2VsZlN1YmplY3RSdWxlc1Jldmlldy5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVNlbGZTdWJqZWN0UnVsZXNSZXZpZXcuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVTZWxmU3ViamVjdFJ1bGVzUmV2aWV3UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBTdWJqZWN0QWNjZXNzUmV2aWV3IGNoZWNrcyB3aGV0aGVyIG9yIG5vdCBhIHVzZXIgb3IgZ3JvdXAgY2FuIHBlcmZvcm0gYW4gYWN0aW9uLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRob3JpemF0aW9uLnYxLlN1YmplY3RBY2Nlc3NSZXZpZXdcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVTdWJqZWN0QWNjZXNzUmV2aWV3IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5hdXRob3JpemF0aW9uLnYxLlN1YmplY3RBY2Nlc3NSZXZpZXdcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ2F1dGhvcml6YXRpb24uazhzLmlvL3YxJyxcbiAgICBraW5kOiAnU3ViamVjdEFjY2Vzc1JldmlldycsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5hdXRob3JpemF0aW9uLnYxLlN1YmplY3RBY2Nlc3NSZXZpZXdcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVN1YmplY3RBY2Nlc3NSZXZpZXdQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVTdWJqZWN0QWNjZXNzUmV2aWV3LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlU3ViamVjdEFjY2Vzc1Jldmlld1Byb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuYXV0aG9yaXphdGlvbi52MS5TdWJqZWN0QWNjZXNzUmV2aWV3XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlU3ViamVjdEFjY2Vzc1Jldmlld1Byb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlU3ViamVjdEFjY2Vzc1Jldmlldy5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVN1YmplY3RBY2Nlc3NSZXZpZXcuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVTdWJqZWN0QWNjZXNzUmV2aWV3UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBjb25maWd1cmF0aW9uIG9mIGEgaG9yaXpvbnRhbCBwb2QgYXV0b3NjYWxlci5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjEuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlciBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjEuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ2F1dG9zY2FsaW5nL3YxJyxcbiAgICBraW5kOiAnSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXInLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjEuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyUHJvcHMgPSB7fSk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlci5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyUHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MS5Ib3Jpem9udGFsUG9kQXV0b3NjYWxlclwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyUHJvcHMgPSB7fSkge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXIuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlclByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogbGlzdCBvZiBob3Jpem9udGFsIHBvZCBhdXRvc2NhbGVyIG9iamVjdHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYxLkhvcml6b250YWxQb2RBdXRvc2NhbGVyTGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyTGlzdCBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjEuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJMaXN0XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdhdXRvc2NhbGluZy92MScsXG4gICAga2luZDogJ0hvcml6b250YWxQb2RBdXRvc2NhbGVyTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MS5Ib3Jpem9udGFsUG9kQXV0b3NjYWxlckxpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyTGlzdFByb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyTGlzdFByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjEuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJMaXN0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJMaXN0UHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlckxpc3QuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlckxpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlckxpc3RQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFNjYWxlIHJlcHJlc2VudHMgYSBzY2FsaW5nIHJlcXVlc3QgZm9yIGEgcmVzb3VyY2UuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYxLlNjYWxlXG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlU2NhbGUgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYxLlNjYWxlXCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdhdXRvc2NhbGluZy92MScsXG4gICAga2luZDogJ1NjYWxlJyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYxLlNjYWxlXCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVTY2FsZVByb3BzID0ge30pOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlU2NhbGUuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVTY2FsZVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjEuU2NhbGVcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVTY2FsZVByb3BzID0ge30pIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVTY2FsZS5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVNjYWxlLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlU2NhbGVQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEhvcml6b250YWxQb2RBdXRvc2NhbGVyIGlzIHRoZSBjb25maWd1cmF0aW9uIGZvciBhIGhvcml6b250YWwgcG9kIGF1dG9zY2FsZXIsIHdoaWNoIGF1dG9tYXRpY2FsbHkgbWFuYWdlcyB0aGUgcmVwbGljYSBjb3VudCBvZiBhbnkgcmVzb3VyY2UgaW1wbGVtZW50aW5nIHRoZSBzY2FsZSBzdWJyZXNvdXJjZSBiYXNlZCBvbiB0aGUgbWV0cmljcyBzcGVjaWZpZWQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTEuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlclYyQmV0YTEgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTEuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ2F1dG9zY2FsaW5nL3YyYmV0YTEnLFxuICAgIGtpbmQ6ICdIb3Jpem9udGFsUG9kQXV0b3NjYWxlcicsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGExLkhvcml6b250YWxQb2RBdXRvc2NhbGVyXCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlclYyQmV0YTFQcm9wcyA9IHt9KTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyVjJCZXRhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyVjJCZXRhMVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMS5Ib3Jpem9udGFsUG9kQXV0b3NjYWxlclwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyVjJCZXRhMVByb3BzID0ge30pIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlclYyQmV0YTEuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlclYyQmV0YTEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlclYyQmV0YTFQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEhvcml6b250YWxQb2RBdXRvc2NhbGVyIGlzIGEgbGlzdCBvZiBob3Jpem9udGFsIHBvZCBhdXRvc2NhbGVyIG9iamVjdHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTEuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJMaXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJMaXN0VjJCZXRhMSBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMS5Ib3Jpem9udGFsUG9kQXV0b3NjYWxlckxpc3RcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ2F1dG9zY2FsaW5nL3YyYmV0YTEnLFxuICAgIGtpbmQ6ICdIb3Jpem9udGFsUG9kQXV0b3NjYWxlckxpc3QnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMS5Ib3Jpem9udGFsUG9kQXV0b3NjYWxlckxpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyTGlzdFYyQmV0YTFQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlckxpc3RWMkJldGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJMaXN0VjJCZXRhMVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMS5Ib3Jpem9udGFsUG9kQXV0b3NjYWxlckxpc3RcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlckxpc3RWMkJldGExUHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlckxpc3RWMkJldGExLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJMaXN0VjJCZXRhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyTGlzdFYyQmV0YTFQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEhvcml6b250YWxQb2RBdXRvc2NhbGVyIGlzIHRoZSBjb25maWd1cmF0aW9uIGZvciBhIGhvcml6b250YWwgcG9kIGF1dG9zY2FsZXIsIHdoaWNoIGF1dG9tYXRpY2FsbHkgbWFuYWdlcyB0aGUgcmVwbGljYSBjb3VudCBvZiBhbnkgcmVzb3VyY2UgaW1wbGVtZW50aW5nIHRoZSBzY2FsZSBzdWJyZXNvdXJjZSBiYXNlZCBvbiB0aGUgbWV0cmljcyBzcGVjaWZpZWQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlclYyQmV0YTIgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ2F1dG9zY2FsaW5nL3YyYmV0YTInLFxuICAgIGtpbmQ6ICdIb3Jpem9udGFsUG9kQXV0b3NjYWxlcicsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGEyLkhvcml6b250YWxQb2RBdXRvc2NhbGVyXCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlclYyQmV0YTJQcm9wcyA9IHt9KTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyVjJCZXRhMi5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyVjJCZXRhMlByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMi5Ib3Jpem9udGFsUG9kQXV0b3NjYWxlclwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyVjJCZXRhMlByb3BzID0ge30pIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlclYyQmV0YTIuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlclYyQmV0YTIuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlclYyQmV0YTJQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEhvcml6b250YWxQb2RBdXRvc2NhbGVyTGlzdCBpcyBhIGxpc3Qgb2YgaG9yaXpvbnRhbCBwb2QgYXV0b3NjYWxlciBvYmplY3RzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGEyLkhvcml6b250YWxQb2RBdXRvc2NhbGVyTGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyTGlzdFYyQmV0YTIgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJMaXN0XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdhdXRvc2NhbGluZy92MmJldGEyJyxcbiAgICBraW5kOiAnSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJMaXN0JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJMaXN0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlckxpc3RWMkJldGEyUHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJMaXN0VjJCZXRhMi5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyTGlzdFYyQmV0YTJQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJMaXN0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJMaXN0VjJCZXRhMlByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJMaXN0VjJCZXRhMi5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyTGlzdFYyQmV0YTIuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlckxpc3RWMkJldGEyUHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBDcm9uSm9iIHJlcHJlc2VudHMgdGhlIGNvbmZpZ3VyYXRpb24gb2YgYSBzaW5nbGUgY3JvbiBqb2IuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmJhdGNoLnYxLkNyb25Kb2JcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVDcm9uSm9iIGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5iYXRjaC52MS5Dcm9uSm9iXCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdiYXRjaC92MScsXG4gICAga2luZDogJ0Nyb25Kb2InLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuYmF0Y2gudjEuQ3JvbkpvYlwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlQ3JvbkpvYlByb3BzID0ge30pOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQ3JvbkpvYi5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUNyb25Kb2JQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmJhdGNoLnYxLkNyb25Kb2JcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVDcm9uSm9iUHJvcHMgPSB7fSkge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZUNyb25Kb2IuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVDcm9uSm9iLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlQ3JvbkpvYlByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQ3JvbkpvYkxpc3QgaXMgYSBjb2xsZWN0aW9uIG9mIGNyb24gam9icy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYmF0Y2gudjEuQ3JvbkpvYkxpc3RcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVDcm9uSm9iTGlzdCBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuYmF0Y2gudjEuQ3JvbkpvYkxpc3RcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ2JhdGNoL3YxJyxcbiAgICBraW5kOiAnQ3JvbkpvYkxpc3QnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuYmF0Y2gudjEuQ3JvbkpvYkxpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZUNyb25Kb2JMaXN0UHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQ3JvbkpvYkxpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDcm9uSm9iTGlzdFByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuYmF0Y2gudjEuQ3JvbkpvYkxpc3RcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVDcm9uSm9iTGlzdFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlQ3JvbkpvYkxpc3QuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVDcm9uSm9iTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUNyb25Kb2JMaXN0UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBKb2IgcmVwcmVzZW50cyB0aGUgY29uZmlndXJhdGlvbiBvZiBhIHNpbmdsZSBqb2IuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmJhdGNoLnYxLkpvYlxuICovXG5leHBvcnQgY2xhc3MgS3ViZUpvYiBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuYmF0Y2gudjEuSm9iXCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdiYXRjaC92MScsXG4gICAga2luZDogJ0pvYicsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5iYXRjaC52MS5Kb2JcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZUpvYlByb3BzID0ge30pOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlSm9iLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlSm9iUHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5iYXRjaC52MS5Kb2JcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVKb2JQcm9wcyA9IHt9KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlSm9iLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlSm9iLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlSm9iUHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBKb2JMaXN0IGlzIGEgY29sbGVjdGlvbiBvZiBqb2JzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5iYXRjaC52MS5Kb2JMaXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlSm9iTGlzdCBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuYmF0Y2gudjEuSm9iTGlzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnYmF0Y2gvdjEnLFxuICAgIGtpbmQ6ICdKb2JMaXN0JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmJhdGNoLnYxLkpvYkxpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZUpvYkxpc3RQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVKb2JMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlSm9iTGlzdFByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuYmF0Y2gudjEuSm9iTGlzdFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZUpvYkxpc3RQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZUpvYkxpc3QuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVKb2JMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlSm9iTGlzdFByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQ3JvbkpvYiByZXByZXNlbnRzIHRoZSBjb25maWd1cmF0aW9uIG9mIGEgc2luZ2xlIGNyb24gam9iLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5iYXRjaC52MWJldGExLkNyb25Kb2JcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVDcm9uSm9iVjFCZXRhMSBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuYmF0Y2gudjFiZXRhMS5Dcm9uSm9iXCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdiYXRjaC92MWJldGExJyxcbiAgICBraW5kOiAnQ3JvbkpvYicsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5iYXRjaC52MWJldGExLkNyb25Kb2JcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZUNyb25Kb2JWMUJldGExUHJvcHMgPSB7fSk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVDcm9uSm9iVjFCZXRhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUNyb25Kb2JWMUJldGExUHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5iYXRjaC52MWJldGExLkNyb25Kb2JcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVDcm9uSm9iVjFCZXRhMVByb3BzID0ge30pIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVDcm9uSm9iVjFCZXRhMS5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUNyb25Kb2JWMUJldGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlQ3JvbkpvYlYxQmV0YTFQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIENyb25Kb2JMaXN0IGlzIGEgY29sbGVjdGlvbiBvZiBjcm9uIGpvYnMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmJhdGNoLnYxYmV0YTEuQ3JvbkpvYkxpc3RcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVDcm9uSm9iTGlzdFYxQmV0YTEgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLmJhdGNoLnYxYmV0YTEuQ3JvbkpvYkxpc3RcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ2JhdGNoL3YxYmV0YTEnLFxuICAgIGtpbmQ6ICdDcm9uSm9iTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5iYXRjaC52MWJldGExLkNyb25Kb2JMaXN0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVDcm9uSm9iTGlzdFYxQmV0YTFQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVDcm9uSm9iTGlzdFYxQmV0YTEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDcm9uSm9iTGlzdFYxQmV0YTFQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmJhdGNoLnYxYmV0YTEuQ3JvbkpvYkxpc3RcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVDcm9uSm9iTGlzdFYxQmV0YTFQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZUNyb25Kb2JMaXN0VjFCZXRhMS5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUNyb25Kb2JMaXN0VjFCZXRhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUNyb25Kb2JMaXN0VjFCZXRhMVByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdCBvYmplY3RzIHByb3ZpZGUgYSBtZWNoYW5pc20gdG8gb2J0YWluIHg1MDkgY2VydGlmaWNhdGVzIGJ5IHN1Ym1pdHRpbmcgYSBjZXJ0aWZpY2F0ZSBzaWduaW5nIHJlcXVlc3QsIGFuZCBoYXZpbmcgaXQgYXN5bmNocm9ub3VzbHkgYXBwcm92ZWQgYW5kIGlzc3VlZC5cblxuS3ViZWxldHMgdXNlIHRoaXMgQVBJIHRvIG9idGFpbjpcbiAxLiBjbGllbnQgY2VydGlmaWNhdGVzIHRvIGF1dGhlbnRpY2F0ZSB0byBrdWJlLWFwaXNlcnZlciAod2l0aCB0aGUgXCJrdWJlcm5ldGVzLmlvL2t1YmUtYXBpc2VydmVyLWNsaWVudC1rdWJlbGV0XCIgc2lnbmVyTmFtZSkuXG4gMi4gc2VydmluZyBjZXJ0aWZpY2F0ZXMgZm9yIFRMUyBlbmRwb2ludHMga3ViZS1hcGlzZXJ2ZXIgY2FuIGNvbm5lY3QgdG8gc2VjdXJlbHkgKHdpdGggdGhlIFwia3ViZXJuZXRlcy5pby9rdWJlbGV0LXNlcnZpbmdcIiBzaWduZXJOYW1lKS5cblxuVGhpcyBBUEkgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjbGllbnQgY2VydGlmaWNhdGVzIHRvIGF1dGhlbnRpY2F0ZSB0byBrdWJlLWFwaXNlcnZlciAod2l0aCB0aGUgXCJrdWJlcm5ldGVzLmlvL2t1YmUtYXBpc2VydmVyLWNsaWVudFwiIHNpZ25lck5hbWUpLCBvciB0byBvYnRhaW4gY2VydGlmaWNhdGVzIGZyb20gY3VzdG9tIG5vbi1LdWJlcm5ldGVzIHNpZ25lcnMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNlcnRpZmljYXRlcy52MS5DZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdCBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuY2VydGlmaWNhdGVzLnYxLkNlcnRpZmljYXRlU2lnbmluZ1JlcXVlc3RcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ2NlcnRpZmljYXRlcy5rOHMuaW8vdjEnLFxuICAgIGtpbmQ6ICdDZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmNlcnRpZmljYXRlcy52MS5DZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVDZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0UHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUNlcnRpZmljYXRlU2lnbmluZ1JlcXVlc3RQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmNlcnRpZmljYXRlcy52MS5DZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdC5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUNlcnRpZmljYXRlU2lnbmluZ1JlcXVlc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBDZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0TGlzdCBpcyBhIGNvbGxlY3Rpb24gb2YgQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdCBvYmplY3RzXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNlcnRpZmljYXRlcy52MS5DZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0TGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZUNlcnRpZmljYXRlU2lnbmluZ1JlcXVlc3RMaXN0IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5jZXJ0aWZpY2F0ZXMudjEuQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdExpc3RcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ2NlcnRpZmljYXRlcy5rOHMuaW8vdjEnLFxuICAgIGtpbmQ6ICdDZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0TGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5jZXJ0aWZpY2F0ZXMudjEuQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdExpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZUNlcnRpZmljYXRlU2lnbmluZ1JlcXVlc3RMaXN0UHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdExpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0TGlzdFByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuY2VydGlmaWNhdGVzLnYxLkNlcnRpZmljYXRlU2lnbmluZ1JlcXVlc3RMaXN0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdExpc3RQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZUNlcnRpZmljYXRlU2lnbmluZ1JlcXVlc3RMaXN0LkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdExpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0TGlzdFByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogTGVhc2UgZGVmaW5lcyBhIGxlYXNlIGNvbmNlcHQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvb3JkaW5hdGlvbi52MS5MZWFzZVxuICovXG5leHBvcnQgY2xhc3MgS3ViZUxlYXNlIGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5jb29yZGluYXRpb24udjEuTGVhc2VcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ2Nvb3JkaW5hdGlvbi5rOHMuaW8vdjEnLFxuICAgIGtpbmQ6ICdMZWFzZScsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5jb29yZGluYXRpb24udjEuTGVhc2VcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZUxlYXNlUHJvcHMgPSB7fSk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVMZWFzZS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUxlYXNlUHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5jb29yZGluYXRpb24udjEuTGVhc2VcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVMZWFzZVByb3BzID0ge30pIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVMZWFzZS5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUxlYXNlLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlTGVhc2VQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIExlYXNlTGlzdCBpcyBhIGxpc3Qgb2YgTGVhc2Ugb2JqZWN0cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29vcmRpbmF0aW9uLnYxLkxlYXNlTGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZUxlYXNlTGlzdCBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuY29vcmRpbmF0aW9uLnYxLkxlYXNlTGlzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnY29vcmRpbmF0aW9uLms4cy5pby92MScsXG4gICAga2luZDogJ0xlYXNlTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5jb29yZGluYXRpb24udjEuTGVhc2VMaXN0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVMZWFzZUxpc3RQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVMZWFzZUxpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVMZWFzZUxpc3RQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmNvb3JkaW5hdGlvbi52MS5MZWFzZUxpc3RcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVMZWFzZUxpc3RQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZUxlYXNlTGlzdC5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUxlYXNlTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUxlYXNlTGlzdFByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQmluZGluZyB0aWVzIG9uZSBvYmplY3QgdG8gYW5vdGhlcjsgZm9yIGV4YW1wbGUsIGEgcG9kIGlzIGJvdW5kIHRvIGEgbm9kZSBieSBhIHNjaGVkdWxlci4gRGVwcmVjYXRlZCBpbiAxLjcsIHBsZWFzZSB1c2UgdGhlIGJpbmRpbmdzIHN1YnJlc291cmNlIG9mIHBvZHMgaW5zdGVhZC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5CaW5kaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlQmluZGluZyBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuY29yZS52MS5CaW5kaW5nXCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICd2MScsXG4gICAga2luZDogJ0JpbmRpbmcnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuY29yZS52MS5CaW5kaW5nXCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVCaW5kaW5nUHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQmluZGluZy5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUJpbmRpbmdQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmNvcmUudjEuQmluZGluZ1wiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZUJpbmRpbmdQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZUJpbmRpbmcuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVCaW5kaW5nLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlQmluZGluZ1Byb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQ29tcG9uZW50U3RhdHVzIChhbmQgQ29tcG9uZW50U3RhdHVzTGlzdCkgaG9sZHMgdGhlIGNsdXN0ZXIgdmFsaWRhdGlvbiBpbmZvLiBEZXByZWNhdGVkOiBUaGlzIEFQSSBpcyBkZXByZWNhdGVkIGluIHYxLjE5K1xuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbXBvbmVudFN0YXR1c1xuICovXG5leHBvcnQgY2xhc3MgS3ViZUNvbXBvbmVudFN0YXR1cyBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuY29yZS52MS5Db21wb25lbnRTdGF0dXNcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3YxJyxcbiAgICBraW5kOiAnQ29tcG9uZW50U3RhdHVzJyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmNvcmUudjEuQ29tcG9uZW50U3RhdHVzXCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVDb21wb25lbnRTdGF0dXNQcm9wcyA9IHt9KTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUNvbXBvbmVudFN0YXR1cy5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUNvbXBvbmVudFN0YXR1c1Byb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuY29yZS52MS5Db21wb25lbnRTdGF0dXNcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVDb21wb25lbnRTdGF0dXNQcm9wcyA9IHt9KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlQ29tcG9uZW50U3RhdHVzLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQ29tcG9uZW50U3RhdHVzLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlQ29tcG9uZW50U3RhdHVzUHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBTdGF0dXMgb2YgYWxsIHRoZSBjb25kaXRpb25zIGZvciB0aGUgY29tcG9uZW50IGFzIGEgbGlzdCBvZiBDb21wb25lbnRTdGF0dXMgb2JqZWN0cy4gRGVwcmVjYXRlZDogVGhpcyBBUEkgaXMgZGVwcmVjYXRlZCBpbiB2MS4xOStcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db21wb25lbnRTdGF0dXNMaXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlQ29tcG9uZW50U3RhdHVzTGlzdCBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuY29yZS52MS5Db21wb25lbnRTdGF0dXNMaXN0XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICd2MScsXG4gICAga2luZDogJ0NvbXBvbmVudFN0YXR1c0xpc3QnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuY29yZS52MS5Db21wb25lbnRTdGF0dXNMaXN0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVDb21wb25lbnRTdGF0dXNMaXN0UHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQ29tcG9uZW50U3RhdHVzTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUNvbXBvbmVudFN0YXR1c0xpc3RQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmNvcmUudjEuQ29tcG9uZW50U3RhdHVzTGlzdFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZUNvbXBvbmVudFN0YXR1c0xpc3RQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZUNvbXBvbmVudFN0YXR1c0xpc3QuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVDb21wb25lbnRTdGF0dXNMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlQ29tcG9uZW50U3RhdHVzTGlzdFByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQ29uZmlnTWFwIGhvbGRzIGNvbmZpZ3VyYXRpb24gZGF0YSBmb3IgcG9kcyB0byBjb25zdW1lLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbmZpZ01hcFxuICovXG5leHBvcnQgY2xhc3MgS3ViZUNvbmZpZ01hcCBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuY29yZS52MS5Db25maWdNYXBcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3YxJyxcbiAgICBraW5kOiAnQ29uZmlnTWFwJyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmNvcmUudjEuQ29uZmlnTWFwXCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVDb25maWdNYXBQcm9wcyA9IHt9KTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUNvbmZpZ01hcC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUNvbmZpZ01hcFByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuY29yZS52MS5Db25maWdNYXBcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVDb25maWdNYXBQcm9wcyA9IHt9KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlQ29uZmlnTWFwLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQ29uZmlnTWFwLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlQ29uZmlnTWFwUHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBDb25maWdNYXBMaXN0IGlzIGEgcmVzb3VyY2UgY29udGFpbmluZyBhIGxpc3Qgb2YgQ29uZmlnTWFwIG9iamVjdHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ29uZmlnTWFwTGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZUNvbmZpZ01hcExpc3QgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLmNvcmUudjEuQ29uZmlnTWFwTGlzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAndjEnLFxuICAgIGtpbmQ6ICdDb25maWdNYXBMaXN0JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmNvcmUudjEuQ29uZmlnTWFwTGlzdFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlQ29uZmlnTWFwTGlzdFByb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUNvbmZpZ01hcExpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDb25maWdNYXBMaXN0UHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5jb3JlLnYxLkNvbmZpZ01hcExpc3RcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVDb25maWdNYXBMaXN0UHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVDb25maWdNYXBMaXN0LkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQ29uZmlnTWFwTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUNvbmZpZ01hcExpc3RQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEVuZHBvaW50cyBpcyBhIGNvbGxlY3Rpb24gb2YgZW5kcG9pbnRzIHRoYXQgaW1wbGVtZW50IHRoZSBhY3R1YWwgc2VydmljZS4gRXhhbXBsZTpcbiAgTmFtZTogXCJteXN2Y1wiLFxuICBTdWJzZXRzOiBbXG4gICAge1xuICAgICAgQWRkcmVzc2VzOiBbe1wiaXBcIjogXCIxMC4xMC4xLjFcIn0sIHtcImlwXCI6IFwiMTAuMTAuMi4yXCJ9XSxcbiAgICAgIFBvcnRzOiBbe1wibmFtZVwiOiBcImFcIiwgXCJwb3J0XCI6IDg2NzV9LCB7XCJuYW1lXCI6IFwiYlwiLCBcInBvcnRcIjogMzA5fV1cbiAgICB9LFxuICAgIHtcbiAgICAgIEFkZHJlc3NlczogW3tcImlwXCI6IFwiMTAuMTAuMy4zXCJ9XSxcbiAgICAgIFBvcnRzOiBbe1wibmFtZVwiOiBcImFcIiwgXCJwb3J0XCI6IDkzfSwge1wibmFtZVwiOiBcImJcIiwgXCJwb3J0XCI6IDc2fV1cbiAgICB9LFxuIF1cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FbmRwb2ludHNcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVFbmRwb2ludHMgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLmNvcmUudjEuRW5kcG9pbnRzXCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICd2MScsXG4gICAga2luZDogJ0VuZHBvaW50cycsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLkVuZHBvaW50c1wiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlRW5kcG9pbnRzUHJvcHMgPSB7fSk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVFbmRwb2ludHMuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVFbmRwb2ludHNQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmNvcmUudjEuRW5kcG9pbnRzXCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlRW5kcG9pbnRzUHJvcHMgPSB7fSkge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZUVuZHBvaW50cy5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUVuZHBvaW50cy5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUVuZHBvaW50c1Byb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogRW5kcG9pbnRzTGlzdCBpcyBhIGxpc3Qgb2YgZW5kcG9pbnRzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkVuZHBvaW50c0xpc3RcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVFbmRwb2ludHNMaXN0IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLkVuZHBvaW50c0xpc3RcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3YxJyxcbiAgICBraW5kOiAnRW5kcG9pbnRzTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLkVuZHBvaW50c0xpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZUVuZHBvaW50c0xpc3RQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVFbmRwb2ludHNMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlRW5kcG9pbnRzTGlzdFByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuY29yZS52MS5FbmRwb2ludHNMaXN0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlRW5kcG9pbnRzTGlzdFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlRW5kcG9pbnRzTGlzdC5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUVuZHBvaW50c0xpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVFbmRwb2ludHNMaXN0UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBFdmVudCBpcyBhIHJlcG9ydCBvZiBhbiBldmVudCBzb21ld2hlcmUgaW4gdGhlIGNsdXN0ZXIuIEl0IGdlbmVyYWxseSBkZW5vdGVzIHNvbWUgc3RhdGUgY2hhbmdlIGluIHRoZSBzeXN0ZW0uIEV2ZW50cyBoYXZlIGEgbGltaXRlZCByZXRlbnRpb24gdGltZSBhbmQgdHJpZ2dlcnMgYW5kIG1lc3NhZ2VzIG1heSBldm9sdmUgd2l0aCB0aW1lLiAgRXZlbnQgY29uc3VtZXJzIHNob3VsZCBub3QgcmVseSBvbiB0aGUgdGltaW5nIG9mIGFuIGV2ZW50IHdpdGggYSBnaXZlbiBSZWFzb24gcmVmbGVjdGluZyBhIGNvbnNpc3RlbnQgdW5kZXJseWluZyB0cmlnZ2VyLCBvciB0aGUgY29udGludWVkIGV4aXN0ZW5jZSBvZiBldmVudHMgd2l0aCB0aGF0IFJlYXNvbi4gIEV2ZW50cyBzaG91bGQgYmUgdHJlYXRlZCBhcyBpbmZvcm1hdGl2ZSwgYmVzdC1lZmZvcnQsIHN1cHBsZW1lbnRhbCBkYXRhLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5ldmVudHMudjEuRXZlbnRcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVFdmVudCBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuZXZlbnRzLnYxLkV2ZW50XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdldmVudHMuazhzLmlvL3YxJyxcbiAgICBraW5kOiAnRXZlbnQnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuZXZlbnRzLnYxLkV2ZW50XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVFdmVudFByb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUV2ZW50LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlRXZlbnRQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmV2ZW50cy52MS5FdmVudFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZUV2ZW50UHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVFdmVudC5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUV2ZW50LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlRXZlbnRQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEV2ZW50TGlzdCBpcyBhIGxpc3Qgb2YgRXZlbnQgb2JqZWN0cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuZXZlbnRzLnYxLkV2ZW50TGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZUV2ZW50TGlzdCBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuZXZlbnRzLnYxLkV2ZW50TGlzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnZXZlbnRzLms4cy5pby92MScsXG4gICAga2luZDogJ0V2ZW50TGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5ldmVudHMudjEuRXZlbnRMaXN0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVFdmVudExpc3RQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVFdmVudExpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVFdmVudExpc3RQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmV2ZW50cy52MS5FdmVudExpc3RcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVFdmVudExpc3RQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZUV2ZW50TGlzdC5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUV2ZW50TGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUV2ZW50TGlzdFByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogTGltaXRSYW5nZSBzZXRzIHJlc291cmNlIHVzYWdlIGxpbWl0cyBmb3IgZWFjaCBraW5kIG9mIHJlc291cmNlIGluIGEgTmFtZXNwYWNlLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkxpbWl0UmFuZ2VcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVMaW1pdFJhbmdlIGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLkxpbWl0UmFuZ2VcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3YxJyxcbiAgICBraW5kOiAnTGltaXRSYW5nZScsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLkxpbWl0UmFuZ2VcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZUxpbWl0UmFuZ2VQcm9wcyA9IHt9KTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUxpbWl0UmFuZ2UuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVMaW1pdFJhbmdlUHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5jb3JlLnYxLkxpbWl0UmFuZ2VcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVMaW1pdFJhbmdlUHJvcHMgPSB7fSkge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZUxpbWl0UmFuZ2UuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVMaW1pdFJhbmdlLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlTGltaXRSYW5nZVByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogTGltaXRSYW5nZUxpc3QgaXMgYSBsaXN0IG9mIExpbWl0UmFuZ2UgaXRlbXMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTGltaXRSYW5nZUxpc3RcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVMaW1pdFJhbmdlTGlzdCBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuY29yZS52MS5MaW1pdFJhbmdlTGlzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAndjEnLFxuICAgIGtpbmQ6ICdMaW1pdFJhbmdlTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLkxpbWl0UmFuZ2VMaXN0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVMaW1pdFJhbmdlTGlzdFByb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUxpbWl0UmFuZ2VMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlTGltaXRSYW5nZUxpc3RQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmNvcmUudjEuTGltaXRSYW5nZUxpc3RcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVMaW1pdFJhbmdlTGlzdFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlTGltaXRSYW5nZUxpc3QuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVMaW1pdFJhbmdlTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUxpbWl0UmFuZ2VMaXN0UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBOYW1lc3BhY2UgcHJvdmlkZXMgYSBzY29wZSBmb3IgTmFtZXMuIFVzZSBvZiBtdWx0aXBsZSBuYW1lc3BhY2VzIGlzIG9wdGlvbmFsLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLk5hbWVzcGFjZVxuICovXG5leHBvcnQgY2xhc3MgS3ViZU5hbWVzcGFjZSBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuY29yZS52MS5OYW1lc3BhY2VcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3YxJyxcbiAgICBraW5kOiAnTmFtZXNwYWNlJyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmNvcmUudjEuTmFtZXNwYWNlXCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVOYW1lc3BhY2VQcm9wcyA9IHt9KTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZU5hbWVzcGFjZS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZU5hbWVzcGFjZVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuY29yZS52MS5OYW1lc3BhY2VcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVOYW1lc3BhY2VQcm9wcyA9IHt9KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlTmFtZXNwYWNlLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlTmFtZXNwYWNlLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlTmFtZXNwYWNlUHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBOYW1lc3BhY2VMaXN0IGlzIGEgbGlzdCBvZiBOYW1lc3BhY2VzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLk5hbWVzcGFjZUxpc3RcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVOYW1lc3BhY2VMaXN0IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLk5hbWVzcGFjZUxpc3RcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3YxJyxcbiAgICBraW5kOiAnTmFtZXNwYWNlTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLk5hbWVzcGFjZUxpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZU5hbWVzcGFjZUxpc3RQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVOYW1lc3BhY2VMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlTmFtZXNwYWNlTGlzdFByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuY29yZS52MS5OYW1lc3BhY2VMaXN0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlTmFtZXNwYWNlTGlzdFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlTmFtZXNwYWNlTGlzdC5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZU5hbWVzcGFjZUxpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVOYW1lc3BhY2VMaXN0UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBOb2RlIGlzIGEgd29ya2VyIG5vZGUgaW4gS3ViZXJuZXRlcy4gRWFjaCBub2RlIHdpbGwgaGF2ZSBhIHVuaXF1ZSBpZGVudGlmaWVyIGluIHRoZSBjYWNoZSAoaS5lLiBpbiBldGNkKS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Ob2RlXG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlTm9kZSBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuY29yZS52MS5Ob2RlXCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICd2MScsXG4gICAga2luZDogJ05vZGUnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuY29yZS52MS5Ob2RlXCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVOb2RlUHJvcHMgPSB7fSk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVOb2RlLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlTm9kZVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuY29yZS52MS5Ob2RlXCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlTm9kZVByb3BzID0ge30pIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVOb2RlLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlTm9kZS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZU5vZGVQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIE5vZGVMaXN0IGlzIHRoZSB3aG9sZSBsaXN0IG9mIGFsbCBOb2RlcyB3aGljaCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCB3aXRoIG1hc3Rlci5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Ob2RlTGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZU5vZGVMaXN0IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLk5vZGVMaXN0XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICd2MScsXG4gICAga2luZDogJ05vZGVMaXN0JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmNvcmUudjEuTm9kZUxpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZU5vZGVMaXN0UHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlTm9kZUxpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVOb2RlTGlzdFByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuY29yZS52MS5Ob2RlTGlzdFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZU5vZGVMaXN0UHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVOb2RlTGlzdC5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZU5vZGVMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlTm9kZUxpc3RQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBlcnNpc3RlbnRWb2x1bWUgKFBWKSBpcyBhIHN0b3JhZ2UgcmVzb3VyY2UgcHJvdmlzaW9uZWQgYnkgYW4gYWRtaW5pc3RyYXRvci4gSXQgaXMgYW5hbG9nb3VzIHRvIGEgbm9kZS4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3BlcnNpc3RlbnQtdm9sdW1lc1xuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVQZXJzaXN0ZW50Vm9sdW1lIGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3YxJyxcbiAgICBraW5kOiAnUGVyc2lzdGVudFZvbHVtZScsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVBlcnNpc3RlbnRWb2x1bWVQcm9wcyA9IHt9KTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVBlcnNpc3RlbnRWb2x1bWUuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVQZXJzaXN0ZW50Vm9sdW1lUHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVQZXJzaXN0ZW50Vm9sdW1lUHJvcHMgPSB7fSkge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVBlcnNpc3RlbnRWb2x1bWUuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVQZXJzaXN0ZW50Vm9sdW1lLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUGVyc2lzdGVudFZvbHVtZVByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUGVyc2lzdGVudFZvbHVtZUNsYWltIGlzIGEgdXNlcidzIHJlcXVlc3QgZm9yIGFuZCBjbGFpbSB0byBhIHBlcnNpc3RlbnQgdm9sdW1lXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZUNsYWltXG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlUGVyc2lzdGVudFZvbHVtZUNsYWltIGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVDbGFpbVwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAndjEnLFxuICAgIGtpbmQ6ICdQZXJzaXN0ZW50Vm9sdW1lQ2xhaW0nLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lQ2xhaW1cIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVBlcnNpc3RlbnRWb2x1bWVDbGFpbVByb3BzID0ge30pOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUGVyc2lzdGVudFZvbHVtZUNsYWltLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUGVyc2lzdGVudFZvbHVtZUNsYWltUHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVDbGFpbVwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVBlcnNpc3RlbnRWb2x1bWVDbGFpbVByb3BzID0ge30pIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVQZXJzaXN0ZW50Vm9sdW1lQ2xhaW0uR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVQZXJzaXN0ZW50Vm9sdW1lQ2xhaW0uR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVQZXJzaXN0ZW50Vm9sdW1lQ2xhaW1Qcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBlcnNpc3RlbnRWb2x1bWVDbGFpbUxpc3QgaXMgYSBsaXN0IG9mIFBlcnNpc3RlbnRWb2x1bWVDbGFpbSBpdGVtcy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lQ2xhaW1MaXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlUGVyc2lzdGVudFZvbHVtZUNsYWltTGlzdCBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lQ2xhaW1MaXN0XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICd2MScsXG4gICAga2luZDogJ1BlcnNpc3RlbnRWb2x1bWVDbGFpbUxpc3QnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lQ2xhaW1MaXN0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVQZXJzaXN0ZW50Vm9sdW1lQ2xhaW1MaXN0UHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUGVyc2lzdGVudFZvbHVtZUNsYWltTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVBlcnNpc3RlbnRWb2x1bWVDbGFpbUxpc3RQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZUNsYWltTGlzdFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVBlcnNpc3RlbnRWb2x1bWVDbGFpbUxpc3RQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVBlcnNpc3RlbnRWb2x1bWVDbGFpbUxpc3QuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVQZXJzaXN0ZW50Vm9sdW1lQ2xhaW1MaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUGVyc2lzdGVudFZvbHVtZUNsYWltTGlzdFByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUGVyc2lzdGVudFZvbHVtZUxpc3QgaXMgYSBsaXN0IG9mIFBlcnNpc3RlbnRWb2x1bWUgaXRlbXMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZUxpc3RcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVQZXJzaXN0ZW50Vm9sdW1lTGlzdCBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lTGlzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAndjEnLFxuICAgIGtpbmQ6ICdQZXJzaXN0ZW50Vm9sdW1lTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVMaXN0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVQZXJzaXN0ZW50Vm9sdW1lTGlzdFByb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVBlcnNpc3RlbnRWb2x1bWVMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUGVyc2lzdGVudFZvbHVtZUxpc3RQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZUxpc3RcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVQZXJzaXN0ZW50Vm9sdW1lTGlzdFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlUGVyc2lzdGVudFZvbHVtZUxpc3QuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVQZXJzaXN0ZW50Vm9sdW1lTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVBlcnNpc3RlbnRWb2x1bWVMaXN0UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2QgaXMgYSBjb2xsZWN0aW9uIG9mIGNvbnRhaW5lcnMgdGhhdCBjYW4gcnVuIG9uIGEgaG9zdC4gVGhpcyByZXNvdXJjZSBpcyBjcmVhdGVkIGJ5IGNsaWVudHMgYW5kIHNjaGVkdWxlZCBvbnRvIGhvc3RzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZFxuICovXG5leHBvcnQgY2xhc3MgS3ViZVBvZCBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuY29yZS52MS5Qb2RcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3YxJyxcbiAgICBraW5kOiAnUG9kJyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmNvcmUudjEuUG9kXCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVQb2RQcm9wcyA9IHt9KTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVBvZC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVBvZFByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuY29yZS52MS5Qb2RcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVQb2RQcm9wcyA9IHt9KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlUG9kLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUG9kLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUG9kUHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2RMaXN0IGlzIGEgbGlzdCBvZiBQb2RzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZExpc3RcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVQb2RMaXN0IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLlBvZExpc3RcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3YxJyxcbiAgICBraW5kOiAnUG9kTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLlBvZExpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVBvZExpc3RQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVQb2RMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUG9kTGlzdFByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuY29yZS52MS5Qb2RMaXN0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlUG9kTGlzdFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlUG9kTGlzdC5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVBvZExpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVQb2RMaXN0UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2RUZW1wbGF0ZSBkZXNjcmliZXMgYSB0ZW1wbGF0ZSBmb3IgY3JlYXRpbmcgY29waWVzIG9mIGEgcHJlZGVmaW5lZCBwb2QuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kVGVtcGxhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVQb2RUZW1wbGF0ZSBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuY29yZS52MS5Qb2RUZW1wbGF0ZVwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAndjEnLFxuICAgIGtpbmQ6ICdQb2RUZW1wbGF0ZScsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLlBvZFRlbXBsYXRlXCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVQb2RUZW1wbGF0ZVByb3BzID0ge30pOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUG9kVGVtcGxhdGUuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVQb2RUZW1wbGF0ZVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuY29yZS52MS5Qb2RUZW1wbGF0ZVwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVBvZFRlbXBsYXRlUHJvcHMgPSB7fSkge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVBvZFRlbXBsYXRlLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUG9kVGVtcGxhdGUuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVQb2RUZW1wbGF0ZVByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUG9kVGVtcGxhdGVMaXN0IGlzIGEgbGlzdCBvZiBQb2RUZW1wbGF0ZXMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kVGVtcGxhdGVMaXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlUG9kVGVtcGxhdGVMaXN0IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLlBvZFRlbXBsYXRlTGlzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAndjEnLFxuICAgIGtpbmQ6ICdQb2RUZW1wbGF0ZUxpc3QnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuY29yZS52MS5Qb2RUZW1wbGF0ZUxpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVBvZFRlbXBsYXRlTGlzdFByb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVBvZFRlbXBsYXRlTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVBvZFRlbXBsYXRlTGlzdFByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuY29yZS52MS5Qb2RUZW1wbGF0ZUxpc3RcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVQb2RUZW1wbGF0ZUxpc3RQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVBvZFRlbXBsYXRlTGlzdC5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVBvZFRlbXBsYXRlTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVBvZFRlbXBsYXRlTGlzdFByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUmVwbGljYXRpb25Db250cm9sbGVyIHJlcHJlc2VudHMgdGhlIGNvbmZpZ3VyYXRpb24gb2YgYSByZXBsaWNhdGlvbiBjb250cm9sbGVyLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlJlcGxpY2F0aW9uQ29udHJvbGxlclxuICovXG5leHBvcnQgY2xhc3MgS3ViZVJlcGxpY2F0aW9uQ29udHJvbGxlciBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuY29yZS52MS5SZXBsaWNhdGlvbkNvbnRyb2xsZXJcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3YxJyxcbiAgICBraW5kOiAnUmVwbGljYXRpb25Db250cm9sbGVyJyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmNvcmUudjEuUmVwbGljYXRpb25Db250cm9sbGVyXCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVSZXBsaWNhdGlvbkNvbnRyb2xsZXJQcm9wcyA9IHt9KTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVJlcGxpY2F0aW9uQ29udHJvbGxlci5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVJlcGxpY2F0aW9uQ29udHJvbGxlclByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuY29yZS52MS5SZXBsaWNhdGlvbkNvbnRyb2xsZXJcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVSZXBsaWNhdGlvbkNvbnRyb2xsZXJQcm9wcyA9IHt9KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlUmVwbGljYXRpb25Db250cm9sbGVyLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUmVwbGljYXRpb25Db250cm9sbGVyLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUmVwbGljYXRpb25Db250cm9sbGVyUHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBSZXBsaWNhdGlvbkNvbnRyb2xsZXJMaXN0IGlzIGEgY29sbGVjdGlvbiBvZiByZXBsaWNhdGlvbiBjb250cm9sbGVycy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5SZXBsaWNhdGlvbkNvbnRyb2xsZXJMaXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlUmVwbGljYXRpb25Db250cm9sbGVyTGlzdCBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuY29yZS52MS5SZXBsaWNhdGlvbkNvbnRyb2xsZXJMaXN0XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICd2MScsXG4gICAga2luZDogJ1JlcGxpY2F0aW9uQ29udHJvbGxlckxpc3QnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuY29yZS52MS5SZXBsaWNhdGlvbkNvbnRyb2xsZXJMaXN0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVSZXBsaWNhdGlvbkNvbnRyb2xsZXJMaXN0UHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUmVwbGljYXRpb25Db250cm9sbGVyTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVJlcGxpY2F0aW9uQ29udHJvbGxlckxpc3RQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmNvcmUudjEuUmVwbGljYXRpb25Db250cm9sbGVyTGlzdFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVJlcGxpY2F0aW9uQ29udHJvbGxlckxpc3RQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVJlcGxpY2F0aW9uQ29udHJvbGxlckxpc3QuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVSZXBsaWNhdGlvbkNvbnRyb2xsZXJMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUmVwbGljYXRpb25Db250cm9sbGVyTGlzdFByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUmVzb3VyY2VRdW90YSBzZXRzIGFnZ3JlZ2F0ZSBxdW90YSByZXN0cmljdGlvbnMgZW5mb3JjZWQgcGVyIG5hbWVzcGFjZVxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlJlc291cmNlUXVvdGFcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVSZXNvdXJjZVF1b3RhIGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLlJlc291cmNlUXVvdGFcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3YxJyxcbiAgICBraW5kOiAnUmVzb3VyY2VRdW90YScsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLlJlc291cmNlUXVvdGFcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVJlc291cmNlUXVvdGFQcm9wcyA9IHt9KTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVJlc291cmNlUXVvdGEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVSZXNvdXJjZVF1b3RhUHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5jb3JlLnYxLlJlc291cmNlUXVvdGFcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVSZXNvdXJjZVF1b3RhUHJvcHMgPSB7fSkge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVJlc291cmNlUXVvdGEuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVSZXNvdXJjZVF1b3RhLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUmVzb3VyY2VRdW90YVByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUmVzb3VyY2VRdW90YUxpc3QgaXMgYSBsaXN0IG9mIFJlc291cmNlUXVvdGEgaXRlbXMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUmVzb3VyY2VRdW90YUxpc3RcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVSZXNvdXJjZVF1b3RhTGlzdCBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuY29yZS52MS5SZXNvdXJjZVF1b3RhTGlzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAndjEnLFxuICAgIGtpbmQ6ICdSZXNvdXJjZVF1b3RhTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLlJlc291cmNlUXVvdGFMaXN0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVSZXNvdXJjZVF1b3RhTGlzdFByb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVJlc291cmNlUXVvdGFMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUmVzb3VyY2VRdW90YUxpc3RQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmNvcmUudjEuUmVzb3VyY2VRdW90YUxpc3RcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVSZXNvdXJjZVF1b3RhTGlzdFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlUmVzb3VyY2VRdW90YUxpc3QuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVSZXNvdXJjZVF1b3RhTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVJlc291cmNlUXVvdGFMaXN0UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBTZWNyZXQgaG9sZHMgc2VjcmV0IGRhdGEgb2YgYSBjZXJ0YWluIHR5cGUuIFRoZSB0b3RhbCBieXRlcyBvZiB0aGUgdmFsdWVzIGluIHRoZSBEYXRhIGZpZWxkIG11c3QgYmUgbGVzcyB0aGFuIE1heFNlY3JldFNpemUgYnl0ZXMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VjcmV0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlU2VjcmV0IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLlNlY3JldFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAndjEnLFxuICAgIGtpbmQ6ICdTZWNyZXQnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuY29yZS52MS5TZWNyZXRcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVNlY3JldFByb3BzID0ge30pOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlU2VjcmV0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlU2VjcmV0UHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5jb3JlLnYxLlNlY3JldFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVNlY3JldFByb3BzID0ge30pIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVTZWNyZXQuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVTZWNyZXQuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVTZWNyZXRQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFNlY3JldExpc3QgaXMgYSBsaXN0IG9mIFNlY3JldC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZWNyZXRMaXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlU2VjcmV0TGlzdCBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuY29yZS52MS5TZWNyZXRMaXN0XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICd2MScsXG4gICAga2luZDogJ1NlY3JldExpc3QnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuY29yZS52MS5TZWNyZXRMaXN0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVTZWNyZXRMaXN0UHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlU2VjcmV0TGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVNlY3JldExpc3RQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmNvcmUudjEuU2VjcmV0TGlzdFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVNlY3JldExpc3RQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVNlY3JldExpc3QuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVTZWNyZXRMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlU2VjcmV0TGlzdFByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogU2VydmljZSBpcyBhIG5hbWVkIGFic3RyYWN0aW9uIG9mIHNvZnR3YXJlIHNlcnZpY2UgKGZvciBleGFtcGxlLCBteXNxbCkgY29uc2lzdGluZyBvZiBsb2NhbCBwb3J0IChmb3IgZXhhbXBsZSAzMzA2KSB0aGF0IHRoZSBwcm94eSBsaXN0ZW5zIG9uLCBhbmQgdGhlIHNlbGVjdG9yIHRoYXQgZGV0ZXJtaW5lcyB3aGljaCBwb2RzIHdpbGwgYW5zd2VyIHJlcXVlc3RzIHNlbnQgdGhyb3VnaCB0aGUgcHJveHkuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZVxuICovXG5leHBvcnQgY2xhc3MgS3ViZVNlcnZpY2UgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZVwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAndjEnLFxuICAgIGtpbmQ6ICdTZXJ2aWNlJyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZVwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlU2VydmljZVByb3BzID0ge30pOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlU2VydmljZS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVNlcnZpY2VQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZVwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVNlcnZpY2VQcm9wcyA9IHt9KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlU2VydmljZS5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVNlcnZpY2UuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVTZXJ2aWNlUHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBTZXJ2aWNlQWNjb3VudCBiaW5kcyB0b2dldGhlcjogKiBhIG5hbWUsIHVuZGVyc3Rvb2QgYnkgdXNlcnMsIGFuZCBwZXJoYXBzIGJ5IHBlcmlwaGVyYWwgc3lzdGVtcywgZm9yIGFuIGlkZW50aXR5ICogYSBwcmluY2lwYWwgdGhhdCBjYW4gYmUgYXV0aGVudGljYXRlZCBhbmQgYXV0aG9yaXplZCAqIGEgc2V0IG9mIHNlY3JldHNcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZXJ2aWNlQWNjb3VudFxuICovXG5leHBvcnQgY2xhc3MgS3ViZVNlcnZpY2VBY2NvdW50IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLlNlcnZpY2VBY2NvdW50XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICd2MScsXG4gICAga2luZDogJ1NlcnZpY2VBY2NvdW50JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZUFjY291bnRcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVNlcnZpY2VBY2NvdW50UHJvcHMgPSB7fSk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVTZXJ2aWNlQWNjb3VudC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVNlcnZpY2VBY2NvdW50UHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5jb3JlLnYxLlNlcnZpY2VBY2NvdW50XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlU2VydmljZUFjY291bnRQcm9wcyA9IHt9KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlU2VydmljZUFjY291bnQuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVTZXJ2aWNlQWNjb3VudC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVNlcnZpY2VBY2NvdW50UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBTZXJ2aWNlQWNjb3VudExpc3QgaXMgYSBsaXN0IG9mIFNlcnZpY2VBY2NvdW50IG9iamVjdHNcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZXJ2aWNlQWNjb3VudExpc3RcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVTZXJ2aWNlQWNjb3VudExpc3QgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZUFjY291bnRMaXN0XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICd2MScsXG4gICAga2luZDogJ1NlcnZpY2VBY2NvdW50TGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLlNlcnZpY2VBY2NvdW50TGlzdFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlU2VydmljZUFjY291bnRMaXN0UHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlU2VydmljZUFjY291bnRMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlU2VydmljZUFjY291bnRMaXN0UHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5jb3JlLnYxLlNlcnZpY2VBY2NvdW50TGlzdFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVNlcnZpY2VBY2NvdW50TGlzdFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlU2VydmljZUFjY291bnRMaXN0LkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlU2VydmljZUFjY291bnRMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlU2VydmljZUFjY291bnRMaXN0UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBTZXJ2aWNlTGlzdCBob2xkcyBhIGxpc3Qgb2Ygc2VydmljZXMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZUxpc3RcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVTZXJ2aWNlTGlzdCBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuY29yZS52MS5TZXJ2aWNlTGlzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAndjEnLFxuICAgIGtpbmQ6ICdTZXJ2aWNlTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5jb3JlLnYxLlNlcnZpY2VMaXN0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVTZXJ2aWNlTGlzdFByb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVNlcnZpY2VMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlU2VydmljZUxpc3RQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZUxpc3RcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVTZXJ2aWNlTGlzdFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlU2VydmljZUxpc3QuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVTZXJ2aWNlTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVNlcnZpY2VMaXN0UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBFbmRwb2ludFNsaWNlIHJlcHJlc2VudHMgYSBzdWJzZXQgb2YgdGhlIGVuZHBvaW50cyB0aGF0IGltcGxlbWVudCBhIHNlcnZpY2UuIEZvciBhIGdpdmVuIHNlcnZpY2UgdGhlcmUgbWF5IGJlIG11bHRpcGxlIEVuZHBvaW50U2xpY2Ugb2JqZWN0cywgc2VsZWN0ZWQgYnkgbGFiZWxzLCB3aGljaCBtdXN0IGJlIGpvaW5lZCB0byBwcm9kdWNlIHRoZSBmdWxsIHNldCBvZiBlbmRwb2ludHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmRpc2NvdmVyeS52MS5FbmRwb2ludFNsaWNlXG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlRW5kcG9pbnRTbGljZSBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuZGlzY292ZXJ5LnYxLkVuZHBvaW50U2xpY2VcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ2Rpc2NvdmVyeS5rOHMuaW8vdjEnLFxuICAgIGtpbmQ6ICdFbmRwb2ludFNsaWNlJyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmRpc2NvdmVyeS52MS5FbmRwb2ludFNsaWNlXCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVFbmRwb2ludFNsaWNlUHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlRW5kcG9pbnRTbGljZS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUVuZHBvaW50U2xpY2VQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmRpc2NvdmVyeS52MS5FbmRwb2ludFNsaWNlXCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlRW5kcG9pbnRTbGljZVByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlRW5kcG9pbnRTbGljZS5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUVuZHBvaW50U2xpY2UuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVFbmRwb2ludFNsaWNlUHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBFbmRwb2ludFNsaWNlTGlzdCByZXByZXNlbnRzIGEgbGlzdCBvZiBlbmRwb2ludCBzbGljZXNcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuZGlzY292ZXJ5LnYxLkVuZHBvaW50U2xpY2VMaXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlRW5kcG9pbnRTbGljZUxpc3QgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLmRpc2NvdmVyeS52MS5FbmRwb2ludFNsaWNlTGlzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnZGlzY292ZXJ5Lms4cy5pby92MScsXG4gICAga2luZDogJ0VuZHBvaW50U2xpY2VMaXN0JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmRpc2NvdmVyeS52MS5FbmRwb2ludFNsaWNlTGlzdFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlRW5kcG9pbnRTbGljZUxpc3RQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVFbmRwb2ludFNsaWNlTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUVuZHBvaW50U2xpY2VMaXN0UHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5kaXNjb3ZlcnkudjEuRW5kcG9pbnRTbGljZUxpc3RcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVFbmRwb2ludFNsaWNlTGlzdFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlRW5kcG9pbnRTbGljZUxpc3QuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVFbmRwb2ludFNsaWNlTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUVuZHBvaW50U2xpY2VMaXN0UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBFbmRwb2ludFNsaWNlIHJlcHJlc2VudHMgYSBzdWJzZXQgb2YgdGhlIGVuZHBvaW50cyB0aGF0IGltcGxlbWVudCBhIHNlcnZpY2UuIEZvciBhIGdpdmVuIHNlcnZpY2UgdGhlcmUgbWF5IGJlIG11bHRpcGxlIEVuZHBvaW50U2xpY2Ugb2JqZWN0cywgc2VsZWN0ZWQgYnkgbGFiZWxzLCB3aGljaCBtdXN0IGJlIGpvaW5lZCB0byBwcm9kdWNlIHRoZSBmdWxsIHNldCBvZiBlbmRwb2ludHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmRpc2NvdmVyeS52MWJldGExLkVuZHBvaW50U2xpY2VcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVFbmRwb2ludFNsaWNlVjFCZXRhMSBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuZGlzY292ZXJ5LnYxYmV0YTEuRW5kcG9pbnRTbGljZVwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnZGlzY292ZXJ5Lms4cy5pby92MWJldGExJyxcbiAgICBraW5kOiAnRW5kcG9pbnRTbGljZScsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5kaXNjb3ZlcnkudjFiZXRhMS5FbmRwb2ludFNsaWNlXCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVFbmRwb2ludFNsaWNlVjFCZXRhMVByb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUVuZHBvaW50U2xpY2VWMUJldGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlRW5kcG9pbnRTbGljZVYxQmV0YTFQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmRpc2NvdmVyeS52MWJldGExLkVuZHBvaW50U2xpY2VcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVFbmRwb2ludFNsaWNlVjFCZXRhMVByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlRW5kcG9pbnRTbGljZVYxQmV0YTEuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVFbmRwb2ludFNsaWNlVjFCZXRhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUVuZHBvaW50U2xpY2VWMUJldGExUHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBFbmRwb2ludFNsaWNlTGlzdCByZXByZXNlbnRzIGEgbGlzdCBvZiBlbmRwb2ludCBzbGljZXNcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuZGlzY292ZXJ5LnYxYmV0YTEuRW5kcG9pbnRTbGljZUxpc3RcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVFbmRwb2ludFNsaWNlTGlzdFYxQmV0YTEgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLmRpc2NvdmVyeS52MWJldGExLkVuZHBvaW50U2xpY2VMaXN0XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdkaXNjb3ZlcnkuazhzLmlvL3YxYmV0YTEnLFxuICAgIGtpbmQ6ICdFbmRwb2ludFNsaWNlTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5kaXNjb3ZlcnkudjFiZXRhMS5FbmRwb2ludFNsaWNlTGlzdFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlRW5kcG9pbnRTbGljZUxpc3RWMUJldGExUHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlRW5kcG9pbnRTbGljZUxpc3RWMUJldGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlRW5kcG9pbnRTbGljZUxpc3RWMUJldGExUHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5kaXNjb3ZlcnkudjFiZXRhMS5FbmRwb2ludFNsaWNlTGlzdFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZUVuZHBvaW50U2xpY2VMaXN0VjFCZXRhMVByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlRW5kcG9pbnRTbGljZUxpc3RWMUJldGExLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlRW5kcG9pbnRTbGljZUxpc3RWMUJldGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlRW5kcG9pbnRTbGljZUxpc3RWMUJldGExUHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBFdmVudCBpcyBhIHJlcG9ydCBvZiBhbiBldmVudCBzb21ld2hlcmUgaW4gdGhlIGNsdXN0ZXIuIEl0IGdlbmVyYWxseSBkZW5vdGVzIHNvbWUgc3RhdGUgY2hhbmdlIGluIHRoZSBzeXN0ZW0uIEV2ZW50cyBoYXZlIGEgbGltaXRlZCByZXRlbnRpb24gdGltZSBhbmQgdHJpZ2dlcnMgYW5kIG1lc3NhZ2VzIG1heSBldm9sdmUgd2l0aCB0aW1lLiAgRXZlbnQgY29uc3VtZXJzIHNob3VsZCBub3QgcmVseSBvbiB0aGUgdGltaW5nIG9mIGFuIGV2ZW50IHdpdGggYSBnaXZlbiBSZWFzb24gcmVmbGVjdGluZyBhIGNvbnNpc3RlbnQgdW5kZXJseWluZyB0cmlnZ2VyLCBvciB0aGUgY29udGludWVkIGV4aXN0ZW5jZSBvZiBldmVudHMgd2l0aCB0aGF0IFJlYXNvbi4gIEV2ZW50cyBzaG91bGQgYmUgdHJlYXRlZCBhcyBpbmZvcm1hdGl2ZSwgYmVzdC1lZmZvcnQsIHN1cHBsZW1lbnRhbCBkYXRhLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5ldmVudHMudjFiZXRhMS5FdmVudFxuICovXG5leHBvcnQgY2xhc3MgS3ViZUV2ZW50VjFCZXRhMSBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuZXZlbnRzLnYxYmV0YTEuRXZlbnRcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ2V2ZW50cy5rOHMuaW8vdjFiZXRhMScsXG4gICAga2luZDogJ0V2ZW50JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmV2ZW50cy52MWJldGExLkV2ZW50XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVFdmVudFYxQmV0YTFQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVFdmVudFYxQmV0YTEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVFdmVudFYxQmV0YTFQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmV2ZW50cy52MWJldGExLkV2ZW50XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlRXZlbnRWMUJldGExUHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVFdmVudFYxQmV0YTEuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVFdmVudFYxQmV0YTEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVFdmVudFYxQmV0YTFQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEV2ZW50TGlzdCBpcyBhIGxpc3Qgb2YgRXZlbnQgb2JqZWN0cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuZXZlbnRzLnYxYmV0YTEuRXZlbnRMaXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlRXZlbnRMaXN0VjFCZXRhMSBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuZXZlbnRzLnYxYmV0YTEuRXZlbnRMaXN0XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdldmVudHMuazhzLmlvL3YxYmV0YTEnLFxuICAgIGtpbmQ6ICdFdmVudExpc3QnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuZXZlbnRzLnYxYmV0YTEuRXZlbnRMaXN0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVFdmVudExpc3RWMUJldGExUHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlRXZlbnRMaXN0VjFCZXRhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUV2ZW50TGlzdFYxQmV0YTFQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmV2ZW50cy52MWJldGExLkV2ZW50TGlzdFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZUV2ZW50TGlzdFYxQmV0YTFQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZUV2ZW50TGlzdFYxQmV0YTEuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVFdmVudExpc3RWMUJldGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlRXZlbnRMaXN0VjFCZXRhMVByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogRmxvd1NjaGVtYSBkZWZpbmVzIHRoZSBzY2hlbWEgb2YgYSBncm91cCBvZiBmbG93cy4gTm90ZSB0aGF0IGEgZmxvdyBpcyBtYWRlIHVwIG9mIGEgc2V0IG9mIGluYm91bmQgQVBJIHJlcXVlc3RzIHdpdGggc2ltaWxhciBhdHRyaWJ1dGVzIGFuZCBpcyBpZGVudGlmaWVkIGJ5IGEgcGFpciBvZiBzdHJpbmdzOiB0aGUgbmFtZSBvZiB0aGUgRmxvd1NjaGVtYSBhbmQgYSBcImZsb3cgZGlzdGluZ3Vpc2hlclwiLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLkZsb3dTY2hlbWFcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVGbG93U2NoZW1hVjFCZXRhMSBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuZmxvd2NvbnRyb2wudjFiZXRhMS5GbG93U2NoZW1hXCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdmbG93Y29udHJvbC5hcGlzZXJ2ZXIuazhzLmlvL3YxYmV0YTEnLFxuICAgIGtpbmQ6ICdGbG93U2NoZW1hJyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuRmxvd1NjaGVtYVwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlRmxvd1NjaGVtYVYxQmV0YTFQcm9wcyA9IHt9KTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUZsb3dTY2hlbWFWMUJldGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlRmxvd1NjaGVtYVYxQmV0YTFQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuRmxvd1NjaGVtYVwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZUZsb3dTY2hlbWFWMUJldGExUHJvcHMgPSB7fSkge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZUZsb3dTY2hlbWFWMUJldGExLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlRmxvd1NjaGVtYVYxQmV0YTEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVGbG93U2NoZW1hVjFCZXRhMVByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogRmxvd1NjaGVtYUxpc3QgaXMgYSBsaXN0IG9mIEZsb3dTY2hlbWEgb2JqZWN0cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuZmxvd2NvbnRyb2wudjFiZXRhMS5GbG93U2NoZW1hTGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZUZsb3dTY2hlbWFMaXN0VjFCZXRhMSBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuZmxvd2NvbnRyb2wudjFiZXRhMS5GbG93U2NoZW1hTGlzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnZmxvd2NvbnRyb2wuYXBpc2VydmVyLms4cy5pby92MWJldGExJyxcbiAgICBraW5kOiAnRmxvd1NjaGVtYUxpc3QnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuZmxvd2NvbnRyb2wudjFiZXRhMS5GbG93U2NoZW1hTGlzdFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlRmxvd1NjaGVtYUxpc3RWMUJldGExUHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlRmxvd1NjaGVtYUxpc3RWMUJldGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlRmxvd1NjaGVtYUxpc3RWMUJldGExUHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLkZsb3dTY2hlbWFMaXN0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlRmxvd1NjaGVtYUxpc3RWMUJldGExUHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVGbG93U2NoZW1hTGlzdFYxQmV0YTEuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVGbG93U2NoZW1hTGlzdFYxQmV0YTEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVGbG93U2NoZW1hTGlzdFYxQmV0YTFQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uIHJlcHJlc2VudHMgdGhlIGNvbmZpZ3VyYXRpb24gb2YgYSBwcmlvcml0eSBsZXZlbC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuZmxvd2NvbnRyb2wudjFiZXRhMS5Qcmlvcml0eUxldmVsQ29uZmlndXJhdGlvblxuICovXG5leHBvcnQgY2xhc3MgS3ViZVByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uVjFCZXRhMSBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuZmxvd2NvbnRyb2wudjFiZXRhMS5Qcmlvcml0eUxldmVsQ29uZmlndXJhdGlvblwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnZmxvd2NvbnRyb2wuYXBpc2VydmVyLms4cy5pby92MWJldGExJyxcbiAgICBraW5kOiAnUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb24nLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuZmxvd2NvbnRyb2wudjFiZXRhMS5Qcmlvcml0eUxldmVsQ29uZmlndXJhdGlvblwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25WMUJldGExUHJvcHMgPSB7fSk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVQcmlvcml0eUxldmVsQ29uZmlndXJhdGlvblYxQmV0YTEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVQcmlvcml0eUxldmVsQ29uZmlndXJhdGlvblYxQmV0YTFQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25cIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVQcmlvcml0eUxldmVsQ29uZmlndXJhdGlvblYxQmV0YTFQcm9wcyA9IHt9KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25WMUJldGExLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25WMUJldGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25WMUJldGExUHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQcmlvcml0eUxldmVsQ29uZmlndXJhdGlvbkxpc3QgaXMgYSBsaXN0IG9mIFByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uIG9iamVjdHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25MaXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25MaXN0VjFCZXRhMSBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuZmxvd2NvbnRyb2wudjFiZXRhMS5Qcmlvcml0eUxldmVsQ29uZmlndXJhdGlvbkxpc3RcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ2Zsb3djb250cm9sLmFwaXNlcnZlci5rOHMuaW8vdjFiZXRhMScsXG4gICAga2luZDogJ1ByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLlByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uTGlzdFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25MaXN0VjFCZXRhMVByb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uTGlzdFYxQmV0YTEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVQcmlvcml0eUxldmVsQ29uZmlndXJhdGlvbkxpc3RWMUJldGExUHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLlByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uTGlzdFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uTGlzdFYxQmV0YTFQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uTGlzdFYxQmV0YTEuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVQcmlvcml0eUxldmVsQ29uZmlndXJhdGlvbkxpc3RWMUJldGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25MaXN0VjFCZXRhMVByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogSW5ncmVzcyBpcyBhIGNvbGxlY3Rpb24gb2YgcnVsZXMgdGhhdCBhbGxvdyBpbmJvdW5kIGNvbm5lY3Rpb25zIHRvIHJlYWNoIHRoZSBlbmRwb2ludHMgZGVmaW5lZCBieSBhIGJhY2tlbmQuIEFuIEluZ3Jlc3MgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gZ2l2ZSBzZXJ2aWNlcyBleHRlcm5hbGx5LXJlYWNoYWJsZSB1cmxzLCBsb2FkIGJhbGFuY2UgdHJhZmZpYywgdGVybWluYXRlIFNTTCwgb2ZmZXIgbmFtZSBiYXNlZCB2aXJ0dWFsIGhvc3RpbmcgZXRjLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3NcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVJbmdyZXNzIGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3NcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ25ldHdvcmtpbmcuazhzLmlvL3YxJyxcbiAgICBraW5kOiAnSW5ncmVzcycsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3NcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZUluZ3Jlc3NQcm9wcyA9IHt9KTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUluZ3Jlc3MuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVJbmdyZXNzUHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3NcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVJbmdyZXNzUHJvcHMgPSB7fSkge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZUluZ3Jlc3MuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVJbmdyZXNzLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlSW5ncmVzc1Byb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogSW5ncmVzc0NsYXNzIHJlcHJlc2VudHMgdGhlIGNsYXNzIG9mIHRoZSBJbmdyZXNzLCByZWZlcmVuY2VkIGJ5IHRoZSBJbmdyZXNzIFNwZWMuIFRoZSBgaW5ncmVzc2NsYXNzLmt1YmVybmV0ZXMuaW8vaXMtZGVmYXVsdC1jbGFzc2AgYW5ub3RhdGlvbiBjYW4gYmUgdXNlZCB0byBpbmRpY2F0ZSB0aGF0IGFuIEluZ3Jlc3NDbGFzcyBzaG91bGQgYmUgY29uc2lkZXJlZCBkZWZhdWx0LiBXaGVuIGEgc2luZ2xlIEluZ3Jlc3NDbGFzcyByZXNvdXJjZSBoYXMgdGhpcyBhbm5vdGF0aW9uIHNldCB0byB0cnVlLCBuZXcgSW5ncmVzcyByZXNvdXJjZXMgd2l0aG91dCBhIGNsYXNzIHNwZWNpZmllZCB3aWxsIGJlIGFzc2lnbmVkIHRoaXMgZGVmYXVsdCBjbGFzcy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5JbmdyZXNzQ2xhc3NcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVJbmdyZXNzQ2xhc3MgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuSW5ncmVzc0NsYXNzXCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICduZXR3b3JraW5nLms4cy5pby92MScsXG4gICAga2luZDogJ0luZ3Jlc3NDbGFzcycsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3NDbGFzc1wiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlSW5ncmVzc0NsYXNzUHJvcHMgPSB7fSk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVJbmdyZXNzQ2xhc3MuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVJbmdyZXNzQ2xhc3NQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuSW5ncmVzc0NsYXNzXCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlSW5ncmVzc0NsYXNzUHJvcHMgPSB7fSkge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZUluZ3Jlc3NDbGFzcy5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUluZ3Jlc3NDbGFzcy5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUluZ3Jlc3NDbGFzc1Byb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogSW5ncmVzc0NsYXNzTGlzdCBpcyBhIGNvbGxlY3Rpb24gb2YgSW5ncmVzc0NsYXNzZXMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuSW5ncmVzc0NsYXNzTGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZUluZ3Jlc3NDbGFzc0xpc3QgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuSW5ncmVzc0NsYXNzTGlzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnbmV0d29ya2luZy5rOHMuaW8vdjEnLFxuICAgIGtpbmQ6ICdJbmdyZXNzQ2xhc3NMaXN0JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuSW5ncmVzc0NsYXNzTGlzdFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlSW5ncmVzc0NsYXNzTGlzdFByb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUluZ3Jlc3NDbGFzc0xpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVJbmdyZXNzQ2xhc3NMaXN0UHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3NDbGFzc0xpc3RcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVJbmdyZXNzQ2xhc3NMaXN0UHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVJbmdyZXNzQ2xhc3NMaXN0LkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlSW5ncmVzc0NsYXNzTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUluZ3Jlc3NDbGFzc0xpc3RQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEluZ3Jlc3NMaXN0IGlzIGEgY29sbGVjdGlvbiBvZiBJbmdyZXNzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3NMaXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlSW5ncmVzc0xpc3QgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuSW5ncmVzc0xpc3RcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ25ldHdvcmtpbmcuazhzLmlvL3YxJyxcbiAgICBraW5kOiAnSW5ncmVzc0xpc3QnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkubmV0d29ya2luZy52MS5JbmdyZXNzTGlzdFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlSW5ncmVzc0xpc3RQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVJbmdyZXNzTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUluZ3Jlc3NMaXN0UHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3NMaXN0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlSW5ncmVzc0xpc3RQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZUluZ3Jlc3NMaXN0LkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlSW5ncmVzc0xpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVJbmdyZXNzTGlzdFByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogTmV0d29ya1BvbGljeSBkZXNjcmliZXMgd2hhdCBuZXR3b3JrIHRyYWZmaWMgaXMgYWxsb3dlZCBmb3IgYSBzZXQgb2YgUG9kc1xuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLk5ldHdvcmtQb2xpY3lcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVOZXR3b3JrUG9saWN5IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLk5ldHdvcmtQb2xpY3lcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ25ldHdvcmtpbmcuazhzLmlvL3YxJyxcbiAgICBraW5kOiAnTmV0d29ya1BvbGljeScsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLk5ldHdvcmtQb2xpY3lcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZU5ldHdvcmtQb2xpY3lQcm9wcyA9IHt9KTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZU5ldHdvcmtQb2xpY3kuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVOZXR3b3JrUG9saWN5UHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLk5ldHdvcmtQb2xpY3lcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVOZXR3b3JrUG9saWN5UHJvcHMgPSB7fSkge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZU5ldHdvcmtQb2xpY3kuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVOZXR3b3JrUG9saWN5LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlTmV0d29ya1BvbGljeVByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogTmV0d29ya1BvbGljeUxpc3QgaXMgYSBsaXN0IG9mIE5ldHdvcmtQb2xpY3kgb2JqZWN0cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5OZXR3b3JrUG9saWN5TGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZU5ldHdvcmtQb2xpY3lMaXN0IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLk5ldHdvcmtQb2xpY3lMaXN0XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICduZXR3b3JraW5nLms4cy5pby92MScsXG4gICAga2luZDogJ05ldHdvcmtQb2xpY3lMaXN0JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuTmV0d29ya1BvbGljeUxpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZU5ldHdvcmtQb2xpY3lMaXN0UHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlTmV0d29ya1BvbGljeUxpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVOZXR3b3JrUG9saWN5TGlzdFByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkubmV0d29ya2luZy52MS5OZXR3b3JrUG9saWN5TGlzdFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZU5ldHdvcmtQb2xpY3lMaXN0UHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVOZXR3b3JrUG9saWN5TGlzdC5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZU5ldHdvcmtQb2xpY3lMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlTmV0d29ya1BvbGljeUxpc3RQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFJ1bnRpbWVDbGFzcyBkZWZpbmVzIGEgY2xhc3Mgb2YgY29udGFpbmVyIHJ1bnRpbWUgc3VwcG9ydGVkIGluIHRoZSBjbHVzdGVyLiBUaGUgUnVudGltZUNsYXNzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGNvbnRhaW5lciBydW50aW1lIGlzIHVzZWQgdG8gcnVuIGFsbCBjb250YWluZXJzIGluIGEgcG9kLiBSdW50aW1lQ2xhc3NlcyBhcmUgbWFudWFsbHkgZGVmaW5lZCBieSBhIHVzZXIgb3IgY2x1c3RlciBwcm92aXNpb25lciwgYW5kIHJlZmVyZW5jZWQgaW4gdGhlIFBvZFNwZWMuIFRoZSBLdWJlbGV0IGlzIHJlc3BvbnNpYmxlIGZvciByZXNvbHZpbmcgdGhlIFJ1bnRpbWVDbGFzc05hbWUgcmVmZXJlbmNlIGJlZm9yZSBydW5uaW5nIHRoZSBwb2QuICBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvY29udGFpbmVycy9ydW50aW1lLWNsYXNzL1xuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5ub2RlLnYxLlJ1bnRpbWVDbGFzc1xuICovXG5leHBvcnQgY2xhc3MgS3ViZVJ1bnRpbWVDbGFzcyBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkubm9kZS52MS5SdW50aW1lQ2xhc3NcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ25vZGUuazhzLmlvL3YxJyxcbiAgICBraW5kOiAnUnVudGltZUNsYXNzJyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLm5vZGUudjEuUnVudGltZUNsYXNzXCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVSdW50aW1lQ2xhc3NQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVSdW50aW1lQ2xhc3MuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVSdW50aW1lQ2xhc3NQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLm5vZGUudjEuUnVudGltZUNsYXNzXCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlUnVudGltZUNsYXNzUHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVSdW50aW1lQ2xhc3MuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVSdW50aW1lQ2xhc3MuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVSdW50aW1lQ2xhc3NQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFJ1bnRpbWVDbGFzc0xpc3QgaXMgYSBsaXN0IG9mIFJ1bnRpbWVDbGFzcyBvYmplY3RzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5ub2RlLnYxLlJ1bnRpbWVDbGFzc0xpc3RcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVSdW50aW1lQ2xhc3NMaXN0IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5ub2RlLnYxLlJ1bnRpbWVDbGFzc0xpc3RcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ25vZGUuazhzLmlvL3YxJyxcbiAgICBraW5kOiAnUnVudGltZUNsYXNzTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5ub2RlLnYxLlJ1bnRpbWVDbGFzc0xpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVJ1bnRpbWVDbGFzc0xpc3RQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVSdW50aW1lQ2xhc3NMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUnVudGltZUNsYXNzTGlzdFByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkubm9kZS52MS5SdW50aW1lQ2xhc3NMaXN0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlUnVudGltZUNsYXNzTGlzdFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlUnVudGltZUNsYXNzTGlzdC5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVJ1bnRpbWVDbGFzc0xpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVSdW50aW1lQ2xhc3NMaXN0UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBSdW50aW1lQ2xhc3MgZGVmaW5lcyBhIGNsYXNzIG9mIGNvbnRhaW5lciBydW50aW1lIHN1cHBvcnRlZCBpbiB0aGUgY2x1c3Rlci4gVGhlIFJ1bnRpbWVDbGFzcyBpcyB1c2VkIHRvIGRldGVybWluZSB3aGljaCBjb250YWluZXIgcnVudGltZSBpcyB1c2VkIHRvIHJ1biBhbGwgY29udGFpbmVycyBpbiBhIHBvZC4gUnVudGltZUNsYXNzZXMgYXJlIChjdXJyZW50bHkpIG1hbnVhbGx5IGRlZmluZWQgYnkgYSB1c2VyIG9yIGNsdXN0ZXIgcHJvdmlzaW9uZXIsIGFuZCByZWZlcmVuY2VkIGluIHRoZSBQb2RTcGVjLiBUaGUgS3ViZWxldCBpcyByZXNwb25zaWJsZSBmb3IgcmVzb2x2aW5nIHRoZSBSdW50aW1lQ2xhc3NOYW1lIHJlZmVyZW5jZSBiZWZvcmUgcnVubmluZyB0aGUgcG9kLiAgRm9yIG1vcmUgZGV0YWlscywgc2VlIGh0dHBzOi8vZ2l0Lms4cy5pby9lbmhhbmNlbWVudHMva2Vwcy9zaWctbm9kZS81ODUtcnVudGltZS1jbGFzc1xuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5ub2RlLnYxYWxwaGExLlJ1bnRpbWVDbGFzc1xuICovXG5leHBvcnQgY2xhc3MgS3ViZVJ1bnRpbWVDbGFzc1YxQWxwaGExIGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5ub2RlLnYxYWxwaGExLlJ1bnRpbWVDbGFzc1wiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnbm9kZS5rOHMuaW8vdjFhbHBoYTEnLFxuICAgIGtpbmQ6ICdSdW50aW1lQ2xhc3MnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkubm9kZS52MWFscGhhMS5SdW50aW1lQ2xhc3NcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVJ1bnRpbWVDbGFzc1YxQWxwaGExUHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUnVudGltZUNsYXNzVjFBbHBoYTEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVSdW50aW1lQ2xhc3NWMUFscGhhMVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkubm9kZS52MWFscGhhMS5SdW50aW1lQ2xhc3NcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVSdW50aW1lQ2xhc3NWMUFscGhhMVByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlUnVudGltZUNsYXNzVjFBbHBoYTEuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVSdW50aW1lQ2xhc3NWMUFscGhhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVJ1bnRpbWVDbGFzc1YxQWxwaGExUHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBSdW50aW1lQ2xhc3NMaXN0IGlzIGEgbGlzdCBvZiBSdW50aW1lQ2xhc3Mgb2JqZWN0cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkubm9kZS52MWFscGhhMS5SdW50aW1lQ2xhc3NMaXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlUnVudGltZUNsYXNzTGlzdFYxQWxwaGExIGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5ub2RlLnYxYWxwaGExLlJ1bnRpbWVDbGFzc0xpc3RcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ25vZGUuazhzLmlvL3YxYWxwaGExJyxcbiAgICBraW5kOiAnUnVudGltZUNsYXNzTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5ub2RlLnYxYWxwaGExLlJ1bnRpbWVDbGFzc0xpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVJ1bnRpbWVDbGFzc0xpc3RWMUFscGhhMVByb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVJ1bnRpbWVDbGFzc0xpc3RWMUFscGhhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVJ1bnRpbWVDbGFzc0xpc3RWMUFscGhhMVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkubm9kZS52MWFscGhhMS5SdW50aW1lQ2xhc3NMaXN0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlUnVudGltZUNsYXNzTGlzdFYxQWxwaGExUHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVSdW50aW1lQ2xhc3NMaXN0VjFBbHBoYTEuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVSdW50aW1lQ2xhc3NMaXN0VjFBbHBoYTEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVSdW50aW1lQ2xhc3NMaXN0VjFBbHBoYTFQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFJ1bnRpbWVDbGFzcyBkZWZpbmVzIGEgY2xhc3Mgb2YgY29udGFpbmVyIHJ1bnRpbWUgc3VwcG9ydGVkIGluIHRoZSBjbHVzdGVyLiBUaGUgUnVudGltZUNsYXNzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGNvbnRhaW5lciBydW50aW1lIGlzIHVzZWQgdG8gcnVuIGFsbCBjb250YWluZXJzIGluIGEgcG9kLiBSdW50aW1lQ2xhc3NlcyBhcmUgKGN1cnJlbnRseSkgbWFudWFsbHkgZGVmaW5lZCBieSBhIHVzZXIgb3IgY2x1c3RlciBwcm92aXNpb25lciwgYW5kIHJlZmVyZW5jZWQgaW4gdGhlIFBvZFNwZWMuIFRoZSBLdWJlbGV0IGlzIHJlc3BvbnNpYmxlIGZvciByZXNvbHZpbmcgdGhlIFJ1bnRpbWVDbGFzc05hbWUgcmVmZXJlbmNlIGJlZm9yZSBydW5uaW5nIHRoZSBwb2QuICBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9naXQuazhzLmlvL2VuaGFuY2VtZW50cy9rZXBzL3NpZy1ub2RlLzU4NS1ydW50aW1lLWNsYXNzXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLm5vZGUudjFiZXRhMS5SdW50aW1lQ2xhc3NcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVSdW50aW1lQ2xhc3NWMUJldGExIGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5ub2RlLnYxYmV0YTEuUnVudGltZUNsYXNzXCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdub2RlLms4cy5pby92MWJldGExJyxcbiAgICBraW5kOiAnUnVudGltZUNsYXNzJyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLm5vZGUudjFiZXRhMS5SdW50aW1lQ2xhc3NcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVJ1bnRpbWVDbGFzc1YxQmV0YTFQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVSdW50aW1lQ2xhc3NWMUJldGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUnVudGltZUNsYXNzVjFCZXRhMVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkubm9kZS52MWJldGExLlJ1bnRpbWVDbGFzc1wiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVJ1bnRpbWVDbGFzc1YxQmV0YTFQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVJ1bnRpbWVDbGFzc1YxQmV0YTEuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVSdW50aW1lQ2xhc3NWMUJldGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUnVudGltZUNsYXNzVjFCZXRhMVByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUnVudGltZUNsYXNzTGlzdCBpcyBhIGxpc3Qgb2YgUnVudGltZUNsYXNzIG9iamVjdHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLm5vZGUudjFiZXRhMS5SdW50aW1lQ2xhc3NMaXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlUnVudGltZUNsYXNzTGlzdFYxQmV0YTEgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLm5vZGUudjFiZXRhMS5SdW50aW1lQ2xhc3NMaXN0XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdub2RlLms4cy5pby92MWJldGExJyxcbiAgICBraW5kOiAnUnVudGltZUNsYXNzTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5ub2RlLnYxYmV0YTEuUnVudGltZUNsYXNzTGlzdFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlUnVudGltZUNsYXNzTGlzdFYxQmV0YTFQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVSdW50aW1lQ2xhc3NMaXN0VjFCZXRhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVJ1bnRpbWVDbGFzc0xpc3RWMUJldGExUHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5ub2RlLnYxYmV0YTEuUnVudGltZUNsYXNzTGlzdFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVJ1bnRpbWVDbGFzc0xpc3RWMUJldGExUHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVSdW50aW1lQ2xhc3NMaXN0VjFCZXRhMS5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVJ1bnRpbWVDbGFzc0xpc3RWMUJldGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUnVudGltZUNsYXNzTGlzdFYxQmV0YTFQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEV2aWN0aW9uIGV2aWN0cyBhIHBvZCBmcm9tIGl0cyBub2RlIHN1YmplY3QgdG8gY2VydGFpbiBwb2xpY2llcyBhbmQgc2FmZXR5IGNvbnN0cmFpbnRzLiBUaGlzIGlzIGEgc3VicmVzb3VyY2Ugb2YgUG9kLiAgQSByZXF1ZXN0IHRvIGNhdXNlIHN1Y2ggYW4gZXZpY3Rpb24gaXMgY3JlYXRlZCBieSBQT1NUaW5nIHRvIC4uLi9wb2RzLzxwb2QgbmFtZT4vZXZpY3Rpb25zLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjEuRXZpY3Rpb25cbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVFdmljdGlvbiBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkucG9saWN5LnYxLkV2aWN0aW9uXCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdwb2xpY3kvdjEnLFxuICAgIGtpbmQ6ICdFdmljdGlvbicsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5wb2xpY3kudjEuRXZpY3Rpb25cIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZUV2aWN0aW9uUHJvcHMgPSB7fSk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVFdmljdGlvbi5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUV2aWN0aW9uUHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5wb2xpY3kudjEuRXZpY3Rpb25cIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVFdmljdGlvblByb3BzID0ge30pIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVFdmljdGlvbi5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUV2aWN0aW9uLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlRXZpY3Rpb25Qcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBvZERpc3J1cHRpb25CdWRnZXQgaXMgYW4gb2JqZWN0IHRvIGRlZmluZSB0aGUgbWF4IGRpc3J1cHRpb24gdGhhdCBjYW4gYmUgY2F1c2VkIHRvIGEgY29sbGVjdGlvbiBvZiBwb2RzXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MS5Qb2REaXNydXB0aW9uQnVkZ2V0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlUG9kRGlzcnVwdGlvbkJ1ZGdldCBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkucG9saWN5LnYxLlBvZERpc3J1cHRpb25CdWRnZXRcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3BvbGljeS92MScsXG4gICAga2luZDogJ1BvZERpc3J1cHRpb25CdWRnZXQnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkucG9saWN5LnYxLlBvZERpc3J1cHRpb25CdWRnZXRcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVBvZERpc3J1cHRpb25CdWRnZXRQcm9wcyA9IHt9KTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVBvZERpc3J1cHRpb25CdWRnZXQuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVQb2REaXNydXB0aW9uQnVkZ2V0UHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5wb2xpY3kudjEuUG9kRGlzcnVwdGlvbkJ1ZGdldFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVBvZERpc3J1cHRpb25CdWRnZXRQcm9wcyA9IHt9KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlUG9kRGlzcnVwdGlvbkJ1ZGdldC5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVBvZERpc3J1cHRpb25CdWRnZXQuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVQb2REaXNydXB0aW9uQnVkZ2V0UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2REaXNydXB0aW9uQnVkZ2V0TGlzdCBpcyBhIGNvbGxlY3Rpb24gb2YgUG9kRGlzcnVwdGlvbkJ1ZGdldHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MS5Qb2REaXNydXB0aW9uQnVkZ2V0TGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZVBvZERpc3J1cHRpb25CdWRnZXRMaXN0IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5wb2xpY3kudjEuUG9kRGlzcnVwdGlvbkJ1ZGdldExpc3RcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3BvbGljeS92MScsXG4gICAga2luZDogJ1BvZERpc3J1cHRpb25CdWRnZXRMaXN0JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLnBvbGljeS52MS5Qb2REaXNydXB0aW9uQnVkZ2V0TGlzdFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlUG9kRGlzcnVwdGlvbkJ1ZGdldExpc3RQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVQb2REaXNydXB0aW9uQnVkZ2V0TGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVBvZERpc3J1cHRpb25CdWRnZXRMaXN0UHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5wb2xpY3kudjEuUG9kRGlzcnVwdGlvbkJ1ZGdldExpc3RcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVQb2REaXNydXB0aW9uQnVkZ2V0TGlzdFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlUG9kRGlzcnVwdGlvbkJ1ZGdldExpc3QuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVQb2REaXNydXB0aW9uQnVkZ2V0TGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVBvZERpc3J1cHRpb25CdWRnZXRMaXN0UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2REaXNydXB0aW9uQnVkZ2V0IGlzIGFuIG9iamVjdCB0byBkZWZpbmUgdGhlIG1heCBkaXNydXB0aW9uIHRoYXQgY2FuIGJlIGNhdXNlZCB0byBhIGNvbGxlY3Rpb24gb2YgcG9kc1xuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5Qb2REaXNydXB0aW9uQnVkZ2V0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlUG9kRGlzcnVwdGlvbkJ1ZGdldFYxQmV0YTEgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlBvZERpc3J1cHRpb25CdWRnZXRcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3BvbGljeS92MWJldGExJyxcbiAgICBraW5kOiAnUG9kRGlzcnVwdGlvbkJ1ZGdldCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5Qb2REaXNydXB0aW9uQnVkZ2V0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVQb2REaXNydXB0aW9uQnVkZ2V0VjFCZXRhMVByb3BzID0ge30pOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUG9kRGlzcnVwdGlvbkJ1ZGdldFYxQmV0YTEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVQb2REaXNydXB0aW9uQnVkZ2V0VjFCZXRhMVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkucG9saWN5LnYxYmV0YTEuUG9kRGlzcnVwdGlvbkJ1ZGdldFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVBvZERpc3J1cHRpb25CdWRnZXRWMUJldGExUHJvcHMgPSB7fSkge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVBvZERpc3J1cHRpb25CdWRnZXRWMUJldGExLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUG9kRGlzcnVwdGlvbkJ1ZGdldFYxQmV0YTEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVQb2REaXNydXB0aW9uQnVkZ2V0VjFCZXRhMVByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUG9kRGlzcnVwdGlvbkJ1ZGdldExpc3QgaXMgYSBjb2xsZWN0aW9uIG9mIFBvZERpc3J1cHRpb25CdWRnZXRzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5Qb2REaXNydXB0aW9uQnVkZ2V0TGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZVBvZERpc3J1cHRpb25CdWRnZXRMaXN0VjFCZXRhMSBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkucG9saWN5LnYxYmV0YTEuUG9kRGlzcnVwdGlvbkJ1ZGdldExpc3RcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3BvbGljeS92MWJldGExJyxcbiAgICBraW5kOiAnUG9kRGlzcnVwdGlvbkJ1ZGdldExpc3QnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkucG9saWN5LnYxYmV0YTEuUG9kRGlzcnVwdGlvbkJ1ZGdldExpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVBvZERpc3J1cHRpb25CdWRnZXRMaXN0VjFCZXRhMVByb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVBvZERpc3J1cHRpb25CdWRnZXRMaXN0VjFCZXRhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVBvZERpc3J1cHRpb25CdWRnZXRMaXN0VjFCZXRhMVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkucG9saWN5LnYxYmV0YTEuUG9kRGlzcnVwdGlvbkJ1ZGdldExpc3RcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVQb2REaXNydXB0aW9uQnVkZ2V0TGlzdFYxQmV0YTFQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVBvZERpc3J1cHRpb25CdWRnZXRMaXN0VjFCZXRhMS5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVBvZERpc3J1cHRpb25CdWRnZXRMaXN0VjFCZXRhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVBvZERpc3J1cHRpb25CdWRnZXRMaXN0VjFCZXRhMVByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUG9kU2VjdXJpdHlQb2xpY3kgZ292ZXJucyB0aGUgYWJpbGl0eSB0byBtYWtlIHJlcXVlc3RzIHRoYXQgYWZmZWN0IHRoZSBTZWN1cml0eSBDb250ZXh0IHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGEgcG9kIGFuZCBjb250YWluZXIuIERlcHJlY2F0ZWQgaW4gMS4yMS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkucG9saWN5LnYxYmV0YTEuUG9kU2VjdXJpdHlQb2xpY3lcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVQb2RTZWN1cml0eVBvbGljeVYxQmV0YTEgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlBvZFNlY3VyaXR5UG9saWN5XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdwb2xpY3kvdjFiZXRhMScsXG4gICAga2luZDogJ1BvZFNlY3VyaXR5UG9saWN5JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlBvZFNlY3VyaXR5UG9saWN5XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVQb2RTZWN1cml0eVBvbGljeVYxQmV0YTFQcm9wcyA9IHt9KTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVBvZFNlY3VyaXR5UG9saWN5VjFCZXRhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVBvZFNlY3VyaXR5UG9saWN5VjFCZXRhMVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkucG9saWN5LnYxYmV0YTEuUG9kU2VjdXJpdHlQb2xpY3lcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVQb2RTZWN1cml0eVBvbGljeVYxQmV0YTFQcm9wcyA9IHt9KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlUG9kU2VjdXJpdHlQb2xpY3lWMUJldGExLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUG9kU2VjdXJpdHlQb2xpY3lWMUJldGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUG9kU2VjdXJpdHlQb2xpY3lWMUJldGExUHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2RTZWN1cml0eVBvbGljeUxpc3QgaXMgYSBsaXN0IG9mIFBvZFNlY3VyaXR5UG9saWN5IG9iamVjdHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlBvZFNlY3VyaXR5UG9saWN5TGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZVBvZFNlY3VyaXR5UG9saWN5TGlzdFYxQmV0YTEgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlBvZFNlY3VyaXR5UG9saWN5TGlzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAncG9saWN5L3YxYmV0YTEnLFxuICAgIGtpbmQ6ICdQb2RTZWN1cml0eVBvbGljeUxpc3QnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkucG9saWN5LnYxYmV0YTEuUG9kU2VjdXJpdHlQb2xpY3lMaXN0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVQb2RTZWN1cml0eVBvbGljeUxpc3RWMUJldGExUHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUG9kU2VjdXJpdHlQb2xpY3lMaXN0VjFCZXRhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVBvZFNlY3VyaXR5UG9saWN5TGlzdFYxQmV0YTFQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlBvZFNlY3VyaXR5UG9saWN5TGlzdFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVBvZFNlY3VyaXR5UG9saWN5TGlzdFYxQmV0YTFQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVBvZFNlY3VyaXR5UG9saWN5TGlzdFYxQmV0YTEuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVQb2RTZWN1cml0eVBvbGljeUxpc3RWMUJldGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUG9kU2VjdXJpdHlQb2xpY3lMaXN0VjFCZXRhMVByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQ2x1c3RlclJvbGUgaXMgYSBjbHVzdGVyIGxldmVsLCBsb2dpY2FsIGdyb3VwaW5nIG9mIFBvbGljeVJ1bGVzIHRoYXQgY2FuIGJlIHJlZmVyZW5jZWQgYXMgYSB1bml0IGJ5IGEgUm9sZUJpbmRpbmcgb3IgQ2x1c3RlclJvbGVCaW5kaW5nLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxLkNsdXN0ZXJSb2xlXG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlQ2x1c3RlclJvbGUgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLnJiYWMudjEuQ2x1c3RlclJvbGVcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3JiYWMuYXV0aG9yaXphdGlvbi5rOHMuaW8vdjEnLFxuICAgIGtpbmQ6ICdDbHVzdGVyUm9sZScsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5yYmFjLnYxLkNsdXN0ZXJSb2xlXCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVDbHVzdGVyUm9sZVByb3BzID0ge30pOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQ2x1c3RlclJvbGUuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDbHVzdGVyUm9sZVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkucmJhYy52MS5DbHVzdGVyUm9sZVwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZUNsdXN0ZXJSb2xlUHJvcHMgPSB7fSkge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZUNsdXN0ZXJSb2xlLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQ2x1c3RlclJvbGUuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDbHVzdGVyUm9sZVByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQ2x1c3RlclJvbGVCaW5kaW5nIHJlZmVyZW5jZXMgYSBDbHVzdGVyUm9sZSwgYnV0IG5vdCBjb250YWluIGl0LiAgSXQgY2FuIHJlZmVyZW5jZSBhIENsdXN0ZXJSb2xlIGluIHRoZSBnbG9iYWwgbmFtZXNwYWNlLCBhbmQgYWRkcyB3aG8gaW5mb3JtYXRpb24gdmlhIFN1YmplY3QuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjEuQ2x1c3RlclJvbGVCaW5kaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlQ2x1c3RlclJvbGVCaW5kaW5nIGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5yYmFjLnYxLkNsdXN0ZXJSb2xlQmluZGluZ1wiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAncmJhYy5hdXRob3JpemF0aW9uLms4cy5pby92MScsXG4gICAga2luZDogJ0NsdXN0ZXJSb2xlQmluZGluZycsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5yYmFjLnYxLkNsdXN0ZXJSb2xlQmluZGluZ1wiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlQ2x1c3RlclJvbGVCaW5kaW5nUHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQ2x1c3RlclJvbGVCaW5kaW5nLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlQ2x1c3RlclJvbGVCaW5kaW5nUHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5yYmFjLnYxLkNsdXN0ZXJSb2xlQmluZGluZ1wiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZUNsdXN0ZXJSb2xlQmluZGluZ1Byb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlQ2x1c3RlclJvbGVCaW5kaW5nLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQ2x1c3RlclJvbGVCaW5kaW5nLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlQ2x1c3RlclJvbGVCaW5kaW5nUHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBDbHVzdGVyUm9sZUJpbmRpbmdMaXN0IGlzIGEgY29sbGVjdGlvbiBvZiBDbHVzdGVyUm9sZUJpbmRpbmdzXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjEuQ2x1c3RlclJvbGVCaW5kaW5nTGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZUNsdXN0ZXJSb2xlQmluZGluZ0xpc3QgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLnJiYWMudjEuQ2x1c3RlclJvbGVCaW5kaW5nTGlzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAncmJhYy5hdXRob3JpemF0aW9uLms4cy5pby92MScsXG4gICAga2luZDogJ0NsdXN0ZXJSb2xlQmluZGluZ0xpc3QnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkucmJhYy52MS5DbHVzdGVyUm9sZUJpbmRpbmdMaXN0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVDbHVzdGVyUm9sZUJpbmRpbmdMaXN0UHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQ2x1c3RlclJvbGVCaW5kaW5nTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUNsdXN0ZXJSb2xlQmluZGluZ0xpc3RQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLnJiYWMudjEuQ2x1c3RlclJvbGVCaW5kaW5nTGlzdFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZUNsdXN0ZXJSb2xlQmluZGluZ0xpc3RQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZUNsdXN0ZXJSb2xlQmluZGluZ0xpc3QuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVDbHVzdGVyUm9sZUJpbmRpbmdMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlQ2x1c3RlclJvbGVCaW5kaW5nTGlzdFByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQ2x1c3RlclJvbGVMaXN0IGlzIGEgY29sbGVjdGlvbiBvZiBDbHVzdGVyUm9sZXNcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MS5DbHVzdGVyUm9sZUxpc3RcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVDbHVzdGVyUm9sZUxpc3QgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLnJiYWMudjEuQ2x1c3RlclJvbGVMaXN0XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdyYmFjLmF1dGhvcml6YXRpb24uazhzLmlvL3YxJyxcbiAgICBraW5kOiAnQ2x1c3RlclJvbGVMaXN0JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLnJiYWMudjEuQ2x1c3RlclJvbGVMaXN0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVDbHVzdGVyUm9sZUxpc3RQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVDbHVzdGVyUm9sZUxpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDbHVzdGVyUm9sZUxpc3RQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLnJiYWMudjEuQ2x1c3RlclJvbGVMaXN0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlQ2x1c3RlclJvbGVMaXN0UHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVDbHVzdGVyUm9sZUxpc3QuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVDbHVzdGVyUm9sZUxpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDbHVzdGVyUm9sZUxpc3RQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFJvbGUgaXMgYSBuYW1lc3BhY2VkLCBsb2dpY2FsIGdyb3VwaW5nIG9mIFBvbGljeVJ1bGVzIHRoYXQgY2FuIGJlIHJlZmVyZW5jZWQgYXMgYSB1bml0IGJ5IGEgUm9sZUJpbmRpbmcuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjEuUm9sZVxuICovXG5leHBvcnQgY2xhc3MgS3ViZVJvbGUgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLnJiYWMudjEuUm9sZVwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAncmJhYy5hdXRob3JpemF0aW9uLms4cy5pby92MScsXG4gICAga2luZDogJ1JvbGUnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkucmJhYy52MS5Sb2xlXCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVSb2xlUHJvcHMgPSB7fSk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVSb2xlLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUm9sZVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkucmJhYy52MS5Sb2xlXCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlUm9sZVByb3BzID0ge30pIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVSb2xlLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUm9sZS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVJvbGVQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFJvbGVCaW5kaW5nIHJlZmVyZW5jZXMgYSByb2xlLCBidXQgZG9lcyBub3QgY29udGFpbiBpdC4gIEl0IGNhbiByZWZlcmVuY2UgYSBSb2xlIGluIHRoZSBzYW1lIG5hbWVzcGFjZSBvciBhIENsdXN0ZXJSb2xlIGluIHRoZSBnbG9iYWwgbmFtZXNwYWNlLiBJdCBhZGRzIHdobyBpbmZvcm1hdGlvbiB2aWEgU3ViamVjdHMgYW5kIG5hbWVzcGFjZSBpbmZvcm1hdGlvbiBieSB3aGljaCBuYW1lc3BhY2UgaXQgZXhpc3RzIGluLiAgUm9sZUJpbmRpbmdzIGluIGEgZ2l2ZW4gbmFtZXNwYWNlIG9ubHkgaGF2ZSBlZmZlY3QgaW4gdGhhdCBuYW1lc3BhY2UuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjEuUm9sZUJpbmRpbmdcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVSb2xlQmluZGluZyBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkucmJhYy52MS5Sb2xlQmluZGluZ1wiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAncmJhYy5hdXRob3JpemF0aW9uLms4cy5pby92MScsXG4gICAga2luZDogJ1JvbGVCaW5kaW5nJyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLnJiYWMudjEuUm9sZUJpbmRpbmdcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVJvbGVCaW5kaW5nUHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUm9sZUJpbmRpbmcuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVSb2xlQmluZGluZ1Byb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkucmJhYy52MS5Sb2xlQmluZGluZ1wiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVJvbGVCaW5kaW5nUHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVSb2xlQmluZGluZy5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVJvbGVCaW5kaW5nLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUm9sZUJpbmRpbmdQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFJvbGVCaW5kaW5nTGlzdCBpcyBhIGNvbGxlY3Rpb24gb2YgUm9sZUJpbmRpbmdzXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjEuUm9sZUJpbmRpbmdMaXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlUm9sZUJpbmRpbmdMaXN0IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5yYmFjLnYxLlJvbGVCaW5kaW5nTGlzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAncmJhYy5hdXRob3JpemF0aW9uLms4cy5pby92MScsXG4gICAga2luZDogJ1JvbGVCaW5kaW5nTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5yYmFjLnYxLlJvbGVCaW5kaW5nTGlzdFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlUm9sZUJpbmRpbmdMaXN0UHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUm9sZUJpbmRpbmdMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUm9sZUJpbmRpbmdMaXN0UHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5yYmFjLnYxLlJvbGVCaW5kaW5nTGlzdFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVJvbGVCaW5kaW5nTGlzdFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlUm9sZUJpbmRpbmdMaXN0LkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUm9sZUJpbmRpbmdMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUm9sZUJpbmRpbmdMaXN0UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBSb2xlTGlzdCBpcyBhIGNvbGxlY3Rpb24gb2YgUm9sZXNcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MS5Sb2xlTGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZVJvbGVMaXN0IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5yYmFjLnYxLlJvbGVMaXN0XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdyYmFjLmF1dGhvcml6YXRpb24uazhzLmlvL3YxJyxcbiAgICBraW5kOiAnUm9sZUxpc3QnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkucmJhYy52MS5Sb2xlTGlzdFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlUm9sZUxpc3RQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVSb2xlTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVJvbGVMaXN0UHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5yYmFjLnYxLlJvbGVMaXN0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlUm9sZUxpc3RQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVJvbGVMaXN0LkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUm9sZUxpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVSb2xlTGlzdFByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQ2x1c3RlclJvbGUgaXMgYSBjbHVzdGVyIGxldmVsLCBsb2dpY2FsIGdyb3VwaW5nIG9mIFBvbGljeVJ1bGVzIHRoYXQgY2FuIGJlIHJlZmVyZW5jZWQgYXMgYSB1bml0IGJ5IGEgUm9sZUJpbmRpbmcgb3IgQ2x1c3RlclJvbGVCaW5kaW5nLiBEZXByZWNhdGVkIGluIHYxLjE3IGluIGZhdm9yIG9mIHJiYWMuYXV0aG9yaXphdGlvbi5rOHMuaW8vdjEgQ2x1c3RlclJvbGUsIGFuZCB3aWxsIG5vIGxvbmdlciBiZSBzZXJ2ZWQgaW4gdjEuMjIuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuQ2x1c3RlclJvbGVcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVDbHVzdGVyUm9sZVYxQWxwaGExIGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5yYmFjLnYxYWxwaGExLkNsdXN0ZXJSb2xlXCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdyYmFjLmF1dGhvcml6YXRpb24uazhzLmlvL3YxYWxwaGExJyxcbiAgICBraW5kOiAnQ2x1c3RlclJvbGUnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkucmJhYy52MWFscGhhMS5DbHVzdGVyUm9sZVwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlQ2x1c3RlclJvbGVWMUFscGhhMVByb3BzID0ge30pOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQ2x1c3RlclJvbGVWMUFscGhhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUNsdXN0ZXJSb2xlVjFBbHBoYTFQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuQ2x1c3RlclJvbGVcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVDbHVzdGVyUm9sZVYxQWxwaGExUHJvcHMgPSB7fSkge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZUNsdXN0ZXJSb2xlVjFBbHBoYTEuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVDbHVzdGVyUm9sZVYxQWxwaGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlQ2x1c3RlclJvbGVWMUFscGhhMVByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQ2x1c3RlclJvbGVCaW5kaW5nIHJlZmVyZW5jZXMgYSBDbHVzdGVyUm9sZSwgYnV0IG5vdCBjb250YWluIGl0LiAgSXQgY2FuIHJlZmVyZW5jZSBhIENsdXN0ZXJSb2xlIGluIHRoZSBnbG9iYWwgbmFtZXNwYWNlLCBhbmQgYWRkcyB3aG8gaW5mb3JtYXRpb24gdmlhIFN1YmplY3QuIERlcHJlY2F0ZWQgaW4gdjEuMTcgaW4gZmF2b3Igb2YgcmJhYy5hdXRob3JpemF0aW9uLms4cy5pby92MSBDbHVzdGVyUm9sZUJpbmRpbmcsIGFuZCB3aWxsIG5vIGxvbmdlciBiZSBzZXJ2ZWQgaW4gdjEuMjIuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuQ2x1c3RlclJvbGVCaW5kaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlQ2x1c3RlclJvbGVCaW5kaW5nVjFBbHBoYTEgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuQ2x1c3RlclJvbGVCaW5kaW5nXCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdyYmFjLmF1dGhvcml6YXRpb24uazhzLmlvL3YxYWxwaGExJyxcbiAgICBraW5kOiAnQ2x1c3RlclJvbGVCaW5kaW5nJyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuQ2x1c3RlclJvbGVCaW5kaW5nXCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVDbHVzdGVyUm9sZUJpbmRpbmdWMUFscGhhMVByb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUNsdXN0ZXJSb2xlQmluZGluZ1YxQWxwaGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlQ2x1c3RlclJvbGVCaW5kaW5nVjFBbHBoYTFQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuQ2x1c3RlclJvbGVCaW5kaW5nXCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlQ2x1c3RlclJvbGVCaW5kaW5nVjFBbHBoYTFQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZUNsdXN0ZXJSb2xlQmluZGluZ1YxQWxwaGExLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQ2x1c3RlclJvbGVCaW5kaW5nVjFBbHBoYTEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDbHVzdGVyUm9sZUJpbmRpbmdWMUFscGhhMVByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQ2x1c3RlclJvbGVCaW5kaW5nTGlzdCBpcyBhIGNvbGxlY3Rpb24gb2YgQ2x1c3RlclJvbGVCaW5kaW5ncy4gRGVwcmVjYXRlZCBpbiB2MS4xNyBpbiBmYXZvciBvZiByYmFjLmF1dGhvcml6YXRpb24uazhzLmlvL3YxIENsdXN0ZXJSb2xlQmluZGluZ3MsIGFuZCB3aWxsIG5vIGxvbmdlciBiZSBzZXJ2ZWQgaW4gdjEuMjIuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuQ2x1c3RlclJvbGVCaW5kaW5nTGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZUNsdXN0ZXJSb2xlQmluZGluZ0xpc3RWMUFscGhhMSBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkucmJhYy52MWFscGhhMS5DbHVzdGVyUm9sZUJpbmRpbmdMaXN0XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdyYmFjLmF1dGhvcml6YXRpb24uazhzLmlvL3YxYWxwaGExJyxcbiAgICBraW5kOiAnQ2x1c3RlclJvbGVCaW5kaW5nTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5yYmFjLnYxYWxwaGExLkNsdXN0ZXJSb2xlQmluZGluZ0xpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZUNsdXN0ZXJSb2xlQmluZGluZ0xpc3RWMUFscGhhMVByb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUNsdXN0ZXJSb2xlQmluZGluZ0xpc3RWMUFscGhhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUNsdXN0ZXJSb2xlQmluZGluZ0xpc3RWMUFscGhhMVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkucmJhYy52MWFscGhhMS5DbHVzdGVyUm9sZUJpbmRpbmdMaXN0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlQ2x1c3RlclJvbGVCaW5kaW5nTGlzdFYxQWxwaGExUHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVDbHVzdGVyUm9sZUJpbmRpbmdMaXN0VjFBbHBoYTEuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVDbHVzdGVyUm9sZUJpbmRpbmdMaXN0VjFBbHBoYTEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDbHVzdGVyUm9sZUJpbmRpbmdMaXN0VjFBbHBoYTFQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIENsdXN0ZXJSb2xlTGlzdCBpcyBhIGNvbGxlY3Rpb24gb2YgQ2x1c3RlclJvbGVzLiBEZXByZWNhdGVkIGluIHYxLjE3IGluIGZhdm9yIG9mIHJiYWMuYXV0aG9yaXphdGlvbi5rOHMuaW8vdjEgQ2x1c3RlclJvbGVzLCBhbmQgd2lsbCBubyBsb25nZXIgYmUgc2VydmVkIGluIHYxLjIyLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxYWxwaGExLkNsdXN0ZXJSb2xlTGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZUNsdXN0ZXJSb2xlTGlzdFYxQWxwaGExIGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5yYmFjLnYxYWxwaGExLkNsdXN0ZXJSb2xlTGlzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAncmJhYy5hdXRob3JpemF0aW9uLms4cy5pby92MWFscGhhMScsXG4gICAga2luZDogJ0NsdXN0ZXJSb2xlTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5yYmFjLnYxYWxwaGExLkNsdXN0ZXJSb2xlTGlzdFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlQ2x1c3RlclJvbGVMaXN0VjFBbHBoYTFQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVDbHVzdGVyUm9sZUxpc3RWMUFscGhhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUNsdXN0ZXJSb2xlTGlzdFYxQWxwaGExUHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5yYmFjLnYxYWxwaGExLkNsdXN0ZXJSb2xlTGlzdFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZUNsdXN0ZXJSb2xlTGlzdFYxQWxwaGExUHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVDbHVzdGVyUm9sZUxpc3RWMUFscGhhMS5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUNsdXN0ZXJSb2xlTGlzdFYxQWxwaGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlQ2x1c3RlclJvbGVMaXN0VjFBbHBoYTFQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFJvbGUgaXMgYSBuYW1lc3BhY2VkLCBsb2dpY2FsIGdyb3VwaW5nIG9mIFBvbGljeVJ1bGVzIHRoYXQgY2FuIGJlIHJlZmVyZW5jZWQgYXMgYSB1bml0IGJ5IGEgUm9sZUJpbmRpbmcuIERlcHJlY2F0ZWQgaW4gdjEuMTcgaW4gZmF2b3Igb2YgcmJhYy5hdXRob3JpemF0aW9uLms4cy5pby92MSBSb2xlLCBhbmQgd2lsbCBubyBsb25nZXIgYmUgc2VydmVkIGluIHYxLjIyLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxYWxwaGExLlJvbGVcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVSb2xlVjFBbHBoYTEgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuUm9sZVwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAncmJhYy5hdXRob3JpemF0aW9uLms4cy5pby92MWFscGhhMScsXG4gICAga2luZDogJ1JvbGUnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkucmJhYy52MWFscGhhMS5Sb2xlXCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVSb2xlVjFBbHBoYTFQcm9wcyA9IHt9KTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVJvbGVWMUFscGhhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVJvbGVWMUFscGhhMVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkucmJhYy52MWFscGhhMS5Sb2xlXCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlUm9sZVYxQWxwaGExUHJvcHMgPSB7fSkge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVJvbGVWMUFscGhhMS5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVJvbGVWMUFscGhhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVJvbGVWMUFscGhhMVByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUm9sZUJpbmRpbmcgcmVmZXJlbmNlcyBhIHJvbGUsIGJ1dCBkb2VzIG5vdCBjb250YWluIGl0LiAgSXQgY2FuIHJlZmVyZW5jZSBhIFJvbGUgaW4gdGhlIHNhbWUgbmFtZXNwYWNlIG9yIGEgQ2x1c3RlclJvbGUgaW4gdGhlIGdsb2JhbCBuYW1lc3BhY2UuIEl0IGFkZHMgd2hvIGluZm9ybWF0aW9uIHZpYSBTdWJqZWN0cyBhbmQgbmFtZXNwYWNlIGluZm9ybWF0aW9uIGJ5IHdoaWNoIG5hbWVzcGFjZSBpdCBleGlzdHMgaW4uICBSb2xlQmluZGluZ3MgaW4gYSBnaXZlbiBuYW1lc3BhY2Ugb25seSBoYXZlIGVmZmVjdCBpbiB0aGF0IG5hbWVzcGFjZS4gRGVwcmVjYXRlZCBpbiB2MS4xNyBpbiBmYXZvciBvZiByYmFjLmF1dGhvcml6YXRpb24uazhzLmlvL3YxIFJvbGVCaW5kaW5nLCBhbmQgd2lsbCBubyBsb25nZXIgYmUgc2VydmVkIGluIHYxLjIyLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxYWxwaGExLlJvbGVCaW5kaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlUm9sZUJpbmRpbmdWMUFscGhhMSBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkucmJhYy52MWFscGhhMS5Sb2xlQmluZGluZ1wiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAncmJhYy5hdXRob3JpemF0aW9uLms4cy5pby92MWFscGhhMScsXG4gICAga2luZDogJ1JvbGVCaW5kaW5nJyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuUm9sZUJpbmRpbmdcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVJvbGVCaW5kaW5nVjFBbHBoYTFQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVSb2xlQmluZGluZ1YxQWxwaGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUm9sZUJpbmRpbmdWMUFscGhhMVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkucmJhYy52MWFscGhhMS5Sb2xlQmluZGluZ1wiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVJvbGVCaW5kaW5nVjFBbHBoYTFQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVJvbGVCaW5kaW5nVjFBbHBoYTEuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVSb2xlQmluZGluZ1YxQWxwaGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUm9sZUJpbmRpbmdWMUFscGhhMVByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUm9sZUJpbmRpbmdMaXN0IGlzIGEgY29sbGVjdGlvbiBvZiBSb2xlQmluZGluZ3MgRGVwcmVjYXRlZCBpbiB2MS4xNyBpbiBmYXZvciBvZiByYmFjLmF1dGhvcml6YXRpb24uazhzLmlvL3YxIFJvbGVCaW5kaW5nTGlzdCwgYW5kIHdpbGwgbm8gbG9uZ2VyIGJlIHNlcnZlZCBpbiB2MS4yMi5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MWFscGhhMS5Sb2xlQmluZGluZ0xpc3RcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVSb2xlQmluZGluZ0xpc3RWMUFscGhhMSBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkucmJhYy52MWFscGhhMS5Sb2xlQmluZGluZ0xpc3RcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3JiYWMuYXV0aG9yaXphdGlvbi5rOHMuaW8vdjFhbHBoYTEnLFxuICAgIGtpbmQ6ICdSb2xlQmluZGluZ0xpc3QnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkucmJhYy52MWFscGhhMS5Sb2xlQmluZGluZ0xpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVJvbGVCaW5kaW5nTGlzdFYxQWxwaGExUHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUm9sZUJpbmRpbmdMaXN0VjFBbHBoYTEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVSb2xlQmluZGluZ0xpc3RWMUFscGhhMVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkucmJhYy52MWFscGhhMS5Sb2xlQmluZGluZ0xpc3RcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVSb2xlQmluZGluZ0xpc3RWMUFscGhhMVByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlUm9sZUJpbmRpbmdMaXN0VjFBbHBoYTEuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVSb2xlQmluZGluZ0xpc3RWMUFscGhhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVJvbGVCaW5kaW5nTGlzdFYxQWxwaGExUHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBSb2xlTGlzdCBpcyBhIGNvbGxlY3Rpb24gb2YgUm9sZXMuIERlcHJlY2F0ZWQgaW4gdjEuMTcgaW4gZmF2b3Igb2YgcmJhYy5hdXRob3JpemF0aW9uLms4cy5pby92MSBSb2xlTGlzdCwgYW5kIHdpbGwgbm8gbG9uZ2VyIGJlIHNlcnZlZCBpbiB2MS4yMi5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MWFscGhhMS5Sb2xlTGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZVJvbGVMaXN0VjFBbHBoYTEgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuUm9sZUxpc3RcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3JiYWMuYXV0aG9yaXphdGlvbi5rOHMuaW8vdjFhbHBoYTEnLFxuICAgIGtpbmQ6ICdSb2xlTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5yYmFjLnYxYWxwaGExLlJvbGVMaXN0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVSb2xlTGlzdFYxQWxwaGExUHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUm9sZUxpc3RWMUFscGhhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVJvbGVMaXN0VjFBbHBoYTFQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuUm9sZUxpc3RcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVSb2xlTGlzdFYxQWxwaGExUHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVSb2xlTGlzdFYxQWxwaGExLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUm9sZUxpc3RWMUFscGhhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVJvbGVMaXN0VjFBbHBoYTFQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFByaW9yaXR5Q2xhc3MgZGVmaW5lcyBtYXBwaW5nIGZyb20gYSBwcmlvcml0eSBjbGFzcyBuYW1lIHRvIHRoZSBwcmlvcml0eSBpbnRlZ2VyIHZhbHVlLiBUaGUgdmFsdWUgY2FuIGJlIGFueSB2YWxpZCBpbnRlZ2VyLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5zY2hlZHVsaW5nLnYxLlByaW9yaXR5Q2xhc3NcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVQcmlvcml0eUNsYXNzIGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5zY2hlZHVsaW5nLnYxLlByaW9yaXR5Q2xhc3NcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3NjaGVkdWxpbmcuazhzLmlvL3YxJyxcbiAgICBraW5kOiAnUHJpb3JpdHlDbGFzcycsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5zY2hlZHVsaW5nLnYxLlByaW9yaXR5Q2xhc3NcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVByaW9yaXR5Q2xhc3NQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVQcmlvcml0eUNsYXNzLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUHJpb3JpdHlDbGFzc1Byb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuc2NoZWR1bGluZy52MS5Qcmlvcml0eUNsYXNzXCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlUHJpb3JpdHlDbGFzc1Byb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlUHJpb3JpdHlDbGFzcy5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVByaW9yaXR5Q2xhc3MuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVQcmlvcml0eUNsYXNzUHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQcmlvcml0eUNsYXNzTGlzdCBpcyBhIGNvbGxlY3Rpb24gb2YgcHJpb3JpdHkgY2xhc3Nlcy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuc2NoZWR1bGluZy52MS5Qcmlvcml0eUNsYXNzTGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZVByaW9yaXR5Q2xhc3NMaXN0IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5zY2hlZHVsaW5nLnYxLlByaW9yaXR5Q2xhc3NMaXN0XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdzY2hlZHVsaW5nLms4cy5pby92MScsXG4gICAga2luZDogJ1ByaW9yaXR5Q2xhc3NMaXN0JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLnNjaGVkdWxpbmcudjEuUHJpb3JpdHlDbGFzc0xpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVByaW9yaXR5Q2xhc3NMaXN0UHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUHJpb3JpdHlDbGFzc0xpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVQcmlvcml0eUNsYXNzTGlzdFByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuc2NoZWR1bGluZy52MS5Qcmlvcml0eUNsYXNzTGlzdFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVByaW9yaXR5Q2xhc3NMaXN0UHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVQcmlvcml0eUNsYXNzTGlzdC5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVByaW9yaXR5Q2xhc3NMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUHJpb3JpdHlDbGFzc0xpc3RQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIERFUFJFQ0FURUQgLSBUaGlzIGdyb3VwIHZlcnNpb24gb2YgUHJpb3JpdHlDbGFzcyBpcyBkZXByZWNhdGVkIGJ5IHNjaGVkdWxpbmcuazhzLmlvL3YxL1ByaW9yaXR5Q2xhc3MuIFByaW9yaXR5Q2xhc3MgZGVmaW5lcyBtYXBwaW5nIGZyb20gYSBwcmlvcml0eSBjbGFzcyBuYW1lIHRvIHRoZSBwcmlvcml0eSBpbnRlZ2VyIHZhbHVlLiBUaGUgdmFsdWUgY2FuIGJlIGFueSB2YWxpZCBpbnRlZ2VyLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5zY2hlZHVsaW5nLnYxYWxwaGExLlByaW9yaXR5Q2xhc3NcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVQcmlvcml0eUNsYXNzVjFBbHBoYTEgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLnNjaGVkdWxpbmcudjFhbHBoYTEuUHJpb3JpdHlDbGFzc1wiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnc2NoZWR1bGluZy5rOHMuaW8vdjFhbHBoYTEnLFxuICAgIGtpbmQ6ICdQcmlvcml0eUNsYXNzJyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLnNjaGVkdWxpbmcudjFhbHBoYTEuUHJpb3JpdHlDbGFzc1wiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlUHJpb3JpdHlDbGFzc1YxQWxwaGExUHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlUHJpb3JpdHlDbGFzc1YxQWxwaGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUHJpb3JpdHlDbGFzc1YxQWxwaGExUHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5zY2hlZHVsaW5nLnYxYWxwaGExLlByaW9yaXR5Q2xhc3NcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVQcmlvcml0eUNsYXNzVjFBbHBoYTFQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVByaW9yaXR5Q2xhc3NWMUFscGhhMS5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVByaW9yaXR5Q2xhc3NWMUFscGhhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVByaW9yaXR5Q2xhc3NWMUFscGhhMVByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUHJpb3JpdHlDbGFzc0xpc3QgaXMgYSBjb2xsZWN0aW9uIG9mIHByaW9yaXR5IGNsYXNzZXMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnNjaGVkdWxpbmcudjFhbHBoYTEuUHJpb3JpdHlDbGFzc0xpc3RcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVQcmlvcml0eUNsYXNzTGlzdFYxQWxwaGExIGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5zY2hlZHVsaW5nLnYxYWxwaGExLlByaW9yaXR5Q2xhc3NMaXN0XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdzY2hlZHVsaW5nLms4cy5pby92MWFscGhhMScsXG4gICAga2luZDogJ1ByaW9yaXR5Q2xhc3NMaXN0JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLnNjaGVkdWxpbmcudjFhbHBoYTEuUHJpb3JpdHlDbGFzc0xpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVByaW9yaXR5Q2xhc3NMaXN0VjFBbHBoYTFQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVQcmlvcml0eUNsYXNzTGlzdFYxQWxwaGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUHJpb3JpdHlDbGFzc0xpc3RWMUFscGhhMVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuc2NoZWR1bGluZy52MWFscGhhMS5Qcmlvcml0eUNsYXNzTGlzdFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVByaW9yaXR5Q2xhc3NMaXN0VjFBbHBoYTFQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVByaW9yaXR5Q2xhc3NMaXN0VjFBbHBoYTEuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVQcmlvcml0eUNsYXNzTGlzdFYxQWxwaGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlUHJpb3JpdHlDbGFzc0xpc3RWMUFscGhhMVByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQ1NJRHJpdmVyIGNhcHR1cmVzIGluZm9ybWF0aW9uIGFib3V0IGEgQ29udGFpbmVyIFN0b3JhZ2UgSW50ZXJmYWNlIChDU0kpIHZvbHVtZSBkcml2ZXIgZGVwbG95ZWQgb24gdGhlIGNsdXN0ZXIuIEt1YmVybmV0ZXMgYXR0YWNoIGRldGFjaCBjb250cm9sbGVyIHVzZXMgdGhpcyBvYmplY3QgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYXR0YWNoIGlzIHJlcXVpcmVkLiBLdWJlbGV0IHVzZXMgdGhpcyBvYmplY3QgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgcG9kIGluZm9ybWF0aW9uIG5lZWRzIHRvIGJlIHBhc3NlZCBvbiBtb3VudC4gQ1NJRHJpdmVyIG9iamVjdHMgYXJlIG5vbi1uYW1lc3BhY2VkLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxLkNTSURyaXZlclxuICovXG5leHBvcnQgY2xhc3MgS3ViZUNzaURyaXZlciBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuc3RvcmFnZS52MS5DU0lEcml2ZXJcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3N0b3JhZ2UuazhzLmlvL3YxJyxcbiAgICBraW5kOiAnQ1NJRHJpdmVyJyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLnN0b3JhZ2UudjEuQ1NJRHJpdmVyXCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVDc2lEcml2ZXJQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVDc2lEcml2ZXIuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDc2lEcml2ZXJQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLnN0b3JhZ2UudjEuQ1NJRHJpdmVyXCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlQ3NpRHJpdmVyUHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVDc2lEcml2ZXIuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVDc2lEcml2ZXIuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDc2lEcml2ZXJQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIENTSURyaXZlckxpc3QgaXMgYSBjb2xsZWN0aW9uIG9mIENTSURyaXZlciBvYmplY3RzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxLkNTSURyaXZlckxpc3RcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVDc2lEcml2ZXJMaXN0IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5zdG9yYWdlLnYxLkNTSURyaXZlckxpc3RcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3N0b3JhZ2UuazhzLmlvL3YxJyxcbiAgICBraW5kOiAnQ1NJRHJpdmVyTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5zdG9yYWdlLnYxLkNTSURyaXZlckxpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZUNzaURyaXZlckxpc3RQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVDc2lEcml2ZXJMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlQ3NpRHJpdmVyTGlzdFByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuc3RvcmFnZS52MS5DU0lEcml2ZXJMaXN0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlQ3NpRHJpdmVyTGlzdFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlQ3NpRHJpdmVyTGlzdC5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUNzaURyaXZlckxpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDc2lEcml2ZXJMaXN0UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBDU0lOb2RlIGhvbGRzIGluZm9ybWF0aW9uIGFib3V0IGFsbCBDU0kgZHJpdmVycyBpbnN0YWxsZWQgb24gYSBub2RlLiBDU0kgZHJpdmVycyBkbyBub3QgbmVlZCB0byBjcmVhdGUgdGhlIENTSU5vZGUgb2JqZWN0IGRpcmVjdGx5LiBBcyBsb25nIGFzIHRoZXkgdXNlIHRoZSBub2RlLWRyaXZlci1yZWdpc3RyYXIgc2lkZWNhciBjb250YWluZXIsIHRoZSBrdWJlbGV0IHdpbGwgYXV0b21hdGljYWxseSBwb3B1bGF0ZSB0aGUgQ1NJTm9kZSBvYmplY3QgZm9yIHRoZSBDU0kgZHJpdmVyIGFzIHBhcnQgb2Yga3ViZWxldCBwbHVnaW4gcmVnaXN0cmF0aW9uLiBDU0lOb2RlIGhhcyB0aGUgc2FtZSBuYW1lIGFzIGEgbm9kZS4gSWYgdGhlIG9iamVjdCBpcyBtaXNzaW5nLCBpdCBtZWFucyBlaXRoZXIgdGhlcmUgYXJlIG5vIENTSSBEcml2ZXJzIGF2YWlsYWJsZSBvbiB0aGUgbm9kZSwgb3IgdGhlIEt1YmVsZXQgdmVyc2lvbiBpcyBsb3cgZW5vdWdoIHRoYXQgaXQgZG9lc24ndCBjcmVhdGUgdGhpcyBvYmplY3QuIENTSU5vZGUgaGFzIGFuIE93bmVyUmVmZXJlbmNlIHRoYXQgcG9pbnRzIHRvIHRoZSBjb3JyZXNwb25kaW5nIG5vZGUgb2JqZWN0LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxLkNTSU5vZGVcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVDc2lOb2RlIGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5zdG9yYWdlLnYxLkNTSU5vZGVcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3N0b3JhZ2UuazhzLmlvL3YxJyxcbiAgICBraW5kOiAnQ1NJTm9kZScsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5zdG9yYWdlLnYxLkNTSU5vZGVcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZUNzaU5vZGVQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVDc2lOb2RlLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlQ3NpTm9kZVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuc3RvcmFnZS52MS5DU0lOb2RlXCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlQ3NpTm9kZVByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlQ3NpTm9kZS5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUNzaU5vZGUuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDc2lOb2RlUHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBDU0lOb2RlTGlzdCBpcyBhIGNvbGxlY3Rpb24gb2YgQ1NJTm9kZSBvYmplY3RzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxLkNTSU5vZGVMaXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlQ3NpTm9kZUxpc3QgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLnN0b3JhZ2UudjEuQ1NJTm9kZUxpc3RcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3N0b3JhZ2UuazhzLmlvL3YxJyxcbiAgICBraW5kOiAnQ1NJTm9kZUxpc3QnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuc3RvcmFnZS52MS5DU0lOb2RlTGlzdFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlQ3NpTm9kZUxpc3RQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVDc2lOb2RlTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUNzaU5vZGVMaXN0UHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5zdG9yYWdlLnYxLkNTSU5vZGVMaXN0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlQ3NpTm9kZUxpc3RQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZUNzaU5vZGVMaXN0LkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQ3NpTm9kZUxpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDc2lOb2RlTGlzdFByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogU3RvcmFnZUNsYXNzIGRlc2NyaWJlcyB0aGUgcGFyYW1ldGVycyBmb3IgYSBjbGFzcyBvZiBzdG9yYWdlIGZvciB3aGljaCBQZXJzaXN0ZW50Vm9sdW1lcyBjYW4gYmUgZHluYW1pY2FsbHkgcHJvdmlzaW9uZWQuXG5cblN0b3JhZ2VDbGFzc2VzIGFyZSBub24tbmFtZXNwYWNlZDsgdGhlIG5hbWUgb2YgdGhlIHN0b3JhZ2UgY2xhc3MgYWNjb3JkaW5nIHRvIGV0Y2QgaXMgaW4gT2JqZWN0TWV0YS5OYW1lLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxLlN0b3JhZ2VDbGFzc1xuICovXG5leHBvcnQgY2xhc3MgS3ViZVN0b3JhZ2VDbGFzcyBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuc3RvcmFnZS52MS5TdG9yYWdlQ2xhc3NcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3N0b3JhZ2UuazhzLmlvL3YxJyxcbiAgICBraW5kOiAnU3RvcmFnZUNsYXNzJyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLnN0b3JhZ2UudjEuU3RvcmFnZUNsYXNzXCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVTdG9yYWdlQ2xhc3NQcm9wcyk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVTdG9yYWdlQ2xhc3MuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVTdG9yYWdlQ2xhc3NQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLnN0b3JhZ2UudjEuU3RvcmFnZUNsYXNzXCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlU3RvcmFnZUNsYXNzUHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVTdG9yYWdlQ2xhc3MuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVTdG9yYWdlQ2xhc3MuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVTdG9yYWdlQ2xhc3NQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFN0b3JhZ2VDbGFzc0xpc3QgaXMgYSBjb2xsZWN0aW9uIG9mIHN0b3JhZ2UgY2xhc3Nlcy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5TdG9yYWdlQ2xhc3NMaXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlU3RvcmFnZUNsYXNzTGlzdCBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuc3RvcmFnZS52MS5TdG9yYWdlQ2xhc3NMaXN0XCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdzdG9yYWdlLms4cy5pby92MScsXG4gICAga2luZDogJ1N0b3JhZ2VDbGFzc0xpc3QnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuc3RvcmFnZS52MS5TdG9yYWdlQ2xhc3NMaXN0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVTdG9yYWdlQ2xhc3NMaXN0UHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlU3RvcmFnZUNsYXNzTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVN0b3JhZ2VDbGFzc0xpc3RQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLnN0b3JhZ2UudjEuU3RvcmFnZUNsYXNzTGlzdFwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVN0b3JhZ2VDbGFzc0xpc3RQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVN0b3JhZ2VDbGFzc0xpc3QuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVTdG9yYWdlQ2xhc3NMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlU3RvcmFnZUNsYXNzTGlzdFByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogVm9sdW1lQXR0YWNobWVudCBjYXB0dXJlcyB0aGUgaW50ZW50IHRvIGF0dGFjaCBvciBkZXRhY2ggdGhlIHNwZWNpZmllZCB2b2x1bWUgdG8vZnJvbSB0aGUgc3BlY2lmaWVkIG5vZGUuXG5cblZvbHVtZUF0dGFjaG1lbnQgb2JqZWN0cyBhcmUgbm9uLW5hbWVzcGFjZWQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjEuVm9sdW1lQXR0YWNobWVudFxuICovXG5leHBvcnQgY2xhc3MgS3ViZVZvbHVtZUF0dGFjaG1lbnQgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLnN0b3JhZ2UudjEuVm9sdW1lQXR0YWNobWVudFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnc3RvcmFnZS5rOHMuaW8vdjEnLFxuICAgIGtpbmQ6ICdWb2x1bWVBdHRhY2htZW50JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLnN0b3JhZ2UudjEuVm9sdW1lQXR0YWNobWVudFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlVm9sdW1lQXR0YWNobWVudFByb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVZvbHVtZUF0dGFjaG1lbnQuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVWb2x1bWVBdHRhY2htZW50UHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5zdG9yYWdlLnYxLlZvbHVtZUF0dGFjaG1lbnRcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVWb2x1bWVBdHRhY2htZW50UHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVWb2x1bWVBdHRhY2htZW50LkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlVm9sdW1lQXR0YWNobWVudC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVZvbHVtZUF0dGFjaG1lbnRQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFZvbHVtZUF0dGFjaG1lbnRMaXN0IGlzIGEgY29sbGVjdGlvbiBvZiBWb2x1bWVBdHRhY2htZW50IG9iamVjdHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjEuVm9sdW1lQXR0YWNobWVudExpc3RcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVWb2x1bWVBdHRhY2htZW50TGlzdCBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuc3RvcmFnZS52MS5Wb2x1bWVBdHRhY2htZW50TGlzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnc3RvcmFnZS5rOHMuaW8vdjEnLFxuICAgIGtpbmQ6ICdWb2x1bWVBdHRhY2htZW50TGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5zdG9yYWdlLnYxLlZvbHVtZUF0dGFjaG1lbnRMaXN0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVWb2x1bWVBdHRhY2htZW50TGlzdFByb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVZvbHVtZUF0dGFjaG1lbnRMaXN0LkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlVm9sdW1lQXR0YWNobWVudExpc3RQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLnN0b3JhZ2UudjEuVm9sdW1lQXR0YWNobWVudExpc3RcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVWb2x1bWVBdHRhY2htZW50TGlzdFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlVm9sdW1lQXR0YWNobWVudExpc3QuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVWb2x1bWVBdHRhY2htZW50TGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVZvbHVtZUF0dGFjaG1lbnRMaXN0UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBDU0lTdG9yYWdlQ2FwYWNpdHkgc3RvcmVzIHRoZSByZXN1bHQgb2Ygb25lIENTSSBHZXRDYXBhY2l0eSBjYWxsLiBGb3IgYSBnaXZlbiBTdG9yYWdlQ2xhc3MsIHRoaXMgZGVzY3JpYmVzIHRoZSBhdmFpbGFibGUgY2FwYWNpdHkgaW4gYSBwYXJ0aWN1bGFyIHRvcG9sb2d5IHNlZ21lbnQuICBUaGlzIGNhbiBiZSB1c2VkIHdoZW4gY29uc2lkZXJpbmcgd2hlcmUgdG8gaW5zdGFudGlhdGUgbmV3IFBlcnNpc3RlbnRWb2x1bWVzLlxuXG5Gb3IgZXhhbXBsZSB0aGlzIGNhbiBleHByZXNzIHRoaW5ncyBsaWtlOiAtIFN0b3JhZ2VDbGFzcyBcInN0YW5kYXJkXCIgaGFzIFwiMTIzNCBHaUJcIiBhdmFpbGFibGUgaW4gXCJ0b3BvbG9neS5rdWJlcm5ldGVzLmlvL3pvbmU9dXMtZWFzdDFcIiAtIFN0b3JhZ2VDbGFzcyBcImxvY2Fsc3NkXCIgaGFzIFwiMTAgR2lCXCIgYXZhaWxhYmxlIGluIFwia3ViZXJuZXRlcy5pby9ob3N0bmFtZT1rbm9kZS1hYmMxMjNcIlxuXG5UaGUgZm9sbG93aW5nIHRocmVlIGNhc2VzIGFsbCBpbXBseSB0aGF0IG5vIGNhcGFjaXR5IGlzIGF2YWlsYWJsZSBmb3IgYSBjZXJ0YWluIGNvbWJpbmF0aW9uOiAtIG5vIG9iamVjdCBleGlzdHMgd2l0aCBzdWl0YWJsZSB0b3BvbG9neSBhbmQgc3RvcmFnZSBjbGFzcyBuYW1lIC0gc3VjaCBhbiBvYmplY3QgZXhpc3RzLCBidXQgdGhlIGNhcGFjaXR5IGlzIHVuc2V0IC0gc3VjaCBhbiBvYmplY3QgZXhpc3RzLCBidXQgdGhlIGNhcGFjaXR5IGlzIHplcm9cblxuVGhlIHByb2R1Y2VyIG9mIHRoZXNlIG9iamVjdHMgY2FuIGRlY2lkZSB3aGljaCBhcHByb2FjaCBpcyBtb3JlIHN1aXRhYmxlLlxuXG5UaGV5IGFyZSBjb25zdW1lZCBieSB0aGUga3ViZS1zY2hlZHVsZXIgaWYgdGhlIENTSVN0b3JhZ2VDYXBhY2l0eSBiZXRhIGZlYXR1cmUgZ2F0ZSBpcyBlbmFibGVkIHRoZXJlIGFuZCBhIENTSSBkcml2ZXIgb3B0cyBpbnRvIGNhcGFjaXR5LWF3YXJlIHNjaGVkdWxpbmcgd2l0aCBDU0lEcml2ZXIuU3RvcmFnZUNhcGFjaXR5LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxYWxwaGExLkNTSVN0b3JhZ2VDYXBhY2l0eVxuICovXG5leHBvcnQgY2xhc3MgS3ViZUNzaVN0b3JhZ2VDYXBhY2l0eVYxQWxwaGExIGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5zdG9yYWdlLnYxYWxwaGExLkNTSVN0b3JhZ2VDYXBhY2l0eVwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnc3RvcmFnZS5rOHMuaW8vdjFhbHBoYTEnLFxuICAgIGtpbmQ6ICdDU0lTdG9yYWdlQ2FwYWNpdHknLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuc3RvcmFnZS52MWFscGhhMS5DU0lTdG9yYWdlQ2FwYWNpdHlcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZUNzaVN0b3JhZ2VDYXBhY2l0eVYxQWxwaGExUHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQ3NpU3RvcmFnZUNhcGFjaXR5VjFBbHBoYTEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDc2lTdG9yYWdlQ2FwYWNpdHlWMUFscGhhMVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuc3RvcmFnZS52MWFscGhhMS5DU0lTdG9yYWdlQ2FwYWNpdHlcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVDc2lTdG9yYWdlQ2FwYWNpdHlWMUFscGhhMVByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlQ3NpU3RvcmFnZUNhcGFjaXR5VjFBbHBoYTEuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVDc2lTdG9yYWdlQ2FwYWNpdHlWMUFscGhhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUNzaVN0b3JhZ2VDYXBhY2l0eVYxQWxwaGExUHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBDU0lTdG9yYWdlQ2FwYWNpdHlMaXN0IGlzIGEgY29sbGVjdGlvbiBvZiBDU0lTdG9yYWdlQ2FwYWNpdHkgb2JqZWN0cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MWFscGhhMS5DU0lTdG9yYWdlQ2FwYWNpdHlMaXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlQ3NpU3RvcmFnZUNhcGFjaXR5TGlzdFYxQWxwaGExIGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5zdG9yYWdlLnYxYWxwaGExLkNTSVN0b3JhZ2VDYXBhY2l0eUxpc3RcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3N0b3JhZ2UuazhzLmlvL3YxYWxwaGExJyxcbiAgICBraW5kOiAnQ1NJU3RvcmFnZUNhcGFjaXR5TGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5zdG9yYWdlLnYxYWxwaGExLkNTSVN0b3JhZ2VDYXBhY2l0eUxpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZUNzaVN0b3JhZ2VDYXBhY2l0eUxpc3RWMUFscGhhMVByb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUNzaVN0b3JhZ2VDYXBhY2l0eUxpc3RWMUFscGhhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUNzaVN0b3JhZ2VDYXBhY2l0eUxpc3RWMUFscGhhMVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuc3RvcmFnZS52MWFscGhhMS5DU0lTdG9yYWdlQ2FwYWNpdHlMaXN0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlQ3NpU3RvcmFnZUNhcGFjaXR5TGlzdFYxQWxwaGExUHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVDc2lTdG9yYWdlQ2FwYWNpdHlMaXN0VjFBbHBoYTEuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVDc2lTdG9yYWdlQ2FwYWNpdHlMaXN0VjFBbHBoYTEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDc2lTdG9yYWdlQ2FwYWNpdHlMaXN0VjFBbHBoYTFQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFZvbHVtZUF0dGFjaG1lbnQgY2FwdHVyZXMgdGhlIGludGVudCB0byBhdHRhY2ggb3IgZGV0YWNoIHRoZSBzcGVjaWZpZWQgdm9sdW1lIHRvL2Zyb20gdGhlIHNwZWNpZmllZCBub2RlLlxuXG5Wb2x1bWVBdHRhY2htZW50IG9iamVjdHMgYXJlIG5vbi1uYW1lc3BhY2VkLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxYWxwaGExLlZvbHVtZUF0dGFjaG1lbnRcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVWb2x1bWVBdHRhY2htZW50VjFBbHBoYTEgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLnN0b3JhZ2UudjFhbHBoYTEuVm9sdW1lQXR0YWNobWVudFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnc3RvcmFnZS5rOHMuaW8vdjFhbHBoYTEnLFxuICAgIGtpbmQ6ICdWb2x1bWVBdHRhY2htZW50JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpLnN0b3JhZ2UudjFhbHBoYTEuVm9sdW1lQXR0YWNobWVudFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlVm9sdW1lQXR0YWNobWVudFYxQWxwaGExUHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlVm9sdW1lQXR0YWNobWVudFYxQWxwaGExLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlVm9sdW1lQXR0YWNobWVudFYxQWxwaGExUHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5zdG9yYWdlLnYxYWxwaGExLlZvbHVtZUF0dGFjaG1lbnRcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVWb2x1bWVBdHRhY2htZW50VjFBbHBoYTFQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZVZvbHVtZUF0dGFjaG1lbnRWMUFscGhhMS5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVZvbHVtZUF0dGFjaG1lbnRWMUFscGhhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZVZvbHVtZUF0dGFjaG1lbnRWMUFscGhhMVByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogVm9sdW1lQXR0YWNobWVudExpc3QgaXMgYSBjb2xsZWN0aW9uIG9mIFZvbHVtZUF0dGFjaG1lbnQgb2JqZWN0cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MWFscGhhMS5Wb2x1bWVBdHRhY2htZW50TGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZVZvbHVtZUF0dGFjaG1lbnRMaXN0VjFBbHBoYTEgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpLnN0b3JhZ2UudjFhbHBoYTEuVm9sdW1lQXR0YWNobWVudExpc3RcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ3N0b3JhZ2UuazhzLmlvL3YxYWxwaGExJyxcbiAgICBraW5kOiAnVm9sdW1lQXR0YWNobWVudExpc3QnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuc3RvcmFnZS52MWFscGhhMS5Wb2x1bWVBdHRhY2htZW50TGlzdFwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlVm9sdW1lQXR0YWNobWVudExpc3RWMUFscGhhMVByb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVZvbHVtZUF0dGFjaG1lbnRMaXN0VjFBbHBoYTEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVWb2x1bWVBdHRhY2htZW50TGlzdFYxQWxwaGExUHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaS5zdG9yYWdlLnYxYWxwaGExLlZvbHVtZUF0dGFjaG1lbnRMaXN0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlVm9sdW1lQXR0YWNobWVudExpc3RWMUFscGhhMVByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlVm9sdW1lQXR0YWNobWVudExpc3RWMUFscGhhMS5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZVZvbHVtZUF0dGFjaG1lbnRMaXN0VjFBbHBoYTEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVWb2x1bWVBdHRhY2htZW50TGlzdFYxQWxwaGExUHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBDU0lTdG9yYWdlQ2FwYWNpdHkgc3RvcmVzIHRoZSByZXN1bHQgb2Ygb25lIENTSSBHZXRDYXBhY2l0eSBjYWxsLiBGb3IgYSBnaXZlbiBTdG9yYWdlQ2xhc3MsIHRoaXMgZGVzY3JpYmVzIHRoZSBhdmFpbGFibGUgY2FwYWNpdHkgaW4gYSBwYXJ0aWN1bGFyIHRvcG9sb2d5IHNlZ21lbnQuICBUaGlzIGNhbiBiZSB1c2VkIHdoZW4gY29uc2lkZXJpbmcgd2hlcmUgdG8gaW5zdGFudGlhdGUgbmV3IFBlcnNpc3RlbnRWb2x1bWVzLlxuXG5Gb3IgZXhhbXBsZSB0aGlzIGNhbiBleHByZXNzIHRoaW5ncyBsaWtlOiAtIFN0b3JhZ2VDbGFzcyBcInN0YW5kYXJkXCIgaGFzIFwiMTIzNCBHaUJcIiBhdmFpbGFibGUgaW4gXCJ0b3BvbG9neS5rdWJlcm5ldGVzLmlvL3pvbmU9dXMtZWFzdDFcIiAtIFN0b3JhZ2VDbGFzcyBcImxvY2Fsc3NkXCIgaGFzIFwiMTAgR2lCXCIgYXZhaWxhYmxlIGluIFwia3ViZXJuZXRlcy5pby9ob3N0bmFtZT1rbm9kZS1hYmMxMjNcIlxuXG5UaGUgZm9sbG93aW5nIHRocmVlIGNhc2VzIGFsbCBpbXBseSB0aGF0IG5vIGNhcGFjaXR5IGlzIGF2YWlsYWJsZSBmb3IgYSBjZXJ0YWluIGNvbWJpbmF0aW9uOiAtIG5vIG9iamVjdCBleGlzdHMgd2l0aCBzdWl0YWJsZSB0b3BvbG9neSBhbmQgc3RvcmFnZSBjbGFzcyBuYW1lIC0gc3VjaCBhbiBvYmplY3QgZXhpc3RzLCBidXQgdGhlIGNhcGFjaXR5IGlzIHVuc2V0IC0gc3VjaCBhbiBvYmplY3QgZXhpc3RzLCBidXQgdGhlIGNhcGFjaXR5IGlzIHplcm9cblxuVGhlIHByb2R1Y2VyIG9mIHRoZXNlIG9iamVjdHMgY2FuIGRlY2lkZSB3aGljaCBhcHByb2FjaCBpcyBtb3JlIHN1aXRhYmxlLlxuXG5UaGV5IGFyZSBjb25zdW1lZCBieSB0aGUga3ViZS1zY2hlZHVsZXIgaWYgdGhlIENTSVN0b3JhZ2VDYXBhY2l0eSBiZXRhIGZlYXR1cmUgZ2F0ZSBpcyBlbmFibGVkIHRoZXJlIGFuZCBhIENTSSBkcml2ZXIgb3B0cyBpbnRvIGNhcGFjaXR5LWF3YXJlIHNjaGVkdWxpbmcgd2l0aCBDU0lEcml2ZXIuU3RvcmFnZUNhcGFjaXR5LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxYmV0YTEuQ1NJU3RvcmFnZUNhcGFjaXR5XG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlQ3NpU3RvcmFnZUNhcGFjaXR5VjFCZXRhMSBleHRlbmRzIEFwaU9iamVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcGlWZXJzaW9uIGFuZCBraW5kIGZvciBcImlvLms4cy5hcGkuc3RvcmFnZS52MWJldGExLkNTSVN0b3JhZ2VDYXBhY2l0eVwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnc3RvcmFnZS5rOHMuaW8vdjFiZXRhMScsXG4gICAga2luZDogJ0NTSVN0b3JhZ2VDYXBhY2l0eScsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmFwaS5zdG9yYWdlLnYxYmV0YTEuQ1NJU3RvcmFnZUNhcGFjaXR5XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVDc2lTdG9yYWdlQ2FwYWNpdHlWMUJldGExUHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQ3NpU3RvcmFnZUNhcGFjaXR5VjFCZXRhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUNzaVN0b3JhZ2VDYXBhY2l0eVYxQmV0YTFQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpLnN0b3JhZ2UudjFiZXRhMS5DU0lTdG9yYWdlQ2FwYWNpdHlcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVDc2lTdG9yYWdlQ2FwYWNpdHlWMUJldGExUHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVDc2lTdG9yYWdlQ2FwYWNpdHlWMUJldGExLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQ3NpU3RvcmFnZUNhcGFjaXR5VjFCZXRhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUNzaVN0b3JhZ2VDYXBhY2l0eVYxQmV0YTFQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIENTSVN0b3JhZ2VDYXBhY2l0eUxpc3QgaXMgYSBjb2xsZWN0aW9uIG9mIENTSVN0b3JhZ2VDYXBhY2l0eSBvYmplY3RzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxYmV0YTEuQ1NJU3RvcmFnZUNhcGFjaXR5TGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZUNzaVN0b3JhZ2VDYXBhY2l0eUxpc3RWMUJldGExIGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaS5zdG9yYWdlLnYxYmV0YTEuQ1NJU3RvcmFnZUNhcGFjaXR5TGlzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnc3RvcmFnZS5rOHMuaW8vdjFiZXRhMScsXG4gICAga2luZDogJ0NTSVN0b3JhZ2VDYXBhY2l0eUxpc3QnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGkuc3RvcmFnZS52MWJldGExLkNTSVN0b3JhZ2VDYXBhY2l0eUxpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZUNzaVN0b3JhZ2VDYXBhY2l0eUxpc3RWMUJldGExUHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQ3NpU3RvcmFnZUNhcGFjaXR5TGlzdFYxQmV0YTEuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDc2lTdG9yYWdlQ2FwYWNpdHlMaXN0VjFCZXRhMVByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGkuc3RvcmFnZS52MWJldGExLkNTSVN0b3JhZ2VDYXBhY2l0eUxpc3RcIiBBUEkgb2JqZWN0XG4gICAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBpZCBhIHNjb3BlLWxvY2FsIG5hbWUgZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEt1YmVDc2lTdG9yYWdlQ2FwYWNpdHlMaXN0VjFCZXRhMVByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlQ3NpU3RvcmFnZUNhcGFjaXR5TGlzdFYxQmV0YTEuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVDc2lTdG9yYWdlQ2FwYWNpdHlMaXN0VjFCZXRhMS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUNzaVN0b3JhZ2VDYXBhY2l0eUxpc3RWMUJldGExUHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBDdXN0b21SZXNvdXJjZURlZmluaXRpb24gcmVwcmVzZW50cyBhIHJlc291cmNlIHRoYXQgc2hvdWxkIGJlIGV4cG9zZWQgb24gdGhlIEFQSSBzZXJ2ZXIuICBJdHMgbmFtZSBNVVNUIGJlIGluIHRoZSBmb3JtYXQgPC5zcGVjLm5hbWU+Ljwuc3BlYy5ncm91cD4uXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5DdXN0b21SZXNvdXJjZURlZmluaXRpb25cbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVDdXN0b21SZXNvdXJjZURlZmluaXRpb24gZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5DdXN0b21SZXNvdXJjZURlZmluaXRpb25cIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ2FwaWV4dGVuc2lvbnMuazhzLmlvL3YxJyxcbiAgICBraW5kOiAnQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uJyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5DdXN0b21SZXNvdXJjZURlZmluaXRpb25cIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZUN1c3RvbVJlc291cmNlRGVmaW5pdGlvblByb3BzKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUN1c3RvbVJlc291cmNlRGVmaW5pdGlvbi5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUN1c3RvbVJlc291cmNlRGVmaW5pdGlvblByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkN1c3RvbVJlc291cmNlRGVmaW5pdGlvblwiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZUN1c3RvbVJlc291cmNlRGVmaW5pdGlvblByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uUHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBDdXN0b21SZXNvdXJjZURlZmluaXRpb25MaXN0IGlzIGEgbGlzdCBvZiBDdXN0b21SZXNvdXJjZURlZmluaXRpb24gb2JqZWN0cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkN1c3RvbVJlc291cmNlRGVmaW5pdGlvbkxpc3RcbiAqL1xuZXhwb3J0IGNsYXNzIEt1YmVDdXN0b21SZXNvdXJjZURlZmluaXRpb25MaXN0IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uTGlzdFwiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAnYXBpZXh0ZW5zaW9ucy5rOHMuaW8vdjEnLFxuICAgIGtpbmQ6ICdDdXN0b21SZXNvdXJjZURlZmluaXRpb25MaXN0JyxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgS3ViZXJuZXRlcyBtYW5pZmVzdCBmb3IgXCJpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5DdXN0b21SZXNvdXJjZURlZmluaXRpb25MaXN0XCIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5saW5lIHJlc291cmNlIG1hbmlmZXN0cyBpbnNpZGUgb3RoZXIgb2JqZWN0cyAoZS5nLiBhcyB0ZW1wbGF0ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWFuaWZlc3QocHJvcHM6IEt1YmVDdXN0b21SZXNvdXJjZURlZmluaXRpb25MaXN0UHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uTGlzdC5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUN1c3RvbVJlc291cmNlRGVmaW5pdGlvbkxpc3RQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5DdXN0b21SZXNvdXJjZURlZmluaXRpb25MaXN0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uTGlzdFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5LdWJlQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uTGlzdC5HVkssXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gS3ViZXJuZXRlcyBKU09OLlxuICAgKi9cbiAgcHVibGljIHRvSnNvbigpOiBhbnkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gc3VwZXIudG9Kc29uKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uS3ViZUN1c3RvbVJlc291cmNlRGVmaW5pdGlvbkxpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVDdXN0b21SZXNvdXJjZURlZmluaXRpb25MaXN0UHJvcHMocmVzb2x2ZWQpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBTdGF0dXMgaXMgYSByZXR1cm4gdmFsdWUgZm9yIGNhbGxzIHRoYXQgZG9uJ3QgcmV0dXJuIG90aGVyIG9iamVjdHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuU3RhdHVzXG4gKi9cbmV4cG9ydCBjbGFzcyBLdWJlU3RhdHVzIGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLlN0YXR1c1wiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdWSzogR3JvdXBWZXJzaW9uS2luZCA9IHtcbiAgICBhcGlWZXJzaW9uOiAndjEnLFxuICAgIGtpbmQ6ICdTdGF0dXMnLFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBLdWJlcm5ldGVzIG1hbmlmZXN0IGZvciBcImlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5TdGF0dXNcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZVN0YXR1c1Byb3BzID0ge30pOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlU3RhdHVzLkdWSyxcbiAgICAgIC4uLnRvSnNvbl9LdWJlU3RhdHVzUHJvcHMocHJvcHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIFwiaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLlN0YXR1c1wiIEFQSSBvYmplY3RcbiAgICogQHBhcmFtIHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBkZWZpbmUgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtIGlkIGEgc2NvcGUtbG9jYWwgbmFtZSBmb3IgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcHMgaW5pdGlhbGl6YXRpb24gcHJvcHNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogS3ViZVN0YXR1c1Byb3BzID0ge30pIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVTdGF0dXMuR1ZLLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHN1cGVyLnRvSnNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkt1YmVTdGF0dXMuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVTdGF0dXNQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEFQSVNlcnZpY2UgcmVwcmVzZW50cyBhIHNlcnZlciBmb3IgYSBwYXJ0aWN1bGFyIEdyb3VwVmVyc2lvbi4gTmFtZSBtdXN0IGJlIFwidmVyc2lvbi5ncm91cFwiLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmt1YmUtYWdncmVnYXRvci5wa2cuYXBpcy5hcGlyZWdpc3RyYXRpb24udjEuQVBJU2VydmljZVxuICovXG5leHBvcnQgY2xhc3MgS3ViZUFwaVNlcnZpY2UgZXh0ZW5kcyBBcGlPYmplY3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBpVmVyc2lvbiBhbmQga2luZCBmb3IgXCJpby5rOHMua3ViZS1hZ2dyZWdhdG9yLnBrZy5hcGlzLmFwaXJlZ2lzdHJhdGlvbi52MS5BUElTZXJ2aWNlXCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1ZLOiBHcm91cFZlcnNpb25LaW5kID0ge1xuICAgIGFwaVZlcnNpb246ICdhcGlyZWdpc3RyYXRpb24uazhzLmlvL3YxJyxcbiAgICBraW5kOiAnQVBJU2VydmljZScsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmt1YmUtYWdncmVnYXRvci5wa2cuYXBpcy5hcGlyZWdpc3RyYXRpb24udjEuQVBJU2VydmljZVwiLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlubGluZSByZXNvdXJjZSBtYW5pZmVzdHMgaW5zaWRlIG90aGVyIG9iamVjdHMgKGUuZy4gYXMgdGVtcGxhdGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1hbmlmZXN0KHByb3BzOiBLdWJlQXBpU2VydmljZVByb3BzID0ge30pOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQXBpU2VydmljZS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUFwaVNlcnZpY2VQcm9wcyhwcm9wcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgXCJpby5rOHMua3ViZS1hZ2dyZWdhdG9yLnBrZy5hcGlzLmFwaXJlZ2lzdHJhdGlvbi52MS5BUElTZXJ2aWNlXCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlQXBpU2VydmljZVByb3BzID0ge30pIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLkt1YmVBcGlTZXJ2aWNlLkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQXBpU2VydmljZS5HVkssXG4gICAgICAuLi50b0pzb25fS3ViZUFwaVNlcnZpY2VQcm9wcyhyZXNvbHZlZCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEFQSVNlcnZpY2VMaXN0IGlzIGEgbGlzdCBvZiBBUElTZXJ2aWNlIG9iamVjdHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMua3ViZS1hZ2dyZWdhdG9yLnBrZy5hcGlzLmFwaXJlZ2lzdHJhdGlvbi52MS5BUElTZXJ2aWNlTGlzdFxuICovXG5leHBvcnQgY2xhc3MgS3ViZUFwaVNlcnZpY2VMaXN0IGV4dGVuZHMgQXBpT2JqZWN0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwaVZlcnNpb24gYW5kIGtpbmQgZm9yIFwiaW8uazhzLmt1YmUtYWdncmVnYXRvci5wa2cuYXBpcy5hcGlyZWdpc3RyYXRpb24udjEuQVBJU2VydmljZUxpc3RcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBHVks6IEdyb3VwVmVyc2lvbktpbmQgPSB7XG4gICAgYXBpVmVyc2lvbjogJ2FwaXJlZ2lzdHJhdGlvbi5rOHMuaW8vdjEnLFxuICAgIGtpbmQ6ICdBUElTZXJ2aWNlTGlzdCcsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEt1YmVybmV0ZXMgbWFuaWZlc3QgZm9yIFwiaW8uazhzLmt1YmUtYWdncmVnYXRvci5wa2cuYXBpcy5hcGlyZWdpc3RyYXRpb24udjEuQVBJU2VydmljZUxpc3RcIi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpbmxpbmUgcmVzb3VyY2UgbWFuaWZlc3RzIGluc2lkZSBvdGhlciBvYmplY3RzIChlLmcuIGFzIHRlbXBsYXRlcykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYW5pZmVzdChwcm9wczogS3ViZUFwaVNlcnZpY2VMaXN0UHJvcHMpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQXBpU2VydmljZUxpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVBcGlTZXJ2aWNlTGlzdFByb3BzKHByb3BzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBcImlvLms4cy5rdWJlLWFnZ3JlZ2F0b3IucGtnLmFwaXMuYXBpcmVnaXN0cmF0aW9uLnYxLkFQSVNlcnZpY2VMaXN0XCIgQVBJIG9iamVjdFxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlIGluIHdoaWNoIHRvIGRlZmluZSB0aGlzIG9iamVjdFxuICAgKiBAcGFyYW0gaWQgYSBzY29wZS1sb2NhbCBuYW1lIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBwcm9wcyBpbml0aWFsaXphdGlvbiBwcm9wc1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBLdWJlQXBpU2VydmljZUxpc3RQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4uS3ViZUFwaVNlcnZpY2VMaXN0LkdWSyxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBLdWJlcm5ldGVzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBzdXBlci50b0pzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5LdWJlQXBpU2VydmljZUxpc3QuR1ZLLFxuICAgICAgLi4udG9Kc29uX0t1YmVBcGlTZXJ2aWNlTGlzdFByb3BzKHJlc29sdmVkKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogTXV0YXRpbmdXZWJob29rQ29uZmlndXJhdGlvbiBkZXNjcmliZXMgdGhlIGNvbmZpZ3VyYXRpb24gb2YgYW5kIGFkbWlzc2lvbiB3ZWJob29rIHRoYXQgYWNjZXB0IG9yIHJlamVjdCBhbmQgbWF5IGNoYW5nZSB0aGUgb2JqZWN0LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuTXV0YXRpbmdXZWJob29rQ29uZmlndXJhdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVNdXRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uUHJvcHMge1xuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0IG1ldGFkYXRhOyBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYWRtaXNzaW9ucmVnaXN0cmF0aW9uLnYxLk11dGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb24jbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogV2ViaG9va3MgaXMgYSBsaXN0IG9mIHdlYmhvb2tzIGFuZCB0aGUgYWZmZWN0ZWQgcmVzb3VyY2VzIGFuZCBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYWRtaXNzaW9ucmVnaXN0cmF0aW9uLnYxLk11dGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb24jd2ViaG9va3NcbiAgICovXG4gIHJlYWRvbmx5IHdlYmhvb2tzPzogTXV0YXRpbmdXZWJob29rW107XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZU11dGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb25Qcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZU11dGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb25Qcm9wcyhvYmo6IEt1YmVNdXRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uUHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3dlYmhvb2tzJzogb2JqLndlYmhvb2tzPy5tYXAoeSA9PiB0b0pzb25fTXV0YXRpbmdXZWJob29rKHkpKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBNdXRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uTGlzdCBpcyBhIGxpc3Qgb2YgTXV0YXRpbmdXZWJob29rQ29uZmlndXJhdGlvbi5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYWRtaXNzaW9ucmVnaXN0cmF0aW9uLnYxLk11dGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb25MaXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZU11dGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb25MaXN0UHJvcHMge1xuICAvKipcbiAgICogTGlzdCBvZiBNdXRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYWRtaXNzaW9ucmVnaXN0cmF0aW9uLnYxLk11dGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb25MaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZU11dGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb25Qcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBsaXN0IG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3R5cGVzLWtpbmRzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuTXV0YXRpbmdXZWJob29rQ29uZmlndXJhdGlvbkxpc3QjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogTGlzdE1ldGE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZU11dGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb25MaXN0UHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVNdXRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uTGlzdFByb3BzKG9iajogS3ViZU11dGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb25MaXN0UHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdpdGVtcyc6IG9iai5pdGVtcz8ubWFwKHkgPT4gdG9Kc29uX0t1YmVNdXRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uUHJvcHMoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9MaXN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFZhbGlkYXRpbmdXZWJob29rQ29uZmlndXJhdGlvbiBkZXNjcmliZXMgdGhlIGNvbmZpZ3VyYXRpb24gb2YgYW5kIGFkbWlzc2lvbiB3ZWJob29rIHRoYXQgYWNjZXB0IG9yIHJlamVjdCBhbmQgb2JqZWN0IHdpdGhvdXQgY2hhbmdpbmcgaXQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmFkbWlzc2lvbnJlZ2lzdHJhdGlvbi52MS5WYWxpZGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uUHJvcHMge1xuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0IG1ldGFkYXRhOyBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYWRtaXNzaW9ucmVnaXN0cmF0aW9uLnYxLlZhbGlkYXRpbmdXZWJob29rQ29uZmlndXJhdGlvbiNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBPYmplY3RNZXRhO1xuXG4gIC8qKlxuICAgKiBXZWJob29rcyBpcyBhIGxpc3Qgb2Ygd2ViaG9va3MgYW5kIHRoZSBhZmZlY3RlZCByZXNvdXJjZXMgYW5kIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uI3dlYmhvb2tzXG4gICAqL1xuICByZWFkb25seSB3ZWJob29rcz86IFZhbGlkYXRpbmdXZWJob29rW107XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZVZhbGlkYXRpbmdXZWJob29rQ29uZmlndXJhdGlvblByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uUHJvcHMob2JqOiBLdWJlVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uUHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3dlYmhvb2tzJzogb2JqLndlYmhvb2tzPy5tYXAoeSA9PiB0b0pzb25fVmFsaWRhdGluZ1dlYmhvb2soeSkpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFZhbGlkYXRpbmdXZWJob29rQ29uZmlndXJhdGlvbkxpc3QgaXMgYSBsaXN0IG9mIFZhbGlkYXRpbmdXZWJob29rQ29uZmlndXJhdGlvbi5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYWRtaXNzaW9ucmVnaXN0cmF0aW9uLnYxLlZhbGlkYXRpbmdXZWJob29rQ29uZmlndXJhdGlvbkxpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uTGlzdFByb3BzIHtcbiAgLyoqXG4gICAqIExpc3Qgb2YgVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYWRtaXNzaW9ucmVnaXN0cmF0aW9uLnYxLlZhbGlkYXRpbmdXZWJob29rQ29uZmlndXJhdGlvbkxpc3QjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zOiBLdWJlVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uUHJvcHNbXTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgbGlzdCBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCN0eXBlcy1raW5kc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYWRtaXNzaW9ucmVnaXN0cmF0aW9uLnYxLlZhbGlkYXRpbmdXZWJob29rQ29uZmlndXJhdGlvbkxpc3QjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogTGlzdE1ldGE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZVZhbGlkYXRpbmdXZWJob29rQ29uZmlndXJhdGlvbkxpc3RQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVZhbGlkYXRpbmdXZWJob29rQ29uZmlndXJhdGlvbkxpc3RQcm9wcyhvYmo6IEt1YmVWYWxpZGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb25MaXN0UHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdpdGVtcyc6IG9iai5pdGVtcz8ubWFwKHkgPT4gdG9Kc29uX0t1YmVWYWxpZGF0aW5nV2ViaG9va0NvbmZpZ3VyYXRpb25Qcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICpcbiAqIFN0b3JhZ2UgdmVyc2lvbiBvZiBhIHNwZWNpZmljIHJlc291cmNlLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcGlzZXJ2ZXJpbnRlcm5hbC52MWFscGhhMS5TdG9yYWdlVmVyc2lvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVTdG9yYWdlVmVyc2lvblYxQWxwaGExUHJvcHMge1xuICAvKipcbiAgICogVGhlIG5hbWUgaXMgPGdyb3VwPi48cmVzb3VyY2U+LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBpc2VydmVyaW50ZXJuYWwudjFhbHBoYTEuU3RvcmFnZVZlcnNpb24jbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogU3BlYyBpcyBhbiBlbXB0eSBzcGVjLiBJdCBpcyBoZXJlIHRvIGNvbXBseSB3aXRoIEt1YmVybmV0ZXMgQVBJIHN0eWxlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBpc2VydmVyaW50ZXJuYWwudjFhbHBoYTEuU3RvcmFnZVZlcnNpb24jc3BlY1xuICAgKi9cbiAgcmVhZG9ubHkgc3BlYzogYW55O1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVTdG9yYWdlVmVyc2lvblYxQWxwaGExUHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVTdG9yYWdlVmVyc2lvblYxQWxwaGExUHJvcHMob2JqOiBLdWJlU3RvcmFnZVZlcnNpb25WMUFscGhhMVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdzcGVjJzogb2JqLnNwZWMsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQSBsaXN0IG9mIFN0b3JhZ2VWZXJzaW9ucy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBpc2VydmVyaW50ZXJuYWwudjFhbHBoYTEuU3RvcmFnZVZlcnNpb25MaXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZVN0b3JhZ2VWZXJzaW9uTGlzdFYxQWxwaGExUHJvcHMge1xuICAvKipcbiAgICogSXRlbXMgaG9sZHMgYSBsaXN0IG9mIFN0b3JhZ2VWZXJzaW9uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcGlzZXJ2ZXJpbnRlcm5hbC52MWFscGhhMS5TdG9yYWdlVmVyc2lvbkxpc3QjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zOiBLdWJlU3RvcmFnZVZlcnNpb25WMUFscGhhMVByb3BzW107XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIGxpc3QgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFwaXNlcnZlcmludGVybmFsLnYxYWxwaGExLlN0b3JhZ2VWZXJzaW9uTGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlU3RvcmFnZVZlcnNpb25MaXN0VjFBbHBoYTFQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVN0b3JhZ2VWZXJzaW9uTGlzdFYxQWxwaGExUHJvcHMob2JqOiBLdWJlU3RvcmFnZVZlcnNpb25MaXN0VjFBbHBoYTFQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZVN0b3JhZ2VWZXJzaW9uVjFBbHBoYTFQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQ29udHJvbGxlclJldmlzaW9uIGltcGxlbWVudHMgYW4gaW1tdXRhYmxlIHNuYXBzaG90IG9mIHN0YXRlIGRhdGEuIENsaWVudHMgYXJlIHJlc3BvbnNpYmxlIGZvciBzZXJpYWxpemluZyBhbmQgZGVzZXJpYWxpemluZyB0aGUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gdGhlaXIgaW50ZXJuYWwgc3RhdGUuIE9uY2UgYSBDb250cm9sbGVyUmV2aXNpb24gaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGNyZWF0ZWQsIGl0IGNhbiBub3QgYmUgdXBkYXRlZC4gVGhlIEFQSSBTZXJ2ZXIgd2lsbCBmYWlsIHZhbGlkYXRpb24gb2YgYWxsIHJlcXVlc3RzIHRoYXQgYXR0ZW1wdCB0byBtdXRhdGUgdGhlIERhdGEgZmllbGQuIENvbnRyb2xsZXJSZXZpc2lvbnMgbWF5LCBob3dldmVyLCBiZSBkZWxldGVkLiBOb3RlIHRoYXQsIGR1ZSB0byBpdHMgdXNlIGJ5IGJvdGggdGhlIERhZW1vblNldCBhbmQgU3RhdGVmdWxTZXQgY29udHJvbGxlcnMgZm9yIHVwZGF0ZSBhbmQgcm9sbGJhY2ssIHRoaXMgb2JqZWN0IGlzIGJldGEuIEhvd2V2ZXIsIGl0IG1heSBiZSBzdWJqZWN0IHRvIG5hbWUgYW5kIHJlcHJlc2VudGF0aW9uIGNoYW5nZXMgaW4gZnV0dXJlIHJlbGVhc2VzLCBhbmQgY2xpZW50cyBzaG91bGQgbm90IGRlcGVuZCBvbiBpdHMgc3RhYmlsaXR5LiBJdCBpcyBwcmltYXJpbHkgZm9yIGludGVybmFsIHVzZSBieSBjb250cm9sbGVycy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5Db250cm9sbGVyUmV2aXNpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlQ29udHJvbGxlclJldmlzaW9uUHJvcHMge1xuICAvKipcbiAgICogRGF0YSBpcyB0aGUgc2VyaWFsaXplZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3RhdGUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLkNvbnRyb2xsZXJSZXZpc2lvbiNkYXRhXG4gICAqL1xuICByZWFkb25seSBkYXRhPzogYW55O1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5Db250cm9sbGVyUmV2aXNpb24jbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogUmV2aXNpb24gaW5kaWNhdGVzIHRoZSByZXZpc2lvbiBvZiB0aGUgc3RhdGUgcmVwcmVzZW50ZWQgYnkgRGF0YS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuQ29udHJvbGxlclJldmlzaW9uI3JldmlzaW9uXG4gICAqL1xuICByZWFkb25seSByZXZpc2lvbjogbnVtYmVyO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVDb250cm9sbGVyUmV2aXNpb25Qcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUNvbnRyb2xsZXJSZXZpc2lvblByb3BzKG9iajogS3ViZUNvbnRyb2xsZXJSZXZpc2lvblByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZGF0YSc6IG9iai5kYXRhLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3JldmlzaW9uJzogb2JqLnJldmlzaW9uLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIENvbnRyb2xsZXJSZXZpc2lvbkxpc3QgaXMgYSByZXNvdXJjZSBjb250YWluaW5nIGEgbGlzdCBvZiBDb250cm9sbGVyUmV2aXNpb24gb2JqZWN0cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5Db250cm9sbGVyUmV2aXNpb25MaXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZUNvbnRyb2xsZXJSZXZpc2lvbkxpc3RQcm9wcyB7XG4gIC8qKlxuICAgKiBJdGVtcyBpcyB0aGUgbGlzdCBvZiBDb250cm9sbGVyUmV2aXNpb25zXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLkNvbnRyb2xsZXJSZXZpc2lvbkxpc3QjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zOiBLdWJlQ29udHJvbGxlclJldmlzaW9uUHJvcHNbXTtcblxuICAvKipcbiAgICogTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5Db250cm9sbGVyUmV2aXNpb25MaXN0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IExpc3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVDb250cm9sbGVyUmV2aXNpb25MaXN0UHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVDb250cm9sbGVyUmV2aXNpb25MaXN0UHJvcHMob2JqOiBLdWJlQ29udHJvbGxlclJldmlzaW9uTGlzdFByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaXRlbXMnOiBvYmouaXRlbXM/Lm1hcCh5ID0+IHRvSnNvbl9LdWJlQ29udHJvbGxlclJldmlzaW9uUHJvcHMoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9MaXN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIERhZW1vblNldCByZXByZXNlbnRzIHRoZSBjb25maWd1cmF0aW9uIG9mIGEgZGFlbW9uIHNldC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5EYWVtb25TZXRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlRGFlbW9uU2V0UHJvcHMge1xuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0J3MgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuRGFlbW9uU2V0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIFRoZSBkZXNpcmVkIGJlaGF2aW9yIG9mIHRoaXMgZGFlbW9uIHNldC4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNzcGVjLWFuZC1zdGF0dXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuRGFlbW9uU2V0I3NwZWNcbiAgICovXG4gIHJlYWRvbmx5IHNwZWM/OiBEYWVtb25TZXRTcGVjO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVEYWVtb25TZXRQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZURhZW1vblNldFByb3BzKG9iajogS3ViZURhZW1vblNldFByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdzcGVjJzogdG9Kc29uX0RhZW1vblNldFNwZWMob2JqLnNwZWMpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIERhZW1vblNldExpc3QgaXMgYSBjb2xsZWN0aW9uIG9mIGRhZW1vbiBzZXRzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLkRhZW1vblNldExpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlRGFlbW9uU2V0TGlzdFByb3BzIHtcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBkYWVtb24gc2V0cy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuRGFlbW9uU2V0TGlzdCNpdGVtc1xuICAgKi9cbiAgcmVhZG9ubHkgaXRlbXM6IEt1YmVEYWVtb25TZXRQcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBsaXN0IG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLkRhZW1vblNldExpc3QjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogTGlzdE1ldGE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZURhZW1vblNldExpc3RQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZURhZW1vblNldExpc3RQcm9wcyhvYmo6IEt1YmVEYWVtb25TZXRMaXN0UHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdpdGVtcyc6IG9iai5pdGVtcz8ubWFwKHkgPT4gdG9Kc29uX0t1YmVEYWVtb25TZXRQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogRGVwbG95bWVudCBlbmFibGVzIGRlY2xhcmF0aXZlIHVwZGF0ZXMgZm9yIFBvZHMgYW5kIFJlcGxpY2FTZXRzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLkRlcGxveW1lbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlRGVwbG95bWVudFByb3BzIHtcbiAgLyoqXG4gICAqIFN0YW5kYXJkIG9iamVjdCdzIG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLkRlcGxveW1lbnQjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbiBvZiB0aGUgZGVzaXJlZCBiZWhhdmlvciBvZiB0aGUgRGVwbG95bWVudC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuRGVwbG95bWVudCNzcGVjXG4gICAqL1xuICByZWFkb25seSBzcGVjPzogRGVwbG95bWVudFNwZWM7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZURlcGxveW1lbnRQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZURlcGxveW1lbnRQcm9wcyhvYmo6IEt1YmVEZXBsb3ltZW50UHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3NwZWMnOiB0b0pzb25fRGVwbG95bWVudFNwZWMob2JqLnNwZWMpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIERlcGxveW1lbnRMaXN0IGlzIGEgbGlzdCBvZiBEZXBsb3ltZW50cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5EZXBsb3ltZW50TGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVEZXBsb3ltZW50TGlzdFByb3BzIHtcbiAgLyoqXG4gICAqIEl0ZW1zIGlzIHRoZSBsaXN0IG9mIERlcGxveW1lbnRzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5EZXBsb3ltZW50TGlzdCNpdGVtc1xuICAgKi9cbiAgcmVhZG9ubHkgaXRlbXM6IEt1YmVEZXBsb3ltZW50UHJvcHNbXTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgbGlzdCBtZXRhZGF0YS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuRGVwbG95bWVudExpc3QjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogTGlzdE1ldGE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZURlcGxveW1lbnRMaXN0UHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVEZXBsb3ltZW50TGlzdFByb3BzKG9iajogS3ViZURlcGxveW1lbnRMaXN0UHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdpdGVtcyc6IG9iai5pdGVtcz8ubWFwKHkgPT4gdG9Kc29uX0t1YmVEZXBsb3ltZW50UHJvcHMoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9MaXN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFJlcGxpY2FTZXQgZW5zdXJlcyB0aGF0IGEgc3BlY2lmaWVkIG51bWJlciBvZiBwb2QgcmVwbGljYXMgYXJlIHJ1bm5pbmcgYXQgYW55IGdpdmVuIHRpbWUuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuUmVwbGljYVNldFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVSZXBsaWNhU2V0UHJvcHMge1xuICAvKipcbiAgICogSWYgdGhlIExhYmVscyBvZiBhIFJlcGxpY2FTZXQgYXJlIGVtcHR5LCB0aGV5IGFyZSBkZWZhdWx0ZWQgdG8gYmUgdGhlIHNhbWUgYXMgdGhlIFBvZChzKSB0aGF0IHRoZSBSZXBsaWNhU2V0IG1hbmFnZXMuIFN0YW5kYXJkIG9iamVjdCdzIG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLlJlcGxpY2FTZXQjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogU3BlYyBkZWZpbmVzIHRoZSBzcGVjaWZpY2F0aW9uIG9mIHRoZSBkZXNpcmVkIGJlaGF2aW9yIG9mIHRoZSBSZXBsaWNhU2V0LiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3NwZWMtYW5kLXN0YXR1c1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5SZXBsaWNhU2V0I3NwZWNcbiAgICovXG4gIHJlYWRvbmx5IHNwZWM/OiBSZXBsaWNhU2V0U3BlYztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlUmVwbGljYVNldFByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlUmVwbGljYVNldFByb3BzKG9iajogS3ViZVJlcGxpY2FTZXRQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX09iamVjdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgICAnc3BlYyc6IHRvSnNvbl9SZXBsaWNhU2V0U3BlYyhvYmouc3BlYyksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUmVwbGljYVNldExpc3QgaXMgYSBjb2xsZWN0aW9uIG9mIFJlcGxpY2FTZXRzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLlJlcGxpY2FTZXRMaXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZVJlcGxpY2FTZXRMaXN0UHJvcHMge1xuICAvKipcbiAgICogTGlzdCBvZiBSZXBsaWNhU2V0cy4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy93b3JrbG9hZHMvY29udHJvbGxlcnMvcmVwbGljYXRpb25jb250cm9sbGVyXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLlJlcGxpY2FTZXRMaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZVJlcGxpY2FTZXRQcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBsaXN0IG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3R5cGVzLWtpbmRzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLlJlcGxpY2FTZXRMaXN0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IExpc3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVSZXBsaWNhU2V0TGlzdFByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlUmVwbGljYVNldExpc3RQcm9wcyhvYmo6IEt1YmVSZXBsaWNhU2V0TGlzdFByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaXRlbXMnOiBvYmouaXRlbXM/Lm1hcCh5ID0+IHRvSnNvbl9LdWJlUmVwbGljYVNldFByb3BzKHkpKSxcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fTGlzdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBTdGF0ZWZ1bFNldCByZXByZXNlbnRzIGEgc2V0IG9mIHBvZHMgd2l0aCBjb25zaXN0ZW50IGlkZW50aXRpZXMuIElkZW50aXRpZXMgYXJlIGRlZmluZWQgYXM6XG4gKiAtIE5ldHdvcms6IEEgc2luZ2xlIHN0YWJsZSBETlMgYW5kIGhvc3RuYW1lLlxuICogLSBTdG9yYWdlOiBBcyBtYW55IFZvbHVtZUNsYWltcyBhcyByZXF1ZXN0ZWQuXG4gKiBUaGUgU3RhdGVmdWxTZXQgZ3VhcmFudGVlcyB0aGF0IGEgZ2l2ZW4gbmV0d29yayBpZGVudGl0eSB3aWxsIGFsd2F5cyBtYXAgdG8gdGhlIHNhbWUgc3RvcmFnZSBpZGVudGl0eS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5TdGF0ZWZ1bFNldFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVTdGF0ZWZ1bFNldFByb3BzIHtcbiAgLyoqXG4gICAqIFN0YW5kYXJkIG9iamVjdCdzIG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLlN0YXRlZnVsU2V0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIFNwZWMgZGVmaW5lcyB0aGUgZGVzaXJlZCBpZGVudGl0aWVzIG9mIHBvZHMgaW4gdGhpcyBzZXQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLlN0YXRlZnVsU2V0I3NwZWNcbiAgICovXG4gIHJlYWRvbmx5IHNwZWM/OiBTdGF0ZWZ1bFNldFNwZWM7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZVN0YXRlZnVsU2V0UHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVTdGF0ZWZ1bFNldFByb3BzKG9iajogS3ViZVN0YXRlZnVsU2V0UHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3NwZWMnOiB0b0pzb25fU3RhdGVmdWxTZXRTcGVjKG9iai5zcGVjKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBTdGF0ZWZ1bFNldExpc3QgaXMgYSBjb2xsZWN0aW9uIG9mIFN0YXRlZnVsU2V0cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5TdGF0ZWZ1bFNldExpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlU3RhdGVmdWxTZXRMaXN0UHJvcHMge1xuICAvKipcbiAgICogSXRlbXMgaXMgdGhlIGxpc3Qgb2Ygc3RhdGVmdWwgc2V0cy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuU3RhdGVmdWxTZXRMaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZVN0YXRlZnVsU2V0UHJvcHNbXTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgbGlzdCdzIG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLlN0YXRlZnVsU2V0TGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlU3RhdGVmdWxTZXRMaXN0UHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVTdGF0ZWZ1bFNldExpc3RQcm9wcyhvYmo6IEt1YmVTdGF0ZWZ1bFNldExpc3RQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZVN0YXRlZnVsU2V0UHJvcHMoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9MaXN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFRva2VuUmVxdWVzdCByZXF1ZXN0cyBhIHRva2VuIGZvciBhIGdpdmVuIHNlcnZpY2UgYWNjb3VudC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0aGVudGljYXRpb24udjEuVG9rZW5SZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZVRva2VuUmVxdWVzdFByb3BzIHtcbiAgLyoqXG4gICAqIFN0YW5kYXJkIG9iamVjdCdzIG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRoZW50aWNhdGlvbi52MS5Ub2tlblJlcXVlc3QjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogU3BlYyBob2xkcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVxdWVzdCBiZWluZyBldmFsdWF0ZWRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dGhlbnRpY2F0aW9uLnYxLlRva2VuUmVxdWVzdCNzcGVjXG4gICAqL1xuICByZWFkb25seSBzcGVjOiBUb2tlblJlcXVlc3RTcGVjO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVUb2tlblJlcXVlc3RQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVRva2VuUmVxdWVzdFByb3BzKG9iajogS3ViZVRva2VuUmVxdWVzdFByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdzcGVjJzogdG9Kc29uX1Rva2VuUmVxdWVzdFNwZWMob2JqLnNwZWMpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFRva2VuUmV2aWV3IGF0dGVtcHRzIHRvIGF1dGhlbnRpY2F0ZSBhIHRva2VuIHRvIGEga25vd24gdXNlci4gTm90ZTogVG9rZW5SZXZpZXcgcmVxdWVzdHMgbWF5IGJlIGNhY2hlZCBieSB0aGUgd2ViaG9vayB0b2tlbiBhdXRoZW50aWNhdG9yIHBsdWdpbiBpbiB0aGUga3ViZS1hcGlzZXJ2ZXIuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dGhlbnRpY2F0aW9uLnYxLlRva2VuUmV2aWV3XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZVRva2VuUmV2aWV3UHJvcHMge1xuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0J3MgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dGhlbnRpY2F0aW9uLnYxLlRva2VuUmV2aWV3I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIFNwZWMgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlcXVlc3QgYmVpbmcgZXZhbHVhdGVkXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRoZW50aWNhdGlvbi52MS5Ub2tlblJldmlldyNzcGVjXG4gICAqL1xuICByZWFkb25seSBzcGVjOiBUb2tlblJldmlld1NwZWM7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZVRva2VuUmV2aWV3UHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVUb2tlblJldmlld1Byb3BzKG9iajogS3ViZVRva2VuUmV2aWV3UHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3NwZWMnOiB0b0pzb25fVG9rZW5SZXZpZXdTcGVjKG9iai5zcGVjKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBMb2NhbFN1YmplY3RBY2Nlc3NSZXZpZXcgY2hlY2tzIHdoZXRoZXIgb3Igbm90IGEgdXNlciBvciBncm91cCBjYW4gcGVyZm9ybSBhbiBhY3Rpb24gaW4gYSBnaXZlbiBuYW1lc3BhY2UuIEhhdmluZyBhIG5hbWVzcGFjZSBzY29wZWQgcmVzb3VyY2UgbWFrZXMgaXQgbXVjaCBlYXNpZXIgdG8gZ3JhbnQgbmFtZXNwYWNlIHNjb3BlZCBwb2xpY3kgdGhhdCBpbmNsdWRlcyBwZXJtaXNzaW9ucyBjaGVja2luZy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0aG9yaXphdGlvbi52MS5Mb2NhbFN1YmplY3RBY2Nlc3NSZXZpZXdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlTG9jYWxTdWJqZWN0QWNjZXNzUmV2aWV3UHJvcHMge1xuICAvKipcbiAgICogU3RhbmRhcmQgbGlzdCBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0aG9yaXphdGlvbi52MS5Mb2NhbFN1YmplY3RBY2Nlc3NSZXZpZXcjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogU3BlYyBob2xkcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVxdWVzdCBiZWluZyBldmFsdWF0ZWQuICBzcGVjLm5hbWVzcGFjZSBtdXN0IGJlIGVxdWFsIHRvIHRoZSBuYW1lc3BhY2UgeW91IG1hZGUgdGhlIHJlcXVlc3QgYWdhaW5zdC4gIElmIGVtcHR5LCBpdCBpcyBkZWZhdWx0ZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRob3JpemF0aW9uLnYxLkxvY2FsU3ViamVjdEFjY2Vzc1JldmlldyNzcGVjXG4gICAqL1xuICByZWFkb25seSBzcGVjOiBTdWJqZWN0QWNjZXNzUmV2aWV3U3BlYztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlTG9jYWxTdWJqZWN0QWNjZXNzUmV2aWV3UHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVMb2NhbFN1YmplY3RBY2Nlc3NSZXZpZXdQcm9wcyhvYmo6IEt1YmVMb2NhbFN1YmplY3RBY2Nlc3NSZXZpZXdQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX09iamVjdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgICAnc3BlYyc6IHRvSnNvbl9TdWJqZWN0QWNjZXNzUmV2aWV3U3BlYyhvYmouc3BlYyksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogU2VsZlN1YmplY3RBY2Nlc3NSZXZpZXcgY2hlY2tzIHdoZXRoZXIgb3IgdGhlIGN1cnJlbnQgdXNlciBjYW4gcGVyZm9ybSBhbiBhY3Rpb24uICBOb3QgZmlsbGluZyBpbiBhIHNwZWMubmFtZXNwYWNlIG1lYW5zIFwiaW4gYWxsIG5hbWVzcGFjZXNcIi4gIFNlbGYgaXMgYSBzcGVjaWFsIGNhc2UsIGJlY2F1c2UgdXNlcnMgc2hvdWxkIGFsd2F5cyBiZSBhYmxlIHRvIGNoZWNrIHdoZXRoZXIgdGhleSBjYW4gcGVyZm9ybSBhbiBhY3Rpb25cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0aG9yaXphdGlvbi52MS5TZWxmU3ViamVjdEFjY2Vzc1Jldmlld1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVTZWxmU3ViamVjdEFjY2Vzc1Jldmlld1Byb3BzIHtcbiAgLyoqXG4gICAqIFN0YW5kYXJkIGxpc3QgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dGhvcml6YXRpb24udjEuU2VsZlN1YmplY3RBY2Nlc3NSZXZpZXcjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogU3BlYyBob2xkcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVxdWVzdCBiZWluZyBldmFsdWF0ZWQuICB1c2VyIGFuZCBncm91cHMgbXVzdCBiZSBlbXB0eVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0aG9yaXphdGlvbi52MS5TZWxmU3ViamVjdEFjY2Vzc1JldmlldyNzcGVjXG4gICAqL1xuICByZWFkb25seSBzcGVjOiBTZWxmU3ViamVjdEFjY2Vzc1Jldmlld1NwZWM7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZVNlbGZTdWJqZWN0QWNjZXNzUmV2aWV3UHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVTZWxmU3ViamVjdEFjY2Vzc1Jldmlld1Byb3BzKG9iajogS3ViZVNlbGZTdWJqZWN0QWNjZXNzUmV2aWV3UHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3NwZWMnOiB0b0pzb25fU2VsZlN1YmplY3RBY2Nlc3NSZXZpZXdTcGVjKG9iai5zcGVjKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBTZWxmU3ViamVjdFJ1bGVzUmV2aWV3IGVudW1lcmF0ZXMgdGhlIHNldCBvZiBhY3Rpb25zIHRoZSBjdXJyZW50IHVzZXIgY2FuIHBlcmZvcm0gd2l0aGluIGEgbmFtZXNwYWNlLiBUaGUgcmV0dXJuZWQgbGlzdCBvZiBhY3Rpb25zIG1heSBiZSBpbmNvbXBsZXRlIGRlcGVuZGluZyBvbiB0aGUgc2VydmVyJ3MgYXV0aG9yaXphdGlvbiBtb2RlLCBhbmQgYW55IGVycm9ycyBleHBlcmllbmNlZCBkdXJpbmcgdGhlIGV2YWx1YXRpb24uIFNlbGZTdWJqZWN0UnVsZXNSZXZpZXcgc2hvdWxkIGJlIHVzZWQgYnkgVUlzIHRvIHNob3cvaGlkZSBhY3Rpb25zLCBvciB0byBxdWlja2x5IGxldCBhbiBlbmQgdXNlciByZWFzb24gYWJvdXQgdGhlaXIgcGVybWlzc2lvbnMuIEl0IHNob3VsZCBOT1QgQmUgdXNlZCBieSBleHRlcm5hbCBzeXN0ZW1zIHRvIGRyaXZlIGF1dGhvcml6YXRpb24gZGVjaXNpb25zIGFzIHRoaXMgcmFpc2VzIGNvbmZ1c2VkIGRlcHV0eSwgY2FjaGUgbGlmZXRpbWUvcmV2b2NhdGlvbiwgYW5kIGNvcnJlY3RuZXNzIGNvbmNlcm5zLiBTdWJqZWN0QWNjZXNzUmV2aWV3LCBhbmQgTG9jYWxBY2Nlc3NSZXZpZXcgYXJlIHRoZSBjb3JyZWN0IHdheSB0byBkZWZlciBhdXRob3JpemF0aW9uIGRlY2lzaW9ucyB0byB0aGUgQVBJIHNlcnZlci5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0aG9yaXphdGlvbi52MS5TZWxmU3ViamVjdFJ1bGVzUmV2aWV3XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZVNlbGZTdWJqZWN0UnVsZXNSZXZpZXdQcm9wcyB7XG4gIC8qKlxuICAgKiBTdGFuZGFyZCBsaXN0IG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRob3JpemF0aW9uLnYxLlNlbGZTdWJqZWN0UnVsZXNSZXZpZXcjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogU3BlYyBob2xkcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVxdWVzdCBiZWluZyBldmFsdWF0ZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRob3JpemF0aW9uLnYxLlNlbGZTdWJqZWN0UnVsZXNSZXZpZXcjc3BlY1xuICAgKi9cbiAgcmVhZG9ubHkgc3BlYzogU2VsZlN1YmplY3RSdWxlc1Jldmlld1NwZWM7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZVNlbGZTdWJqZWN0UnVsZXNSZXZpZXdQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVNlbGZTdWJqZWN0UnVsZXNSZXZpZXdQcm9wcyhvYmo6IEt1YmVTZWxmU3ViamVjdFJ1bGVzUmV2aWV3UHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3NwZWMnOiB0b0pzb25fU2VsZlN1YmplY3RSdWxlc1Jldmlld1NwZWMob2JqLnNwZWMpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFN1YmplY3RBY2Nlc3NSZXZpZXcgY2hlY2tzIHdoZXRoZXIgb3Igbm90IGEgdXNlciBvciBncm91cCBjYW4gcGVyZm9ybSBhbiBhY3Rpb24uXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dGhvcml6YXRpb24udjEuU3ViamVjdEFjY2Vzc1Jldmlld1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVTdWJqZWN0QWNjZXNzUmV2aWV3UHJvcHMge1xuICAvKipcbiAgICogU3RhbmRhcmQgbGlzdCBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0aG9yaXphdGlvbi52MS5TdWJqZWN0QWNjZXNzUmV2aWV3I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIFNwZWMgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlcXVlc3QgYmVpbmcgZXZhbHVhdGVkXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRob3JpemF0aW9uLnYxLlN1YmplY3RBY2Nlc3NSZXZpZXcjc3BlY1xuICAgKi9cbiAgcmVhZG9ubHkgc3BlYzogU3ViamVjdEFjY2Vzc1Jldmlld1NwZWM7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZVN1YmplY3RBY2Nlc3NSZXZpZXdQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVN1YmplY3RBY2Nlc3NSZXZpZXdQcm9wcyhvYmo6IEt1YmVTdWJqZWN0QWNjZXNzUmV2aWV3UHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3NwZWMnOiB0b0pzb25fU3ViamVjdEFjY2Vzc1Jldmlld1NwZWMob2JqLnNwZWMpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIGNvbmZpZ3VyYXRpb24gb2YgYSBob3Jpem9udGFsIHBvZCBhdXRvc2NhbGVyLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MS5Ib3Jpem9udGFsUG9kQXV0b3NjYWxlclxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlclByb3BzIHtcbiAgLyoqXG4gICAqIFN0YW5kYXJkIG9iamVjdCBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjEuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXIjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogYmVoYXZpb3VyIG9mIGF1dG9zY2FsZXIuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjc3BlYy1hbmQtc3RhdHVzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjEuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXIjc3BlY1xuICAgKi9cbiAgcmVhZG9ubHkgc3BlYz86IEhvcml6b250YWxQb2RBdXRvc2NhbGVyU3BlYztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyUHJvcHMob2JqOiBLdWJlSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX09iamVjdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgICAnc3BlYyc6IHRvSnNvbl9Ib3Jpem9udGFsUG9kQXV0b3NjYWxlclNwZWMob2JqLnNwZWMpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIGxpc3Qgb2YgaG9yaXpvbnRhbCBwb2QgYXV0b3NjYWxlciBvYmplY3RzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MS5Ib3Jpem9udGFsUG9kQXV0b3NjYWxlckxpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJMaXN0UHJvcHMge1xuICAvKipcbiAgICogbGlzdCBvZiBob3Jpem9udGFsIHBvZCBhdXRvc2NhbGVyIG9iamVjdHMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MS5Ib3Jpem9udGFsUG9kQXV0b3NjYWxlckxpc3QjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zOiBLdWJlSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJQcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBsaXN0IG1ldGFkYXRhLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjEuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJMaXN0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IExpc3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlckxpc3RQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyTGlzdFByb3BzKG9iajogS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyTGlzdFByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaXRlbXMnOiBvYmouaXRlbXM/Lm1hcCh5ID0+IHRvSnNvbl9LdWJlSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogU2NhbGUgcmVwcmVzZW50cyBhIHNjYWxpbmcgcmVxdWVzdCBmb3IgYSByZXNvdXJjZS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjEuU2NhbGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlU2NhbGVQcm9wcyB7XG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QgbWV0YWRhdGE7IE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGEuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MS5TY2FsZSNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBPYmplY3RNZXRhO1xuXG4gIC8qKlxuICAgKiBkZWZpbmVzIHRoZSBiZWhhdmlvciBvZiB0aGUgc2NhbGUuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjc3BlYy1hbmQtc3RhdHVzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjEuU2NhbGUjc3BlY1xuICAgKi9cbiAgcmVhZG9ubHkgc3BlYz86IFNjYWxlU3BlYztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlU2NhbGVQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVNjYWxlUHJvcHMob2JqOiBLdWJlU2NhbGVQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX09iamVjdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgICAnc3BlYyc6IHRvSnNvbl9TY2FsZVNwZWMob2JqLnNwZWMpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEhvcml6b250YWxQb2RBdXRvc2NhbGVyIGlzIHRoZSBjb25maWd1cmF0aW9uIGZvciBhIGhvcml6b250YWwgcG9kIGF1dG9zY2FsZXIsIHdoaWNoIGF1dG9tYXRpY2FsbHkgbWFuYWdlcyB0aGUgcmVwbGljYSBjb3VudCBvZiBhbnkgcmVzb3VyY2UgaW1wbGVtZW50aW5nIHRoZSBzY2FsZSBzdWJyZXNvdXJjZSBiYXNlZCBvbiB0aGUgbWV0cmljcyBzcGVjaWZpZWQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTEuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJWMkJldGExUHJvcHMge1xuICAvKipcbiAgICogbWV0YWRhdGEgaXMgdGhlIHN0YW5kYXJkIG9iamVjdCBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMS5Ib3Jpem9udGFsUG9kQXV0b3NjYWxlciNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBPYmplY3RNZXRhO1xuXG4gIC8qKlxuICAgKiBzcGVjIGlzIHRoZSBzcGVjaWZpY2F0aW9uIGZvciB0aGUgYmVoYXZpb3VyIG9mIHRoZSBhdXRvc2NhbGVyLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3NwZWMtYW5kLXN0YXR1cy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTEuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXIjc3BlY1xuICAgKi9cbiAgcmVhZG9ubHkgc3BlYz86IEhvcml6b250YWxQb2RBdXRvc2NhbGVyU3BlY1YyQmV0YTE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyVjJCZXRhMVByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJWMkJldGExUHJvcHMob2JqOiBLdWJlSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJWMkJldGExUHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3NwZWMnOiB0b0pzb25fSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJTcGVjVjJCZXRhMShvYmouc3BlYyksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXIgaXMgYSBsaXN0IG9mIGhvcml6b250YWwgcG9kIGF1dG9zY2FsZXIgb2JqZWN0cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMS5Ib3Jpem9udGFsUG9kQXV0b3NjYWxlckxpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJMaXN0VjJCZXRhMVByb3BzIHtcbiAgLyoqXG4gICAqIGl0ZW1zIGlzIHRoZSBsaXN0IG9mIGhvcml6b250YWwgcG9kIGF1dG9zY2FsZXIgb2JqZWN0cy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTEuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJMaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyVjJCZXRhMVByb3BzW107XG5cbiAgLyoqXG4gICAqIG1ldGFkYXRhIGlzIHRoZSBzdGFuZGFyZCBsaXN0IG1ldGFkYXRhLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMS5Ib3Jpem9udGFsUG9kQXV0b3NjYWxlckxpc3QjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogTGlzdE1ldGE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyTGlzdFYyQmV0YTFQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyTGlzdFYyQmV0YTFQcm9wcyhvYmo6IEt1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlckxpc3RWMkJldGExUHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdpdGVtcyc6IG9iai5pdGVtcz8ubWFwKHkgPT4gdG9Kc29uX0t1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlclYyQmV0YTFQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXIgaXMgdGhlIGNvbmZpZ3VyYXRpb24gZm9yIGEgaG9yaXpvbnRhbCBwb2QgYXV0b3NjYWxlciwgd2hpY2ggYXV0b21hdGljYWxseSBtYW5hZ2VzIHRoZSByZXBsaWNhIGNvdW50IG9mIGFueSByZXNvdXJjZSBpbXBsZW1lbnRpbmcgdGhlIHNjYWxlIHN1YnJlc291cmNlIGJhc2VkIG9uIHRoZSBtZXRyaWNzIHNwZWNpZmllZC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMi5Ib3Jpem9udGFsUG9kQXV0b3NjYWxlclxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlclYyQmV0YTJQcm9wcyB7XG4gIC8qKlxuICAgKiBtZXRhZGF0YSBpcyB0aGUgc3RhbmRhcmQgb2JqZWN0IG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGEyLkhvcml6b250YWxQb2RBdXRvc2NhbGVyI21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIHNwZWMgaXMgdGhlIHNwZWNpZmljYXRpb24gZm9yIHRoZSBiZWhhdmlvdXIgb2YgdGhlIGF1dG9zY2FsZXIuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjc3BlYy1hbmQtc3RhdHVzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMi5Ib3Jpem9udGFsUG9kQXV0b3NjYWxlciNzcGVjXG4gICAqL1xuICByZWFkb25seSBzcGVjPzogSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJTcGVjVjJCZXRhMjtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJWMkJldGEyUHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlclYyQmV0YTJQcm9wcyhvYmo6IEt1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlclYyQmV0YTJQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX09iamVjdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgICAnc3BlYyc6IHRvSnNvbl9Ib3Jpem9udGFsUG9kQXV0b3NjYWxlclNwZWNWMkJldGEyKG9iai5zcGVjKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBIb3Jpem9udGFsUG9kQXV0b3NjYWxlckxpc3QgaXMgYSBsaXN0IG9mIGhvcml6b250YWwgcG9kIGF1dG9zY2FsZXIgb2JqZWN0cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMi5Ib3Jpem9udGFsUG9kQXV0b3NjYWxlckxpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJMaXN0VjJCZXRhMlByb3BzIHtcbiAgLyoqXG4gICAqIGl0ZW1zIGlzIHRoZSBsaXN0IG9mIGhvcml6b250YWwgcG9kIGF1dG9zY2FsZXIgb2JqZWN0cy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJMaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyVjJCZXRhMlByb3BzW107XG5cbiAgLyoqXG4gICAqIG1ldGFkYXRhIGlzIHRoZSBzdGFuZGFyZCBsaXN0IG1ldGFkYXRhLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMi5Ib3Jpem9udGFsUG9kQXV0b3NjYWxlckxpc3QjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogTGlzdE1ldGE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyTGlzdFYyQmV0YTJQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUhvcml6b250YWxQb2RBdXRvc2NhbGVyTGlzdFYyQmV0YTJQcm9wcyhvYmo6IEt1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlckxpc3RWMkJldGEyUHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdpdGVtcyc6IG9iai5pdGVtcz8ubWFwKHkgPT4gdG9Kc29uX0t1YmVIb3Jpem9udGFsUG9kQXV0b3NjYWxlclYyQmV0YTJQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQ3JvbkpvYiByZXByZXNlbnRzIHRoZSBjb25maWd1cmF0aW9uIG9mIGEgc2luZ2xlIGNyb24gam9iLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5iYXRjaC52MS5Dcm9uSm9iXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZUNyb25Kb2JQcm9wcyB7XG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYmF0Y2gudjEuQ3JvbkpvYiNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBPYmplY3RNZXRhO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uIG9mIHRoZSBkZXNpcmVkIGJlaGF2aW9yIG9mIGEgY3JvbiBqb2IsIGluY2x1ZGluZyB0aGUgc2NoZWR1bGUuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjc3BlYy1hbmQtc3RhdHVzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5iYXRjaC52MS5Dcm9uSm9iI3NwZWNcbiAgICovXG4gIHJlYWRvbmx5IHNwZWM/OiBDcm9uSm9iU3BlYztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlQ3JvbkpvYlByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlQ3JvbkpvYlByb3BzKG9iajogS3ViZUNyb25Kb2JQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX09iamVjdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgICAnc3BlYyc6IHRvSnNvbl9Dcm9uSm9iU3BlYyhvYmouc3BlYyksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQ3JvbkpvYkxpc3QgaXMgYSBjb2xsZWN0aW9uIG9mIGNyb24gam9icy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYmF0Y2gudjEuQ3JvbkpvYkxpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlQ3JvbkpvYkxpc3RQcm9wcyB7XG4gIC8qKlxuICAgKiBpdGVtcyBpcyB0aGUgbGlzdCBvZiBDcm9uSm9icy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmJhdGNoLnYxLkNyb25Kb2JMaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZUNyb25Kb2JQcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBsaXN0IG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5iYXRjaC52MS5Dcm9uSm9iTGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlQ3JvbkpvYkxpc3RQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUNyb25Kb2JMaXN0UHJvcHMob2JqOiBLdWJlQ3JvbkpvYkxpc3RQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZUNyb25Kb2JQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogSm9iIHJlcHJlc2VudHMgdGhlIGNvbmZpZ3VyYXRpb24gb2YgYSBzaW5nbGUgam9iLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5iYXRjaC52MS5Kb2JcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlSm9iUHJvcHMge1xuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0J3MgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmJhdGNoLnYxLkpvYiNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBPYmplY3RNZXRhO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uIG9mIHRoZSBkZXNpcmVkIGJlaGF2aW9yIG9mIGEgam9iLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3NwZWMtYW5kLXN0YXR1c1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYmF0Y2gudjEuSm9iI3NwZWNcbiAgICovXG4gIHJlYWRvbmx5IHNwZWM/OiBKb2JTcGVjO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVKb2JQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUpvYlByb3BzKG9iajogS3ViZUpvYlByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdzcGVjJzogdG9Kc29uX0pvYlNwZWMob2JqLnNwZWMpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEpvYkxpc3QgaXMgYSBjb2xsZWN0aW9uIG9mIGpvYnMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmJhdGNoLnYxLkpvYkxpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlSm9iTGlzdFByb3BzIHtcbiAgLyoqXG4gICAqIGl0ZW1zIGlzIHRoZSBsaXN0IG9mIEpvYnMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5iYXRjaC52MS5Kb2JMaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZUpvYlByb3BzW107XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIGxpc3QgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmJhdGNoLnYxLkpvYkxpc3QjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogTGlzdE1ldGE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZUpvYkxpc3RQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUpvYkxpc3RQcm9wcyhvYmo6IEt1YmVKb2JMaXN0UHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdpdGVtcyc6IG9iai5pdGVtcz8ubWFwKHkgPT4gdG9Kc29uX0t1YmVKb2JQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQ3JvbkpvYiByZXByZXNlbnRzIHRoZSBjb25maWd1cmF0aW9uIG9mIGEgc2luZ2xlIGNyb24gam9iLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5iYXRjaC52MWJldGExLkNyb25Kb2JcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlQ3JvbkpvYlYxQmV0YTFQcm9wcyB7XG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYmF0Y2gudjFiZXRhMS5Dcm9uSm9iI21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb24gb2YgdGhlIGRlc2lyZWQgYmVoYXZpb3Igb2YgYSBjcm9uIGpvYiwgaW5jbHVkaW5nIHRoZSBzY2hlZHVsZS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNzcGVjLWFuZC1zdGF0dXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmJhdGNoLnYxYmV0YTEuQ3JvbkpvYiNzcGVjXG4gICAqL1xuICByZWFkb25seSBzcGVjPzogQ3JvbkpvYlNwZWNWMUJldGExO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVDcm9uSm9iVjFCZXRhMVByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlQ3JvbkpvYlYxQmV0YTFQcm9wcyhvYmo6IEt1YmVDcm9uSm9iVjFCZXRhMVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdzcGVjJzogdG9Kc29uX0Nyb25Kb2JTcGVjVjFCZXRhMShvYmouc3BlYyksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQ3JvbkpvYkxpc3QgaXMgYSBjb2xsZWN0aW9uIG9mIGNyb24gam9icy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYmF0Y2gudjFiZXRhMS5Dcm9uSm9iTGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVDcm9uSm9iTGlzdFYxQmV0YTFQcm9wcyB7XG4gIC8qKlxuICAgKiBpdGVtcyBpcyB0aGUgbGlzdCBvZiBDcm9uSm9icy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmJhdGNoLnYxYmV0YTEuQ3JvbkpvYkxpc3QjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zOiBLdWJlQ3JvbkpvYlYxQmV0YTFQcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBsaXN0IG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5iYXRjaC52MWJldGExLkNyb25Kb2JMaXN0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IExpc3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVDcm9uSm9iTGlzdFYxQmV0YTFQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUNyb25Kb2JMaXN0VjFCZXRhMVByb3BzKG9iajogS3ViZUNyb25Kb2JMaXN0VjFCZXRhMVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaXRlbXMnOiBvYmouaXRlbXM/Lm1hcCh5ID0+IHRvSnNvbl9LdWJlQ3JvbkpvYlYxQmV0YTFQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdCBvYmplY3RzIHByb3ZpZGUgYSBtZWNoYW5pc20gdG8gb2J0YWluIHg1MDkgY2VydGlmaWNhdGVzIGJ5IHN1Ym1pdHRpbmcgYSBjZXJ0aWZpY2F0ZSBzaWduaW5nIHJlcXVlc3QsIGFuZCBoYXZpbmcgaXQgYXN5bmNocm9ub3VzbHkgYXBwcm92ZWQgYW5kIGlzc3VlZC5cbiAqXG4gKiBLdWJlbGV0cyB1c2UgdGhpcyBBUEkgdG8gb2J0YWluOlxuICogMS4gY2xpZW50IGNlcnRpZmljYXRlcyB0byBhdXRoZW50aWNhdGUgdG8ga3ViZS1hcGlzZXJ2ZXIgKHdpdGggdGhlIFwia3ViZXJuZXRlcy5pby9rdWJlLWFwaXNlcnZlci1jbGllbnQta3ViZWxldFwiIHNpZ25lck5hbWUpLlxuICogMi4gc2VydmluZyBjZXJ0aWZpY2F0ZXMgZm9yIFRMUyBlbmRwb2ludHMga3ViZS1hcGlzZXJ2ZXIgY2FuIGNvbm5lY3QgdG8gc2VjdXJlbHkgKHdpdGggdGhlIFwia3ViZXJuZXRlcy5pby9rdWJlbGV0LXNlcnZpbmdcIiBzaWduZXJOYW1lKS5cbiAqXG4gKiBUaGlzIEFQSSBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNsaWVudCBjZXJ0aWZpY2F0ZXMgdG8gYXV0aGVudGljYXRlIHRvIGt1YmUtYXBpc2VydmVyICh3aXRoIHRoZSBcImt1YmVybmV0ZXMuaW8va3ViZS1hcGlzZXJ2ZXItY2xpZW50XCIgc2lnbmVyTmFtZSksIG9yIHRvIG9idGFpbiBjZXJ0aWZpY2F0ZXMgZnJvbSBjdXN0b20gbm9uLUt1YmVybmV0ZXMgc2lnbmVycy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY2VydGlmaWNhdGVzLnYxLkNlcnRpZmljYXRlU2lnbmluZ1JlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdFByb3BzIHtcbiAgLyoqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jZXJ0aWZpY2F0ZXMudjEuQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBPYmplY3RNZXRhO1xuXG4gIC8qKlxuICAgKiBzcGVjIGNvbnRhaW5zIHRoZSBjZXJ0aWZpY2F0ZSByZXF1ZXN0LCBhbmQgaXMgaW1tdXRhYmxlIGFmdGVyIGNyZWF0aW9uLiBPbmx5IHRoZSByZXF1ZXN0LCBzaWduZXJOYW1lLCBleHBpcmF0aW9uU2Vjb25kcywgYW5kIHVzYWdlcyBmaWVsZHMgY2FuIGJlIHNldCBvbiBjcmVhdGlvbi4gT3RoZXIgZmllbGRzIGFyZSBkZXJpdmVkIGJ5IEt1YmVybmV0ZXMgYW5kIGNhbm5vdCBiZSBtb2RpZmllZCBieSB1c2Vycy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNlcnRpZmljYXRlcy52MS5DZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0I3NwZWNcbiAgICovXG4gIHJlYWRvbmx5IHNwZWM6IENlcnRpZmljYXRlU2lnbmluZ1JlcXVlc3RTcGVjO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVDZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0UHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVDZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0UHJvcHMob2JqOiBLdWJlQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdFByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdzcGVjJzogdG9Kc29uX0NlcnRpZmljYXRlU2lnbmluZ1JlcXVlc3RTcGVjKG9iai5zcGVjKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBDZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0TGlzdCBpcyBhIGNvbGxlY3Rpb24gb2YgQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdCBvYmplY3RzXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNlcnRpZmljYXRlcy52MS5DZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0TGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVDZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0TGlzdFByb3BzIHtcbiAgLyoqXG4gICAqIGl0ZW1zIGlzIGEgY29sbGVjdGlvbiBvZiBDZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0IG9iamVjdHNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNlcnRpZmljYXRlcy52MS5DZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0TGlzdCNpdGVtc1xuICAgKi9cbiAgcmVhZG9ubHkgaXRlbXM6IEt1YmVDZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0UHJvcHNbXTtcblxuICAvKipcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNlcnRpZmljYXRlcy52MS5DZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0TGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdExpc3RQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUNlcnRpZmljYXRlU2lnbmluZ1JlcXVlc3RMaXN0UHJvcHMob2JqOiBLdWJlQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdExpc3RQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZUNlcnRpZmljYXRlU2lnbmluZ1JlcXVlc3RQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogTGVhc2UgZGVmaW5lcyBhIGxlYXNlIGNvbmNlcHQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvb3JkaW5hdGlvbi52MS5MZWFzZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVMZWFzZVByb3BzIHtcbiAgLyoqXG4gICAqIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvb3JkaW5hdGlvbi52MS5MZWFzZSNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBPYmplY3RNZXRhO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uIG9mIHRoZSBMZWFzZS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNzcGVjLWFuZC1zdGF0dXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvb3JkaW5hdGlvbi52MS5MZWFzZSNzcGVjXG4gICAqL1xuICByZWFkb25seSBzcGVjPzogTGVhc2VTcGVjO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVMZWFzZVByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlTGVhc2VQcm9wcyhvYmo6IEt1YmVMZWFzZVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdzcGVjJzogdG9Kc29uX0xlYXNlU3BlYyhvYmouc3BlYyksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogTGVhc2VMaXN0IGlzIGEgbGlzdCBvZiBMZWFzZSBvYmplY3RzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb29yZGluYXRpb24udjEuTGVhc2VMaXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZUxlYXNlTGlzdFByb3BzIHtcbiAgLyoqXG4gICAqIEl0ZW1zIGlzIGEgbGlzdCBvZiBzY2hlbWEgb2JqZWN0cy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvb3JkaW5hdGlvbi52MS5MZWFzZUxpc3QjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zOiBLdWJlTGVhc2VQcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBsaXN0IG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb29yZGluYXRpb24udjEuTGVhc2VMaXN0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IExpc3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVMZWFzZUxpc3RQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUxlYXNlTGlzdFByb3BzKG9iajogS3ViZUxlYXNlTGlzdFByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaXRlbXMnOiBvYmouaXRlbXM/Lm1hcCh5ID0+IHRvSnNvbl9LdWJlTGVhc2VQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQmluZGluZyB0aWVzIG9uZSBvYmplY3QgdG8gYW5vdGhlcjsgZm9yIGV4YW1wbGUsIGEgcG9kIGlzIGJvdW5kIHRvIGEgbm9kZSBieSBhIHNjaGVkdWxlci4gRGVwcmVjYXRlZCBpbiAxLjcsIHBsZWFzZSB1c2UgdGhlIGJpbmRpbmdzIHN1YnJlc291cmNlIG9mIHBvZHMgaW5zdGVhZC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5CaW5kaW5nXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZUJpbmRpbmdQcm9wcyB7XG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5CaW5kaW5nI21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIFRoZSB0YXJnZXQgb2JqZWN0IHRoYXQgeW91IHdhbnQgdG8gYmluZCB0byB0aGUgc3RhbmRhcmQgb2JqZWN0LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5CaW5kaW5nI3RhcmdldFxuICAgKi9cbiAgcmVhZG9ubHkgdGFyZ2V0OiBPYmplY3RSZWZlcmVuY2U7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZUJpbmRpbmdQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUJpbmRpbmdQcm9wcyhvYmo6IEt1YmVCaW5kaW5nUHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3RhcmdldCc6IHRvSnNvbl9PYmplY3RSZWZlcmVuY2Uob2JqLnRhcmdldCksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQ29tcG9uZW50U3RhdHVzIChhbmQgQ29tcG9uZW50U3RhdHVzTGlzdCkgaG9sZHMgdGhlIGNsdXN0ZXIgdmFsaWRhdGlvbiBpbmZvLiBEZXByZWNhdGVkOiBUaGlzIEFQSSBpcyBkZXByZWNhdGVkIGluIHYxLjE5K1xuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbXBvbmVudFN0YXR1c1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVDb21wb25lbnRTdGF0dXNQcm9wcyB7XG4gIC8qKlxuICAgKiBMaXN0IG9mIGNvbXBvbmVudCBjb25kaXRpb25zIG9ic2VydmVkXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbXBvbmVudFN0YXR1cyNjb25kaXRpb25zXG4gICAqL1xuICByZWFkb25seSBjb25kaXRpb25zPzogQ29tcG9uZW50Q29uZGl0aW9uW107XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIG9iamVjdCdzIG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbXBvbmVudFN0YXR1cyNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBPYmplY3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVDb21wb25lbnRTdGF0dXNQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUNvbXBvbmVudFN0YXR1c1Byb3BzKG9iajogS3ViZUNvbXBvbmVudFN0YXR1c1Byb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnY29uZGl0aW9ucyc6IG9iai5jb25kaXRpb25zPy5tYXAoeSA9PiB0b0pzb25fQ29tcG9uZW50Q29uZGl0aW9uKHkpKSxcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFN0YXR1cyBvZiBhbGwgdGhlIGNvbmRpdGlvbnMgZm9yIHRoZSBjb21wb25lbnQgYXMgYSBsaXN0IG9mIENvbXBvbmVudFN0YXR1cyBvYmplY3RzLiBEZXByZWNhdGVkOiBUaGlzIEFQSSBpcyBkZXByZWNhdGVkIGluIHYxLjE5K1xuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbXBvbmVudFN0YXR1c0xpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlQ29tcG9uZW50U3RhdHVzTGlzdFByb3BzIHtcbiAgLyoqXG4gICAqIExpc3Qgb2YgQ29tcG9uZW50U3RhdHVzIG9iamVjdHMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbXBvbmVudFN0YXR1c0xpc3QjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zOiBLdWJlQ29tcG9uZW50U3RhdHVzUHJvcHNbXTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgbGlzdCBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCN0eXBlcy1raW5kc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db21wb25lbnRTdGF0dXNMaXN0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IExpc3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVDb21wb25lbnRTdGF0dXNMaXN0UHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVDb21wb25lbnRTdGF0dXNMaXN0UHJvcHMob2JqOiBLdWJlQ29tcG9uZW50U3RhdHVzTGlzdFByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaXRlbXMnOiBvYmouaXRlbXM/Lm1hcCh5ID0+IHRvSnNvbl9LdWJlQ29tcG9uZW50U3RhdHVzUHJvcHMoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9MaXN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIENvbmZpZ01hcCBob2xkcyBjb25maWd1cmF0aW9uIGRhdGEgZm9yIHBvZHMgdG8gY29uc3VtZS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db25maWdNYXBcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlQ29uZmlnTWFwUHJvcHMge1xuICAvKipcbiAgICogQmluYXJ5RGF0YSBjb250YWlucyB0aGUgYmluYXJ5IGRhdGEuIEVhY2gga2V5IG11c3QgY29uc2lzdCBvZiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycywgJy0nLCAnXycgb3IgJy4nLiBCaW5hcnlEYXRhIGNhbiBjb250YWluIGJ5dGUgc2VxdWVuY2VzIHRoYXQgYXJlIG5vdCBpbiB0aGUgVVRGLTggcmFuZ2UuIFRoZSBrZXlzIHN0b3JlZCBpbiBCaW5hcnlEYXRhIG11c3Qgbm90IG92ZXJsYXAgd2l0aCB0aGUgb25lcyBpbiB0aGUgRGF0YSBmaWVsZCwgdGhpcyBpcyBlbmZvcmNlZCBkdXJpbmcgdmFsaWRhdGlvbiBwcm9jZXNzLiBVc2luZyB0aGlzIGZpZWxkIHdpbGwgcmVxdWlyZSAxLjEwKyBhcGlzZXJ2ZXIgYW5kIGt1YmVsZXQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbmZpZ01hcCNiaW5hcnlEYXRhXG4gICAqL1xuICByZWFkb25seSBiaW5hcnlEYXRhPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcblxuICAvKipcbiAgICogRGF0YSBjb250YWlucyB0aGUgY29uZmlndXJhdGlvbiBkYXRhLiBFYWNoIGtleSBtdXN0IGNvbnNpc3Qgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMsICctJywgJ18nIG9yICcuJy4gVmFsdWVzIHdpdGggbm9uLVVURi04IGJ5dGUgc2VxdWVuY2VzIG11c3QgdXNlIHRoZSBCaW5hcnlEYXRhIGZpZWxkLiBUaGUga2V5cyBzdG9yZWQgaW4gRGF0YSBtdXN0IG5vdCBvdmVybGFwIHdpdGggdGhlIGtleXMgaW4gdGhlIEJpbmFyeURhdGEgZmllbGQsIHRoaXMgaXMgZW5mb3JjZWQgZHVyaW5nIHZhbGlkYXRpb24gcHJvY2Vzcy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ29uZmlnTWFwI2RhdGFcbiAgICovXG4gIHJlYWRvbmx5IGRhdGE/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXG4gIC8qKlxuICAgKiBJbW11dGFibGUsIGlmIHNldCB0byB0cnVlLCBlbnN1cmVzIHRoYXQgZGF0YSBzdG9yZWQgaW4gdGhlIENvbmZpZ01hcCBjYW5ub3QgYmUgdXBkYXRlZCAob25seSBvYmplY3QgbWV0YWRhdGEgY2FuIGJlIG1vZGlmaWVkKS4gSWYgbm90IHNldCB0byB0cnVlLCB0aGUgZmllbGQgY2FuIGJlIG1vZGlmaWVkIGF0IGFueSB0aW1lLiBEZWZhdWx0ZWQgdG8gbmlsLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db25maWdNYXAjaW1tdXRhYmxlXG4gICAqL1xuICByZWFkb25seSBpbW11dGFibGU/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db25maWdNYXAjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlQ29uZmlnTWFwUHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVDb25maWdNYXBQcm9wcyhvYmo6IEt1YmVDb25maWdNYXBQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2JpbmFyeURhdGEnOiAoKG9iai5iaW5hcnlEYXRhKSA9PT0gdW5kZWZpbmVkKSA/IHVuZGVmaW5lZCA6IChPYmplY3QuZW50cmllcyhvYmouYmluYXJ5RGF0YSkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KSksXG4gICAgJ2RhdGEnOiAoKG9iai5kYXRhKSA9PT0gdW5kZWZpbmVkKSA/IHVuZGVmaW5lZCA6IChPYmplY3QuZW50cmllcyhvYmouZGF0YSkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KSksXG4gICAgJ2ltbXV0YWJsZSc6IG9iai5pbW11dGFibGUsXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX09iamVjdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBDb25maWdNYXBMaXN0IGlzIGEgcmVzb3VyY2UgY29udGFpbmluZyBhIGxpc3Qgb2YgQ29uZmlnTWFwIG9iamVjdHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ29uZmlnTWFwTGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVDb25maWdNYXBMaXN0UHJvcHMge1xuICAvKipcbiAgICogSXRlbXMgaXMgdGhlIGxpc3Qgb2YgQ29uZmlnTWFwcy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ29uZmlnTWFwTGlzdCNpdGVtc1xuICAgKi9cbiAgcmVhZG9ubHkgaXRlbXM6IEt1YmVDb25maWdNYXBQcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbmZpZ01hcExpc3QjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogTGlzdE1ldGE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZUNvbmZpZ01hcExpc3RQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUNvbmZpZ01hcExpc3RQcm9wcyhvYmo6IEt1YmVDb25maWdNYXBMaXN0UHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdpdGVtcyc6IG9iai5pdGVtcz8ubWFwKHkgPT4gdG9Kc29uX0t1YmVDb25maWdNYXBQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogRW5kcG9pbnRzIGlzIGEgY29sbGVjdGlvbiBvZiBlbmRwb2ludHMgdGhhdCBpbXBsZW1lbnQgdGhlIGFjdHVhbCBzZXJ2aWNlLiBFeGFtcGxlOlxuICogTmFtZTogXCJteXN2Y1wiLFxuICogU3Vic2V0czogW1xuICoge1xuICogQWRkcmVzc2VzOiBbe1wiaXBcIjogXCIxMC4xMC4xLjFcIn0sIHtcImlwXCI6IFwiMTAuMTAuMi4yXCJ9XSxcbiAqIFBvcnRzOiBbe1wibmFtZVwiOiBcImFcIiwgXCJwb3J0XCI6IDg2NzV9LCB7XCJuYW1lXCI6IFwiYlwiLCBcInBvcnRcIjogMzA5fV1cbiAqIH0sXG4gKiB7XG4gKiBBZGRyZXNzZXM6IFt7XCJpcFwiOiBcIjEwLjEwLjMuM1wifV0sXG4gKiBQb3J0czogW3tcIm5hbWVcIjogXCJhXCIsIFwicG9ydFwiOiA5M30sIHtcIm5hbWVcIjogXCJiXCIsIFwicG9ydFwiOiA3Nn1dXG4gKiB9LFxuICogXVxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkVuZHBvaW50c1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVFbmRwb2ludHNQcm9wcyB7XG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FbmRwb2ludHMjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogVGhlIHNldCBvZiBhbGwgZW5kcG9pbnRzIGlzIHRoZSB1bmlvbiBvZiBhbGwgc3Vic2V0cy4gQWRkcmVzc2VzIGFyZSBwbGFjZWQgaW50byBzdWJzZXRzIGFjY29yZGluZyB0byB0aGUgSVBzIHRoZXkgc2hhcmUuIEEgc2luZ2xlIGFkZHJlc3Mgd2l0aCBtdWx0aXBsZSBwb3J0cywgc29tZSBvZiB3aGljaCBhcmUgcmVhZHkgYW5kIHNvbWUgb2Ygd2hpY2ggYXJlIG5vdCAoYmVjYXVzZSB0aGV5IGNvbWUgZnJvbSBkaWZmZXJlbnQgY29udGFpbmVycykgd2lsbCByZXN1bHQgaW4gdGhlIGFkZHJlc3MgYmVpbmcgZGlzcGxheWVkIGluIGRpZmZlcmVudCBzdWJzZXRzIGZvciB0aGUgZGlmZmVyZW50IHBvcnRzLiBObyBhZGRyZXNzIHdpbGwgYXBwZWFyIGluIGJvdGggQWRkcmVzc2VzIGFuZCBOb3RSZWFkeUFkZHJlc3NlcyBpbiB0aGUgc2FtZSBzdWJzZXQuIFNldHMgb2YgYWRkcmVzc2VzIGFuZCBwb3J0cyB0aGF0IGNvbXByaXNlIGEgc2VydmljZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRW5kcG9pbnRzI3N1YnNldHNcbiAgICovXG4gIHJlYWRvbmx5IHN1YnNldHM/OiBFbmRwb2ludFN1YnNldFtdO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVFbmRwb2ludHNQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUVuZHBvaW50c1Byb3BzKG9iajogS3ViZUVuZHBvaW50c1Byb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdzdWJzZXRzJzogb2JqLnN1YnNldHM/Lm1hcCh5ID0+IHRvSnNvbl9FbmRwb2ludFN1YnNldCh5KSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogRW5kcG9pbnRzTGlzdCBpcyBhIGxpc3Qgb2YgZW5kcG9pbnRzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkVuZHBvaW50c0xpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlRW5kcG9pbnRzTGlzdFByb3BzIHtcbiAgLyoqXG4gICAqIExpc3Qgb2YgZW5kcG9pbnRzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FbmRwb2ludHNMaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZUVuZHBvaW50c1Byb3BzW107XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIGxpc3QgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjdHlwZXMta2luZHNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRW5kcG9pbnRzTGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlRW5kcG9pbnRzTGlzdFByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlRW5kcG9pbnRzTGlzdFByb3BzKG9iajogS3ViZUVuZHBvaW50c0xpc3RQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZUVuZHBvaW50c1Byb3BzKHkpKSxcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fTGlzdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBFdmVudCBpcyBhIHJlcG9ydCBvZiBhbiBldmVudCBzb21ld2hlcmUgaW4gdGhlIGNsdXN0ZXIuIEl0IGdlbmVyYWxseSBkZW5vdGVzIHNvbWUgc3RhdGUgY2hhbmdlIGluIHRoZSBzeXN0ZW0uIEV2ZW50cyBoYXZlIGEgbGltaXRlZCByZXRlbnRpb24gdGltZSBhbmQgdHJpZ2dlcnMgYW5kIG1lc3NhZ2VzIG1heSBldm9sdmUgd2l0aCB0aW1lLiAgRXZlbnQgY29uc3VtZXJzIHNob3VsZCBub3QgcmVseSBvbiB0aGUgdGltaW5nIG9mIGFuIGV2ZW50IHdpdGggYSBnaXZlbiBSZWFzb24gcmVmbGVjdGluZyBhIGNvbnNpc3RlbnQgdW5kZXJseWluZyB0cmlnZ2VyLCBvciB0aGUgY29udGludWVkIGV4aXN0ZW5jZSBvZiBldmVudHMgd2l0aCB0aGF0IFJlYXNvbi4gIEV2ZW50cyBzaG91bGQgYmUgdHJlYXRlZCBhcyBpbmZvcm1hdGl2ZSwgYmVzdC1lZmZvcnQsIHN1cHBsZW1lbnRhbCBkYXRhLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5ldmVudHMudjEuRXZlbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlRXZlbnRQcm9wcyB7XG4gIC8qKlxuICAgKiBhY3Rpb24gaXMgd2hhdCBhY3Rpb24gd2FzIHRha2VuL2ZhaWxlZCByZWdhcmRpbmcgdG8gdGhlIHJlZ2FyZGluZyBvYmplY3QuIEl0IGlzIG1hY2hpbmUtcmVhZGFibGUuIFRoaXMgZmllbGQgY2Fubm90IGJlIGVtcHR5IGZvciBuZXcgRXZlbnRzIGFuZCBpdCBjYW4gaGF2ZSBhdCBtb3N0IDEyOCBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZXZlbnRzLnYxLkV2ZW50I2FjdGlvblxuICAgKi9cbiAgcmVhZG9ubHkgYWN0aW9uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBkZXByZWNhdGVkQ291bnQgaXMgdGhlIGRlcHJlY2F0ZWQgZmllbGQgYXNzdXJpbmcgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIGNvcmUudjEgRXZlbnQgdHlwZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmV2ZW50cy52MS5FdmVudCNkZXByZWNhdGVkQ291bnRcbiAgICovXG4gIHJlYWRvbmx5IGRlcHJlY2F0ZWRDb3VudD86IG51bWJlcjtcblxuICAvKipcbiAgICogZGVwcmVjYXRlZEZpcnN0VGltZXN0YW1wIGlzIHRoZSBkZXByZWNhdGVkIGZpZWxkIGFzc3VyaW5nIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBjb3JlLnYxIEV2ZW50IHR5cGUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5ldmVudHMudjEuRXZlbnQjZGVwcmVjYXRlZEZpcnN0VGltZXN0YW1wXG4gICAqL1xuICByZWFkb25seSBkZXByZWNhdGVkRmlyc3RUaW1lc3RhbXA/OiBEYXRlO1xuXG4gIC8qKlxuICAgKiBkZXByZWNhdGVkTGFzdFRpbWVzdGFtcCBpcyB0aGUgZGVwcmVjYXRlZCBmaWVsZCBhc3N1cmluZyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggY29yZS52MSBFdmVudCB0eXBlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZXZlbnRzLnYxLkV2ZW50I2RlcHJlY2F0ZWRMYXN0VGltZXN0YW1wXG4gICAqL1xuICByZWFkb25seSBkZXByZWNhdGVkTGFzdFRpbWVzdGFtcD86IERhdGU7XG5cbiAgLyoqXG4gICAqIGRlcHJlY2F0ZWRTb3VyY2UgaXMgdGhlIGRlcHJlY2F0ZWQgZmllbGQgYXNzdXJpbmcgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIGNvcmUudjEgRXZlbnQgdHlwZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmV2ZW50cy52MS5FdmVudCNkZXByZWNhdGVkU291cmNlXG4gICAqL1xuICByZWFkb25seSBkZXByZWNhdGVkU291cmNlPzogRXZlbnRTb3VyY2U7XG5cbiAgLyoqXG4gICAqIGV2ZW50VGltZSBpcyB0aGUgdGltZSB3aGVuIHRoaXMgRXZlbnQgd2FzIGZpcnN0IG9ic2VydmVkLiBJdCBpcyByZXF1aXJlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmV2ZW50cy52MS5FdmVudCNldmVudFRpbWVcbiAgICovXG4gIHJlYWRvbmx5IGV2ZW50VGltZTogRGF0ZTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0J3MgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmV2ZW50cy52MS5FdmVudCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBPYmplY3RNZXRhO1xuXG4gIC8qKlxuICAgKiBub3RlIGlzIGEgaHVtYW4tcmVhZGFibGUgZGVzY3JpcHRpb24gb2YgdGhlIHN0YXR1cyBvZiB0aGlzIG9wZXJhdGlvbi4gTWF4aW1hbCBsZW5ndGggb2YgdGhlIG5vdGUgaXMgMWtCLCBidXQgbGlicmFyaWVzIHNob3VsZCBiZSBwcmVwYXJlZCB0byBoYW5kbGUgdmFsdWVzIHVwIHRvIDY0a0IuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5ldmVudHMudjEuRXZlbnQjbm90ZVxuICAgKi9cbiAgcmVhZG9ubHkgbm90ZT86IHN0cmluZztcblxuICAvKipcbiAgICogcmVhc29uIGlzIHdoeSB0aGUgYWN0aW9uIHdhcyB0YWtlbi4gSXQgaXMgaHVtYW4tcmVhZGFibGUuIFRoaXMgZmllbGQgY2Fubm90IGJlIGVtcHR5IGZvciBuZXcgRXZlbnRzIGFuZCBpdCBjYW4gaGF2ZSBhdCBtb3N0IDEyOCBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZXZlbnRzLnYxLkV2ZW50I3JlYXNvblxuICAgKi9cbiAgcmVhZG9ubHkgcmVhc29uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiByZWdhcmRpbmcgY29udGFpbnMgdGhlIG9iamVjdCB0aGlzIEV2ZW50IGlzIGFib3V0LiBJbiBtb3N0IGNhc2VzIGl0J3MgYW4gT2JqZWN0IHJlcG9ydGluZyBjb250cm9sbGVyIGltcGxlbWVudHMsIGUuZy4gUmVwbGljYVNldENvbnRyb2xsZXIgaW1wbGVtZW50cyBSZXBsaWNhU2V0cyBhbmQgdGhpcyBldmVudCBpcyBlbWl0dGVkIGJlY2F1c2UgaXQgYWN0cyBvbiBzb21lIGNoYW5nZXMgaW4gYSBSZXBsaWNhU2V0IG9iamVjdC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmV2ZW50cy52MS5FdmVudCNyZWdhcmRpbmdcbiAgICovXG4gIHJlYWRvbmx5IHJlZ2FyZGluZz86IE9iamVjdFJlZmVyZW5jZTtcblxuICAvKipcbiAgICogcmVsYXRlZCBpcyB0aGUgb3B0aW9uYWwgc2Vjb25kYXJ5IG9iamVjdCBmb3IgbW9yZSBjb21wbGV4IGFjdGlvbnMuIEUuZy4gd2hlbiByZWdhcmRpbmcgb2JqZWN0IHRyaWdnZXJzIGEgY3JlYXRpb24gb3IgZGVsZXRpb24gb2YgcmVsYXRlZCBvYmplY3QuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5ldmVudHMudjEuRXZlbnQjcmVsYXRlZFxuICAgKi9cbiAgcmVhZG9ubHkgcmVsYXRlZD86IE9iamVjdFJlZmVyZW5jZTtcblxuICAvKipcbiAgICogcmVwb3J0aW5nQ29udHJvbGxlciBpcyB0aGUgbmFtZSBvZiB0aGUgY29udHJvbGxlciB0aGF0IGVtaXR0ZWQgdGhpcyBFdmVudCwgZS5nLiBga3ViZXJuZXRlcy5pby9rdWJlbGV0YC4gVGhpcyBmaWVsZCBjYW5ub3QgYmUgZW1wdHkgZm9yIG5ldyBFdmVudHMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5ldmVudHMudjEuRXZlbnQjcmVwb3J0aW5nQ29udHJvbGxlclxuICAgKi9cbiAgcmVhZG9ubHkgcmVwb3J0aW5nQ29udHJvbGxlcj86IHN0cmluZztcblxuICAvKipcbiAgICogcmVwb3J0aW5nSW5zdGFuY2UgaXMgdGhlIElEIG9mIHRoZSBjb250cm9sbGVyIGluc3RhbmNlLCBlLmcuIGBrdWJlbGV0LXh5emZgLiBUaGlzIGZpZWxkIGNhbm5vdCBiZSBlbXB0eSBmb3IgbmV3IEV2ZW50cyBhbmQgaXQgY2FuIGhhdmUgYXQgbW9zdCAxMjggY2hhcmFjdGVycy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmV2ZW50cy52MS5FdmVudCNyZXBvcnRpbmdJbnN0YW5jZVxuICAgKi9cbiAgcmVhZG9ubHkgcmVwb3J0aW5nSW5zdGFuY2U/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIHNlcmllcyBpcyBkYXRhIGFib3V0IHRoZSBFdmVudCBzZXJpZXMgdGhpcyBldmVudCByZXByZXNlbnRzIG9yIG5pbCBpZiBpdCdzIGEgc2luZ2xldG9uIEV2ZW50LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZXZlbnRzLnYxLkV2ZW50I3Nlcmllc1xuICAgKi9cbiAgcmVhZG9ubHkgc2VyaWVzPzogRXZlbnRTZXJpZXM7XG5cbiAgLyoqXG4gICAqIHR5cGUgaXMgdGhlIHR5cGUgb2YgdGhpcyBldmVudCAoTm9ybWFsLCBXYXJuaW5nKSwgbmV3IHR5cGVzIGNvdWxkIGJlIGFkZGVkIGluIHRoZSBmdXR1cmUuIEl0IGlzIG1hY2hpbmUtcmVhZGFibGUuIFRoaXMgZmllbGQgY2Fubm90IGJlIGVtcHR5IGZvciBuZXcgRXZlbnRzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZXZlbnRzLnYxLkV2ZW50I3R5cGVcbiAgICovXG4gIHJlYWRvbmx5IHR5cGU/OiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZUV2ZW50UHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVFdmVudFByb3BzKG9iajogS3ViZUV2ZW50UHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdhY3Rpb24nOiBvYmouYWN0aW9uLFxuICAgICdkZXByZWNhdGVkQ291bnQnOiBvYmouZGVwcmVjYXRlZENvdW50LFxuICAgICdkZXByZWNhdGVkRmlyc3RUaW1lc3RhbXAnOiBvYmouZGVwcmVjYXRlZEZpcnN0VGltZXN0YW1wPy50b0lTT1N0cmluZygpLFxuICAgICdkZXByZWNhdGVkTGFzdFRpbWVzdGFtcCc6IG9iai5kZXByZWNhdGVkTGFzdFRpbWVzdGFtcD8udG9JU09TdHJpbmcoKSxcbiAgICAnZGVwcmVjYXRlZFNvdXJjZSc6IHRvSnNvbl9FdmVudFNvdXJjZShvYmouZGVwcmVjYXRlZFNvdXJjZSksXG4gICAgJ2V2ZW50VGltZSc6IG9iai5ldmVudFRpbWU/LnRvSVNPU3RyaW5nKCksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX09iamVjdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgICAnbm90ZSc6IG9iai5ub3RlLFxuICAgICdyZWFzb24nOiBvYmoucmVhc29uLFxuICAgICdyZWdhcmRpbmcnOiB0b0pzb25fT2JqZWN0UmVmZXJlbmNlKG9iai5yZWdhcmRpbmcpLFxuICAgICdyZWxhdGVkJzogdG9Kc29uX09iamVjdFJlZmVyZW5jZShvYmoucmVsYXRlZCksXG4gICAgJ3JlcG9ydGluZ0NvbnRyb2xsZXInOiBvYmoucmVwb3J0aW5nQ29udHJvbGxlcixcbiAgICAncmVwb3J0aW5nSW5zdGFuY2UnOiBvYmoucmVwb3J0aW5nSW5zdGFuY2UsXG4gICAgJ3Nlcmllcyc6IHRvSnNvbl9FdmVudFNlcmllcyhvYmouc2VyaWVzKSxcbiAgICAndHlwZSc6IG9iai50eXBlLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEV2ZW50TGlzdCBpcyBhIGxpc3Qgb2YgRXZlbnQgb2JqZWN0cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuZXZlbnRzLnYxLkV2ZW50TGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVFdmVudExpc3RQcm9wcyB7XG4gIC8qKlxuICAgKiBpdGVtcyBpcyBhIGxpc3Qgb2Ygc2NoZW1hIG9iamVjdHMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5ldmVudHMudjEuRXZlbnRMaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZUV2ZW50UHJvcHNbXTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgbGlzdCBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZXZlbnRzLnYxLkV2ZW50TGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlRXZlbnRMaXN0UHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVFdmVudExpc3RQcm9wcyhvYmo6IEt1YmVFdmVudExpc3RQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZUV2ZW50UHJvcHMoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9MaXN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIExpbWl0UmFuZ2Ugc2V0cyByZXNvdXJjZSB1c2FnZSBsaW1pdHMgZm9yIGVhY2gga2luZCBvZiByZXNvdXJjZSBpbiBhIE5hbWVzcGFjZS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5MaW1pdFJhbmdlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZUxpbWl0UmFuZ2VQcm9wcyB7XG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5MaW1pdFJhbmdlI21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIFNwZWMgZGVmaW5lcyB0aGUgbGltaXRzIGVuZm9yY2VkLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3NwZWMtYW5kLXN0YXR1c1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5MaW1pdFJhbmdlI3NwZWNcbiAgICovXG4gIHJlYWRvbmx5IHNwZWM/OiBMaW1pdFJhbmdlU3BlYztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlTGltaXRSYW5nZVByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlTGltaXRSYW5nZVByb3BzKG9iajogS3ViZUxpbWl0UmFuZ2VQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX09iamVjdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgICAnc3BlYyc6IHRvSnNvbl9MaW1pdFJhbmdlU3BlYyhvYmouc3BlYyksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogTGltaXRSYW5nZUxpc3QgaXMgYSBsaXN0IG9mIExpbWl0UmFuZ2UgaXRlbXMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTGltaXRSYW5nZUxpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlTGltaXRSYW5nZUxpc3RQcm9wcyB7XG4gIC8qKlxuICAgKiBJdGVtcyBpcyBhIGxpc3Qgb2YgTGltaXRSYW5nZSBvYmplY3RzLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL2NvbmZpZ3VyYXRpb24vbWFuYWdlLXJlc291cmNlcy1jb250YWluZXJzL1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5MaW1pdFJhbmdlTGlzdCNpdGVtc1xuICAgKi9cbiAgcmVhZG9ubHkgaXRlbXM6IEt1YmVMaW1pdFJhbmdlUHJvcHNbXTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgbGlzdCBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCN0eXBlcy1raW5kc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5MaW1pdFJhbmdlTGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlTGltaXRSYW5nZUxpc3RQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUxpbWl0UmFuZ2VMaXN0UHJvcHMob2JqOiBLdWJlTGltaXRSYW5nZUxpc3RQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZUxpbWl0UmFuZ2VQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogTmFtZXNwYWNlIHByb3ZpZGVzIGEgc2NvcGUgZm9yIE5hbWVzLiBVc2Ugb2YgbXVsdGlwbGUgbmFtZXNwYWNlcyBpcyBvcHRpb25hbC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5OYW1lc3BhY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlTmFtZXNwYWNlUHJvcHMge1xuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0J3MgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTmFtZXNwYWNlI21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIFNwZWMgZGVmaW5lcyB0aGUgYmVoYXZpb3Igb2YgdGhlIE5hbWVzcGFjZS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNzcGVjLWFuZC1zdGF0dXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTmFtZXNwYWNlI3NwZWNcbiAgICovXG4gIHJlYWRvbmx5IHNwZWM/OiBOYW1lc3BhY2VTcGVjO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVOYW1lc3BhY2VQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZU5hbWVzcGFjZVByb3BzKG9iajogS3ViZU5hbWVzcGFjZVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdzcGVjJzogdG9Kc29uX05hbWVzcGFjZVNwZWMob2JqLnNwZWMpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIE5hbWVzcGFjZUxpc3QgaXMgYSBsaXN0IG9mIE5hbWVzcGFjZXMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTmFtZXNwYWNlTGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVOYW1lc3BhY2VMaXN0UHJvcHMge1xuICAvKipcbiAgICogSXRlbXMgaXMgdGhlIGxpc3Qgb2YgTmFtZXNwYWNlIG9iamVjdHMgaW4gdGhlIGxpc3QuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvb3ZlcnZpZXcvd29ya2luZy13aXRoLW9iamVjdHMvbmFtZXNwYWNlcy9cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTmFtZXNwYWNlTGlzdCNpdGVtc1xuICAgKi9cbiAgcmVhZG9ubHkgaXRlbXM6IEt1YmVOYW1lc3BhY2VQcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBsaXN0IG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3R5cGVzLWtpbmRzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLk5hbWVzcGFjZUxpc3QjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogTGlzdE1ldGE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZU5hbWVzcGFjZUxpc3RQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZU5hbWVzcGFjZUxpc3RQcm9wcyhvYmo6IEt1YmVOYW1lc3BhY2VMaXN0UHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdpdGVtcyc6IG9iai5pdGVtcz8ubWFwKHkgPT4gdG9Kc29uX0t1YmVOYW1lc3BhY2VQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogTm9kZSBpcyBhIHdvcmtlciBub2RlIGluIEt1YmVybmV0ZXMuIEVhY2ggbm9kZSB3aWxsIGhhdmUgYSB1bmlxdWUgaWRlbnRpZmllciBpbiB0aGUgY2FjaGUgKGkuZS4gaW4gZXRjZCkuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTm9kZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVOb2RlUHJvcHMge1xuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0J3MgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTm9kZSNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBPYmplY3RNZXRhO1xuXG4gIC8qKlxuICAgKiBTcGVjIGRlZmluZXMgdGhlIGJlaGF2aW9yIG9mIGEgbm9kZS4gaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjc3BlYy1hbmQtc3RhdHVzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLk5vZGUjc3BlY1xuICAgKi9cbiAgcmVhZG9ubHkgc3BlYz86IE5vZGVTcGVjO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVOb2RlUHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVOb2RlUHJvcHMob2JqOiBLdWJlTm9kZVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdzcGVjJzogdG9Kc29uX05vZGVTcGVjKG9iai5zcGVjKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBOb2RlTGlzdCBpcyB0aGUgd2hvbGUgbGlzdCBvZiBhbGwgTm9kZXMgd2hpY2ggaGF2ZSBiZWVuIHJlZ2lzdGVyZWQgd2l0aCBtYXN0ZXIuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTm9kZUxpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlTm9kZUxpc3RQcm9wcyB7XG4gIC8qKlxuICAgKiBMaXN0IG9mIG5vZGVzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLk5vZGVMaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZU5vZGVQcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBsaXN0IG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3R5cGVzLWtpbmRzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLk5vZGVMaXN0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IExpc3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVOb2RlTGlzdFByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlTm9kZUxpc3RQcm9wcyhvYmo6IEt1YmVOb2RlTGlzdFByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaXRlbXMnOiBvYmouaXRlbXM/Lm1hcCh5ID0+IHRvSnNvbl9LdWJlTm9kZVByb3BzKHkpKSxcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fTGlzdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBQZXJzaXN0ZW50Vm9sdW1lIChQVikgaXMgYSBzdG9yYWdlIHJlc291cmNlIHByb3Zpc2lvbmVkIGJ5IGFuIGFkbWluaXN0cmF0b3IuIEl0IGlzIGFuYWxvZ291cyB0byBhIG5vZGUuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvc3RvcmFnZS9wZXJzaXN0ZW50LXZvbHVtZXNcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZVBlcnNpc3RlbnRWb2x1bWVQcm9wcyB7XG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lI21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIFNwZWMgZGVmaW5lcyBhIHNwZWNpZmljYXRpb24gb2YgYSBwZXJzaXN0ZW50IHZvbHVtZSBvd25lZCBieSB0aGUgY2x1c3Rlci4gUHJvdmlzaW9uZWQgYnkgYW4gYWRtaW5pc3RyYXRvci4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3BlcnNpc3RlbnQtdm9sdW1lcyNwZXJzaXN0ZW50LXZvbHVtZXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZSNzcGVjXG4gICAqL1xuICByZWFkb25seSBzcGVjPzogUGVyc2lzdGVudFZvbHVtZVNwZWM7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZVBlcnNpc3RlbnRWb2x1bWVQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVBlcnNpc3RlbnRWb2x1bWVQcm9wcyhvYmo6IEt1YmVQZXJzaXN0ZW50Vm9sdW1lUHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3NwZWMnOiB0b0pzb25fUGVyc2lzdGVudFZvbHVtZVNwZWMob2JqLnNwZWMpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFBlcnNpc3RlbnRWb2x1bWVDbGFpbSBpcyBhIHVzZXIncyByZXF1ZXN0IGZvciBhbmQgY2xhaW0gdG8gYSBwZXJzaXN0ZW50IHZvbHVtZVxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVDbGFpbVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVQZXJzaXN0ZW50Vm9sdW1lQ2xhaW1Qcm9wcyB7XG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lQ2xhaW0jbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogU3BlYyBkZWZpbmVzIHRoZSBkZXNpcmVkIGNoYXJhY3RlcmlzdGljcyBvZiBhIHZvbHVtZSByZXF1ZXN0ZWQgYnkgYSBwb2QgYXV0aG9yLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2UvcGVyc2lzdGVudC12b2x1bWVzI3BlcnNpc3RlbnR2b2x1bWVjbGFpbXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZUNsYWltI3NwZWNcbiAgICovXG4gIHJlYWRvbmx5IHNwZWM/OiBQZXJzaXN0ZW50Vm9sdW1lQ2xhaW1TcGVjO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVQZXJzaXN0ZW50Vm9sdW1lQ2xhaW1Qcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVBlcnNpc3RlbnRWb2x1bWVDbGFpbVByb3BzKG9iajogS3ViZVBlcnNpc3RlbnRWb2x1bWVDbGFpbVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdzcGVjJzogdG9Kc29uX1BlcnNpc3RlbnRWb2x1bWVDbGFpbVNwZWMob2JqLnNwZWMpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFBlcnNpc3RlbnRWb2x1bWVDbGFpbUxpc3QgaXMgYSBsaXN0IG9mIFBlcnNpc3RlbnRWb2x1bWVDbGFpbSBpdGVtcy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lQ2xhaW1MaXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZVBlcnNpc3RlbnRWb2x1bWVDbGFpbUxpc3RQcm9wcyB7XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgcGVyc2lzdGVudCB2b2x1bWUgY2xhaW1zLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2UvcGVyc2lzdGVudC12b2x1bWVzI3BlcnNpc3RlbnR2b2x1bWVjbGFpbXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZUNsYWltTGlzdCNpdGVtc1xuICAgKi9cbiAgcmVhZG9ubHkgaXRlbXM6IEt1YmVQZXJzaXN0ZW50Vm9sdW1lQ2xhaW1Qcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBsaXN0IG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3R5cGVzLWtpbmRzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVDbGFpbUxpc3QjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogTGlzdE1ldGE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZVBlcnNpc3RlbnRWb2x1bWVDbGFpbUxpc3RQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVBlcnNpc3RlbnRWb2x1bWVDbGFpbUxpc3RQcm9wcyhvYmo6IEt1YmVQZXJzaXN0ZW50Vm9sdW1lQ2xhaW1MaXN0UHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdpdGVtcyc6IG9iai5pdGVtcz8ubWFwKHkgPT4gdG9Kc29uX0t1YmVQZXJzaXN0ZW50Vm9sdW1lQ2xhaW1Qcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUGVyc2lzdGVudFZvbHVtZUxpc3QgaXMgYSBsaXN0IG9mIFBlcnNpc3RlbnRWb2x1bWUgaXRlbXMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZUxpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlUGVyc2lzdGVudFZvbHVtZUxpc3RQcm9wcyB7XG4gIC8qKlxuICAgKiBMaXN0IG9mIHBlcnNpc3RlbnQgdm9sdW1lcy4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3BlcnNpc3RlbnQtdm9sdW1lc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lTGlzdCNpdGVtc1xuICAgKi9cbiAgcmVhZG9ubHkgaXRlbXM6IEt1YmVQZXJzaXN0ZW50Vm9sdW1lUHJvcHNbXTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgbGlzdCBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCN0eXBlcy1raW5kc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lTGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlUGVyc2lzdGVudFZvbHVtZUxpc3RQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVBlcnNpc3RlbnRWb2x1bWVMaXN0UHJvcHMob2JqOiBLdWJlUGVyc2lzdGVudFZvbHVtZUxpc3RQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZVBlcnNpc3RlbnRWb2x1bWVQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUG9kIGlzIGEgY29sbGVjdGlvbiBvZiBjb250YWluZXJzIHRoYXQgY2FuIHJ1biBvbiBhIGhvc3QuIFRoaXMgcmVzb3VyY2UgaXMgY3JlYXRlZCBieSBjbGllbnRzIGFuZCBzY2hlZHVsZWQgb250byBob3N0cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlUG9kUHJvcHMge1xuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0J3MgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kI21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb24gb2YgdGhlIGRlc2lyZWQgYmVoYXZpb3Igb2YgdGhlIHBvZC4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNzcGVjLWFuZC1zdGF0dXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kI3NwZWNcbiAgICovXG4gIHJlYWRvbmx5IHNwZWM/OiBQb2RTcGVjO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVQb2RQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVBvZFByb3BzKG9iajogS3ViZVBvZFByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdzcGVjJzogdG9Kc29uX1BvZFNwZWMob2JqLnNwZWMpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFBvZExpc3QgaXMgYSBsaXN0IG9mIFBvZHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kTGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVQb2RMaXN0UHJvcHMge1xuICAvKipcbiAgICogTGlzdCBvZiBwb2RzLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZExpc3QjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zOiBLdWJlUG9kUHJvcHNbXTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgbGlzdCBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCN0eXBlcy1raW5kc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RMaXN0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IExpc3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVQb2RMaXN0UHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVQb2RMaXN0UHJvcHMob2JqOiBLdWJlUG9kTGlzdFByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaXRlbXMnOiBvYmouaXRlbXM/Lm1hcCh5ID0+IHRvSnNvbl9LdWJlUG9kUHJvcHMoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9MaXN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFBvZFRlbXBsYXRlIGRlc2NyaWJlcyBhIHRlbXBsYXRlIGZvciBjcmVhdGluZyBjb3BpZXMgb2YgYSBwcmVkZWZpbmVkIHBvZC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RUZW1wbGF0ZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVQb2RUZW1wbGF0ZVByb3BzIHtcbiAgLyoqXG4gICAqIFN0YW5kYXJkIG9iamVjdCdzIG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZFRlbXBsYXRlI21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIFRlbXBsYXRlIGRlZmluZXMgdGhlIHBvZHMgdGhhdCB3aWxsIGJlIGNyZWF0ZWQgZnJvbSB0aGlzIHBvZCB0ZW1wbGF0ZS4gaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjc3BlYy1hbmQtc3RhdHVzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZFRlbXBsYXRlI3RlbXBsYXRlXG4gICAqL1xuICByZWFkb25seSB0ZW1wbGF0ZT86IFBvZFRlbXBsYXRlU3BlYztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlUG9kVGVtcGxhdGVQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVBvZFRlbXBsYXRlUHJvcHMob2JqOiBLdWJlUG9kVGVtcGxhdGVQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX09iamVjdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgICAndGVtcGxhdGUnOiB0b0pzb25fUG9kVGVtcGxhdGVTcGVjKG9iai50ZW1wbGF0ZSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUG9kVGVtcGxhdGVMaXN0IGlzIGEgbGlzdCBvZiBQb2RUZW1wbGF0ZXMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kVGVtcGxhdGVMaXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZVBvZFRlbXBsYXRlTGlzdFByb3BzIHtcbiAgLyoqXG4gICAqIExpc3Qgb2YgcG9kIHRlbXBsYXRlc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RUZW1wbGF0ZUxpc3QjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zOiBLdWJlUG9kVGVtcGxhdGVQcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBsaXN0IG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3R5cGVzLWtpbmRzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZFRlbXBsYXRlTGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlUG9kVGVtcGxhdGVMaXN0UHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVQb2RUZW1wbGF0ZUxpc3RQcm9wcyhvYmo6IEt1YmVQb2RUZW1wbGF0ZUxpc3RQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZVBvZFRlbXBsYXRlUHJvcHMoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9MaXN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFJlcGxpY2F0aW9uQ29udHJvbGxlciByZXByZXNlbnRzIHRoZSBjb25maWd1cmF0aW9uIG9mIGEgcmVwbGljYXRpb24gY29udHJvbGxlci5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5SZXBsaWNhdGlvbkNvbnRyb2xsZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlUmVwbGljYXRpb25Db250cm9sbGVyUHJvcHMge1xuICAvKipcbiAgICogSWYgdGhlIExhYmVscyBvZiBhIFJlcGxpY2F0aW9uQ29udHJvbGxlciBhcmUgZW1wdHksIHRoZXkgYXJlIGRlZmF1bHRlZCB0byBiZSB0aGUgc2FtZSBhcyB0aGUgUG9kKHMpIHRoYXQgdGhlIHJlcGxpY2F0aW9uIGNvbnRyb2xsZXIgbWFuYWdlcy4gU3RhbmRhcmQgb2JqZWN0J3MgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUmVwbGljYXRpb25Db250cm9sbGVyI21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIFNwZWMgZGVmaW5lcyB0aGUgc3BlY2lmaWNhdGlvbiBvZiB0aGUgZGVzaXJlZCBiZWhhdmlvciBvZiB0aGUgcmVwbGljYXRpb24gY29udHJvbGxlci4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNzcGVjLWFuZC1zdGF0dXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUmVwbGljYXRpb25Db250cm9sbGVyI3NwZWNcbiAgICovXG4gIHJlYWRvbmx5IHNwZWM/OiBSZXBsaWNhdGlvbkNvbnRyb2xsZXJTcGVjO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVSZXBsaWNhdGlvbkNvbnRyb2xsZXJQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVJlcGxpY2F0aW9uQ29udHJvbGxlclByb3BzKG9iajogS3ViZVJlcGxpY2F0aW9uQ29udHJvbGxlclByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdzcGVjJzogdG9Kc29uX1JlcGxpY2F0aW9uQ29udHJvbGxlclNwZWMob2JqLnNwZWMpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFJlcGxpY2F0aW9uQ29udHJvbGxlckxpc3QgaXMgYSBjb2xsZWN0aW9uIG9mIHJlcGxpY2F0aW9uIGNvbnRyb2xsZXJzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlJlcGxpY2F0aW9uQ29udHJvbGxlckxpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlUmVwbGljYXRpb25Db250cm9sbGVyTGlzdFByb3BzIHtcbiAgLyoqXG4gICAqIExpc3Qgb2YgcmVwbGljYXRpb24gY29udHJvbGxlcnMuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL2NvbnRyb2xsZXJzL3JlcGxpY2F0aW9uY29udHJvbGxlclxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5SZXBsaWNhdGlvbkNvbnRyb2xsZXJMaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZVJlcGxpY2F0aW9uQ29udHJvbGxlclByb3BzW107XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIGxpc3QgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjdHlwZXMta2luZHNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUmVwbGljYXRpb25Db250cm9sbGVyTGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlUmVwbGljYXRpb25Db250cm9sbGVyTGlzdFByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlUmVwbGljYXRpb25Db250cm9sbGVyTGlzdFByb3BzKG9iajogS3ViZVJlcGxpY2F0aW9uQ29udHJvbGxlckxpc3RQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZVJlcGxpY2F0aW9uQ29udHJvbGxlclByb3BzKHkpKSxcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fTGlzdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBSZXNvdXJjZVF1b3RhIHNldHMgYWdncmVnYXRlIHF1b3RhIHJlc3RyaWN0aW9ucyBlbmZvcmNlZCBwZXIgbmFtZXNwYWNlXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUmVzb3VyY2VRdW90YVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVSZXNvdXJjZVF1b3RhUHJvcHMge1xuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0J3MgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUmVzb3VyY2VRdW90YSNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBPYmplY3RNZXRhO1xuXG4gIC8qKlxuICAgKiBTcGVjIGRlZmluZXMgdGhlIGRlc2lyZWQgcXVvdGEuIGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3NwZWMtYW5kLXN0YXR1c1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5SZXNvdXJjZVF1b3RhI3NwZWNcbiAgICovXG4gIHJlYWRvbmx5IHNwZWM/OiBSZXNvdXJjZVF1b3RhU3BlYztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlUmVzb3VyY2VRdW90YVByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlUmVzb3VyY2VRdW90YVByb3BzKG9iajogS3ViZVJlc291cmNlUXVvdGFQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX09iamVjdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgICAnc3BlYyc6IHRvSnNvbl9SZXNvdXJjZVF1b3RhU3BlYyhvYmouc3BlYyksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUmVzb3VyY2VRdW90YUxpc3QgaXMgYSBsaXN0IG9mIFJlc291cmNlUXVvdGEgaXRlbXMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUmVzb3VyY2VRdW90YUxpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlUmVzb3VyY2VRdW90YUxpc3RQcm9wcyB7XG4gIC8qKlxuICAgKiBJdGVtcyBpcyBhIGxpc3Qgb2YgUmVzb3VyY2VRdW90YSBvYmplY3RzLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3BvbGljeS9yZXNvdXJjZS1xdW90YXMvXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlJlc291cmNlUXVvdGFMaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZVJlc291cmNlUXVvdGFQcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBsaXN0IG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3R5cGVzLWtpbmRzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlJlc291cmNlUXVvdGFMaXN0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IExpc3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVSZXNvdXJjZVF1b3RhTGlzdFByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlUmVzb3VyY2VRdW90YUxpc3RQcm9wcyhvYmo6IEt1YmVSZXNvdXJjZVF1b3RhTGlzdFByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaXRlbXMnOiBvYmouaXRlbXM/Lm1hcCh5ID0+IHRvSnNvbl9LdWJlUmVzb3VyY2VRdW90YVByb3BzKHkpKSxcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fTGlzdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBTZWNyZXQgaG9sZHMgc2VjcmV0IGRhdGEgb2YgYSBjZXJ0YWluIHR5cGUuIFRoZSB0b3RhbCBieXRlcyBvZiB0aGUgdmFsdWVzIGluIHRoZSBEYXRhIGZpZWxkIG11c3QgYmUgbGVzcyB0aGFuIE1heFNlY3JldFNpemUgYnl0ZXMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VjcmV0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZVNlY3JldFByb3BzIHtcbiAgLyoqXG4gICAqIERhdGEgY29udGFpbnMgdGhlIHNlY3JldCBkYXRhLiBFYWNoIGtleSBtdXN0IGNvbnNpc3Qgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMsICctJywgJ18nIG9yICcuJy4gVGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgc2VjcmV0IGRhdGEgaXMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcsIHJlcHJlc2VudGluZyB0aGUgYXJiaXRyYXJ5IChwb3NzaWJseSBub24tc3RyaW5nKSBkYXRhIHZhbHVlIGhlcmUuIERlc2NyaWJlZCBpbiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDY0OCNzZWN0aW9uLTRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VjcmV0I2RhdGFcbiAgICovXG4gIHJlYWRvbmx5IGRhdGE/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXG4gIC8qKlxuICAgKiBJbW11dGFibGUsIGlmIHNldCB0byB0cnVlLCBlbnN1cmVzIHRoYXQgZGF0YSBzdG9yZWQgaW4gdGhlIFNlY3JldCBjYW5ub3QgYmUgdXBkYXRlZCAob25seSBvYmplY3QgbWV0YWRhdGEgY2FuIGJlIG1vZGlmaWVkKS4gSWYgbm90IHNldCB0byB0cnVlLCB0aGUgZmllbGQgY2FuIGJlIG1vZGlmaWVkIGF0IGFueSB0aW1lLiBEZWZhdWx0ZWQgdG8gbmlsLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZWNyZXQjaW1tdXRhYmxlXG4gICAqL1xuICByZWFkb25seSBpbW11dGFibGU/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZWNyZXQjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogc3RyaW5nRGF0YSBhbGxvd3Mgc3BlY2lmeWluZyBub24tYmluYXJ5IHNlY3JldCBkYXRhIGluIHN0cmluZyBmb3JtLiBJdCBpcyBwcm92aWRlZCBhcyBhIHdyaXRlLW9ubHkgaW5wdXQgZmllbGQgZm9yIGNvbnZlbmllbmNlLiBBbGwga2V5cyBhbmQgdmFsdWVzIGFyZSBtZXJnZWQgaW50byB0aGUgZGF0YSBmaWVsZCBvbiB3cml0ZSwgb3ZlcndyaXRpbmcgYW55IGV4aXN0aW5nIHZhbHVlcy4gVGhlIHN0cmluZ0RhdGEgZmllbGQgaXMgbmV2ZXIgb3V0cHV0IHdoZW4gcmVhZGluZyBmcm9tIHRoZSBBUEkuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlY3JldCNzdHJpbmdEYXRhXG4gICAqL1xuICByZWFkb25seSBzdHJpbmdEYXRhPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcblxuICAvKipcbiAgICogVXNlZCB0byBmYWNpbGl0YXRlIHByb2dyYW1tYXRpYyBoYW5kbGluZyBvZiBzZWNyZXQgZGF0YS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VjcmV0I3R5cGVcbiAgICovXG4gIHJlYWRvbmx5IHR5cGU/OiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZVNlY3JldFByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlU2VjcmV0UHJvcHMob2JqOiBLdWJlU2VjcmV0UHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdkYXRhJzogKChvYmouZGF0YSkgPT09IHVuZGVmaW5lZCkgPyB1bmRlZmluZWQgOiAoT2JqZWN0LmVudHJpZXMob2JqLmRhdGEpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSkpLFxuICAgICdpbW11dGFibGUnOiBvYmouaW1tdXRhYmxlLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3N0cmluZ0RhdGEnOiAoKG9iai5zdHJpbmdEYXRhKSA9PT0gdW5kZWZpbmVkKSA/IHVuZGVmaW5lZCA6IChPYmplY3QuZW50cmllcyhvYmouc3RyaW5nRGF0YSkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KSksXG4gICAgJ3R5cGUnOiBvYmoudHlwZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBTZWNyZXRMaXN0IGlzIGEgbGlzdCBvZiBTZWNyZXQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VjcmV0TGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVTZWNyZXRMaXN0UHJvcHMge1xuICAvKipcbiAgICogSXRlbXMgaXMgYSBsaXN0IG9mIHNlY3JldCBvYmplY3RzLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL2NvbmZpZ3VyYXRpb24vc2VjcmV0XG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlY3JldExpc3QjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zOiBLdWJlU2VjcmV0UHJvcHNbXTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgbGlzdCBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCN0eXBlcy1raW5kc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZWNyZXRMaXN0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IExpc3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVTZWNyZXRMaXN0UHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVTZWNyZXRMaXN0UHJvcHMob2JqOiBLdWJlU2VjcmV0TGlzdFByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaXRlbXMnOiBvYmouaXRlbXM/Lm1hcCh5ID0+IHRvSnNvbl9LdWJlU2VjcmV0UHJvcHMoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9MaXN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFNlcnZpY2UgaXMgYSBuYW1lZCBhYnN0cmFjdGlvbiBvZiBzb2Z0d2FyZSBzZXJ2aWNlIChmb3IgZXhhbXBsZSwgbXlzcWwpIGNvbnNpc3Rpbmcgb2YgbG9jYWwgcG9ydCAoZm9yIGV4YW1wbGUgMzMwNikgdGhhdCB0aGUgcHJveHkgbGlzdGVucyBvbiwgYW5kIHRoZSBzZWxlY3RvciB0aGF0IGRldGVybWluZXMgd2hpY2ggcG9kcyB3aWxsIGFuc3dlciByZXF1ZXN0cyBzZW50IHRocm91Z2ggdGhlIHByb3h5LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlcnZpY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlU2VydmljZVByb3BzIHtcbiAgLyoqXG4gICAqIFN0YW5kYXJkIG9iamVjdCdzIG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlcnZpY2UjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogU3BlYyBkZWZpbmVzIHRoZSBiZWhhdmlvciBvZiBhIHNlcnZpY2UuIGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3NwZWMtYW5kLXN0YXR1c1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZXJ2aWNlI3NwZWNcbiAgICovXG4gIHJlYWRvbmx5IHNwZWM/OiBTZXJ2aWNlU3BlYztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlU2VydmljZVByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlU2VydmljZVByb3BzKG9iajogS3ViZVNlcnZpY2VQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX09iamVjdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgICAnc3BlYyc6IHRvSnNvbl9TZXJ2aWNlU3BlYyhvYmouc3BlYyksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogU2VydmljZUFjY291bnQgYmluZHMgdG9nZXRoZXI6ICogYSBuYW1lLCB1bmRlcnN0b29kIGJ5IHVzZXJzLCBhbmQgcGVyaGFwcyBieSBwZXJpcGhlcmFsIHN5c3RlbXMsIGZvciBhbiBpZGVudGl0eSAqIGEgcHJpbmNpcGFsIHRoYXQgY2FuIGJlIGF1dGhlbnRpY2F0ZWQgYW5kIGF1dGhvcml6ZWQgKiBhIHNldCBvZiBzZWNyZXRzXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZUFjY291bnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlU2VydmljZUFjY291bnRQcm9wcyB7XG4gIC8qKlxuICAgKiBBdXRvbW91bnRTZXJ2aWNlQWNjb3VudFRva2VuIGluZGljYXRlcyB3aGV0aGVyIHBvZHMgcnVubmluZyBhcyB0aGlzIHNlcnZpY2UgYWNjb3VudCBzaG91bGQgaGF2ZSBhbiBBUEkgdG9rZW4gYXV0b21hdGljYWxseSBtb3VudGVkLiBDYW4gYmUgb3ZlcnJpZGRlbiBhdCB0aGUgcG9kIGxldmVsLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZXJ2aWNlQWNjb3VudCNhdXRvbW91bnRTZXJ2aWNlQWNjb3VudFRva2VuXG4gICAqL1xuICByZWFkb25seSBhdXRvbW91bnRTZXJ2aWNlQWNjb3VudFRva2VuPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSW1hZ2VQdWxsU2VjcmV0cyBpcyBhIGxpc3Qgb2YgcmVmZXJlbmNlcyB0byBzZWNyZXRzIGluIHRoZSBzYW1lIG5hbWVzcGFjZSB0byB1c2UgZm9yIHB1bGxpbmcgYW55IGltYWdlcyBpbiBwb2RzIHRoYXQgcmVmZXJlbmNlIHRoaXMgU2VydmljZUFjY291bnQuIEltYWdlUHVsbFNlY3JldHMgYXJlIGRpc3RpbmN0IGZyb20gU2VjcmV0cyBiZWNhdXNlIFNlY3JldHMgY2FuIGJlIG1vdW50ZWQgaW4gdGhlIHBvZCwgYnV0IEltYWdlUHVsbFNlY3JldHMgYXJlIG9ubHkgYWNjZXNzZWQgYnkgdGhlIGt1YmVsZXQuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvY29udGFpbmVycy9pbWFnZXMvI3NwZWNpZnlpbmctaW1hZ2VwdWxsc2VjcmV0cy1vbi1hLXBvZFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZXJ2aWNlQWNjb3VudCNpbWFnZVB1bGxTZWNyZXRzXG4gICAqL1xuICByZWFkb25seSBpbWFnZVB1bGxTZWNyZXRzPzogTG9jYWxPYmplY3RSZWZlcmVuY2VbXTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0J3MgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZUFjY291bnQjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogU2VjcmV0cyBpcyB0aGUgbGlzdCBvZiBzZWNyZXRzIGFsbG93ZWQgdG8gYmUgdXNlZCBieSBwb2RzIHJ1bm5pbmcgdXNpbmcgdGhpcyBTZXJ2aWNlQWNjb3VudC4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9jb25maWd1cmF0aW9uL3NlY3JldFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZXJ2aWNlQWNjb3VudCNzZWNyZXRzXG4gICAqL1xuICByZWFkb25seSBzZWNyZXRzPzogT2JqZWN0UmVmZXJlbmNlW107XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZVNlcnZpY2VBY2NvdW50UHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVTZXJ2aWNlQWNjb3VudFByb3BzKG9iajogS3ViZVNlcnZpY2VBY2NvdW50UHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdhdXRvbW91bnRTZXJ2aWNlQWNjb3VudFRva2VuJzogb2JqLmF1dG9tb3VudFNlcnZpY2VBY2NvdW50VG9rZW4sXG4gICAgJ2ltYWdlUHVsbFNlY3JldHMnOiBvYmouaW1hZ2VQdWxsU2VjcmV0cz8ubWFwKHkgPT4gdG9Kc29uX0xvY2FsT2JqZWN0UmVmZXJlbmNlKHkpKSxcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdzZWNyZXRzJzogb2JqLnNlY3JldHM/Lm1hcCh5ID0+IHRvSnNvbl9PYmplY3RSZWZlcmVuY2UoeSkpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFNlcnZpY2VBY2NvdW50TGlzdCBpcyBhIGxpc3Qgb2YgU2VydmljZUFjY291bnQgb2JqZWN0c1xuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlcnZpY2VBY2NvdW50TGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVTZXJ2aWNlQWNjb3VudExpc3RQcm9wcyB7XG4gIC8qKlxuICAgKiBMaXN0IG9mIFNlcnZpY2VBY2NvdW50cy4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy90YXNrcy9jb25maWd1cmUtcG9kLWNvbnRhaW5lci9jb25maWd1cmUtc2VydmljZS1hY2NvdW50L1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZXJ2aWNlQWNjb3VudExpc3QjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zOiBLdWJlU2VydmljZUFjY291bnRQcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBsaXN0IG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3R5cGVzLWtpbmRzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlcnZpY2VBY2NvdW50TGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlU2VydmljZUFjY291bnRMaXN0UHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVTZXJ2aWNlQWNjb3VudExpc3RQcm9wcyhvYmo6IEt1YmVTZXJ2aWNlQWNjb3VudExpc3RQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZVNlcnZpY2VBY2NvdW50UHJvcHMoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9MaXN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFNlcnZpY2VMaXN0IGhvbGRzIGEgbGlzdCBvZiBzZXJ2aWNlcy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZXJ2aWNlTGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVTZXJ2aWNlTGlzdFByb3BzIHtcbiAgLyoqXG4gICAqIExpc3Qgb2Ygc2VydmljZXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZUxpc3QjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zOiBLdWJlU2VydmljZVByb3BzW107XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIGxpc3QgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjdHlwZXMta2luZHNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZUxpc3QjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogTGlzdE1ldGE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZVNlcnZpY2VMaXN0UHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVTZXJ2aWNlTGlzdFByb3BzKG9iajogS3ViZVNlcnZpY2VMaXN0UHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdpdGVtcyc6IG9iai5pdGVtcz8ubWFwKHkgPT4gdG9Kc29uX0t1YmVTZXJ2aWNlUHJvcHMoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9MaXN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEVuZHBvaW50U2xpY2UgcmVwcmVzZW50cyBhIHN1YnNldCBvZiB0aGUgZW5kcG9pbnRzIHRoYXQgaW1wbGVtZW50IGEgc2VydmljZS4gRm9yIGEgZ2l2ZW4gc2VydmljZSB0aGVyZSBtYXkgYmUgbXVsdGlwbGUgRW5kcG9pbnRTbGljZSBvYmplY3RzLCBzZWxlY3RlZCBieSBsYWJlbHMsIHdoaWNoIG11c3QgYmUgam9pbmVkIHRvIHByb2R1Y2UgdGhlIGZ1bGwgc2V0IG9mIGVuZHBvaW50cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuZGlzY292ZXJ5LnYxLkVuZHBvaW50U2xpY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlRW5kcG9pbnRTbGljZVByb3BzIHtcbiAgLyoqXG4gICAqIGFkZHJlc3NUeXBlIHNwZWNpZmllcyB0aGUgdHlwZSBvZiBhZGRyZXNzIGNhcnJpZWQgYnkgdGhpcyBFbmRwb2ludFNsaWNlLiBBbGwgYWRkcmVzc2VzIGluIHRoaXMgc2xpY2UgbXVzdCBiZSB0aGUgc2FtZSB0eXBlLiBUaGlzIGZpZWxkIGlzIGltbXV0YWJsZSBhZnRlciBjcmVhdGlvbi4gVGhlIGZvbGxvd2luZyBhZGRyZXNzIHR5cGVzIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkOiAqIElQdjQ6IFJlcHJlc2VudHMgYW4gSVB2NCBBZGRyZXNzLiAqIElQdjY6IFJlcHJlc2VudHMgYW4gSVB2NiBBZGRyZXNzLiAqIEZRRE46IFJlcHJlc2VudHMgYSBGdWxseSBRdWFsaWZpZWQgRG9tYWluIE5hbWUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjEuRW5kcG9pbnRTbGljZSNhZGRyZXNzVHlwZVxuICAgKi9cbiAgcmVhZG9ubHkgYWRkcmVzc1R5cGU6IHN0cmluZztcblxuICAvKipcbiAgICogZW5kcG9pbnRzIGlzIGEgbGlzdCBvZiB1bmlxdWUgZW5kcG9pbnRzIGluIHRoaXMgc2xpY2UuIEVhY2ggc2xpY2UgbWF5IGluY2x1ZGUgYSBtYXhpbXVtIG9mIDEwMDAgZW5kcG9pbnRzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZGlzY292ZXJ5LnYxLkVuZHBvaW50U2xpY2UjZW5kcG9pbnRzXG4gICAqL1xuICByZWFkb25seSBlbmRwb2ludHM6IEVuZHBvaW50W107XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIG9iamVjdCdzIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZGlzY292ZXJ5LnYxLkVuZHBvaW50U2xpY2UjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogcG9ydHMgc3BlY2lmaWVzIHRoZSBsaXN0IG9mIG5ldHdvcmsgcG9ydHMgZXhwb3NlZCBieSBlYWNoIGVuZHBvaW50IGluIHRoaXMgc2xpY2UuIEVhY2ggcG9ydCBtdXN0IGhhdmUgYSB1bmlxdWUgbmFtZS4gV2hlbiBwb3J0cyBpcyBlbXB0eSwgaXQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgYXJlIG5vIGRlZmluZWQgcG9ydHMuIFdoZW4gYSBwb3J0IGlzIGRlZmluZWQgd2l0aCBhIG5pbCBwb3J0IHZhbHVlLCBpdCBpbmRpY2F0ZXMgXCJhbGwgcG9ydHNcIi4gRWFjaCBzbGljZSBtYXkgaW5jbHVkZSBhIG1heGltdW0gb2YgMTAwIHBvcnRzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZGlzY292ZXJ5LnYxLkVuZHBvaW50U2xpY2UjcG9ydHNcbiAgICovXG4gIHJlYWRvbmx5IHBvcnRzPzogRW5kcG9pbnRQb3J0W107XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZUVuZHBvaW50U2xpY2VQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUVuZHBvaW50U2xpY2VQcm9wcyhvYmo6IEt1YmVFbmRwb2ludFNsaWNlUHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdhZGRyZXNzVHlwZSc6IG9iai5hZGRyZXNzVHlwZSxcbiAgICAnZW5kcG9pbnRzJzogb2JqLmVuZHBvaW50cz8ubWFwKHkgPT4gdG9Kc29uX0VuZHBvaW50KHkpKSxcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdwb3J0cyc6IG9iai5wb3J0cz8ubWFwKHkgPT4gdG9Kc29uX0VuZHBvaW50UG9ydCh5KSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogRW5kcG9pbnRTbGljZUxpc3QgcmVwcmVzZW50cyBhIGxpc3Qgb2YgZW5kcG9pbnQgc2xpY2VzXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmRpc2NvdmVyeS52MS5FbmRwb2ludFNsaWNlTGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVFbmRwb2ludFNsaWNlTGlzdFByb3BzIHtcbiAgLyoqXG4gICAqIExpc3Qgb2YgZW5kcG9pbnQgc2xpY2VzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjEuRW5kcG9pbnRTbGljZUxpc3QjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zOiBLdWJlRW5kcG9pbnRTbGljZVByb3BzW107XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIGxpc3QgbWV0YWRhdGEuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjEuRW5kcG9pbnRTbGljZUxpc3QjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogTGlzdE1ldGE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZUVuZHBvaW50U2xpY2VMaXN0UHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVFbmRwb2ludFNsaWNlTGlzdFByb3BzKG9iajogS3ViZUVuZHBvaW50U2xpY2VMaXN0UHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdpdGVtcyc6IG9iai5pdGVtcz8ubWFwKHkgPT4gdG9Kc29uX0t1YmVFbmRwb2ludFNsaWNlUHJvcHMoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9MaXN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEVuZHBvaW50U2xpY2UgcmVwcmVzZW50cyBhIHN1YnNldCBvZiB0aGUgZW5kcG9pbnRzIHRoYXQgaW1wbGVtZW50IGEgc2VydmljZS4gRm9yIGEgZ2l2ZW4gc2VydmljZSB0aGVyZSBtYXkgYmUgbXVsdGlwbGUgRW5kcG9pbnRTbGljZSBvYmplY3RzLCBzZWxlY3RlZCBieSBsYWJlbHMsIHdoaWNoIG11c3QgYmUgam9pbmVkIHRvIHByb2R1Y2UgdGhlIGZ1bGwgc2V0IG9mIGVuZHBvaW50cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuZGlzY292ZXJ5LnYxYmV0YTEuRW5kcG9pbnRTbGljZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVFbmRwb2ludFNsaWNlVjFCZXRhMVByb3BzIHtcbiAgLyoqXG4gICAqIGFkZHJlc3NUeXBlIHNwZWNpZmllcyB0aGUgdHlwZSBvZiBhZGRyZXNzIGNhcnJpZWQgYnkgdGhpcyBFbmRwb2ludFNsaWNlLiBBbGwgYWRkcmVzc2VzIGluIHRoaXMgc2xpY2UgbXVzdCBiZSB0aGUgc2FtZSB0eXBlLiBUaGlzIGZpZWxkIGlzIGltbXV0YWJsZSBhZnRlciBjcmVhdGlvbi4gVGhlIGZvbGxvd2luZyBhZGRyZXNzIHR5cGVzIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkOiAqIElQdjQ6IFJlcHJlc2VudHMgYW4gSVB2NCBBZGRyZXNzLiAqIElQdjY6IFJlcHJlc2VudHMgYW4gSVB2NiBBZGRyZXNzLiAqIEZRRE46IFJlcHJlc2VudHMgYSBGdWxseSBRdWFsaWZpZWQgRG9tYWluIE5hbWUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjFiZXRhMS5FbmRwb2ludFNsaWNlI2FkZHJlc3NUeXBlXG4gICAqL1xuICByZWFkb25seSBhZGRyZXNzVHlwZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBlbmRwb2ludHMgaXMgYSBsaXN0IG9mIHVuaXF1ZSBlbmRwb2ludHMgaW4gdGhpcyBzbGljZS4gRWFjaCBzbGljZSBtYXkgaW5jbHVkZSBhIG1heGltdW0gb2YgMTAwMCBlbmRwb2ludHMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjFiZXRhMS5FbmRwb2ludFNsaWNlI2VuZHBvaW50c1xuICAgKi9cbiAgcmVhZG9ubHkgZW5kcG9pbnRzOiBFbmRwb2ludFYxQmV0YTFbXTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0J3MgbWV0YWRhdGEuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjFiZXRhMS5FbmRwb2ludFNsaWNlI21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIHBvcnRzIHNwZWNpZmllcyB0aGUgbGlzdCBvZiBuZXR3b3JrIHBvcnRzIGV4cG9zZWQgYnkgZWFjaCBlbmRwb2ludCBpbiB0aGlzIHNsaWNlLiBFYWNoIHBvcnQgbXVzdCBoYXZlIGEgdW5pcXVlIG5hbWUuIFdoZW4gcG9ydHMgaXMgZW1wdHksIGl0IGluZGljYXRlcyB0aGF0IHRoZXJlIGFyZSBubyBkZWZpbmVkIHBvcnRzLiBXaGVuIGEgcG9ydCBpcyBkZWZpbmVkIHdpdGggYSBuaWwgcG9ydCB2YWx1ZSwgaXQgaW5kaWNhdGVzIFwiYWxsIHBvcnRzXCIuIEVhY2ggc2xpY2UgbWF5IGluY2x1ZGUgYSBtYXhpbXVtIG9mIDEwMCBwb3J0cy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmRpc2NvdmVyeS52MWJldGExLkVuZHBvaW50U2xpY2UjcG9ydHNcbiAgICovXG4gIHJlYWRvbmx5IHBvcnRzPzogRW5kcG9pbnRQb3J0VjFCZXRhMVtdO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVFbmRwb2ludFNsaWNlVjFCZXRhMVByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlRW5kcG9pbnRTbGljZVYxQmV0YTFQcm9wcyhvYmo6IEt1YmVFbmRwb2ludFNsaWNlVjFCZXRhMVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnYWRkcmVzc1R5cGUnOiBvYmouYWRkcmVzc1R5cGUsXG4gICAgJ2VuZHBvaW50cyc6IG9iai5lbmRwb2ludHM/Lm1hcCh5ID0+IHRvSnNvbl9FbmRwb2ludFYxQmV0YTEoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3BvcnRzJzogb2JqLnBvcnRzPy5tYXAoeSA9PiB0b0pzb25fRW5kcG9pbnRQb3J0VjFCZXRhMSh5KSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogRW5kcG9pbnRTbGljZUxpc3QgcmVwcmVzZW50cyBhIGxpc3Qgb2YgZW5kcG9pbnQgc2xpY2VzXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmRpc2NvdmVyeS52MWJldGExLkVuZHBvaW50U2xpY2VMaXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZUVuZHBvaW50U2xpY2VMaXN0VjFCZXRhMVByb3BzIHtcbiAgLyoqXG4gICAqIExpc3Qgb2YgZW5kcG9pbnQgc2xpY2VzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjFiZXRhMS5FbmRwb2ludFNsaWNlTGlzdCNpdGVtc1xuICAgKi9cbiAgcmVhZG9ubHkgaXRlbXM6IEt1YmVFbmRwb2ludFNsaWNlVjFCZXRhMVByb3BzW107XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIGxpc3QgbWV0YWRhdGEuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjFiZXRhMS5FbmRwb2ludFNsaWNlTGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlRW5kcG9pbnRTbGljZUxpc3RWMUJldGExUHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVFbmRwb2ludFNsaWNlTGlzdFYxQmV0YTFQcm9wcyhvYmo6IEt1YmVFbmRwb2ludFNsaWNlTGlzdFYxQmV0YTFQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZUVuZHBvaW50U2xpY2VWMUJldGExUHJvcHMoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9MaXN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEV2ZW50IGlzIGEgcmVwb3J0IG9mIGFuIGV2ZW50IHNvbWV3aGVyZSBpbiB0aGUgY2x1c3Rlci4gSXQgZ2VuZXJhbGx5IGRlbm90ZXMgc29tZSBzdGF0ZSBjaGFuZ2UgaW4gdGhlIHN5c3RlbS4gRXZlbnRzIGhhdmUgYSBsaW1pdGVkIHJldGVudGlvbiB0aW1lIGFuZCB0cmlnZ2VycyBhbmQgbWVzc2FnZXMgbWF5IGV2b2x2ZSB3aXRoIHRpbWUuICBFdmVudCBjb25zdW1lcnMgc2hvdWxkIG5vdCByZWx5IG9uIHRoZSB0aW1pbmcgb2YgYW4gZXZlbnQgd2l0aCBhIGdpdmVuIFJlYXNvbiByZWZsZWN0aW5nIGEgY29uc2lzdGVudCB1bmRlcmx5aW5nIHRyaWdnZXIsIG9yIHRoZSBjb250aW51ZWQgZXhpc3RlbmNlIG9mIGV2ZW50cyB3aXRoIHRoYXQgUmVhc29uLiAgRXZlbnRzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGluZm9ybWF0aXZlLCBiZXN0LWVmZm9ydCwgc3VwcGxlbWVudGFsIGRhdGEuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmV2ZW50cy52MWJldGExLkV2ZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZUV2ZW50VjFCZXRhMVByb3BzIHtcbiAgLyoqXG4gICAqIGFjdGlvbiBpcyB3aGF0IGFjdGlvbiB3YXMgdGFrZW4vZmFpbGVkIHJlZ2FyZGluZyB0byB0aGUgcmVnYXJkaW5nIG9iamVjdC4gSXQgaXMgbWFjaGluZS1yZWFkYWJsZS4gVGhpcyBmaWVsZCBjYW4gaGF2ZSBhdCBtb3N0IDEyOCBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZXZlbnRzLnYxYmV0YTEuRXZlbnQjYWN0aW9uXG4gICAqL1xuICByZWFkb25seSBhY3Rpb24/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGRlcHJlY2F0ZWRDb3VudCBpcyB0aGUgZGVwcmVjYXRlZCBmaWVsZCBhc3N1cmluZyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggY29yZS52MSBFdmVudCB0eXBlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZXZlbnRzLnYxYmV0YTEuRXZlbnQjZGVwcmVjYXRlZENvdW50XG4gICAqL1xuICByZWFkb25seSBkZXByZWNhdGVkQ291bnQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIGRlcHJlY2F0ZWRGaXJzdFRpbWVzdGFtcCBpcyB0aGUgZGVwcmVjYXRlZCBmaWVsZCBhc3N1cmluZyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggY29yZS52MSBFdmVudCB0eXBlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZXZlbnRzLnYxYmV0YTEuRXZlbnQjZGVwcmVjYXRlZEZpcnN0VGltZXN0YW1wXG4gICAqL1xuICByZWFkb25seSBkZXByZWNhdGVkRmlyc3RUaW1lc3RhbXA/OiBEYXRlO1xuXG4gIC8qKlxuICAgKiBkZXByZWNhdGVkTGFzdFRpbWVzdGFtcCBpcyB0aGUgZGVwcmVjYXRlZCBmaWVsZCBhc3N1cmluZyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggY29yZS52MSBFdmVudCB0eXBlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZXZlbnRzLnYxYmV0YTEuRXZlbnQjZGVwcmVjYXRlZExhc3RUaW1lc3RhbXBcbiAgICovXG4gIHJlYWRvbmx5IGRlcHJlY2F0ZWRMYXN0VGltZXN0YW1wPzogRGF0ZTtcblxuICAvKipcbiAgICogZGVwcmVjYXRlZFNvdXJjZSBpcyB0aGUgZGVwcmVjYXRlZCBmaWVsZCBhc3N1cmluZyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggY29yZS52MSBFdmVudCB0eXBlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZXZlbnRzLnYxYmV0YTEuRXZlbnQjZGVwcmVjYXRlZFNvdXJjZVxuICAgKi9cbiAgcmVhZG9ubHkgZGVwcmVjYXRlZFNvdXJjZT86IEV2ZW50U291cmNlO1xuXG4gIC8qKlxuICAgKiBldmVudFRpbWUgaXMgdGhlIHRpbWUgd2hlbiB0aGlzIEV2ZW50IHdhcyBmaXJzdCBvYnNlcnZlZC4gSXQgaXMgcmVxdWlyZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5ldmVudHMudjFiZXRhMS5FdmVudCNldmVudFRpbWVcbiAgICovXG4gIHJlYWRvbmx5IGV2ZW50VGltZTogRGF0ZTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0J3MgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmV2ZW50cy52MWJldGExLkV2ZW50I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIG5vdGUgaXMgYSBodW1hbi1yZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiB0aGUgc3RhdHVzIG9mIHRoaXMgb3BlcmF0aW9uLiBNYXhpbWFsIGxlbmd0aCBvZiB0aGUgbm90ZSBpcyAxa0IsIGJ1dCBsaWJyYXJpZXMgc2hvdWxkIGJlIHByZXBhcmVkIHRvIGhhbmRsZSB2YWx1ZXMgdXAgdG8gNjRrQi5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmV2ZW50cy52MWJldGExLkV2ZW50I25vdGVcbiAgICovXG4gIHJlYWRvbmx5IG5vdGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIHJlYXNvbiBpcyB3aHkgdGhlIGFjdGlvbiB3YXMgdGFrZW4uIEl0IGlzIGh1bWFuLXJlYWRhYmxlLiBUaGlzIGZpZWxkIGNhbiBoYXZlIGF0IG1vc3QgMTI4IGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5ldmVudHMudjFiZXRhMS5FdmVudCNyZWFzb25cbiAgICovXG4gIHJlYWRvbmx5IHJlYXNvbj86IHN0cmluZztcblxuICAvKipcbiAgICogcmVnYXJkaW5nIGNvbnRhaW5zIHRoZSBvYmplY3QgdGhpcyBFdmVudCBpcyBhYm91dC4gSW4gbW9zdCBjYXNlcyBpdCdzIGFuIE9iamVjdCByZXBvcnRpbmcgY29udHJvbGxlciBpbXBsZW1lbnRzLCBlLmcuIFJlcGxpY2FTZXRDb250cm9sbGVyIGltcGxlbWVudHMgUmVwbGljYVNldHMgYW5kIHRoaXMgZXZlbnQgaXMgZW1pdHRlZCBiZWNhdXNlIGl0IGFjdHMgb24gc29tZSBjaGFuZ2VzIGluIGEgUmVwbGljYVNldCBvYmplY3QuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5ldmVudHMudjFiZXRhMS5FdmVudCNyZWdhcmRpbmdcbiAgICovXG4gIHJlYWRvbmx5IHJlZ2FyZGluZz86IE9iamVjdFJlZmVyZW5jZTtcblxuICAvKipcbiAgICogcmVsYXRlZCBpcyB0aGUgb3B0aW9uYWwgc2Vjb25kYXJ5IG9iamVjdCBmb3IgbW9yZSBjb21wbGV4IGFjdGlvbnMuIEUuZy4gd2hlbiByZWdhcmRpbmcgb2JqZWN0IHRyaWdnZXJzIGEgY3JlYXRpb24gb3IgZGVsZXRpb24gb2YgcmVsYXRlZCBvYmplY3QuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5ldmVudHMudjFiZXRhMS5FdmVudCNyZWxhdGVkXG4gICAqL1xuICByZWFkb25seSByZWxhdGVkPzogT2JqZWN0UmVmZXJlbmNlO1xuXG4gIC8qKlxuICAgKiByZXBvcnRpbmdDb250cm9sbGVyIGlzIHRoZSBuYW1lIG9mIHRoZSBjb250cm9sbGVyIHRoYXQgZW1pdHRlZCB0aGlzIEV2ZW50LCBlLmcuIGBrdWJlcm5ldGVzLmlvL2t1YmVsZXRgLiBUaGlzIGZpZWxkIGNhbm5vdCBiZSBlbXB0eSBmb3IgbmV3IEV2ZW50cy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmV2ZW50cy52MWJldGExLkV2ZW50I3JlcG9ydGluZ0NvbnRyb2xsZXJcbiAgICovXG4gIHJlYWRvbmx5IHJlcG9ydGluZ0NvbnRyb2xsZXI/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIHJlcG9ydGluZ0luc3RhbmNlIGlzIHRoZSBJRCBvZiB0aGUgY29udHJvbGxlciBpbnN0YW5jZSwgZS5nLiBga3ViZWxldC14eXpmYC4gVGhpcyBmaWVsZCBjYW5ub3QgYmUgZW1wdHkgZm9yIG5ldyBFdmVudHMgYW5kIGl0IGNhbiBoYXZlIGF0IG1vc3QgMTI4IGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5ldmVudHMudjFiZXRhMS5FdmVudCNyZXBvcnRpbmdJbnN0YW5jZVxuICAgKi9cbiAgcmVhZG9ubHkgcmVwb3J0aW5nSW5zdGFuY2U/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIHNlcmllcyBpcyBkYXRhIGFib3V0IHRoZSBFdmVudCBzZXJpZXMgdGhpcyBldmVudCByZXByZXNlbnRzIG9yIG5pbCBpZiBpdCdzIGEgc2luZ2xldG9uIEV2ZW50LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZXZlbnRzLnYxYmV0YTEuRXZlbnQjc2VyaWVzXG4gICAqL1xuICByZWFkb25seSBzZXJpZXM/OiBFdmVudFNlcmllc1YxQmV0YTE7XG5cbiAgLyoqXG4gICAqIHR5cGUgaXMgdGhlIHR5cGUgb2YgdGhpcyBldmVudCAoTm9ybWFsLCBXYXJuaW5nKSwgbmV3IHR5cGVzIGNvdWxkIGJlIGFkZGVkIGluIHRoZSBmdXR1cmUuIEl0IGlzIG1hY2hpbmUtcmVhZGFibGUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5ldmVudHMudjFiZXRhMS5FdmVudCN0eXBlXG4gICAqL1xuICByZWFkb25seSB0eXBlPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVFdmVudFYxQmV0YTFQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUV2ZW50VjFCZXRhMVByb3BzKG9iajogS3ViZUV2ZW50VjFCZXRhMVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnYWN0aW9uJzogb2JqLmFjdGlvbixcbiAgICAnZGVwcmVjYXRlZENvdW50Jzogb2JqLmRlcHJlY2F0ZWRDb3VudCxcbiAgICAnZGVwcmVjYXRlZEZpcnN0VGltZXN0YW1wJzogb2JqLmRlcHJlY2F0ZWRGaXJzdFRpbWVzdGFtcD8udG9JU09TdHJpbmcoKSxcbiAgICAnZGVwcmVjYXRlZExhc3RUaW1lc3RhbXAnOiBvYmouZGVwcmVjYXRlZExhc3RUaW1lc3RhbXA/LnRvSVNPU3RyaW5nKCksXG4gICAgJ2RlcHJlY2F0ZWRTb3VyY2UnOiB0b0pzb25fRXZlbnRTb3VyY2Uob2JqLmRlcHJlY2F0ZWRTb3VyY2UpLFxuICAgICdldmVudFRpbWUnOiBvYmouZXZlbnRUaW1lPy50b0lTT1N0cmluZygpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ25vdGUnOiBvYmoubm90ZSxcbiAgICAncmVhc29uJzogb2JqLnJlYXNvbixcbiAgICAncmVnYXJkaW5nJzogdG9Kc29uX09iamVjdFJlZmVyZW5jZShvYmoucmVnYXJkaW5nKSxcbiAgICAncmVsYXRlZCc6IHRvSnNvbl9PYmplY3RSZWZlcmVuY2Uob2JqLnJlbGF0ZWQpLFxuICAgICdyZXBvcnRpbmdDb250cm9sbGVyJzogb2JqLnJlcG9ydGluZ0NvbnRyb2xsZXIsXG4gICAgJ3JlcG9ydGluZ0luc3RhbmNlJzogb2JqLnJlcG9ydGluZ0luc3RhbmNlLFxuICAgICdzZXJpZXMnOiB0b0pzb25fRXZlbnRTZXJpZXNWMUJldGExKG9iai5zZXJpZXMpLFxuICAgICd0eXBlJzogb2JqLnR5cGUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogRXZlbnRMaXN0IGlzIGEgbGlzdCBvZiBFdmVudCBvYmplY3RzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5ldmVudHMudjFiZXRhMS5FdmVudExpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlRXZlbnRMaXN0VjFCZXRhMVByb3BzIHtcbiAgLyoqXG4gICAqIGl0ZW1zIGlzIGEgbGlzdCBvZiBzY2hlbWEgb2JqZWN0cy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmV2ZW50cy52MWJldGExLkV2ZW50TGlzdCNpdGVtc1xuICAgKi9cbiAgcmVhZG9ubHkgaXRlbXM6IEt1YmVFdmVudFYxQmV0YTFQcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBsaXN0IG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5ldmVudHMudjFiZXRhMS5FdmVudExpc3QjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogTGlzdE1ldGE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZUV2ZW50TGlzdFYxQmV0YTFQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUV2ZW50TGlzdFYxQmV0YTFQcm9wcyhvYmo6IEt1YmVFdmVudExpc3RWMUJldGExUHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdpdGVtcyc6IG9iai5pdGVtcz8ubWFwKHkgPT4gdG9Kc29uX0t1YmVFdmVudFYxQmV0YTFQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogRmxvd1NjaGVtYSBkZWZpbmVzIHRoZSBzY2hlbWEgb2YgYSBncm91cCBvZiBmbG93cy4gTm90ZSB0aGF0IGEgZmxvdyBpcyBtYWRlIHVwIG9mIGEgc2V0IG9mIGluYm91bmQgQVBJIHJlcXVlc3RzIHdpdGggc2ltaWxhciBhdHRyaWJ1dGVzIGFuZCBpcyBpZGVudGlmaWVkIGJ5IGEgcGFpciBvZiBzdHJpbmdzOiB0aGUgbmFtZSBvZiB0aGUgRmxvd1NjaGVtYSBhbmQgYSBcImZsb3cgZGlzdGluZ3Vpc2hlclwiLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLkZsb3dTY2hlbWFcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlRmxvd1NjaGVtYVYxQmV0YTFQcm9wcyB7XG4gIC8qKlxuICAgKiBgbWV0YWRhdGFgIGlzIHRoZSBzdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZmxvd2NvbnRyb2wudjFiZXRhMS5GbG93U2NoZW1hI21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIGBzcGVjYCBpcyB0aGUgc3BlY2lmaWNhdGlvbiBvZiB0aGUgZGVzaXJlZCBiZWhhdmlvciBvZiBhIEZsb3dTY2hlbWEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjc3BlYy1hbmQtc3RhdHVzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLkZsb3dTY2hlbWEjc3BlY1xuICAgKi9cbiAgcmVhZG9ubHkgc3BlYz86IEZsb3dTY2hlbWFTcGVjVjFCZXRhMTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlRmxvd1NjaGVtYVYxQmV0YTFQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUZsb3dTY2hlbWFWMUJldGExUHJvcHMob2JqOiBLdWJlRmxvd1NjaGVtYVYxQmV0YTFQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX09iamVjdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgICAnc3BlYyc6IHRvSnNvbl9GbG93U2NoZW1hU3BlY1YxQmV0YTEob2JqLnNwZWMpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEZsb3dTY2hlbWFMaXN0IGlzIGEgbGlzdCBvZiBGbG93U2NoZW1hIG9iamVjdHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuRmxvd1NjaGVtYUxpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlRmxvd1NjaGVtYUxpc3RWMUJldGExUHJvcHMge1xuICAvKipcbiAgICogYGl0ZW1zYCBpcyBhIGxpc3Qgb2YgRmxvd1NjaGVtYXMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLkZsb3dTY2hlbWFMaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZUZsb3dTY2hlbWFWMUJldGExUHJvcHNbXTtcblxuICAvKipcbiAgICogYG1ldGFkYXRhYCBpcyB0aGUgc3RhbmRhcmQgbGlzdCBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZmxvd2NvbnRyb2wudjFiZXRhMS5GbG93U2NoZW1hTGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlRmxvd1NjaGVtYUxpc3RWMUJldGExUHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVGbG93U2NoZW1hTGlzdFYxQmV0YTFQcm9wcyhvYmo6IEt1YmVGbG93U2NoZW1hTGlzdFYxQmV0YTFQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZUZsb3dTY2hlbWFWMUJldGExUHJvcHMoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9MaXN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uIHJlcHJlc2VudHMgdGhlIGNvbmZpZ3VyYXRpb24gb2YgYSBwcmlvcml0eSBsZXZlbC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuZmxvd2NvbnRyb2wudjFiZXRhMS5Qcmlvcml0eUxldmVsQ29uZmlndXJhdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVQcmlvcml0eUxldmVsQ29uZmlndXJhdGlvblYxQmV0YTFQcm9wcyB7XG4gIC8qKlxuICAgKiBgbWV0YWRhdGFgIGlzIHRoZSBzdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZmxvd2NvbnRyb2wudjFiZXRhMS5Qcmlvcml0eUxldmVsQ29uZmlndXJhdGlvbiNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBPYmplY3RNZXRhO1xuXG4gIC8qKlxuICAgKiBgc3BlY2AgaXMgdGhlIHNwZWNpZmljYXRpb24gb2YgdGhlIGRlc2lyZWQgYmVoYXZpb3Igb2YgYSBcInJlcXVlc3QtcHJpb3JpdHlcIi4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNzcGVjLWFuZC1zdGF0dXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb24jc3BlY1xuICAgKi9cbiAgcmVhZG9ubHkgc3BlYz86IFByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uU3BlY1YxQmV0YTE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZVByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uVjFCZXRhMVByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25WMUJldGExUHJvcHMob2JqOiBLdWJlUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25WMUJldGExUHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3NwZWMnOiB0b0pzb25fUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25TcGVjVjFCZXRhMShvYmouc3BlYyksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25MaXN0IGlzIGEgbGlzdCBvZiBQcmlvcml0eUxldmVsQ29uZmlndXJhdGlvbiBvYmplY3RzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLlByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uTGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVQcmlvcml0eUxldmVsQ29uZmlndXJhdGlvbkxpc3RWMUJldGExUHJvcHMge1xuICAvKipcbiAgICogYGl0ZW1zYCBpcyBhIGxpc3Qgb2YgcmVxdWVzdC1wcmlvcml0aWVzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZmxvd2NvbnRyb2wudjFiZXRhMS5Qcmlvcml0eUxldmVsQ29uZmlndXJhdGlvbkxpc3QjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zOiBLdWJlUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25WMUJldGExUHJvcHNbXTtcblxuICAvKipcbiAgICogYG1ldGFkYXRhYCBpcyB0aGUgc3RhbmRhcmQgb2JqZWN0J3MgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25MaXN0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IExpc3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVQcmlvcml0eUxldmVsQ29uZmlndXJhdGlvbkxpc3RWMUJldGExUHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVQcmlvcml0eUxldmVsQ29uZmlndXJhdGlvbkxpc3RWMUJldGExUHJvcHMob2JqOiBLdWJlUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25MaXN0VjFCZXRhMVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaXRlbXMnOiBvYmouaXRlbXM/Lm1hcCh5ID0+IHRvSnNvbl9LdWJlUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25WMUJldGExUHJvcHMoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9MaXN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEluZ3Jlc3MgaXMgYSBjb2xsZWN0aW9uIG9mIHJ1bGVzIHRoYXQgYWxsb3cgaW5ib3VuZCBjb25uZWN0aW9ucyB0byByZWFjaCB0aGUgZW5kcG9pbnRzIGRlZmluZWQgYnkgYSBiYWNrZW5kLiBBbiBJbmdyZXNzIGNhbiBiZSBjb25maWd1cmVkIHRvIGdpdmUgc2VydmljZXMgZXh0ZXJuYWxseS1yZWFjaGFibGUgdXJscywgbG9hZCBiYWxhbmNlIHRyYWZmaWMsIHRlcm1pbmF0ZSBTU0wsIG9mZmVyIG5hbWUgYmFzZWQgdmlydHVhbCBob3N0aW5nIGV0Yy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5JbmdyZXNzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZUluZ3Jlc3NQcm9wcyB7XG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5JbmdyZXNzI21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIFNwZWMgaXMgdGhlIGRlc2lyZWQgc3RhdGUgb2YgdGhlIEluZ3Jlc3MuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjc3BlYy1hbmQtc3RhdHVzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3Mjc3BlY1xuICAgKi9cbiAgcmVhZG9ubHkgc3BlYz86IEluZ3Jlc3NTcGVjO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVJbmdyZXNzUHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVJbmdyZXNzUHJvcHMob2JqOiBLdWJlSW5ncmVzc1Byb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdzcGVjJzogdG9Kc29uX0luZ3Jlc3NTcGVjKG9iai5zcGVjKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBJbmdyZXNzQ2xhc3MgcmVwcmVzZW50cyB0aGUgY2xhc3Mgb2YgdGhlIEluZ3Jlc3MsIHJlZmVyZW5jZWQgYnkgdGhlIEluZ3Jlc3MgU3BlYy4gVGhlIGBpbmdyZXNzY2xhc3Mua3ViZXJuZXRlcy5pby9pcy1kZWZhdWx0LWNsYXNzYCBhbm5vdGF0aW9uIGNhbiBiZSB1c2VkIHRvIGluZGljYXRlIHRoYXQgYW4gSW5ncmVzc0NsYXNzIHNob3VsZCBiZSBjb25zaWRlcmVkIGRlZmF1bHQuIFdoZW4gYSBzaW5nbGUgSW5ncmVzc0NsYXNzIHJlc291cmNlIGhhcyB0aGlzIGFubm90YXRpb24gc2V0IHRvIHRydWUsIG5ldyBJbmdyZXNzIHJlc291cmNlcyB3aXRob3V0IGEgY2xhc3Mgc3BlY2lmaWVkIHdpbGwgYmUgYXNzaWduZWQgdGhpcyBkZWZhdWx0IGNsYXNzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3NDbGFzc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVJbmdyZXNzQ2xhc3NQcm9wcyB7XG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5JbmdyZXNzQ2xhc3MjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogU3BlYyBpcyB0aGUgZGVzaXJlZCBzdGF0ZSBvZiB0aGUgSW5ncmVzc0NsYXNzLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3NwZWMtYW5kLXN0YXR1c1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5JbmdyZXNzQ2xhc3Mjc3BlY1xuICAgKi9cbiAgcmVhZG9ubHkgc3BlYz86IEluZ3Jlc3NDbGFzc1NwZWM7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZUluZ3Jlc3NDbGFzc1Byb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlSW5ncmVzc0NsYXNzUHJvcHMob2JqOiBLdWJlSW5ncmVzc0NsYXNzUHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3NwZWMnOiB0b0pzb25fSW5ncmVzc0NsYXNzU3BlYyhvYmouc3BlYyksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogSW5ncmVzc0NsYXNzTGlzdCBpcyBhIGNvbGxlY3Rpb24gb2YgSW5ncmVzc0NsYXNzZXMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuSW5ncmVzc0NsYXNzTGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVJbmdyZXNzQ2xhc3NMaXN0UHJvcHMge1xuICAvKipcbiAgICogSXRlbXMgaXMgdGhlIGxpc3Qgb2YgSW5ncmVzc0NsYXNzZXMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3NDbGFzc0xpc3QjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zOiBLdWJlSW5ncmVzc0NsYXNzUHJvcHNbXTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgbGlzdCBtZXRhZGF0YS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuSW5ncmVzc0NsYXNzTGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlSW5ncmVzc0NsYXNzTGlzdFByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlSW5ncmVzc0NsYXNzTGlzdFByb3BzKG9iajogS3ViZUluZ3Jlc3NDbGFzc0xpc3RQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZUluZ3Jlc3NDbGFzc1Byb3BzKHkpKSxcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fTGlzdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBJbmdyZXNzTGlzdCBpcyBhIGNvbGxlY3Rpb24gb2YgSW5ncmVzcy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5JbmdyZXNzTGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVJbmdyZXNzTGlzdFByb3BzIHtcbiAgLyoqXG4gICAqIEl0ZW1zIGlzIHRoZSBsaXN0IG9mIEluZ3Jlc3MuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3NMaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZUluZ3Jlc3NQcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5JbmdyZXNzTGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlSW5ncmVzc0xpc3RQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUluZ3Jlc3NMaXN0UHJvcHMob2JqOiBLdWJlSW5ncmVzc0xpc3RQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZUluZ3Jlc3NQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogTmV0d29ya1BvbGljeSBkZXNjcmliZXMgd2hhdCBuZXR3b3JrIHRyYWZmaWMgaXMgYWxsb3dlZCBmb3IgYSBzZXQgb2YgUG9kc1xuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLk5ldHdvcmtQb2xpY3lcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlTmV0d29ya1BvbGljeVByb3BzIHtcbiAgLyoqXG4gICAqIFN0YW5kYXJkIG9iamVjdCdzIG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLk5ldHdvcmtQb2xpY3kjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbiBvZiB0aGUgZGVzaXJlZCBiZWhhdmlvciBmb3IgdGhpcyBOZXR3b3JrUG9saWN5LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5OZXR3b3JrUG9saWN5I3NwZWNcbiAgICovXG4gIHJlYWRvbmx5IHNwZWM/OiBOZXR3b3JrUG9saWN5U3BlYztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlTmV0d29ya1BvbGljeVByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlTmV0d29ya1BvbGljeVByb3BzKG9iajogS3ViZU5ldHdvcmtQb2xpY3lQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX09iamVjdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgICAnc3BlYyc6IHRvSnNvbl9OZXR3b3JrUG9saWN5U3BlYyhvYmouc3BlYyksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogTmV0d29ya1BvbGljeUxpc3QgaXMgYSBsaXN0IG9mIE5ldHdvcmtQb2xpY3kgb2JqZWN0cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5OZXR3b3JrUG9saWN5TGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVOZXR3b3JrUG9saWN5TGlzdFByb3BzIHtcbiAgLyoqXG4gICAqIEl0ZW1zIGlzIGEgbGlzdCBvZiBzY2hlbWEgb2JqZWN0cy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuTmV0d29ya1BvbGljeUxpc3QjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zOiBLdWJlTmV0d29ya1BvbGljeVByb3BzW107XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIGxpc3QgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuTmV0d29ya1BvbGljeUxpc3QjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogTGlzdE1ldGE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZU5ldHdvcmtQb2xpY3lMaXN0UHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVOZXR3b3JrUG9saWN5TGlzdFByb3BzKG9iajogS3ViZU5ldHdvcmtQb2xpY3lMaXN0UHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdpdGVtcyc6IG9iai5pdGVtcz8ubWFwKHkgPT4gdG9Kc29uX0t1YmVOZXR3b3JrUG9saWN5UHJvcHMoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9MaXN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFJ1bnRpbWVDbGFzcyBkZWZpbmVzIGEgY2xhc3Mgb2YgY29udGFpbmVyIHJ1bnRpbWUgc3VwcG9ydGVkIGluIHRoZSBjbHVzdGVyLiBUaGUgUnVudGltZUNsYXNzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGNvbnRhaW5lciBydW50aW1lIGlzIHVzZWQgdG8gcnVuIGFsbCBjb250YWluZXJzIGluIGEgcG9kLiBSdW50aW1lQ2xhc3NlcyBhcmUgbWFudWFsbHkgZGVmaW5lZCBieSBhIHVzZXIgb3IgY2x1c3RlciBwcm92aXNpb25lciwgYW5kIHJlZmVyZW5jZWQgaW4gdGhlIFBvZFNwZWMuIFRoZSBLdWJlbGV0IGlzIHJlc3BvbnNpYmxlIGZvciByZXNvbHZpbmcgdGhlIFJ1bnRpbWVDbGFzc05hbWUgcmVmZXJlbmNlIGJlZm9yZSBydW5uaW5nIHRoZSBwb2QuICBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvY29udGFpbmVycy9ydW50aW1lLWNsYXNzL1xuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5ub2RlLnYxLlJ1bnRpbWVDbGFzc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVSdW50aW1lQ2xhc3NQcm9wcyB7XG4gIC8qKlxuICAgKiBIYW5kbGVyIHNwZWNpZmllcyB0aGUgdW5kZXJseWluZyBydW50aW1lIGFuZCBjb25maWd1cmF0aW9uIHRoYXQgdGhlIENSSSBpbXBsZW1lbnRhdGlvbiB3aWxsIHVzZSB0byBoYW5kbGUgcG9kcyBvZiB0aGlzIGNsYXNzLiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZSBzcGVjaWZpYyB0byB0aGUgbm9kZSAmIENSSSBjb25maWd1cmF0aW9uLiAgSXQgaXMgYXNzdW1lZCB0aGF0IGFsbCBoYW5kbGVycyBhcmUgYXZhaWxhYmxlIG9uIGV2ZXJ5IG5vZGUsIGFuZCBoYW5kbGVycyBvZiB0aGUgc2FtZSBuYW1lIGFyZSBlcXVpdmFsZW50IG9uIGV2ZXJ5IG5vZGUuIEZvciBleGFtcGxlLCBhIGhhbmRsZXIgY2FsbGVkIFwicnVuY1wiIG1pZ2h0IHNwZWNpZnkgdGhhdCB0aGUgcnVuYyBPQ0kgcnVudGltZSAodXNpbmcgbmF0aXZlIExpbnV4IGNvbnRhaW5lcnMpIHdpbGwgYmUgdXNlZCB0byBydW4gdGhlIGNvbnRhaW5lcnMgaW4gYSBwb2QuIFRoZSBIYW5kbGVyIG11c3QgYmUgbG93ZXJjYXNlLCBjb25mb3JtIHRvIHRoZSBETlMgTGFiZWwgKFJGQyAxMTIzKSByZXF1aXJlbWVudHMsIGFuZCBpcyBpbW11dGFibGUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5ub2RlLnYxLlJ1bnRpbWVDbGFzcyNoYW5kbGVyXG4gICAqL1xuICByZWFkb25seSBoYW5kbGVyOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5vZGUudjEuUnVudGltZUNsYXNzI21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIE92ZXJoZWFkIHJlcHJlc2VudHMgdGhlIHJlc291cmNlIG92ZXJoZWFkIGFzc29jaWF0ZWQgd2l0aCBydW5uaW5nIGEgcG9kIGZvciBhIGdpdmVuIFJ1bnRpbWVDbGFzcy4gRm9yIG1vcmUgZGV0YWlscywgc2VlXG4gICAqIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3NjaGVkdWxpbmctZXZpY3Rpb24vcG9kLW92ZXJoZWFkL1xuICAgKiBUaGlzIGZpZWxkIGlzIGluIGJldGEgc3RhcnRpbmcgdjEuMTggYW5kIGlzIG9ubHkgaG9ub3JlZCBieSBzZXJ2ZXJzIHRoYXQgZW5hYmxlIHRoZSBQb2RPdmVyaGVhZCBmZWF0dXJlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubm9kZS52MS5SdW50aW1lQ2xhc3Mjb3ZlcmhlYWRcbiAgICovXG4gIHJlYWRvbmx5IG92ZXJoZWFkPzogT3ZlcmhlYWQ7XG5cbiAgLyoqXG4gICAqIFNjaGVkdWxpbmcgaG9sZHMgdGhlIHNjaGVkdWxpbmcgY29uc3RyYWludHMgdG8gZW5zdXJlIHRoYXQgcG9kcyBydW5uaW5nIHdpdGggdGhpcyBSdW50aW1lQ2xhc3MgYXJlIHNjaGVkdWxlZCB0byBub2RlcyB0aGF0IHN1cHBvcnQgaXQuIElmIHNjaGVkdWxpbmcgaXMgbmlsLCB0aGlzIFJ1bnRpbWVDbGFzcyBpcyBhc3N1bWVkIHRvIGJlIHN1cHBvcnRlZCBieSBhbGwgbm9kZXMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5ub2RlLnYxLlJ1bnRpbWVDbGFzcyNzY2hlZHVsaW5nXG4gICAqL1xuICByZWFkb25seSBzY2hlZHVsaW5nPzogU2NoZWR1bGluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlUnVudGltZUNsYXNzUHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVSdW50aW1lQ2xhc3NQcm9wcyhvYmo6IEt1YmVSdW50aW1lQ2xhc3NQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2hhbmRsZXInOiBvYmouaGFuZGxlcixcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdvdmVyaGVhZCc6IHRvSnNvbl9PdmVyaGVhZChvYmoub3ZlcmhlYWQpLFxuICAgICdzY2hlZHVsaW5nJzogdG9Kc29uX1NjaGVkdWxpbmcob2JqLnNjaGVkdWxpbmcpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFJ1bnRpbWVDbGFzc0xpc3QgaXMgYSBsaXN0IG9mIFJ1bnRpbWVDbGFzcyBvYmplY3RzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5ub2RlLnYxLlJ1bnRpbWVDbGFzc0xpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlUnVudGltZUNsYXNzTGlzdFByb3BzIHtcbiAgLyoqXG4gICAqIEl0ZW1zIGlzIGEgbGlzdCBvZiBzY2hlbWEgb2JqZWN0cy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5vZGUudjEuUnVudGltZUNsYXNzTGlzdCNpdGVtc1xuICAgKi9cbiAgcmVhZG9ubHkgaXRlbXM6IEt1YmVSdW50aW1lQ2xhc3NQcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBsaXN0IG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5ub2RlLnYxLlJ1bnRpbWVDbGFzc0xpc3QjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogTGlzdE1ldGE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZVJ1bnRpbWVDbGFzc0xpc3RQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVJ1bnRpbWVDbGFzc0xpc3RQcm9wcyhvYmo6IEt1YmVSdW50aW1lQ2xhc3NMaXN0UHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdpdGVtcyc6IG9iai5pdGVtcz8ubWFwKHkgPT4gdG9Kc29uX0t1YmVSdW50aW1lQ2xhc3NQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUnVudGltZUNsYXNzIGRlZmluZXMgYSBjbGFzcyBvZiBjb250YWluZXIgcnVudGltZSBzdXBwb3J0ZWQgaW4gdGhlIGNsdXN0ZXIuIFRoZSBSdW50aW1lQ2xhc3MgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggY29udGFpbmVyIHJ1bnRpbWUgaXMgdXNlZCB0byBydW4gYWxsIGNvbnRhaW5lcnMgaW4gYSBwb2QuIFJ1bnRpbWVDbGFzc2VzIGFyZSAoY3VycmVudGx5KSBtYW51YWxseSBkZWZpbmVkIGJ5IGEgdXNlciBvciBjbHVzdGVyIHByb3Zpc2lvbmVyLCBhbmQgcmVmZXJlbmNlZCBpbiB0aGUgUG9kU3BlYy4gVGhlIEt1YmVsZXQgaXMgcmVzcG9uc2libGUgZm9yIHJlc29sdmluZyB0aGUgUnVudGltZUNsYXNzTmFtZSByZWZlcmVuY2UgYmVmb3JlIHJ1bm5pbmcgdGhlIHBvZC4gIEZvciBtb3JlIGRldGFpbHMsIHNlZSBodHRwczovL2dpdC5rOHMuaW8vZW5oYW5jZW1lbnRzL2tlcHMvc2lnLW5vZGUvNTg1LXJ1bnRpbWUtY2xhc3NcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkubm9kZS52MWFscGhhMS5SdW50aW1lQ2xhc3NcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlUnVudGltZUNsYXNzVjFBbHBoYTFQcm9wcyB7XG4gIC8qKlxuICAgKiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5ub2RlLnYxYWxwaGExLlJ1bnRpbWVDbGFzcyNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBPYmplY3RNZXRhO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uIG9mIHRoZSBSdW50aW1lQ2xhc3MgTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNzcGVjLWFuZC1zdGF0dXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5vZGUudjFhbHBoYTEuUnVudGltZUNsYXNzI3NwZWNcbiAgICovXG4gIHJlYWRvbmx5IHNwZWM6IFJ1bnRpbWVDbGFzc1NwZWNWMUFscGhhMTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlUnVudGltZUNsYXNzVjFBbHBoYTFQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVJ1bnRpbWVDbGFzc1YxQWxwaGExUHJvcHMob2JqOiBLdWJlUnVudGltZUNsYXNzVjFBbHBoYTFQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX09iamVjdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgICAnc3BlYyc6IHRvSnNvbl9SdW50aW1lQ2xhc3NTcGVjVjFBbHBoYTEob2JqLnNwZWMpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFJ1bnRpbWVDbGFzc0xpc3QgaXMgYSBsaXN0IG9mIFJ1bnRpbWVDbGFzcyBvYmplY3RzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5ub2RlLnYxYWxwaGExLlJ1bnRpbWVDbGFzc0xpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlUnVudGltZUNsYXNzTGlzdFYxQWxwaGExUHJvcHMge1xuICAvKipcbiAgICogSXRlbXMgaXMgYSBsaXN0IG9mIHNjaGVtYSBvYmplY3RzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubm9kZS52MWFscGhhMS5SdW50aW1lQ2xhc3NMaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZVJ1bnRpbWVDbGFzc1YxQWxwaGExUHJvcHNbXTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgbGlzdCBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubm9kZS52MWFscGhhMS5SdW50aW1lQ2xhc3NMaXN0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IExpc3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVSdW50aW1lQ2xhc3NMaXN0VjFBbHBoYTFQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVJ1bnRpbWVDbGFzc0xpc3RWMUFscGhhMVByb3BzKG9iajogS3ViZVJ1bnRpbWVDbGFzc0xpc3RWMUFscGhhMVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaXRlbXMnOiBvYmouaXRlbXM/Lm1hcCh5ID0+IHRvSnNvbl9LdWJlUnVudGltZUNsYXNzVjFBbHBoYTFQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUnVudGltZUNsYXNzIGRlZmluZXMgYSBjbGFzcyBvZiBjb250YWluZXIgcnVudGltZSBzdXBwb3J0ZWQgaW4gdGhlIGNsdXN0ZXIuIFRoZSBSdW50aW1lQ2xhc3MgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggY29udGFpbmVyIHJ1bnRpbWUgaXMgdXNlZCB0byBydW4gYWxsIGNvbnRhaW5lcnMgaW4gYSBwb2QuIFJ1bnRpbWVDbGFzc2VzIGFyZSAoY3VycmVudGx5KSBtYW51YWxseSBkZWZpbmVkIGJ5IGEgdXNlciBvciBjbHVzdGVyIHByb3Zpc2lvbmVyLCBhbmQgcmVmZXJlbmNlZCBpbiB0aGUgUG9kU3BlYy4gVGhlIEt1YmVsZXQgaXMgcmVzcG9uc2libGUgZm9yIHJlc29sdmluZyB0aGUgUnVudGltZUNsYXNzTmFtZSByZWZlcmVuY2UgYmVmb3JlIHJ1bm5pbmcgdGhlIHBvZC4gIEZvciBtb3JlIGRldGFpbHMsIHNlZSBodHRwczovL2dpdC5rOHMuaW8vZW5oYW5jZW1lbnRzL2tlcHMvc2lnLW5vZGUvNTg1LXJ1bnRpbWUtY2xhc3NcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkubm9kZS52MWJldGExLlJ1bnRpbWVDbGFzc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVSdW50aW1lQ2xhc3NWMUJldGExUHJvcHMge1xuICAvKipcbiAgICogSGFuZGxlciBzcGVjaWZpZXMgdGhlIHVuZGVybHlpbmcgcnVudGltZSBhbmQgY29uZmlndXJhdGlvbiB0aGF0IHRoZSBDUkkgaW1wbGVtZW50YXRpb24gd2lsbCB1c2UgdG8gaGFuZGxlIHBvZHMgb2YgdGhpcyBjbGFzcy4gVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmUgc3BlY2lmaWMgdG8gdGhlIG5vZGUgJiBDUkkgY29uZmlndXJhdGlvbi4gIEl0IGlzIGFzc3VtZWQgdGhhdCBhbGwgaGFuZGxlcnMgYXJlIGF2YWlsYWJsZSBvbiBldmVyeSBub2RlLCBhbmQgaGFuZGxlcnMgb2YgdGhlIHNhbWUgbmFtZSBhcmUgZXF1aXZhbGVudCBvbiBldmVyeSBub2RlLiBGb3IgZXhhbXBsZSwgYSBoYW5kbGVyIGNhbGxlZCBcInJ1bmNcIiBtaWdodCBzcGVjaWZ5IHRoYXQgdGhlIHJ1bmMgT0NJIHJ1bnRpbWUgKHVzaW5nIG5hdGl2ZSBMaW51eCBjb250YWluZXJzKSB3aWxsIGJlIHVzZWQgdG8gcnVuIHRoZSBjb250YWluZXJzIGluIGEgcG9kLiBUaGUgSGFuZGxlciBtdXN0IGJlIGxvd2VyY2FzZSwgY29uZm9ybSB0byB0aGUgRE5TIExhYmVsIChSRkMgMTEyMykgcmVxdWlyZW1lbnRzLCBhbmQgaXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubm9kZS52MWJldGExLlJ1bnRpbWVDbGFzcyNoYW5kbGVyXG4gICAqL1xuICByZWFkb25seSBoYW5kbGVyOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5vZGUudjFiZXRhMS5SdW50aW1lQ2xhc3MjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogT3ZlcmhlYWQgcmVwcmVzZW50cyB0aGUgcmVzb3VyY2Ugb3ZlcmhlYWQgYXNzb2NpYXRlZCB3aXRoIHJ1bm5pbmcgYSBwb2QgZm9yIGEgZ2l2ZW4gUnVudGltZUNsYXNzLiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9naXQuazhzLmlvL2VuaGFuY2VtZW50cy9rZXBzL3NpZy1ub2RlLzY4OC1wb2Qtb3ZlcmhlYWQvUkVBRE1FLm1kIFRoaXMgZmllbGQgaXMgYmV0YS1sZXZlbCBhcyBvZiBLdWJlcm5ldGVzIHYxLjE4LCBhbmQgaXMgb25seSBob25vcmVkIGJ5IHNlcnZlcnMgdGhhdCBlbmFibGUgdGhlIFBvZE92ZXJoZWFkIGZlYXR1cmUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5ub2RlLnYxYmV0YTEuUnVudGltZUNsYXNzI292ZXJoZWFkXG4gICAqL1xuICByZWFkb25seSBvdmVyaGVhZD86IE92ZXJoZWFkVjFCZXRhMTtcblxuICAvKipcbiAgICogU2NoZWR1bGluZyBob2xkcyB0aGUgc2NoZWR1bGluZyBjb25zdHJhaW50cyB0byBlbnN1cmUgdGhhdCBwb2RzIHJ1bm5pbmcgd2l0aCB0aGlzIFJ1bnRpbWVDbGFzcyBhcmUgc2NoZWR1bGVkIHRvIG5vZGVzIHRoYXQgc3VwcG9ydCBpdC4gSWYgc2NoZWR1bGluZyBpcyBuaWwsIHRoaXMgUnVudGltZUNsYXNzIGlzIGFzc3VtZWQgdG8gYmUgc3VwcG9ydGVkIGJ5IGFsbCBub2Rlcy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5vZGUudjFiZXRhMS5SdW50aW1lQ2xhc3Mjc2NoZWR1bGluZ1xuICAgKi9cbiAgcmVhZG9ubHkgc2NoZWR1bGluZz86IFNjaGVkdWxpbmdWMUJldGExO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVSdW50aW1lQ2xhc3NWMUJldGExUHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVSdW50aW1lQ2xhc3NWMUJldGExUHJvcHMob2JqOiBLdWJlUnVudGltZUNsYXNzVjFCZXRhMVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaGFuZGxlcic6IG9iai5oYW5kbGVyLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ292ZXJoZWFkJzogdG9Kc29uX092ZXJoZWFkVjFCZXRhMShvYmoub3ZlcmhlYWQpLFxuICAgICdzY2hlZHVsaW5nJzogdG9Kc29uX1NjaGVkdWxpbmdWMUJldGExKG9iai5zY2hlZHVsaW5nKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBSdW50aW1lQ2xhc3NMaXN0IGlzIGEgbGlzdCBvZiBSdW50aW1lQ2xhc3Mgb2JqZWN0cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkubm9kZS52MWJldGExLlJ1bnRpbWVDbGFzc0xpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlUnVudGltZUNsYXNzTGlzdFYxQmV0YTFQcm9wcyB7XG4gIC8qKlxuICAgKiBJdGVtcyBpcyBhIGxpc3Qgb2Ygc2NoZW1hIG9iamVjdHMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5ub2RlLnYxYmV0YTEuUnVudGltZUNsYXNzTGlzdCNpdGVtc1xuICAgKi9cbiAgcmVhZG9ubHkgaXRlbXM6IEt1YmVSdW50aW1lQ2xhc3NWMUJldGExUHJvcHNbXTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgbGlzdCBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubm9kZS52MWJldGExLlJ1bnRpbWVDbGFzc0xpc3QjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogTGlzdE1ldGE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZVJ1bnRpbWVDbGFzc0xpc3RWMUJldGExUHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVSdW50aW1lQ2xhc3NMaXN0VjFCZXRhMVByb3BzKG9iajogS3ViZVJ1bnRpbWVDbGFzc0xpc3RWMUJldGExUHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdpdGVtcyc6IG9iai5pdGVtcz8ubWFwKHkgPT4gdG9Kc29uX0t1YmVSdW50aW1lQ2xhc3NWMUJldGExUHJvcHMoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9MaXN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEV2aWN0aW9uIGV2aWN0cyBhIHBvZCBmcm9tIGl0cyBub2RlIHN1YmplY3QgdG8gY2VydGFpbiBwb2xpY2llcyBhbmQgc2FmZXR5IGNvbnN0cmFpbnRzLiBUaGlzIGlzIGEgc3VicmVzb3VyY2Ugb2YgUG9kLiAgQSByZXF1ZXN0IHRvIGNhdXNlIHN1Y2ggYW4gZXZpY3Rpb24gaXMgY3JlYXRlZCBieSBQT1NUaW5nIHRvIC4uLi9wb2RzLzxwb2QgbmFtZT4vZXZpY3Rpb25zLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjEuRXZpY3Rpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlRXZpY3Rpb25Qcm9wcyB7XG4gIC8qKlxuICAgKiBEZWxldGVPcHRpb25zIG1heSBiZSBwcm92aWRlZFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucG9saWN5LnYxLkV2aWN0aW9uI2RlbGV0ZU9wdGlvbnNcbiAgICovXG4gIHJlYWRvbmx5IGRlbGV0ZU9wdGlvbnM/OiBEZWxldGVPcHRpb25zO1xuXG4gIC8qKlxuICAgKiBPYmplY3RNZXRhIGRlc2NyaWJlcyB0aGUgcG9kIHRoYXQgaXMgYmVpbmcgZXZpY3RlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MS5FdmljdGlvbiNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBPYmplY3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVFdmljdGlvblByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlRXZpY3Rpb25Qcm9wcyhvYmo6IEt1YmVFdmljdGlvblByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZGVsZXRlT3B0aW9ucyc6IHRvSnNvbl9EZWxldGVPcHRpb25zKG9iai5kZWxldGVPcHRpb25zKSxcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFBvZERpc3J1cHRpb25CdWRnZXQgaXMgYW4gb2JqZWN0IHRvIGRlZmluZSB0aGUgbWF4IGRpc3J1cHRpb24gdGhhdCBjYW4gYmUgY2F1c2VkIHRvIGEgY29sbGVjdGlvbiBvZiBwb2RzXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MS5Qb2REaXNydXB0aW9uQnVkZ2V0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZVBvZERpc3J1cHRpb25CdWRnZXRQcm9wcyB7XG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucG9saWN5LnYxLlBvZERpc3J1cHRpb25CdWRnZXQjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbiBvZiB0aGUgZGVzaXJlZCBiZWhhdmlvciBvZiB0aGUgUG9kRGlzcnVwdGlvbkJ1ZGdldC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MS5Qb2REaXNydXB0aW9uQnVkZ2V0I3NwZWNcbiAgICovXG4gIHJlYWRvbmx5IHNwZWM/OiBQb2REaXNydXB0aW9uQnVkZ2V0U3BlYztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlUG9kRGlzcnVwdGlvbkJ1ZGdldFByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlUG9kRGlzcnVwdGlvbkJ1ZGdldFByb3BzKG9iajogS3ViZVBvZERpc3J1cHRpb25CdWRnZXRQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX09iamVjdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgICAnc3BlYyc6IHRvSnNvbl9Qb2REaXNydXB0aW9uQnVkZ2V0U3BlYyhvYmouc3BlYyksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUG9kRGlzcnVwdGlvbkJ1ZGdldExpc3QgaXMgYSBjb2xsZWN0aW9uIG9mIFBvZERpc3J1cHRpb25CdWRnZXRzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjEuUG9kRGlzcnVwdGlvbkJ1ZGdldExpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlUG9kRGlzcnVwdGlvbkJ1ZGdldExpc3RQcm9wcyB7XG4gIC8qKlxuICAgKiBJdGVtcyBpcyBhIGxpc3Qgb2YgUG9kRGlzcnVwdGlvbkJ1ZGdldHNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MS5Qb2REaXNydXB0aW9uQnVkZ2V0TGlzdCNpdGVtc1xuICAgKi9cbiAgcmVhZG9ubHkgaXRlbXM6IEt1YmVQb2REaXNydXB0aW9uQnVkZ2V0UHJvcHNbXTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0J3MgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MS5Qb2REaXNydXB0aW9uQnVkZ2V0TGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlUG9kRGlzcnVwdGlvbkJ1ZGdldExpc3RQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVBvZERpc3J1cHRpb25CdWRnZXRMaXN0UHJvcHMob2JqOiBLdWJlUG9kRGlzcnVwdGlvbkJ1ZGdldExpc3RQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZVBvZERpc3J1cHRpb25CdWRnZXRQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUG9kRGlzcnVwdGlvbkJ1ZGdldCBpcyBhbiBvYmplY3QgdG8gZGVmaW5lIHRoZSBtYXggZGlzcnVwdGlvbiB0aGF0IGNhbiBiZSBjYXVzZWQgdG8gYSBjb2xsZWN0aW9uIG9mIHBvZHNcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkucG9saWN5LnYxYmV0YTEuUG9kRGlzcnVwdGlvbkJ1ZGdldFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVQb2REaXNydXB0aW9uQnVkZ2V0VjFCZXRhMVByb3BzIHtcbiAgLyoqXG4gICAqIFN0YW5kYXJkIG9iamVjdCdzIG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5Qb2REaXNydXB0aW9uQnVkZ2V0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb24gb2YgdGhlIGRlc2lyZWQgYmVoYXZpb3Igb2YgdGhlIFBvZERpc3J1cHRpb25CdWRnZXQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5Qb2REaXNydXB0aW9uQnVkZ2V0I3NwZWNcbiAgICovXG4gIHJlYWRvbmx5IHNwZWM/OiBQb2REaXNydXB0aW9uQnVkZ2V0U3BlY1YxQmV0YTE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZVBvZERpc3J1cHRpb25CdWRnZXRWMUJldGExUHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVQb2REaXNydXB0aW9uQnVkZ2V0VjFCZXRhMVByb3BzKG9iajogS3ViZVBvZERpc3J1cHRpb25CdWRnZXRWMUJldGExUHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3NwZWMnOiB0b0pzb25fUG9kRGlzcnVwdGlvbkJ1ZGdldFNwZWNWMUJldGExKG9iai5zcGVjKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBQb2REaXNydXB0aW9uQnVkZ2V0TGlzdCBpcyBhIGNvbGxlY3Rpb24gb2YgUG9kRGlzcnVwdGlvbkJ1ZGdldHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlBvZERpc3J1cHRpb25CdWRnZXRMaXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZVBvZERpc3J1cHRpb25CdWRnZXRMaXN0VjFCZXRhMVByb3BzIHtcbiAgLyoqXG4gICAqIGl0ZW1zIGxpc3QgaW5kaXZpZHVhbCBQb2REaXNydXB0aW9uQnVkZ2V0IG9iamVjdHNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlBvZERpc3J1cHRpb25CdWRnZXRMaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZVBvZERpc3J1cHRpb25CdWRnZXRWMUJldGExUHJvcHNbXTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0J3MgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlBvZERpc3J1cHRpb25CdWRnZXRMaXN0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IExpc3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVQb2REaXNydXB0aW9uQnVkZ2V0TGlzdFYxQmV0YTFQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVBvZERpc3J1cHRpb25CdWRnZXRMaXN0VjFCZXRhMVByb3BzKG9iajogS3ViZVBvZERpc3J1cHRpb25CdWRnZXRMaXN0VjFCZXRhMVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaXRlbXMnOiBvYmouaXRlbXM/Lm1hcCh5ID0+IHRvSnNvbl9LdWJlUG9kRGlzcnVwdGlvbkJ1ZGdldFYxQmV0YTFQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUG9kU2VjdXJpdHlQb2xpY3kgZ292ZXJucyB0aGUgYWJpbGl0eSB0byBtYWtlIHJlcXVlc3RzIHRoYXQgYWZmZWN0IHRoZSBTZWN1cml0eSBDb250ZXh0IHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGEgcG9kIGFuZCBjb250YWluZXIuIERlcHJlY2F0ZWQgaW4gMS4yMS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkucG9saWN5LnYxYmV0YTEuUG9kU2VjdXJpdHlQb2xpY3lcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlUG9kU2VjdXJpdHlQb2xpY3lWMUJldGExUHJvcHMge1xuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0J3MgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlBvZFNlY3VyaXR5UG9saWN5I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIHNwZWMgZGVmaW5lcyB0aGUgcG9saWN5IGVuZm9yY2VkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucG9saWN5LnYxYmV0YTEuUG9kU2VjdXJpdHlQb2xpY3kjc3BlY1xuICAgKi9cbiAgcmVhZG9ubHkgc3BlYz86IFBvZFNlY3VyaXR5UG9saWN5U3BlY1YxQmV0YTE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZVBvZFNlY3VyaXR5UG9saWN5VjFCZXRhMVByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlUG9kU2VjdXJpdHlQb2xpY3lWMUJldGExUHJvcHMob2JqOiBLdWJlUG9kU2VjdXJpdHlQb2xpY3lWMUJldGExUHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3NwZWMnOiB0b0pzb25fUG9kU2VjdXJpdHlQb2xpY3lTcGVjVjFCZXRhMShvYmouc3BlYyksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUG9kU2VjdXJpdHlQb2xpY3lMaXN0IGlzIGEgbGlzdCBvZiBQb2RTZWN1cml0eVBvbGljeSBvYmplY3RzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5Qb2RTZWN1cml0eVBvbGljeUxpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlUG9kU2VjdXJpdHlQb2xpY3lMaXN0VjFCZXRhMVByb3BzIHtcbiAgLyoqXG4gICAqIGl0ZW1zIGlzIGEgbGlzdCBvZiBzY2hlbWEgb2JqZWN0cy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlBvZFNlY3VyaXR5UG9saWN5TGlzdCNpdGVtc1xuICAgKi9cbiAgcmVhZG9ubHkgaXRlbXM6IEt1YmVQb2RTZWN1cml0eVBvbGljeVYxQmV0YTFQcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBsaXN0IG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5Qb2RTZWN1cml0eVBvbGljeUxpc3QjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogTGlzdE1ldGE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZVBvZFNlY3VyaXR5UG9saWN5TGlzdFYxQmV0YTFQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVBvZFNlY3VyaXR5UG9saWN5TGlzdFYxQmV0YTFQcm9wcyhvYmo6IEt1YmVQb2RTZWN1cml0eVBvbGljeUxpc3RWMUJldGExUHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdpdGVtcyc6IG9iai5pdGVtcz8ubWFwKHkgPT4gdG9Kc29uX0t1YmVQb2RTZWN1cml0eVBvbGljeVYxQmV0YTFQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQ2x1c3RlclJvbGUgaXMgYSBjbHVzdGVyIGxldmVsLCBsb2dpY2FsIGdyb3VwaW5nIG9mIFBvbGljeVJ1bGVzIHRoYXQgY2FuIGJlIHJlZmVyZW5jZWQgYXMgYSB1bml0IGJ5IGEgUm9sZUJpbmRpbmcgb3IgQ2x1c3RlclJvbGVCaW5kaW5nLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxLkNsdXN0ZXJSb2xlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZUNsdXN0ZXJSb2xlUHJvcHMge1xuICAvKipcbiAgICogQWdncmVnYXRpb25SdWxlIGlzIGFuIG9wdGlvbmFsIGZpZWxkIHRoYXQgZGVzY3JpYmVzIGhvdyB0byBidWlsZCB0aGUgUnVsZXMgZm9yIHRoaXMgQ2x1c3RlclJvbGUuIElmIEFnZ3JlZ2F0aW9uUnVsZSBpcyBzZXQsIHRoZW4gdGhlIFJ1bGVzIGFyZSBjb250cm9sbGVyIG1hbmFnZWQgYW5kIGRpcmVjdCBjaGFuZ2VzIHRvIFJ1bGVzIHdpbGwgYmUgc3RvbXBlZCBieSB0aGUgY29udHJvbGxlci5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjEuQ2x1c3RlclJvbGUjYWdncmVnYXRpb25SdWxlXG4gICAqL1xuICByZWFkb25seSBhZ2dyZWdhdGlvblJ1bGU/OiBBZ2dyZWdhdGlvblJ1bGU7XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIG9iamVjdCdzIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MS5DbHVzdGVyUm9sZSNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBPYmplY3RNZXRhO1xuXG4gIC8qKlxuICAgKiBSdWxlcyBob2xkcyBhbGwgdGhlIFBvbGljeVJ1bGVzIGZvciB0aGlzIENsdXN0ZXJSb2xlXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxLkNsdXN0ZXJSb2xlI3J1bGVzXG4gICAqL1xuICByZWFkb25seSBydWxlcz86IFBvbGljeVJ1bGVbXTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlQ2x1c3RlclJvbGVQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUNsdXN0ZXJSb2xlUHJvcHMob2JqOiBLdWJlQ2x1c3RlclJvbGVQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2FnZ3JlZ2F0aW9uUnVsZSc6IHRvSnNvbl9BZ2dyZWdhdGlvblJ1bGUob2JqLmFnZ3JlZ2F0aW9uUnVsZSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX09iamVjdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgICAncnVsZXMnOiBvYmoucnVsZXM/Lm1hcCh5ID0+IHRvSnNvbl9Qb2xpY3lSdWxlKHkpKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBDbHVzdGVyUm9sZUJpbmRpbmcgcmVmZXJlbmNlcyBhIENsdXN0ZXJSb2xlLCBidXQgbm90IGNvbnRhaW4gaXQuICBJdCBjYW4gcmVmZXJlbmNlIGEgQ2x1c3RlclJvbGUgaW4gdGhlIGdsb2JhbCBuYW1lc3BhY2UsIGFuZCBhZGRzIHdobyBpbmZvcm1hdGlvbiB2aWEgU3ViamVjdC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MS5DbHVzdGVyUm9sZUJpbmRpbmdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlQ2x1c3RlclJvbGVCaW5kaW5nUHJvcHMge1xuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0J3MgbWV0YWRhdGEuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxLkNsdXN0ZXJSb2xlQmluZGluZyNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBPYmplY3RNZXRhO1xuXG4gIC8qKlxuICAgKiBSb2xlUmVmIGNhbiBvbmx5IHJlZmVyZW5jZSBhIENsdXN0ZXJSb2xlIGluIHRoZSBnbG9iYWwgbmFtZXNwYWNlLiBJZiB0aGUgUm9sZVJlZiBjYW5ub3QgYmUgcmVzb2x2ZWQsIHRoZSBBdXRob3JpemVyIG11c3QgcmV0dXJuIGFuIGVycm9yLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MS5DbHVzdGVyUm9sZUJpbmRpbmcjcm9sZVJlZlxuICAgKi9cbiAgcmVhZG9ubHkgcm9sZVJlZjogUm9sZVJlZjtcblxuICAvKipcbiAgICogU3ViamVjdHMgaG9sZHMgcmVmZXJlbmNlcyB0byB0aGUgb2JqZWN0cyB0aGUgcm9sZSBhcHBsaWVzIHRvLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MS5DbHVzdGVyUm9sZUJpbmRpbmcjc3ViamVjdHNcbiAgICovXG4gIHJlYWRvbmx5IHN1YmplY3RzPzogU3ViamVjdFtdO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVDbHVzdGVyUm9sZUJpbmRpbmdQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUNsdXN0ZXJSb2xlQmluZGluZ1Byb3BzKG9iajogS3ViZUNsdXN0ZXJSb2xlQmluZGluZ1Byb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdyb2xlUmVmJzogdG9Kc29uX1JvbGVSZWYob2JqLnJvbGVSZWYpLFxuICAgICdzdWJqZWN0cyc6IG9iai5zdWJqZWN0cz8ubWFwKHkgPT4gdG9Kc29uX1N1YmplY3QoeSkpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIENsdXN0ZXJSb2xlQmluZGluZ0xpc3QgaXMgYSBjb2xsZWN0aW9uIG9mIENsdXN0ZXJSb2xlQmluZGluZ3NcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MS5DbHVzdGVyUm9sZUJpbmRpbmdMaXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZUNsdXN0ZXJSb2xlQmluZGluZ0xpc3RQcm9wcyB7XG4gIC8qKlxuICAgKiBJdGVtcyBpcyBhIGxpc3Qgb2YgQ2x1c3RlclJvbGVCaW5kaW5nc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MS5DbHVzdGVyUm9sZUJpbmRpbmdMaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZUNsdXN0ZXJSb2xlQmluZGluZ1Byb3BzW107XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIG9iamVjdCdzIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MS5DbHVzdGVyUm9sZUJpbmRpbmdMaXN0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IExpc3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVDbHVzdGVyUm9sZUJpbmRpbmdMaXN0UHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVDbHVzdGVyUm9sZUJpbmRpbmdMaXN0UHJvcHMob2JqOiBLdWJlQ2x1c3RlclJvbGVCaW5kaW5nTGlzdFByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaXRlbXMnOiBvYmouaXRlbXM/Lm1hcCh5ID0+IHRvSnNvbl9LdWJlQ2x1c3RlclJvbGVCaW5kaW5nUHJvcHMoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9MaXN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIENsdXN0ZXJSb2xlTGlzdCBpcyBhIGNvbGxlY3Rpb24gb2YgQ2x1c3RlclJvbGVzXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjEuQ2x1c3RlclJvbGVMaXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZUNsdXN0ZXJSb2xlTGlzdFByb3BzIHtcbiAgLyoqXG4gICAqIEl0ZW1zIGlzIGEgbGlzdCBvZiBDbHVzdGVyUm9sZXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjEuQ2x1c3RlclJvbGVMaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZUNsdXN0ZXJSb2xlUHJvcHNbXTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0J3MgbWV0YWRhdGEuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxLkNsdXN0ZXJSb2xlTGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlQ2x1c3RlclJvbGVMaXN0UHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVDbHVzdGVyUm9sZUxpc3RQcm9wcyhvYmo6IEt1YmVDbHVzdGVyUm9sZUxpc3RQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZUNsdXN0ZXJSb2xlUHJvcHMoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9MaXN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFJvbGUgaXMgYSBuYW1lc3BhY2VkLCBsb2dpY2FsIGdyb3VwaW5nIG9mIFBvbGljeVJ1bGVzIHRoYXQgY2FuIGJlIHJlZmVyZW5jZWQgYXMgYSB1bml0IGJ5IGEgUm9sZUJpbmRpbmcuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjEuUm9sZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVSb2xlUHJvcHMge1xuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0J3MgbWV0YWRhdGEuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxLlJvbGUjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogUnVsZXMgaG9sZHMgYWxsIHRoZSBQb2xpY3lSdWxlcyBmb3IgdGhpcyBSb2xlXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxLlJvbGUjcnVsZXNcbiAgICovXG4gIHJlYWRvbmx5IHJ1bGVzPzogUG9saWN5UnVsZVtdO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVSb2xlUHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVSb2xlUHJvcHMob2JqOiBLdWJlUm9sZVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdydWxlcyc6IG9iai5ydWxlcz8ubWFwKHkgPT4gdG9Kc29uX1BvbGljeVJ1bGUoeSkpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFJvbGVCaW5kaW5nIHJlZmVyZW5jZXMgYSByb2xlLCBidXQgZG9lcyBub3QgY29udGFpbiBpdC4gIEl0IGNhbiByZWZlcmVuY2UgYSBSb2xlIGluIHRoZSBzYW1lIG5hbWVzcGFjZSBvciBhIENsdXN0ZXJSb2xlIGluIHRoZSBnbG9iYWwgbmFtZXNwYWNlLiBJdCBhZGRzIHdobyBpbmZvcm1hdGlvbiB2aWEgU3ViamVjdHMgYW5kIG5hbWVzcGFjZSBpbmZvcm1hdGlvbiBieSB3aGljaCBuYW1lc3BhY2UgaXQgZXhpc3RzIGluLiAgUm9sZUJpbmRpbmdzIGluIGEgZ2l2ZW4gbmFtZXNwYWNlIG9ubHkgaGF2ZSBlZmZlY3QgaW4gdGhhdCBuYW1lc3BhY2UuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjEuUm9sZUJpbmRpbmdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlUm9sZUJpbmRpbmdQcm9wcyB7XG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjEuUm9sZUJpbmRpbmcjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogUm9sZVJlZiBjYW4gcmVmZXJlbmNlIGEgUm9sZSBpbiB0aGUgY3VycmVudCBuYW1lc3BhY2Ugb3IgYSBDbHVzdGVyUm9sZSBpbiB0aGUgZ2xvYmFsIG5hbWVzcGFjZS4gSWYgdGhlIFJvbGVSZWYgY2Fubm90IGJlIHJlc29sdmVkLCB0aGUgQXV0aG9yaXplciBtdXN0IHJldHVybiBhbiBlcnJvci5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjEuUm9sZUJpbmRpbmcjcm9sZVJlZlxuICAgKi9cbiAgcmVhZG9ubHkgcm9sZVJlZjogUm9sZVJlZjtcblxuICAvKipcbiAgICogU3ViamVjdHMgaG9sZHMgcmVmZXJlbmNlcyB0byB0aGUgb2JqZWN0cyB0aGUgcm9sZSBhcHBsaWVzIHRvLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MS5Sb2xlQmluZGluZyNzdWJqZWN0c1xuICAgKi9cbiAgcmVhZG9ubHkgc3ViamVjdHM/OiBTdWJqZWN0W107XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZVJvbGVCaW5kaW5nUHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVSb2xlQmluZGluZ1Byb3BzKG9iajogS3ViZVJvbGVCaW5kaW5nUHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3JvbGVSZWYnOiB0b0pzb25fUm9sZVJlZihvYmoucm9sZVJlZiksXG4gICAgJ3N1YmplY3RzJzogb2JqLnN1YmplY3RzPy5tYXAoeSA9PiB0b0pzb25fU3ViamVjdCh5KSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUm9sZUJpbmRpbmdMaXN0IGlzIGEgY29sbGVjdGlvbiBvZiBSb2xlQmluZGluZ3NcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MS5Sb2xlQmluZGluZ0xpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlUm9sZUJpbmRpbmdMaXN0UHJvcHMge1xuICAvKipcbiAgICogSXRlbXMgaXMgYSBsaXN0IG9mIFJvbGVCaW5kaW5nc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MS5Sb2xlQmluZGluZ0xpc3QjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zOiBLdWJlUm9sZUJpbmRpbmdQcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjEuUm9sZUJpbmRpbmdMaXN0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IExpc3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVSb2xlQmluZGluZ0xpc3RQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVJvbGVCaW5kaW5nTGlzdFByb3BzKG9iajogS3ViZVJvbGVCaW5kaW5nTGlzdFByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaXRlbXMnOiBvYmouaXRlbXM/Lm1hcCh5ID0+IHRvSnNvbl9LdWJlUm9sZUJpbmRpbmdQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUm9sZUxpc3QgaXMgYSBjb2xsZWN0aW9uIG9mIFJvbGVzXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjEuUm9sZUxpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlUm9sZUxpc3RQcm9wcyB7XG4gIC8qKlxuICAgKiBJdGVtcyBpcyBhIGxpc3Qgb2YgUm9sZXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjEuUm9sZUxpc3QjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zOiBLdWJlUm9sZVByb3BzW107XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIG9iamVjdCdzIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MS5Sb2xlTGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlUm9sZUxpc3RQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVJvbGVMaXN0UHJvcHMob2JqOiBLdWJlUm9sZUxpc3RQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZVJvbGVQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQ2x1c3RlclJvbGUgaXMgYSBjbHVzdGVyIGxldmVsLCBsb2dpY2FsIGdyb3VwaW5nIG9mIFBvbGljeVJ1bGVzIHRoYXQgY2FuIGJlIHJlZmVyZW5jZWQgYXMgYSB1bml0IGJ5IGEgUm9sZUJpbmRpbmcgb3IgQ2x1c3RlclJvbGVCaW5kaW5nLiBEZXByZWNhdGVkIGluIHYxLjE3IGluIGZhdm9yIG9mIHJiYWMuYXV0aG9yaXphdGlvbi5rOHMuaW8vdjEgQ2x1c3RlclJvbGUsIGFuZCB3aWxsIG5vIGxvbmdlciBiZSBzZXJ2ZWQgaW4gdjEuMjIuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuQ2x1c3RlclJvbGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlQ2x1c3RlclJvbGVWMUFscGhhMVByb3BzIHtcbiAgLyoqXG4gICAqIEFnZ3JlZ2F0aW9uUnVsZSBpcyBhbiBvcHRpb25hbCBmaWVsZCB0aGF0IGRlc2NyaWJlcyBob3cgdG8gYnVpbGQgdGhlIFJ1bGVzIGZvciB0aGlzIENsdXN0ZXJSb2xlLiBJZiBBZ2dyZWdhdGlvblJ1bGUgaXMgc2V0LCB0aGVuIHRoZSBSdWxlcyBhcmUgY29udHJvbGxlciBtYW5hZ2VkIGFuZCBkaXJlY3QgY2hhbmdlcyB0byBSdWxlcyB3aWxsIGJlIHN0b21wZWQgYnkgdGhlIGNvbnRyb2xsZXIuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxYWxwaGExLkNsdXN0ZXJSb2xlI2FnZ3JlZ2F0aW9uUnVsZVxuICAgKi9cbiAgcmVhZG9ubHkgYWdncmVnYXRpb25SdWxlPzogQWdncmVnYXRpb25SdWxlVjFBbHBoYTE7XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIG9iamVjdCdzIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MWFscGhhMS5DbHVzdGVyUm9sZSNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBPYmplY3RNZXRhO1xuXG4gIC8qKlxuICAgKiBSdWxlcyBob2xkcyBhbGwgdGhlIFBvbGljeVJ1bGVzIGZvciB0aGlzIENsdXN0ZXJSb2xlXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxYWxwaGExLkNsdXN0ZXJSb2xlI3J1bGVzXG4gICAqL1xuICByZWFkb25seSBydWxlcz86IFBvbGljeVJ1bGVWMUFscGhhMVtdO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVDbHVzdGVyUm9sZVYxQWxwaGExUHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVDbHVzdGVyUm9sZVYxQWxwaGExUHJvcHMob2JqOiBLdWJlQ2x1c3RlclJvbGVWMUFscGhhMVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnYWdncmVnYXRpb25SdWxlJzogdG9Kc29uX0FnZ3JlZ2F0aW9uUnVsZVYxQWxwaGExKG9iai5hZ2dyZWdhdGlvblJ1bGUpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3J1bGVzJzogb2JqLnJ1bGVzPy5tYXAoeSA9PiB0b0pzb25fUG9saWN5UnVsZVYxQWxwaGExKHkpKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBDbHVzdGVyUm9sZUJpbmRpbmcgcmVmZXJlbmNlcyBhIENsdXN0ZXJSb2xlLCBidXQgbm90IGNvbnRhaW4gaXQuICBJdCBjYW4gcmVmZXJlbmNlIGEgQ2x1c3RlclJvbGUgaW4gdGhlIGdsb2JhbCBuYW1lc3BhY2UsIGFuZCBhZGRzIHdobyBpbmZvcm1hdGlvbiB2aWEgU3ViamVjdC4gRGVwcmVjYXRlZCBpbiB2MS4xNyBpbiBmYXZvciBvZiByYmFjLmF1dGhvcml6YXRpb24uazhzLmlvL3YxIENsdXN0ZXJSb2xlQmluZGluZywgYW5kIHdpbGwgbm8gbG9uZ2VyIGJlIHNlcnZlZCBpbiB2MS4yMi5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MWFscGhhMS5DbHVzdGVyUm9sZUJpbmRpbmdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlQ2x1c3RlclJvbGVCaW5kaW5nVjFBbHBoYTFQcm9wcyB7XG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuQ2x1c3RlclJvbGVCaW5kaW5nI21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIFJvbGVSZWYgY2FuIG9ubHkgcmVmZXJlbmNlIGEgQ2x1c3RlclJvbGUgaW4gdGhlIGdsb2JhbCBuYW1lc3BhY2UuIElmIHRoZSBSb2xlUmVmIGNhbm5vdCBiZSByZXNvbHZlZCwgdGhlIEF1dGhvcml6ZXIgbXVzdCByZXR1cm4gYW4gZXJyb3IuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxYWxwaGExLkNsdXN0ZXJSb2xlQmluZGluZyNyb2xlUmVmXG4gICAqL1xuICByZWFkb25seSByb2xlUmVmOiBSb2xlUmVmVjFBbHBoYTE7XG5cbiAgLyoqXG4gICAqIFN1YmplY3RzIGhvbGRzIHJlZmVyZW5jZXMgdG8gdGhlIG9iamVjdHMgdGhlIHJvbGUgYXBwbGllcyB0by5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuQ2x1c3RlclJvbGVCaW5kaW5nI3N1YmplY3RzXG4gICAqL1xuICByZWFkb25seSBzdWJqZWN0cz86IFN1YmplY3RWMUFscGhhMVtdO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVDbHVzdGVyUm9sZUJpbmRpbmdWMUFscGhhMVByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlQ2x1c3RlclJvbGVCaW5kaW5nVjFBbHBoYTFQcm9wcyhvYmo6IEt1YmVDbHVzdGVyUm9sZUJpbmRpbmdWMUFscGhhMVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdyb2xlUmVmJzogdG9Kc29uX1JvbGVSZWZWMUFscGhhMShvYmoucm9sZVJlZiksXG4gICAgJ3N1YmplY3RzJzogb2JqLnN1YmplY3RzPy5tYXAoeSA9PiB0b0pzb25fU3ViamVjdFYxQWxwaGExKHkpKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBDbHVzdGVyUm9sZUJpbmRpbmdMaXN0IGlzIGEgY29sbGVjdGlvbiBvZiBDbHVzdGVyUm9sZUJpbmRpbmdzLiBEZXByZWNhdGVkIGluIHYxLjE3IGluIGZhdm9yIG9mIHJiYWMuYXV0aG9yaXphdGlvbi5rOHMuaW8vdjEgQ2x1c3RlclJvbGVCaW5kaW5ncywgYW5kIHdpbGwgbm8gbG9uZ2VyIGJlIHNlcnZlZCBpbiB2MS4yMi5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MWFscGhhMS5DbHVzdGVyUm9sZUJpbmRpbmdMaXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZUNsdXN0ZXJSb2xlQmluZGluZ0xpc3RWMUFscGhhMVByb3BzIHtcbiAgLyoqXG4gICAqIEl0ZW1zIGlzIGEgbGlzdCBvZiBDbHVzdGVyUm9sZUJpbmRpbmdzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxYWxwaGExLkNsdXN0ZXJSb2xlQmluZGluZ0xpc3QjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zOiBLdWJlQ2x1c3RlclJvbGVCaW5kaW5nVjFBbHBoYTFQcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuQ2x1c3RlclJvbGVCaW5kaW5nTGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlQ2x1c3RlclJvbGVCaW5kaW5nTGlzdFYxQWxwaGExUHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVDbHVzdGVyUm9sZUJpbmRpbmdMaXN0VjFBbHBoYTFQcm9wcyhvYmo6IEt1YmVDbHVzdGVyUm9sZUJpbmRpbmdMaXN0VjFBbHBoYTFQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZUNsdXN0ZXJSb2xlQmluZGluZ1YxQWxwaGExUHJvcHMoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9MaXN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIENsdXN0ZXJSb2xlTGlzdCBpcyBhIGNvbGxlY3Rpb24gb2YgQ2x1c3RlclJvbGVzLiBEZXByZWNhdGVkIGluIHYxLjE3IGluIGZhdm9yIG9mIHJiYWMuYXV0aG9yaXphdGlvbi5rOHMuaW8vdjEgQ2x1c3RlclJvbGVzLCBhbmQgd2lsbCBubyBsb25nZXIgYmUgc2VydmVkIGluIHYxLjIyLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxYWxwaGExLkNsdXN0ZXJSb2xlTGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVDbHVzdGVyUm9sZUxpc3RWMUFscGhhMVByb3BzIHtcbiAgLyoqXG4gICAqIEl0ZW1zIGlzIGEgbGlzdCBvZiBDbHVzdGVyUm9sZXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuQ2x1c3RlclJvbGVMaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZUNsdXN0ZXJSb2xlVjFBbHBoYTFQcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuQ2x1c3RlclJvbGVMaXN0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IExpc3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVDbHVzdGVyUm9sZUxpc3RWMUFscGhhMVByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlQ2x1c3RlclJvbGVMaXN0VjFBbHBoYTFQcm9wcyhvYmo6IEt1YmVDbHVzdGVyUm9sZUxpc3RWMUFscGhhMVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaXRlbXMnOiBvYmouaXRlbXM/Lm1hcCh5ID0+IHRvSnNvbl9LdWJlQ2x1c3RlclJvbGVWMUFscGhhMVByb3BzKHkpKSxcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fTGlzdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBSb2xlIGlzIGEgbmFtZXNwYWNlZCwgbG9naWNhbCBncm91cGluZyBvZiBQb2xpY3lSdWxlcyB0aGF0IGNhbiBiZSByZWZlcmVuY2VkIGFzIGEgdW5pdCBieSBhIFJvbGVCaW5kaW5nLiBEZXByZWNhdGVkIGluIHYxLjE3IGluIGZhdm9yIG9mIHJiYWMuYXV0aG9yaXphdGlvbi5rOHMuaW8vdjEgUm9sZSwgYW5kIHdpbGwgbm8gbG9uZ2VyIGJlIHNlcnZlZCBpbiB2MS4yMi5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MWFscGhhMS5Sb2xlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZVJvbGVWMUFscGhhMVByb3BzIHtcbiAgLyoqXG4gICAqIFN0YW5kYXJkIG9iamVjdCdzIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MWFscGhhMS5Sb2xlI21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIFJ1bGVzIGhvbGRzIGFsbCB0aGUgUG9saWN5UnVsZXMgZm9yIHRoaXMgUm9sZVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MWFscGhhMS5Sb2xlI3J1bGVzXG4gICAqL1xuICByZWFkb25seSBydWxlcz86IFBvbGljeVJ1bGVWMUFscGhhMVtdO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVSb2xlVjFBbHBoYTFQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVJvbGVWMUFscGhhMVByb3BzKG9iajogS3ViZVJvbGVWMUFscGhhMVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdydWxlcyc6IG9iai5ydWxlcz8ubWFwKHkgPT4gdG9Kc29uX1BvbGljeVJ1bGVWMUFscGhhMSh5KSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUm9sZUJpbmRpbmcgcmVmZXJlbmNlcyBhIHJvbGUsIGJ1dCBkb2VzIG5vdCBjb250YWluIGl0LiAgSXQgY2FuIHJlZmVyZW5jZSBhIFJvbGUgaW4gdGhlIHNhbWUgbmFtZXNwYWNlIG9yIGEgQ2x1c3RlclJvbGUgaW4gdGhlIGdsb2JhbCBuYW1lc3BhY2UuIEl0IGFkZHMgd2hvIGluZm9ybWF0aW9uIHZpYSBTdWJqZWN0cyBhbmQgbmFtZXNwYWNlIGluZm9ybWF0aW9uIGJ5IHdoaWNoIG5hbWVzcGFjZSBpdCBleGlzdHMgaW4uICBSb2xlQmluZGluZ3MgaW4gYSBnaXZlbiBuYW1lc3BhY2Ugb25seSBoYXZlIGVmZmVjdCBpbiB0aGF0IG5hbWVzcGFjZS4gRGVwcmVjYXRlZCBpbiB2MS4xNyBpbiBmYXZvciBvZiByYmFjLmF1dGhvcml6YXRpb24uazhzLmlvL3YxIFJvbGVCaW5kaW5nLCBhbmQgd2lsbCBubyBsb25nZXIgYmUgc2VydmVkIGluIHYxLjIyLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxYWxwaGExLlJvbGVCaW5kaW5nXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZVJvbGVCaW5kaW5nVjFBbHBoYTFQcm9wcyB7XG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuUm9sZUJpbmRpbmcjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogUm9sZVJlZiBjYW4gcmVmZXJlbmNlIGEgUm9sZSBpbiB0aGUgY3VycmVudCBuYW1lc3BhY2Ugb3IgYSBDbHVzdGVyUm9sZSBpbiB0aGUgZ2xvYmFsIG5hbWVzcGFjZS4gSWYgdGhlIFJvbGVSZWYgY2Fubm90IGJlIHJlc29sdmVkLCB0aGUgQXV0aG9yaXplciBtdXN0IHJldHVybiBhbiBlcnJvci5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuUm9sZUJpbmRpbmcjcm9sZVJlZlxuICAgKi9cbiAgcmVhZG9ubHkgcm9sZVJlZjogUm9sZVJlZlYxQWxwaGExO1xuXG4gIC8qKlxuICAgKiBTdWJqZWN0cyBob2xkcyByZWZlcmVuY2VzIHRvIHRoZSBvYmplY3RzIHRoZSByb2xlIGFwcGxpZXMgdG8uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxYWxwaGExLlJvbGVCaW5kaW5nI3N1YmplY3RzXG4gICAqL1xuICByZWFkb25seSBzdWJqZWN0cz86IFN1YmplY3RWMUFscGhhMVtdO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVSb2xlQmluZGluZ1YxQWxwaGExUHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVSb2xlQmluZGluZ1YxQWxwaGExUHJvcHMob2JqOiBLdWJlUm9sZUJpbmRpbmdWMUFscGhhMVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdyb2xlUmVmJzogdG9Kc29uX1JvbGVSZWZWMUFscGhhMShvYmoucm9sZVJlZiksXG4gICAgJ3N1YmplY3RzJzogb2JqLnN1YmplY3RzPy5tYXAoeSA9PiB0b0pzb25fU3ViamVjdFYxQWxwaGExKHkpKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBSb2xlQmluZGluZ0xpc3QgaXMgYSBjb2xsZWN0aW9uIG9mIFJvbGVCaW5kaW5ncyBEZXByZWNhdGVkIGluIHYxLjE3IGluIGZhdm9yIG9mIHJiYWMuYXV0aG9yaXphdGlvbi5rOHMuaW8vdjEgUm9sZUJpbmRpbmdMaXN0LCBhbmQgd2lsbCBubyBsb25nZXIgYmUgc2VydmVkIGluIHYxLjIyLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxYWxwaGExLlJvbGVCaW5kaW5nTGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVSb2xlQmluZGluZ0xpc3RWMUFscGhhMVByb3BzIHtcbiAgLyoqXG4gICAqIEl0ZW1zIGlzIGEgbGlzdCBvZiBSb2xlQmluZGluZ3NcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuUm9sZUJpbmRpbmdMaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZVJvbGVCaW5kaW5nVjFBbHBoYTFQcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuUm9sZUJpbmRpbmdMaXN0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IExpc3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVSb2xlQmluZGluZ0xpc3RWMUFscGhhMVByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlUm9sZUJpbmRpbmdMaXN0VjFBbHBoYTFQcm9wcyhvYmo6IEt1YmVSb2xlQmluZGluZ0xpc3RWMUFscGhhMVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaXRlbXMnOiBvYmouaXRlbXM/Lm1hcCh5ID0+IHRvSnNvbl9LdWJlUm9sZUJpbmRpbmdWMUFscGhhMVByb3BzKHkpKSxcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fTGlzdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBSb2xlTGlzdCBpcyBhIGNvbGxlY3Rpb24gb2YgUm9sZXMuIERlcHJlY2F0ZWQgaW4gdjEuMTcgaW4gZmF2b3Igb2YgcmJhYy5hdXRob3JpemF0aW9uLms4cy5pby92MSBSb2xlTGlzdCwgYW5kIHdpbGwgbm8gbG9uZ2VyIGJlIHNlcnZlZCBpbiB2MS4yMi5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MWFscGhhMS5Sb2xlTGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVSb2xlTGlzdFYxQWxwaGExUHJvcHMge1xuICAvKipcbiAgICogSXRlbXMgaXMgYSBsaXN0IG9mIFJvbGVzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxYWxwaGExLlJvbGVMaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZVJvbGVWMUFscGhhMVByb3BzW107XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIG9iamVjdCdzIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MWFscGhhMS5Sb2xlTGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlUm9sZUxpc3RWMUFscGhhMVByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlUm9sZUxpc3RWMUFscGhhMVByb3BzKG9iajogS3ViZVJvbGVMaXN0VjFBbHBoYTFQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZVJvbGVWMUFscGhhMVByb3BzKHkpKSxcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fTGlzdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBQcmlvcml0eUNsYXNzIGRlZmluZXMgbWFwcGluZyBmcm9tIGEgcHJpb3JpdHkgY2xhc3MgbmFtZSB0byB0aGUgcHJpb3JpdHkgaW50ZWdlciB2YWx1ZS4gVGhlIHZhbHVlIGNhbiBiZSBhbnkgdmFsaWQgaW50ZWdlci5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuc2NoZWR1bGluZy52MS5Qcmlvcml0eUNsYXNzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZVByaW9yaXR5Q2xhc3NQcm9wcyB7XG4gIC8qKlxuICAgKiBkZXNjcmlwdGlvbiBpcyBhbiBhcmJpdHJhcnkgc3RyaW5nIHRoYXQgdXN1YWxseSBwcm92aWRlcyBndWlkZWxpbmVzIG9uIHdoZW4gdGhpcyBwcmlvcml0eSBjbGFzcyBzaG91bGQgYmUgdXNlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnNjaGVkdWxpbmcudjEuUHJpb3JpdHlDbGFzcyNkZXNjcmlwdGlvblxuICAgKi9cbiAgcmVhZG9ubHkgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGdsb2JhbERlZmF1bHQgc3BlY2lmaWVzIHdoZXRoZXIgdGhpcyBQcmlvcml0eUNsYXNzIHNob3VsZCBiZSBjb25zaWRlcmVkIGFzIHRoZSBkZWZhdWx0IHByaW9yaXR5IGZvciBwb2RzIHRoYXQgZG8gbm90IGhhdmUgYW55IHByaW9yaXR5IGNsYXNzLiBPbmx5IG9uZSBQcmlvcml0eUNsYXNzIGNhbiBiZSBtYXJrZWQgYXMgYGdsb2JhbERlZmF1bHRgLiBIb3dldmVyLCBpZiBtb3JlIHRoYW4gb25lIFByaW9yaXR5Q2xhc3NlcyBleGlzdHMgd2l0aCB0aGVpciBgZ2xvYmFsRGVmYXVsdGAgZmllbGQgc2V0IHRvIHRydWUsIHRoZSBzbWFsbGVzdCB2YWx1ZSBvZiBzdWNoIGdsb2JhbCBkZWZhdWx0IFByaW9yaXR5Q2xhc3NlcyB3aWxsIGJlIHVzZWQgYXMgdGhlIGRlZmF1bHQgcHJpb3JpdHkuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zY2hlZHVsaW5nLnYxLlByaW9yaXR5Q2xhc3MjZ2xvYmFsRGVmYXVsdFxuICAgKi9cbiAgcmVhZG9ubHkgZ2xvYmFsRGVmYXVsdD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIG9iamVjdCdzIG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zY2hlZHVsaW5nLnYxLlByaW9yaXR5Q2xhc3MjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogUHJlZW1wdGlvblBvbGljeSBpcyB0aGUgUG9saWN5IGZvciBwcmVlbXB0aW5nIHBvZHMgd2l0aCBsb3dlciBwcmlvcml0eS4gT25lIG9mIE5ldmVyLCBQcmVlbXB0TG93ZXJQcmlvcml0eS4gRGVmYXVsdHMgdG8gUHJlZW1wdExvd2VyUHJpb3JpdHkgaWYgdW5zZXQuIFRoaXMgZmllbGQgaXMgYmV0YS1sZXZlbCwgZ2F0ZWQgYnkgdGhlIE5vblByZWVtcHRpbmdQcmlvcml0eSBmZWF0dXJlLWdhdGUuXG4gICAqXG4gICAqIEBkZWZhdWx0IFByZWVtcHRMb3dlclByaW9yaXR5IGlmIHVuc2V0LiBUaGlzIGZpZWxkIGlzIGJldGEtbGV2ZWwsIGdhdGVkIGJ5IHRoZSBOb25QcmVlbXB0aW5nUHJpb3JpdHkgZmVhdHVyZS1nYXRlLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc2NoZWR1bGluZy52MS5Qcmlvcml0eUNsYXNzI3ByZWVtcHRpb25Qb2xpY3lcbiAgICovXG4gIHJlYWRvbmx5IHByZWVtcHRpb25Qb2xpY3k/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBvZiB0aGlzIHByaW9yaXR5IGNsYXNzLiBUaGlzIGlzIHRoZSBhY3R1YWwgcHJpb3JpdHkgdGhhdCBwb2RzIHJlY2VpdmUgd2hlbiB0aGV5IGhhdmUgdGhlIG5hbWUgb2YgdGhpcyBjbGFzcyBpbiB0aGVpciBwb2Qgc3BlYy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnNjaGVkdWxpbmcudjEuUHJpb3JpdHlDbGFzcyN2YWx1ZVxuICAgKi9cbiAgcmVhZG9ubHkgdmFsdWU6IG51bWJlcjtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlUHJpb3JpdHlDbGFzc1Byb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlUHJpb3JpdHlDbGFzc1Byb3BzKG9iajogS3ViZVByaW9yaXR5Q2xhc3NQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2Rlc2NyaXB0aW9uJzogb2JqLmRlc2NyaXB0aW9uLFxuICAgICdnbG9iYWxEZWZhdWx0Jzogb2JqLmdsb2JhbERlZmF1bHQsXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX09iamVjdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgICAncHJlZW1wdGlvblBvbGljeSc6IG9iai5wcmVlbXB0aW9uUG9saWN5LFxuICAgICd2YWx1ZSc6IG9iai52YWx1ZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBQcmlvcml0eUNsYXNzTGlzdCBpcyBhIGNvbGxlY3Rpb24gb2YgcHJpb3JpdHkgY2xhc3Nlcy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuc2NoZWR1bGluZy52MS5Qcmlvcml0eUNsYXNzTGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVQcmlvcml0eUNsYXNzTGlzdFByb3BzIHtcbiAgLyoqXG4gICAqIGl0ZW1zIGlzIHRoZSBsaXN0IG9mIFByaW9yaXR5Q2xhc3Nlc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc2NoZWR1bGluZy52MS5Qcmlvcml0eUNsYXNzTGlzdCNpdGVtc1xuICAgKi9cbiAgcmVhZG9ubHkgaXRlbXM6IEt1YmVQcmlvcml0eUNsYXNzUHJvcHNbXTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgbGlzdCBtZXRhZGF0YSBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zY2hlZHVsaW5nLnYxLlByaW9yaXR5Q2xhc3NMaXN0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IExpc3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVQcmlvcml0eUNsYXNzTGlzdFByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlUHJpb3JpdHlDbGFzc0xpc3RQcm9wcyhvYmo6IEt1YmVQcmlvcml0eUNsYXNzTGlzdFByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaXRlbXMnOiBvYmouaXRlbXM/Lm1hcCh5ID0+IHRvSnNvbl9LdWJlUHJpb3JpdHlDbGFzc1Byb3BzKHkpKSxcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fTGlzdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBERVBSRUNBVEVEIC0gVGhpcyBncm91cCB2ZXJzaW9uIG9mIFByaW9yaXR5Q2xhc3MgaXMgZGVwcmVjYXRlZCBieSBzY2hlZHVsaW5nLms4cy5pby92MS9Qcmlvcml0eUNsYXNzLiBQcmlvcml0eUNsYXNzIGRlZmluZXMgbWFwcGluZyBmcm9tIGEgcHJpb3JpdHkgY2xhc3MgbmFtZSB0byB0aGUgcHJpb3JpdHkgaW50ZWdlciB2YWx1ZS4gVGhlIHZhbHVlIGNhbiBiZSBhbnkgdmFsaWQgaW50ZWdlci5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuc2NoZWR1bGluZy52MWFscGhhMS5Qcmlvcml0eUNsYXNzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZVByaW9yaXR5Q2xhc3NWMUFscGhhMVByb3BzIHtcbiAgLyoqXG4gICAqIGRlc2NyaXB0aW9uIGlzIGFuIGFyYml0cmFyeSBzdHJpbmcgdGhhdCB1c3VhbGx5IHByb3ZpZGVzIGd1aWRlbGluZXMgb24gd2hlbiB0aGlzIHByaW9yaXR5IGNsYXNzIHNob3VsZCBiZSB1c2VkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc2NoZWR1bGluZy52MWFscGhhMS5Qcmlvcml0eUNsYXNzI2Rlc2NyaXB0aW9uXG4gICAqL1xuICByZWFkb25seSBkZXNjcmlwdGlvbj86IHN0cmluZztcblxuICAvKipcbiAgICogZ2xvYmFsRGVmYXVsdCBzcGVjaWZpZXMgd2hldGhlciB0aGlzIFByaW9yaXR5Q2xhc3Mgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgdGhlIGRlZmF1bHQgcHJpb3JpdHkgZm9yIHBvZHMgdGhhdCBkbyBub3QgaGF2ZSBhbnkgcHJpb3JpdHkgY2xhc3MuIE9ubHkgb25lIFByaW9yaXR5Q2xhc3MgY2FuIGJlIG1hcmtlZCBhcyBgZ2xvYmFsRGVmYXVsdGAuIEhvd2V2ZXIsIGlmIG1vcmUgdGhhbiBvbmUgUHJpb3JpdHlDbGFzc2VzIGV4aXN0cyB3aXRoIHRoZWlyIGBnbG9iYWxEZWZhdWx0YCBmaWVsZCBzZXQgdG8gdHJ1ZSwgdGhlIHNtYWxsZXN0IHZhbHVlIG9mIHN1Y2ggZ2xvYmFsIGRlZmF1bHQgUHJpb3JpdHlDbGFzc2VzIHdpbGwgYmUgdXNlZCBhcyB0aGUgZGVmYXVsdCBwcmlvcml0eS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnNjaGVkdWxpbmcudjFhbHBoYTEuUHJpb3JpdHlDbGFzcyNnbG9iYWxEZWZhdWx0XG4gICAqL1xuICByZWFkb25seSBnbG9iYWxEZWZhdWx0PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0J3MgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnNjaGVkdWxpbmcudjFhbHBoYTEuUHJpb3JpdHlDbGFzcyNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBPYmplY3RNZXRhO1xuXG4gIC8qKlxuICAgKiBQcmVlbXB0aW9uUG9saWN5IGlzIHRoZSBQb2xpY3kgZm9yIHByZWVtcHRpbmcgcG9kcyB3aXRoIGxvd2VyIHByaW9yaXR5LiBPbmUgb2YgTmV2ZXIsIFByZWVtcHRMb3dlclByaW9yaXR5LiBEZWZhdWx0cyB0byBQcmVlbXB0TG93ZXJQcmlvcml0eSBpZiB1bnNldC4gVGhpcyBmaWVsZCBpcyBiZXRhLWxldmVsLCBnYXRlZCBieSB0aGUgTm9uUHJlZW1wdGluZ1ByaW9yaXR5IGZlYXR1cmUtZ2F0ZS5cbiAgICpcbiAgICogQGRlZmF1bHQgUHJlZW1wdExvd2VyUHJpb3JpdHkgaWYgdW5zZXQuIFRoaXMgZmllbGQgaXMgYmV0YS1sZXZlbCwgZ2F0ZWQgYnkgdGhlIE5vblByZWVtcHRpbmdQcmlvcml0eSBmZWF0dXJlLWdhdGUuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zY2hlZHVsaW5nLnYxYWxwaGExLlByaW9yaXR5Q2xhc3MjcHJlZW1wdGlvblBvbGljeVxuICAgKi9cbiAgcmVhZG9ubHkgcHJlZW1wdGlvblBvbGljeT86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoaXMgcHJpb3JpdHkgY2xhc3MuIFRoaXMgaXMgdGhlIGFjdHVhbCBwcmlvcml0eSB0aGF0IHBvZHMgcmVjZWl2ZSB3aGVuIHRoZXkgaGF2ZSB0aGUgbmFtZSBvZiB0aGlzIGNsYXNzIGluIHRoZWlyIHBvZCBzcGVjLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc2NoZWR1bGluZy52MWFscGhhMS5Qcmlvcml0eUNsYXNzI3ZhbHVlXG4gICAqL1xuICByZWFkb25seSB2YWx1ZTogbnVtYmVyO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVQcmlvcml0eUNsYXNzVjFBbHBoYTFQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVByaW9yaXR5Q2xhc3NWMUFscGhhMVByb3BzKG9iajogS3ViZVByaW9yaXR5Q2xhc3NWMUFscGhhMVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZGVzY3JpcHRpb24nOiBvYmouZGVzY3JpcHRpb24sXG4gICAgJ2dsb2JhbERlZmF1bHQnOiBvYmouZ2xvYmFsRGVmYXVsdCxcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdwcmVlbXB0aW9uUG9saWN5Jzogb2JqLnByZWVtcHRpb25Qb2xpY3ksXG4gICAgJ3ZhbHVlJzogb2JqLnZhbHVlLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFByaW9yaXR5Q2xhc3NMaXN0IGlzIGEgY29sbGVjdGlvbiBvZiBwcmlvcml0eSBjbGFzc2VzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5zY2hlZHVsaW5nLnYxYWxwaGExLlByaW9yaXR5Q2xhc3NMaXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZVByaW9yaXR5Q2xhc3NMaXN0VjFBbHBoYTFQcm9wcyB7XG4gIC8qKlxuICAgKiBpdGVtcyBpcyB0aGUgbGlzdCBvZiBQcmlvcml0eUNsYXNzZXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnNjaGVkdWxpbmcudjFhbHBoYTEuUHJpb3JpdHlDbGFzc0xpc3QjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zOiBLdWJlUHJpb3JpdHlDbGFzc1YxQWxwaGExUHJvcHNbXTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgbGlzdCBtZXRhZGF0YSBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zY2hlZHVsaW5nLnYxYWxwaGExLlByaW9yaXR5Q2xhc3NMaXN0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IExpc3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVQcmlvcml0eUNsYXNzTGlzdFYxQWxwaGExUHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVQcmlvcml0eUNsYXNzTGlzdFYxQWxwaGExUHJvcHMob2JqOiBLdWJlUHJpb3JpdHlDbGFzc0xpc3RWMUFscGhhMVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaXRlbXMnOiBvYmouaXRlbXM/Lm1hcCh5ID0+IHRvSnNvbl9LdWJlUHJpb3JpdHlDbGFzc1YxQWxwaGExUHJvcHMoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9MaXN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIENTSURyaXZlciBjYXB0dXJlcyBpbmZvcm1hdGlvbiBhYm91dCBhIENvbnRhaW5lciBTdG9yYWdlIEludGVyZmFjZSAoQ1NJKSB2b2x1bWUgZHJpdmVyIGRlcGxveWVkIG9uIHRoZSBjbHVzdGVyLiBLdWJlcm5ldGVzIGF0dGFjaCBkZXRhY2ggY29udHJvbGxlciB1c2VzIHRoaXMgb2JqZWN0IHRvIGRldGVybWluZSB3aGV0aGVyIGF0dGFjaCBpcyByZXF1aXJlZC4gS3ViZWxldCB1c2VzIHRoaXMgb2JqZWN0IHRvIGRldGVybWluZSB3aGV0aGVyIHBvZCBpbmZvcm1hdGlvbiBuZWVkcyB0byBiZSBwYXNzZWQgb24gbW91bnQuIENTSURyaXZlciBvYmplY3RzIGFyZSBub24tbmFtZXNwYWNlZC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5DU0lEcml2ZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlQ3NpRHJpdmVyUHJvcHMge1xuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0IG1ldGFkYXRhLiBtZXRhZGF0YS5OYW1lIGluZGljYXRlcyB0aGUgbmFtZSBvZiB0aGUgQ1NJIGRyaXZlciB0aGF0IHRoaXMgb2JqZWN0IHJlZmVycyB0bzsgaXQgTVVTVCBiZSB0aGUgc2FtZSBuYW1lIHJldHVybmVkIGJ5IHRoZSBDU0kgR2V0UGx1Z2luTmFtZSgpIGNhbGwgZm9yIHRoYXQgZHJpdmVyLiBUaGUgZHJpdmVyIG5hbWUgbXVzdCBiZSA2MyBjaGFyYWN0ZXJzIG9yIGxlc3MsIGJlZ2lubmluZyBhbmQgZW5kaW5nIHdpdGggYW4gYWxwaGFudW1lcmljIGNoYXJhY3RlciAoW2EtejAtOUEtWl0pIHdpdGggZGFzaGVzICgtKSwgZG90cyAoLiksIGFuZCBhbHBoYW51bWVyaWNzIGJldHdlZW4uIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjEuQ1NJRHJpdmVyI21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb24gb2YgdGhlIENTSSBEcml2ZXIuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxLkNTSURyaXZlciNzcGVjXG4gICAqL1xuICByZWFkb25seSBzcGVjOiBDc2lEcml2ZXJTcGVjO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVDc2lEcml2ZXJQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUNzaURyaXZlclByb3BzKG9iajogS3ViZUNzaURyaXZlclByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdzcGVjJzogdG9Kc29uX0NzaURyaXZlclNwZWMob2JqLnNwZWMpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIENTSURyaXZlckxpc3QgaXMgYSBjb2xsZWN0aW9uIG9mIENTSURyaXZlciBvYmplY3RzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxLkNTSURyaXZlckxpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlQ3NpRHJpdmVyTGlzdFByb3BzIHtcbiAgLyoqXG4gICAqIGl0ZW1zIGlzIHRoZSBsaXN0IG9mIENTSURyaXZlclxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5DU0lEcml2ZXJMaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZUNzaURyaXZlclByb3BzW107XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIGxpc3QgbWV0YWRhdGEgTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5DU0lEcml2ZXJMaXN0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IExpc3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVDc2lEcml2ZXJMaXN0UHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVDc2lEcml2ZXJMaXN0UHJvcHMob2JqOiBLdWJlQ3NpRHJpdmVyTGlzdFByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaXRlbXMnOiBvYmouaXRlbXM/Lm1hcCh5ID0+IHRvSnNvbl9LdWJlQ3NpRHJpdmVyUHJvcHMoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9MaXN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIENTSU5vZGUgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgYWxsIENTSSBkcml2ZXJzIGluc3RhbGxlZCBvbiBhIG5vZGUuIENTSSBkcml2ZXJzIGRvIG5vdCBuZWVkIHRvIGNyZWF0ZSB0aGUgQ1NJTm9kZSBvYmplY3QgZGlyZWN0bHkuIEFzIGxvbmcgYXMgdGhleSB1c2UgdGhlIG5vZGUtZHJpdmVyLXJlZ2lzdHJhciBzaWRlY2FyIGNvbnRhaW5lciwgdGhlIGt1YmVsZXQgd2lsbCBhdXRvbWF0aWNhbGx5IHBvcHVsYXRlIHRoZSBDU0lOb2RlIG9iamVjdCBmb3IgdGhlIENTSSBkcml2ZXIgYXMgcGFydCBvZiBrdWJlbGV0IHBsdWdpbiByZWdpc3RyYXRpb24uIENTSU5vZGUgaGFzIHRoZSBzYW1lIG5hbWUgYXMgYSBub2RlLiBJZiB0aGUgb2JqZWN0IGlzIG1pc3NpbmcsIGl0IG1lYW5zIGVpdGhlciB0aGVyZSBhcmUgbm8gQ1NJIERyaXZlcnMgYXZhaWxhYmxlIG9uIHRoZSBub2RlLCBvciB0aGUgS3ViZWxldCB2ZXJzaW9uIGlzIGxvdyBlbm91Z2ggdGhhdCBpdCBkb2Vzbid0IGNyZWF0ZSB0aGlzIG9iamVjdC4gQ1NJTm9kZSBoYXMgYW4gT3duZXJSZWZlcmVuY2UgdGhhdCBwb2ludHMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgbm9kZSBvYmplY3QuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjEuQ1NJTm9kZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVDc2lOb2RlUHJvcHMge1xuICAvKipcbiAgICogbWV0YWRhdGEubmFtZSBtdXN0IGJlIHRoZSBLdWJlcm5ldGVzIG5vZGUgbmFtZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjEuQ1NJTm9kZSNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBPYmplY3RNZXRhO1xuXG4gIC8qKlxuICAgKiBzcGVjIGlzIHRoZSBzcGVjaWZpY2F0aW9uIG9mIENTSU5vZGVcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjEuQ1NJTm9kZSNzcGVjXG4gICAqL1xuICByZWFkb25seSBzcGVjOiBDc2lOb2RlU3BlYztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlQ3NpTm9kZVByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlQ3NpTm9kZVByb3BzKG9iajogS3ViZUNzaU5vZGVQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX09iamVjdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgICAnc3BlYyc6IHRvSnNvbl9Dc2lOb2RlU3BlYyhvYmouc3BlYyksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQ1NJTm9kZUxpc3QgaXMgYSBjb2xsZWN0aW9uIG9mIENTSU5vZGUgb2JqZWN0cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5DU0lOb2RlTGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVDc2lOb2RlTGlzdFByb3BzIHtcbiAgLyoqXG4gICAqIGl0ZW1zIGlzIHRoZSBsaXN0IG9mIENTSU5vZGVcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjEuQ1NJTm9kZUxpc3QjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zOiBLdWJlQ3NpTm9kZVByb3BzW107XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIGxpc3QgbWV0YWRhdGEgTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5DU0lOb2RlTGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlQ3NpTm9kZUxpc3RQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUNzaU5vZGVMaXN0UHJvcHMob2JqOiBLdWJlQ3NpTm9kZUxpc3RQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZUNzaU5vZGVQcm9wcyh5KSksXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogU3RvcmFnZUNsYXNzIGRlc2NyaWJlcyB0aGUgcGFyYW1ldGVycyBmb3IgYSBjbGFzcyBvZiBzdG9yYWdlIGZvciB3aGljaCBQZXJzaXN0ZW50Vm9sdW1lcyBjYW4gYmUgZHluYW1pY2FsbHkgcHJvdmlzaW9uZWQuXG4gKlxuICogU3RvcmFnZUNsYXNzZXMgYXJlIG5vbi1uYW1lc3BhY2VkOyB0aGUgbmFtZSBvZiB0aGUgc3RvcmFnZSBjbGFzcyBhY2NvcmRpbmcgdG8gZXRjZCBpcyBpbiBPYmplY3RNZXRhLk5hbWUuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjEuU3RvcmFnZUNsYXNzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZVN0b3JhZ2VDbGFzc1Byb3BzIHtcbiAgLyoqXG4gICAqIEFsbG93Vm9sdW1lRXhwYW5zaW9uIHNob3dzIHdoZXRoZXIgdGhlIHN0b3JhZ2UgY2xhc3MgYWxsb3cgdm9sdW1lIGV4cGFuZFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5TdG9yYWdlQ2xhc3MjYWxsb3dWb2x1bWVFeHBhbnNpb25cbiAgICovXG4gIHJlYWRvbmx5IGFsbG93Vm9sdW1lRXhwYW5zaW9uPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogUmVzdHJpY3QgdGhlIG5vZGUgdG9wb2xvZ2llcyB3aGVyZSB2b2x1bWVzIGNhbiBiZSBkeW5hbWljYWxseSBwcm92aXNpb25lZC4gRWFjaCB2b2x1bWUgcGx1Z2luIGRlZmluZXMgaXRzIG93biBzdXBwb3J0ZWQgdG9wb2xvZ3kgc3BlY2lmaWNhdGlvbnMuIEFuIGVtcHR5IFRvcG9sb2d5U2VsZWN0b3JUZXJtIGxpc3QgbWVhbnMgdGhlcmUgaXMgbm8gdG9wb2xvZ3kgcmVzdHJpY3Rpb24uIFRoaXMgZmllbGQgaXMgb25seSBob25vcmVkIGJ5IHNlcnZlcnMgdGhhdCBlbmFibGUgdGhlIFZvbHVtZVNjaGVkdWxpbmcgZmVhdHVyZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjEuU3RvcmFnZUNsYXNzI2FsbG93ZWRUb3BvbG9naWVzXG4gICAqL1xuICByZWFkb25seSBhbGxvd2VkVG9wb2xvZ2llcz86IFRvcG9sb2d5U2VsZWN0b3JUZXJtW107XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIG9iamVjdCdzIG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxLlN0b3JhZ2VDbGFzcyNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBPYmplY3RNZXRhO1xuXG4gIC8qKlxuICAgKiBEeW5hbWljYWxseSBwcm92aXNpb25lZCBQZXJzaXN0ZW50Vm9sdW1lcyBvZiB0aGlzIHN0b3JhZ2UgY2xhc3MgYXJlIGNyZWF0ZWQgd2l0aCB0aGVzZSBtb3VudE9wdGlvbnMsIGUuZy4gW1wicm9cIiwgXCJzb2Z0XCJdLiBOb3QgdmFsaWRhdGVkIC0gbW91bnQgb2YgdGhlIFBWcyB3aWxsIHNpbXBseSBmYWlsIGlmIG9uZSBpcyBpbnZhbGlkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5TdG9yYWdlQ2xhc3MjbW91bnRPcHRpb25zXG4gICAqL1xuICByZWFkb25seSBtb3VudE9wdGlvbnM/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogUGFyYW1ldGVycyBob2xkcyB0aGUgcGFyYW1ldGVycyBmb3IgdGhlIHByb3Zpc2lvbmVyIHRoYXQgc2hvdWxkIGNyZWF0ZSB2b2x1bWVzIG9mIHRoaXMgc3RvcmFnZSBjbGFzcy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjEuU3RvcmFnZUNsYXNzI3BhcmFtZXRlcnNcbiAgICovXG4gIHJlYWRvbmx5IHBhcmFtZXRlcnM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXG4gIC8qKlxuICAgKiBQcm92aXNpb25lciBpbmRpY2F0ZXMgdGhlIHR5cGUgb2YgdGhlIHByb3Zpc2lvbmVyLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5TdG9yYWdlQ2xhc3MjcHJvdmlzaW9uZXJcbiAgICovXG4gIHJlYWRvbmx5IHByb3Zpc2lvbmVyOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIER5bmFtaWNhbGx5IHByb3Zpc2lvbmVkIFBlcnNpc3RlbnRWb2x1bWVzIG9mIHRoaXMgc3RvcmFnZSBjbGFzcyBhcmUgY3JlYXRlZCB3aXRoIHRoaXMgcmVjbGFpbVBvbGljeS4gRGVmYXVsdHMgdG8gRGVsZXRlLlxuICAgKlxuICAgKiBAZGVmYXVsdCBEZWxldGUuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxLlN0b3JhZ2VDbGFzcyNyZWNsYWltUG9saWN5XG4gICAqL1xuICByZWFkb25seSByZWNsYWltUG9saWN5Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBWb2x1bWVCaW5kaW5nTW9kZSBpbmRpY2F0ZXMgaG93IFBlcnNpc3RlbnRWb2x1bWVDbGFpbXMgc2hvdWxkIGJlIHByb3Zpc2lvbmVkIGFuZCBib3VuZC4gIFdoZW4gdW5zZXQsIFZvbHVtZUJpbmRpbmdJbW1lZGlhdGUgaXMgdXNlZC4gVGhpcyBmaWVsZCBpcyBvbmx5IGhvbm9yZWQgYnkgc2VydmVycyB0aGF0IGVuYWJsZSB0aGUgVm9sdW1lU2NoZWR1bGluZyBmZWF0dXJlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5TdG9yYWdlQ2xhc3Mjdm9sdW1lQmluZGluZ01vZGVcbiAgICovXG4gIHJlYWRvbmx5IHZvbHVtZUJpbmRpbmdNb2RlPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVTdG9yYWdlQ2xhc3NQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVN0b3JhZ2VDbGFzc1Byb3BzKG9iajogS3ViZVN0b3JhZ2VDbGFzc1Byb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnYWxsb3dWb2x1bWVFeHBhbnNpb24nOiBvYmouYWxsb3dWb2x1bWVFeHBhbnNpb24sXG4gICAgJ2FsbG93ZWRUb3BvbG9naWVzJzogb2JqLmFsbG93ZWRUb3BvbG9naWVzPy5tYXAoeSA9PiB0b0pzb25fVG9wb2xvZ3lTZWxlY3RvclRlcm0oeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ21vdW50T3B0aW9ucyc6IG9iai5tb3VudE9wdGlvbnM/Lm1hcCh5ID0+IHkpLFxuICAgICdwYXJhbWV0ZXJzJzogKChvYmoucGFyYW1ldGVycykgPT09IHVuZGVmaW5lZCkgPyB1bmRlZmluZWQgOiAoT2JqZWN0LmVudHJpZXMob2JqLnBhcmFtZXRlcnMpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSkpLFxuICAgICdwcm92aXNpb25lcic6IG9iai5wcm92aXNpb25lcixcbiAgICAncmVjbGFpbVBvbGljeSc6IG9iai5yZWNsYWltUG9saWN5LFxuICAgICd2b2x1bWVCaW5kaW5nTW9kZSc6IG9iai52b2x1bWVCaW5kaW5nTW9kZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBTdG9yYWdlQ2xhc3NMaXN0IGlzIGEgY29sbGVjdGlvbiBvZiBzdG9yYWdlIGNsYXNzZXMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjEuU3RvcmFnZUNsYXNzTGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVTdG9yYWdlQ2xhc3NMaXN0UHJvcHMge1xuICAvKipcbiAgICogSXRlbXMgaXMgdGhlIGxpc3Qgb2YgU3RvcmFnZUNsYXNzZXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjEuU3RvcmFnZUNsYXNzTGlzdCNpdGVtc1xuICAgKi9cbiAgcmVhZG9ubHkgaXRlbXM6IEt1YmVTdG9yYWdlQ2xhc3NQcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBsaXN0IG1ldGFkYXRhIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjEuU3RvcmFnZUNsYXNzTGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlU3RvcmFnZUNsYXNzTGlzdFByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlU3RvcmFnZUNsYXNzTGlzdFByb3BzKG9iajogS3ViZVN0b3JhZ2VDbGFzc0xpc3RQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZVN0b3JhZ2VDbGFzc1Byb3BzKHkpKSxcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fTGlzdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBWb2x1bWVBdHRhY2htZW50IGNhcHR1cmVzIHRoZSBpbnRlbnQgdG8gYXR0YWNoIG9yIGRldGFjaCB0aGUgc3BlY2lmaWVkIHZvbHVtZSB0by9mcm9tIHRoZSBzcGVjaWZpZWQgbm9kZS5cbiAqXG4gKiBWb2x1bWVBdHRhY2htZW50IG9iamVjdHMgYXJlIG5vbi1uYW1lc3BhY2VkLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxLlZvbHVtZUF0dGFjaG1lbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlVm9sdW1lQXR0YWNobWVudFByb3BzIHtcbiAgLyoqXG4gICAqIFN0YW5kYXJkIG9iamVjdCBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5Wb2x1bWVBdHRhY2htZW50I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb24gb2YgdGhlIGRlc2lyZWQgYXR0YWNoL2RldGFjaCB2b2x1bWUgYmVoYXZpb3IuIFBvcHVsYXRlZCBieSB0aGUgS3ViZXJuZXRlcyBzeXN0ZW0uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxLlZvbHVtZUF0dGFjaG1lbnQjc3BlY1xuICAgKi9cbiAgcmVhZG9ubHkgc3BlYzogVm9sdW1lQXR0YWNobWVudFNwZWM7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZVZvbHVtZUF0dGFjaG1lbnRQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVZvbHVtZUF0dGFjaG1lbnRQcm9wcyhvYmo6IEt1YmVWb2x1bWVBdHRhY2htZW50UHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3NwZWMnOiB0b0pzb25fVm9sdW1lQXR0YWNobWVudFNwZWMob2JqLnNwZWMpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFZvbHVtZUF0dGFjaG1lbnRMaXN0IGlzIGEgY29sbGVjdGlvbiBvZiBWb2x1bWVBdHRhY2htZW50IG9iamVjdHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjEuVm9sdW1lQXR0YWNobWVudExpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlVm9sdW1lQXR0YWNobWVudExpc3RQcm9wcyB7XG4gIC8qKlxuICAgKiBJdGVtcyBpcyB0aGUgbGlzdCBvZiBWb2x1bWVBdHRhY2htZW50c1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5Wb2x1bWVBdHRhY2htZW50TGlzdCNpdGVtc1xuICAgKi9cbiAgcmVhZG9ubHkgaXRlbXM6IEt1YmVWb2x1bWVBdHRhY2htZW50UHJvcHNbXTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgbGlzdCBtZXRhZGF0YSBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxLlZvbHVtZUF0dGFjaG1lbnRMaXN0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IExpc3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVWb2x1bWVBdHRhY2htZW50TGlzdFByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlVm9sdW1lQXR0YWNobWVudExpc3RQcm9wcyhvYmo6IEt1YmVWb2x1bWVBdHRhY2htZW50TGlzdFByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaXRlbXMnOiBvYmouaXRlbXM/Lm1hcCh5ID0+IHRvSnNvbl9LdWJlVm9sdW1lQXR0YWNobWVudFByb3BzKHkpKSxcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fTGlzdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBDU0lTdG9yYWdlQ2FwYWNpdHkgc3RvcmVzIHRoZSByZXN1bHQgb2Ygb25lIENTSSBHZXRDYXBhY2l0eSBjYWxsLiBGb3IgYSBnaXZlbiBTdG9yYWdlQ2xhc3MsIHRoaXMgZGVzY3JpYmVzIHRoZSBhdmFpbGFibGUgY2FwYWNpdHkgaW4gYSBwYXJ0aWN1bGFyIHRvcG9sb2d5IHNlZ21lbnQuICBUaGlzIGNhbiBiZSB1c2VkIHdoZW4gY29uc2lkZXJpbmcgd2hlcmUgdG8gaW5zdGFudGlhdGUgbmV3IFBlcnNpc3RlbnRWb2x1bWVzLlxuICpcbiAqIEZvciBleGFtcGxlIHRoaXMgY2FuIGV4cHJlc3MgdGhpbmdzIGxpa2U6IC0gU3RvcmFnZUNsYXNzIFwic3RhbmRhcmRcIiBoYXMgXCIxMjM0IEdpQlwiIGF2YWlsYWJsZSBpbiBcInRvcG9sb2d5Lmt1YmVybmV0ZXMuaW8vem9uZT11cy1lYXN0MVwiIC0gU3RvcmFnZUNsYXNzIFwibG9jYWxzc2RcIiBoYXMgXCIxMCBHaUJcIiBhdmFpbGFibGUgaW4gXCJrdWJlcm5ldGVzLmlvL2hvc3RuYW1lPWtub2RlLWFiYzEyM1wiXG4gKlxuICogVGhlIGZvbGxvd2luZyB0aHJlZSBjYXNlcyBhbGwgaW1wbHkgdGhhdCBubyBjYXBhY2l0eSBpcyBhdmFpbGFibGUgZm9yIGEgY2VydGFpbiBjb21iaW5hdGlvbjogLSBubyBvYmplY3QgZXhpc3RzIHdpdGggc3VpdGFibGUgdG9wb2xvZ3kgYW5kIHN0b3JhZ2UgY2xhc3MgbmFtZSAtIHN1Y2ggYW4gb2JqZWN0IGV4aXN0cywgYnV0IHRoZSBjYXBhY2l0eSBpcyB1bnNldCAtIHN1Y2ggYW4gb2JqZWN0IGV4aXN0cywgYnV0IHRoZSBjYXBhY2l0eSBpcyB6ZXJvXG4gKlxuICogVGhlIHByb2R1Y2VyIG9mIHRoZXNlIG9iamVjdHMgY2FuIGRlY2lkZSB3aGljaCBhcHByb2FjaCBpcyBtb3JlIHN1aXRhYmxlLlxuICpcbiAqIFRoZXkgYXJlIGNvbnN1bWVkIGJ5IHRoZSBrdWJlLXNjaGVkdWxlciBpZiB0aGUgQ1NJU3RvcmFnZUNhcGFjaXR5IGJldGEgZmVhdHVyZSBnYXRlIGlzIGVuYWJsZWQgdGhlcmUgYW5kIGEgQ1NJIGRyaXZlciBvcHRzIGludG8gY2FwYWNpdHktYXdhcmUgc2NoZWR1bGluZyB3aXRoIENTSURyaXZlci5TdG9yYWdlQ2FwYWNpdHkuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjFhbHBoYTEuQ1NJU3RvcmFnZUNhcGFjaXR5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZUNzaVN0b3JhZ2VDYXBhY2l0eVYxQWxwaGExUHJvcHMge1xuICAvKipcbiAgICogQ2FwYWNpdHkgaXMgdGhlIHZhbHVlIHJlcG9ydGVkIGJ5IHRoZSBDU0kgZHJpdmVyIGluIGl0cyBHZXRDYXBhY2l0eVJlc3BvbnNlIGZvciBhIEdldENhcGFjaXR5UmVxdWVzdCB3aXRoIHRvcG9sb2d5IGFuZCBwYXJhbWV0ZXJzIHRoYXQgbWF0Y2ggdGhlIHByZXZpb3VzIGZpZWxkcy5cbiAgICpcbiAgICogVGhlIHNlbWFudGljIGlzIGN1cnJlbnRseSAoQ1NJIHNwZWMgMS4yKSBkZWZpbmVkIGFzOiBUaGUgYXZhaWxhYmxlIGNhcGFjaXR5LCBpbiBieXRlcywgb2YgdGhlIHN0b3JhZ2UgdGhhdCBjYW4gYmUgdXNlZCB0byBwcm92aXNpb24gdm9sdW1lcy4gSWYgbm90IHNldCwgdGhhdCBpbmZvcm1hdGlvbiBpcyBjdXJyZW50bHkgdW5hdmFpbGFibGUgYW5kIHRyZWF0ZWQgbGlrZSB6ZXJvIGNhcGFjaXR5LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MWFscGhhMS5DU0lTdG9yYWdlQ2FwYWNpdHkjY2FwYWNpdHlcbiAgICovXG4gIHJlYWRvbmx5IGNhcGFjaXR5PzogUXVhbnRpdHk7XG5cbiAgLyoqXG4gICAqIE1heGltdW1Wb2x1bWVTaXplIGlzIHRoZSB2YWx1ZSByZXBvcnRlZCBieSB0aGUgQ1NJIGRyaXZlciBpbiBpdHMgR2V0Q2FwYWNpdHlSZXNwb25zZSBmb3IgYSBHZXRDYXBhY2l0eVJlcXVlc3Qgd2l0aCB0b3BvbG9neSBhbmQgcGFyYW1ldGVycyB0aGF0IG1hdGNoIHRoZSBwcmV2aW91cyBmaWVsZHMuXG4gICAqXG4gICAqIFRoaXMgaXMgZGVmaW5lZCBzaW5jZSBDU0kgc3BlYyAxLjQuMCBhcyB0aGUgbGFyZ2VzdCBzaXplIHRoYXQgbWF5IGJlIHVzZWQgaW4gYSBDcmVhdGVWb2x1bWVSZXF1ZXN0LmNhcGFjaXR5X3JhbmdlLnJlcXVpcmVkX2J5dGVzIGZpZWxkIHRvIGNyZWF0ZSBhIHZvbHVtZSB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMgYXMgdGhvc2UgaW4gR2V0Q2FwYWNpdHlSZXF1ZXN0LiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBpbiB0aGUgS3ViZXJuZXRlcyBBUEkgaXMgUmVzb3VyY2VSZXF1aXJlbWVudHMuUmVxdWVzdHMgaW4gYSB2b2x1bWUgY2xhaW0uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxYWxwaGExLkNTSVN0b3JhZ2VDYXBhY2l0eSNtYXhpbXVtVm9sdW1lU2l6ZVxuICAgKi9cbiAgcmVhZG9ubHkgbWF4aW11bVZvbHVtZVNpemU/OiBRdWFudGl0eTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0J3MgbWV0YWRhdGEuIFRoZSBuYW1lIGhhcyBubyBwYXJ0aWN1bGFyIG1lYW5pbmcuIEl0IG11c3QgYmUgYmUgYSBETlMgc3ViZG9tYWluIChkb3RzIGFsbG93ZWQsIDI1MyBjaGFyYWN0ZXJzKS4gVG8gZW5zdXJlIHRoYXQgdGhlcmUgYXJlIG5vIGNvbmZsaWN0cyB3aXRoIG90aGVyIENTSSBkcml2ZXJzIG9uIHRoZSBjbHVzdGVyLCB0aGUgcmVjb21tZW5kYXRpb24gaXMgdG8gdXNlIGNzaXNjLTx1dWlkPiwgYSBnZW5lcmF0ZWQgbmFtZSwgb3IgYSByZXZlcnNlLWRvbWFpbiBuYW1lIHdoaWNoIGVuZHMgd2l0aCB0aGUgdW5pcXVlIENTSSBkcml2ZXIgbmFtZS5cbiAgICpcbiAgICogT2JqZWN0cyBhcmUgbmFtZXNwYWNlZC5cbiAgICpcbiAgICogTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MWFscGhhMS5DU0lTdG9yYWdlQ2FwYWNpdHkjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogTm9kZVRvcG9sb2d5IGRlZmluZXMgd2hpY2ggbm9kZXMgaGF2ZSBhY2Nlc3MgdG8gdGhlIHN0b3JhZ2UgZm9yIHdoaWNoIGNhcGFjaXR5IHdhcyByZXBvcnRlZC4gSWYgbm90IHNldCwgdGhlIHN0b3JhZ2UgaXMgbm90IGFjY2Vzc2libGUgZnJvbSBhbnkgbm9kZSBpbiB0aGUgY2x1c3Rlci4gSWYgZW1wdHksIHRoZSBzdG9yYWdlIGlzIGFjY2Vzc2libGUgZnJvbSBhbGwgbm9kZXMuIFRoaXMgZmllbGQgaXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MWFscGhhMS5DU0lTdG9yYWdlQ2FwYWNpdHkjbm9kZVRvcG9sb2d5XG4gICAqL1xuICByZWFkb25seSBub2RlVG9wb2xvZ3k/OiBMYWJlbFNlbGVjdG9yO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgU3RvcmFnZUNsYXNzIHRoYXQgdGhlIHJlcG9ydGVkIGNhcGFjaXR5IGFwcGxpZXMgdG8uIEl0IG11c3QgbWVldCB0aGUgc2FtZSByZXF1aXJlbWVudHMgYXMgdGhlIG5hbWUgb2YgYSBTdG9yYWdlQ2xhc3Mgb2JqZWN0IChub24tZW1wdHksIEROUyBzdWJkb21haW4pLiBJZiB0aGF0IG9iamVjdCBubyBsb25nZXIgZXhpc3RzLCB0aGUgQ1NJU3RvcmFnZUNhcGFjaXR5IG9iamVjdCBpcyBvYnNvbGV0ZSBhbmQgc2hvdWxkIGJlIHJlbW92ZWQgYnkgaXRzIGNyZWF0b3IuIFRoaXMgZmllbGQgaXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MWFscGhhMS5DU0lTdG9yYWdlQ2FwYWNpdHkjc3RvcmFnZUNsYXNzTmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgc3RvcmFnZUNsYXNzTmFtZTogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVDc2lTdG9yYWdlQ2FwYWNpdHlWMUFscGhhMVByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlQ3NpU3RvcmFnZUNhcGFjaXR5VjFBbHBoYTFQcm9wcyhvYmo6IEt1YmVDc2lTdG9yYWdlQ2FwYWNpdHlWMUFscGhhMVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnY2FwYWNpdHknOiBvYmouY2FwYWNpdHk/LnZhbHVlLFxuICAgICdtYXhpbXVtVm9sdW1lU2l6ZSc6IG9iai5tYXhpbXVtVm9sdW1lU2l6ZT8udmFsdWUsXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX09iamVjdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgICAnbm9kZVRvcG9sb2d5JzogdG9Kc29uX0xhYmVsU2VsZWN0b3Iob2JqLm5vZGVUb3BvbG9neSksXG4gICAgJ3N0b3JhZ2VDbGFzc05hbWUnOiBvYmouc3RvcmFnZUNsYXNzTmFtZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBDU0lTdG9yYWdlQ2FwYWNpdHlMaXN0IGlzIGEgY29sbGVjdGlvbiBvZiBDU0lTdG9yYWdlQ2FwYWNpdHkgb2JqZWN0cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MWFscGhhMS5DU0lTdG9yYWdlQ2FwYWNpdHlMaXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZUNzaVN0b3JhZ2VDYXBhY2l0eUxpc3RWMUFscGhhMVByb3BzIHtcbiAgLyoqXG4gICAqIEl0ZW1zIGlzIHRoZSBsaXN0IG9mIENTSVN0b3JhZ2VDYXBhY2l0eSBvYmplY3RzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MWFscGhhMS5DU0lTdG9yYWdlQ2FwYWNpdHlMaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZUNzaVN0b3JhZ2VDYXBhY2l0eVYxQWxwaGExUHJvcHNbXTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgbGlzdCBtZXRhZGF0YSBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxYWxwaGExLkNTSVN0b3JhZ2VDYXBhY2l0eUxpc3QjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogTGlzdE1ldGE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZUNzaVN0b3JhZ2VDYXBhY2l0eUxpc3RWMUFscGhhMVByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlQ3NpU3RvcmFnZUNhcGFjaXR5TGlzdFYxQWxwaGExUHJvcHMob2JqOiBLdWJlQ3NpU3RvcmFnZUNhcGFjaXR5TGlzdFYxQWxwaGExUHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdpdGVtcyc6IG9iai5pdGVtcz8ubWFwKHkgPT4gdG9Kc29uX0t1YmVDc2lTdG9yYWdlQ2FwYWNpdHlWMUFscGhhMVByb3BzKHkpKSxcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fTGlzdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBWb2x1bWVBdHRhY2htZW50IGNhcHR1cmVzIHRoZSBpbnRlbnQgdG8gYXR0YWNoIG9yIGRldGFjaCB0aGUgc3BlY2lmaWVkIHZvbHVtZSB0by9mcm9tIHRoZSBzcGVjaWZpZWQgbm9kZS5cbiAqXG4gKiBWb2x1bWVBdHRhY2htZW50IG9iamVjdHMgYXJlIG5vbi1uYW1lc3BhY2VkLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxYWxwaGExLlZvbHVtZUF0dGFjaG1lbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlVm9sdW1lQXR0YWNobWVudFYxQWxwaGExUHJvcHMge1xuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0IG1ldGFkYXRhLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxYWxwaGExLlZvbHVtZUF0dGFjaG1lbnQjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbiBvZiB0aGUgZGVzaXJlZCBhdHRhY2gvZGV0YWNoIHZvbHVtZSBiZWhhdmlvci4gUG9wdWxhdGVkIGJ5IHRoZSBLdWJlcm5ldGVzIHN5c3RlbS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjFhbHBoYTEuVm9sdW1lQXR0YWNobWVudCNzcGVjXG4gICAqL1xuICByZWFkb25seSBzcGVjOiBWb2x1bWVBdHRhY2htZW50U3BlY1YxQWxwaGExO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVWb2x1bWVBdHRhY2htZW50VjFBbHBoYTFQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVZvbHVtZUF0dGFjaG1lbnRWMUFscGhhMVByb3BzKG9iajogS3ViZVZvbHVtZUF0dGFjaG1lbnRWMUFscGhhMVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdzcGVjJzogdG9Kc29uX1ZvbHVtZUF0dGFjaG1lbnRTcGVjVjFBbHBoYTEob2JqLnNwZWMpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFZvbHVtZUF0dGFjaG1lbnRMaXN0IGlzIGEgY29sbGVjdGlvbiBvZiBWb2x1bWVBdHRhY2htZW50IG9iamVjdHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjFhbHBoYTEuVm9sdW1lQXR0YWNobWVudExpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlVm9sdW1lQXR0YWNobWVudExpc3RWMUFscGhhMVByb3BzIHtcbiAgLyoqXG4gICAqIEl0ZW1zIGlzIHRoZSBsaXN0IG9mIFZvbHVtZUF0dGFjaG1lbnRzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxYWxwaGExLlZvbHVtZUF0dGFjaG1lbnRMaXN0I2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtczogS3ViZVZvbHVtZUF0dGFjaG1lbnRWMUFscGhhMVByb3BzW107XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIGxpc3QgbWV0YWRhdGEgTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MWFscGhhMS5Wb2x1bWVBdHRhY2htZW50TGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlVm9sdW1lQXR0YWNobWVudExpc3RWMUFscGhhMVByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlVm9sdW1lQXR0YWNobWVudExpc3RWMUFscGhhMVByb3BzKG9iajogS3ViZVZvbHVtZUF0dGFjaG1lbnRMaXN0VjFBbHBoYTFQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZVZvbHVtZUF0dGFjaG1lbnRWMUFscGhhMVByb3BzKHkpKSxcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fTGlzdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBDU0lTdG9yYWdlQ2FwYWNpdHkgc3RvcmVzIHRoZSByZXN1bHQgb2Ygb25lIENTSSBHZXRDYXBhY2l0eSBjYWxsLiBGb3IgYSBnaXZlbiBTdG9yYWdlQ2xhc3MsIHRoaXMgZGVzY3JpYmVzIHRoZSBhdmFpbGFibGUgY2FwYWNpdHkgaW4gYSBwYXJ0aWN1bGFyIHRvcG9sb2d5IHNlZ21lbnQuICBUaGlzIGNhbiBiZSB1c2VkIHdoZW4gY29uc2lkZXJpbmcgd2hlcmUgdG8gaW5zdGFudGlhdGUgbmV3IFBlcnNpc3RlbnRWb2x1bWVzLlxuICpcbiAqIEZvciBleGFtcGxlIHRoaXMgY2FuIGV4cHJlc3MgdGhpbmdzIGxpa2U6IC0gU3RvcmFnZUNsYXNzIFwic3RhbmRhcmRcIiBoYXMgXCIxMjM0IEdpQlwiIGF2YWlsYWJsZSBpbiBcInRvcG9sb2d5Lmt1YmVybmV0ZXMuaW8vem9uZT11cy1lYXN0MVwiIC0gU3RvcmFnZUNsYXNzIFwibG9jYWxzc2RcIiBoYXMgXCIxMCBHaUJcIiBhdmFpbGFibGUgaW4gXCJrdWJlcm5ldGVzLmlvL2hvc3RuYW1lPWtub2RlLWFiYzEyM1wiXG4gKlxuICogVGhlIGZvbGxvd2luZyB0aHJlZSBjYXNlcyBhbGwgaW1wbHkgdGhhdCBubyBjYXBhY2l0eSBpcyBhdmFpbGFibGUgZm9yIGEgY2VydGFpbiBjb21iaW5hdGlvbjogLSBubyBvYmplY3QgZXhpc3RzIHdpdGggc3VpdGFibGUgdG9wb2xvZ3kgYW5kIHN0b3JhZ2UgY2xhc3MgbmFtZSAtIHN1Y2ggYW4gb2JqZWN0IGV4aXN0cywgYnV0IHRoZSBjYXBhY2l0eSBpcyB1bnNldCAtIHN1Y2ggYW4gb2JqZWN0IGV4aXN0cywgYnV0IHRoZSBjYXBhY2l0eSBpcyB6ZXJvXG4gKlxuICogVGhlIHByb2R1Y2VyIG9mIHRoZXNlIG9iamVjdHMgY2FuIGRlY2lkZSB3aGljaCBhcHByb2FjaCBpcyBtb3JlIHN1aXRhYmxlLlxuICpcbiAqIFRoZXkgYXJlIGNvbnN1bWVkIGJ5IHRoZSBrdWJlLXNjaGVkdWxlciBpZiB0aGUgQ1NJU3RvcmFnZUNhcGFjaXR5IGJldGEgZmVhdHVyZSBnYXRlIGlzIGVuYWJsZWQgdGhlcmUgYW5kIGEgQ1NJIGRyaXZlciBvcHRzIGludG8gY2FwYWNpdHktYXdhcmUgc2NoZWR1bGluZyB3aXRoIENTSURyaXZlci5TdG9yYWdlQ2FwYWNpdHkuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjFiZXRhMS5DU0lTdG9yYWdlQ2FwYWNpdHlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlQ3NpU3RvcmFnZUNhcGFjaXR5VjFCZXRhMVByb3BzIHtcbiAgLyoqXG4gICAqIENhcGFjaXR5IGlzIHRoZSB2YWx1ZSByZXBvcnRlZCBieSB0aGUgQ1NJIGRyaXZlciBpbiBpdHMgR2V0Q2FwYWNpdHlSZXNwb25zZSBmb3IgYSBHZXRDYXBhY2l0eVJlcXVlc3Qgd2l0aCB0b3BvbG9neSBhbmQgcGFyYW1ldGVycyB0aGF0IG1hdGNoIHRoZSBwcmV2aW91cyBmaWVsZHMuXG4gICAqXG4gICAqIFRoZSBzZW1hbnRpYyBpcyBjdXJyZW50bHkgKENTSSBzcGVjIDEuMikgZGVmaW5lZCBhczogVGhlIGF2YWlsYWJsZSBjYXBhY2l0eSwgaW4gYnl0ZXMsIG9mIHRoZSBzdG9yYWdlIHRoYXQgY2FuIGJlIHVzZWQgdG8gcHJvdmlzaW9uIHZvbHVtZXMuIElmIG5vdCBzZXQsIHRoYXQgaW5mb3JtYXRpb24gaXMgY3VycmVudGx5IHVuYXZhaWxhYmxlIGFuZCB0cmVhdGVkIGxpa2UgemVybyBjYXBhY2l0eS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjFiZXRhMS5DU0lTdG9yYWdlQ2FwYWNpdHkjY2FwYWNpdHlcbiAgICovXG4gIHJlYWRvbmx5IGNhcGFjaXR5PzogUXVhbnRpdHk7XG5cbiAgLyoqXG4gICAqIE1heGltdW1Wb2x1bWVTaXplIGlzIHRoZSB2YWx1ZSByZXBvcnRlZCBieSB0aGUgQ1NJIGRyaXZlciBpbiBpdHMgR2V0Q2FwYWNpdHlSZXNwb25zZSBmb3IgYSBHZXRDYXBhY2l0eVJlcXVlc3Qgd2l0aCB0b3BvbG9neSBhbmQgcGFyYW1ldGVycyB0aGF0IG1hdGNoIHRoZSBwcmV2aW91cyBmaWVsZHMuXG4gICAqXG4gICAqIFRoaXMgaXMgZGVmaW5lZCBzaW5jZSBDU0kgc3BlYyAxLjQuMCBhcyB0aGUgbGFyZ2VzdCBzaXplIHRoYXQgbWF5IGJlIHVzZWQgaW4gYSBDcmVhdGVWb2x1bWVSZXF1ZXN0LmNhcGFjaXR5X3JhbmdlLnJlcXVpcmVkX2J5dGVzIGZpZWxkIHRvIGNyZWF0ZSBhIHZvbHVtZSB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMgYXMgdGhvc2UgaW4gR2V0Q2FwYWNpdHlSZXF1ZXN0LiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBpbiB0aGUgS3ViZXJuZXRlcyBBUEkgaXMgUmVzb3VyY2VSZXF1aXJlbWVudHMuUmVxdWVzdHMgaW4gYSB2b2x1bWUgY2xhaW0uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxYmV0YTEuQ1NJU3RvcmFnZUNhcGFjaXR5I21heGltdW1Wb2x1bWVTaXplXG4gICAqL1xuICByZWFkb25seSBtYXhpbXVtVm9sdW1lU2l6ZT86IFF1YW50aXR5O1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS4gVGhlIG5hbWUgaGFzIG5vIHBhcnRpY3VsYXIgbWVhbmluZy4gSXQgbXVzdCBiZSBiZSBhIEROUyBzdWJkb21haW4gKGRvdHMgYWxsb3dlZCwgMjUzIGNoYXJhY3RlcnMpLiBUbyBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgbm8gY29uZmxpY3RzIHdpdGggb3RoZXIgQ1NJIGRyaXZlcnMgb24gdGhlIGNsdXN0ZXIsIHRoZSByZWNvbW1lbmRhdGlvbiBpcyB0byB1c2UgY3Npc2MtPHV1aWQ+LCBhIGdlbmVyYXRlZCBuYW1lLCBvciBhIHJldmVyc2UtZG9tYWluIG5hbWUgd2hpY2ggZW5kcyB3aXRoIHRoZSB1bmlxdWUgQ1NJIGRyaXZlciBuYW1lLlxuICAgKlxuICAgKiBPYmplY3RzIGFyZSBuYW1lc3BhY2VkLlxuICAgKlxuICAgKiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxYmV0YTEuQ1NJU3RvcmFnZUNhcGFjaXR5I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIE5vZGVUb3BvbG9neSBkZWZpbmVzIHdoaWNoIG5vZGVzIGhhdmUgYWNjZXNzIHRvIHRoZSBzdG9yYWdlIGZvciB3aGljaCBjYXBhY2l0eSB3YXMgcmVwb3J0ZWQuIElmIG5vdCBzZXQsIHRoZSBzdG9yYWdlIGlzIG5vdCBhY2Nlc3NpYmxlIGZyb20gYW55IG5vZGUgaW4gdGhlIGNsdXN0ZXIuIElmIGVtcHR5LCB0aGUgc3RvcmFnZSBpcyBhY2Nlc3NpYmxlIGZyb20gYWxsIG5vZGVzLiBUaGlzIGZpZWxkIGlzIGltbXV0YWJsZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjFiZXRhMS5DU0lTdG9yYWdlQ2FwYWNpdHkjbm9kZVRvcG9sb2d5XG4gICAqL1xuICByZWFkb25seSBub2RlVG9wb2xvZ3k/OiBMYWJlbFNlbGVjdG9yO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgU3RvcmFnZUNsYXNzIHRoYXQgdGhlIHJlcG9ydGVkIGNhcGFjaXR5IGFwcGxpZXMgdG8uIEl0IG11c3QgbWVldCB0aGUgc2FtZSByZXF1aXJlbWVudHMgYXMgdGhlIG5hbWUgb2YgYSBTdG9yYWdlQ2xhc3Mgb2JqZWN0IChub24tZW1wdHksIEROUyBzdWJkb21haW4pLiBJZiB0aGF0IG9iamVjdCBubyBsb25nZXIgZXhpc3RzLCB0aGUgQ1NJU3RvcmFnZUNhcGFjaXR5IG9iamVjdCBpcyBvYnNvbGV0ZSBhbmQgc2hvdWxkIGJlIHJlbW92ZWQgYnkgaXRzIGNyZWF0b3IuIFRoaXMgZmllbGQgaXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MWJldGExLkNTSVN0b3JhZ2VDYXBhY2l0eSNzdG9yYWdlQ2xhc3NOYW1lXG4gICAqL1xuICByZWFkb25seSBzdG9yYWdlQ2xhc3NOYW1lOiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZUNzaVN0b3JhZ2VDYXBhY2l0eVYxQmV0YTFQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUNzaVN0b3JhZ2VDYXBhY2l0eVYxQmV0YTFQcm9wcyhvYmo6IEt1YmVDc2lTdG9yYWdlQ2FwYWNpdHlWMUJldGExUHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdjYXBhY2l0eSc6IG9iai5jYXBhY2l0eT8udmFsdWUsXG4gICAgJ21heGltdW1Wb2x1bWVTaXplJzogb2JqLm1heGltdW1Wb2x1bWVTaXplPy52YWx1ZSxcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdub2RlVG9wb2xvZ3knOiB0b0pzb25fTGFiZWxTZWxlY3RvcihvYmoubm9kZVRvcG9sb2d5KSxcbiAgICAnc3RvcmFnZUNsYXNzTmFtZSc6IG9iai5zdG9yYWdlQ2xhc3NOYW1lLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIENTSVN0b3JhZ2VDYXBhY2l0eUxpc3QgaXMgYSBjb2xsZWN0aW9uIG9mIENTSVN0b3JhZ2VDYXBhY2l0eSBvYmplY3RzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxYmV0YTEuQ1NJU3RvcmFnZUNhcGFjaXR5TGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVDc2lTdG9yYWdlQ2FwYWNpdHlMaXN0VjFCZXRhMVByb3BzIHtcbiAgLyoqXG4gICAqIEl0ZW1zIGlzIHRoZSBsaXN0IG9mIENTSVN0b3JhZ2VDYXBhY2l0eSBvYmplY3RzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MWJldGExLkNTSVN0b3JhZ2VDYXBhY2l0eUxpc3QjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zOiBLdWJlQ3NpU3RvcmFnZUNhcGFjaXR5VjFCZXRhMVByb3BzW107XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIGxpc3QgbWV0YWRhdGEgTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MWJldGExLkNTSVN0b3JhZ2VDYXBhY2l0eUxpc3QjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogTGlzdE1ldGE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnS3ViZUNzaVN0b3JhZ2VDYXBhY2l0eUxpc3RWMUJldGExUHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVDc2lTdG9yYWdlQ2FwYWNpdHlMaXN0VjFCZXRhMVByb3BzKG9iajogS3ViZUNzaVN0b3JhZ2VDYXBhY2l0eUxpc3RWMUJldGExUHJvcHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdpdGVtcyc6IG9iai5pdGVtcz8ubWFwKHkgPT4gdG9Kc29uX0t1YmVDc2lTdG9yYWdlQ2FwYWNpdHlWMUJldGExUHJvcHMoeSkpLFxuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9MaXN0TWV0YShvYmoubWV0YWRhdGEpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEN1c3RvbVJlc291cmNlRGVmaW5pdGlvbiByZXByZXNlbnRzIGEgcmVzb3VyY2UgdGhhdCBzaG91bGQgYmUgZXhwb3NlZCBvbiB0aGUgQVBJIHNlcnZlci4gIEl0cyBuYW1lIE1VU1QgYmUgaW4gdGhlIGZvcm1hdCA8LnNwZWMubmFtZT4uPC5zcGVjLmdyb3VwPi5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkN1c3RvbVJlc291cmNlRGVmaW5pdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVDdXN0b21SZXNvdXJjZURlZmluaXRpb25Qcm9wcyB7XG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YSBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uI21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIHNwZWMgZGVzY3JpYmVzIGhvdyB0aGUgdXNlciB3YW50cyB0aGUgcmVzb3VyY2VzIHRvIGFwcGVhclxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkN1c3RvbVJlc291cmNlRGVmaW5pdGlvbiNzcGVjXG4gICAqL1xuICByZWFkb25seSBzcGVjOiBDdXN0b21SZXNvdXJjZURlZmluaXRpb25TcGVjO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVDdXN0b21SZXNvdXJjZURlZmluaXRpb25Qcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZUN1c3RvbVJlc291cmNlRGVmaW5pdGlvblByb3BzKG9iajogS3ViZUN1c3RvbVJlc291cmNlRGVmaW5pdGlvblByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdzcGVjJzogdG9Kc29uX0N1c3RvbVJlc291cmNlRGVmaW5pdGlvblNwZWMob2JqLnNwZWMpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEN1c3RvbVJlc291cmNlRGVmaW5pdGlvbkxpc3QgaXMgYSBsaXN0IG9mIEN1c3RvbVJlc291cmNlRGVmaW5pdGlvbiBvYmplY3RzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uTGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEt1YmVDdXN0b21SZXNvdXJjZURlZmluaXRpb25MaXN0UHJvcHMge1xuICAvKipcbiAgICogaXRlbXMgbGlzdCBpbmRpdmlkdWFsIEN1c3RvbVJlc291cmNlRGVmaW5pdGlvbiBvYmplY3RzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uTGlzdCNpdGVtc1xuICAgKi9cbiAgcmVhZG9ubHkgaXRlbXM6IEt1YmVDdXN0b21SZXNvdXJjZURlZmluaXRpb25Qcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YSBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI21ldGFkYXRhXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uTGlzdCNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBMaXN0TWV0YTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdLdWJlQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uTGlzdFByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uTGlzdFByb3BzKG9iajogS3ViZUN1c3RvbVJlc291cmNlRGVmaW5pdGlvbkxpc3RQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS3ViZUN1c3RvbVJlc291cmNlRGVmaW5pdGlvblByb3BzKHkpKSxcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fTGlzdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBTdGF0dXMgaXMgYSByZXR1cm4gdmFsdWUgZm9yIGNhbGxzIHRoYXQgZG9uJ3QgcmV0dXJuIG90aGVyIG9iamVjdHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuU3RhdHVzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZVN0YXR1c1Byb3BzIHtcbiAgLyoqXG4gICAqIFN1Z2dlc3RlZCBIVFRQIHJldHVybiBjb2RlIGZvciB0aGlzIHN0YXR1cywgMCBpZiBub3Qgc2V0LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5TdGF0dXMjY29kZVxuICAgKi9cbiAgcmVhZG9ubHkgY29kZT86IG51bWJlcjtcblxuICAvKipcbiAgICogRXh0ZW5kZWQgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIHJlYXNvbi4gIEVhY2ggcmVhc29uIG1heSBkZWZpbmUgaXRzIG93biBleHRlbmRlZCBkZXRhaWxzLiBUaGlzIGZpZWxkIGlzIG9wdGlvbmFsIGFuZCB0aGUgZGF0YSByZXR1cm5lZCBpcyBub3QgZ3VhcmFudGVlZCB0byBjb25mb3JtIHRvIGFueSBzY2hlbWEgZXhjZXB0IHRoYXQgZGVmaW5lZCBieSB0aGUgcmVhc29uIHR5cGUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLlN0YXR1cyNkZXRhaWxzXG4gICAqL1xuICByZWFkb25seSBkZXRhaWxzPzogU3RhdHVzRGV0YWlscztcblxuICAvKipcbiAgICogQSBodW1hbi1yZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiB0aGUgc3RhdHVzIG9mIHRoaXMgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5TdGF0dXMjbWVzc2FnZVxuICAgKi9cbiAgcmVhZG9ubHkgbWVzc2FnZT86IHN0cmluZztcblxuICAvKipcbiAgICogU3RhbmRhcmQgbGlzdCBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCN0eXBlcy1raW5kc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5TdGF0dXMjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogTGlzdE1ldGE7XG5cbiAgLyoqXG4gICAqIEEgbWFjaGluZS1yZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiB3aHkgdGhpcyBvcGVyYXRpb24gaXMgaW4gdGhlIFwiRmFpbHVyZVwiIHN0YXR1cy4gSWYgdGhpcyB2YWx1ZSBpcyBlbXB0eSB0aGVyZSBpcyBubyBpbmZvcm1hdGlvbiBhdmFpbGFibGUuIEEgUmVhc29uIGNsYXJpZmllcyBhbiBIVFRQIHN0YXR1cyBjb2RlIGJ1dCBkb2VzIG5vdCBvdmVycmlkZSBpdC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuU3RhdHVzI3JlYXNvblxuICAgKi9cbiAgcmVhZG9ubHkgcmVhc29uPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVTdGF0dXNQcm9wcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS3ViZVN0YXR1c1Byb3BzKG9iajogS3ViZVN0YXR1c1Byb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnY29kZSc6IG9iai5jb2RlLFxuICAgICdkZXRhaWxzJzogdG9Kc29uX1N0YXR1c0RldGFpbHMob2JqLmRldGFpbHMpLFxuICAgICdtZXNzYWdlJzogb2JqLm1lc3NhZ2UsXG4gICAgJ21ldGFkYXRhJzogdG9Kc29uX0xpc3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3JlYXNvbic6IG9iai5yZWFzb24sXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQVBJU2VydmljZSByZXByZXNlbnRzIGEgc2VydmVyIGZvciBhIHBhcnRpY3VsYXIgR3JvdXBWZXJzaW9uLiBOYW1lIG11c3QgYmUgXCJ2ZXJzaW9uLmdyb3VwXCIuXG4gKlxuICogQHNjaGVtYSBpby5rOHMua3ViZS1hZ2dyZWdhdG9yLnBrZy5hcGlzLmFwaXJlZ2lzdHJhdGlvbi52MS5BUElTZXJ2aWNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS3ViZUFwaVNlcnZpY2VQcm9wcyB7XG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5rdWJlLWFnZ3JlZ2F0b3IucGtnLmFwaXMuYXBpcmVnaXN0cmF0aW9uLnYxLkFQSVNlcnZpY2UjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogU3BlYyBjb250YWlucyBpbmZvcm1hdGlvbiBmb3IgbG9jYXRpbmcgYW5kIGNvbW11bmljYXRpbmcgd2l0aCBhIHNlcnZlclxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5rdWJlLWFnZ3JlZ2F0b3IucGtnLmFwaXMuYXBpcmVnaXN0cmF0aW9uLnYxLkFQSVNlcnZpY2Ujc3BlY1xuICAgKi9cbiAgcmVhZG9ubHkgc3BlYz86IEFwaVNlcnZpY2VTcGVjO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVBcGlTZXJ2aWNlUHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0t1YmVBcGlTZXJ2aWNlUHJvcHMob2JqOiBLdWJlQXBpU2VydmljZVByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdzcGVjJzogdG9Kc29uX0FwaVNlcnZpY2VTcGVjKG9iai5zcGVjKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBBUElTZXJ2aWNlTGlzdCBpcyBhIGxpc3Qgb2YgQVBJU2VydmljZSBvYmplY3RzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmt1YmUtYWdncmVnYXRvci5wa2cuYXBpcy5hcGlyZWdpc3RyYXRpb24udjEuQVBJU2VydmljZUxpc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBLdWJlQXBpU2VydmljZUxpc3RQcm9wcyB7XG4gIC8qKlxuICAgKiBJdGVtcyBpcyB0aGUgbGlzdCBvZiBBUElTZXJ2aWNlXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmt1YmUtYWdncmVnYXRvci5wa2cuYXBpcy5hcGlyZWdpc3RyYXRpb24udjEuQVBJU2VydmljZUxpc3QjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zOiBLdWJlQXBpU2VydmljZVByb3BzW107XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIGxpc3QgbWV0YWRhdGEgTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5rdWJlLWFnZ3JlZ2F0b3IucGtnLmFwaXMuYXBpcmVnaXN0cmF0aW9uLnYxLkFQSVNlcnZpY2VMaXN0I21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IExpc3RNZXRhO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0t1YmVBcGlTZXJ2aWNlTGlzdFByb3BzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9LdWJlQXBpU2VydmljZUxpc3RQcm9wcyhvYmo6IEt1YmVBcGlTZXJ2aWNlTGlzdFByb3BzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaXRlbXMnOiBvYmouaXRlbXM/Lm1hcCh5ID0+IHRvSnNvbl9LdWJlQXBpU2VydmljZVByb3BzKHkpKSxcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fTGlzdE1ldGEob2JqLm1ldGFkYXRhKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBPYmplY3RNZXRhIGlzIG1ldGFkYXRhIHRoYXQgYWxsIHBlcnNpc3RlZCByZXNvdXJjZXMgbXVzdCBoYXZlLCB3aGljaCBpbmNsdWRlcyBhbGwgb2JqZWN0cyB1c2VycyBtdXN0IGNyZWF0ZS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5PYmplY3RNZXRhXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT2JqZWN0TWV0YSB7XG4gIC8qKlxuICAgKiBBbm5vdGF0aW9ucyBpcyBhbiB1bnN0cnVjdHVyZWQga2V5IHZhbHVlIG1hcCBzdG9yZWQgd2l0aCBhIHJlc291cmNlIHRoYXQgbWF5IGJlIHNldCBieSBleHRlcm5hbCB0b29scyB0byBzdG9yZSBhbmQgcmV0cmlldmUgYXJiaXRyYXJ5IG1ldGFkYXRhLiBUaGV5IGFyZSBub3QgcXVlcnlhYmxlIGFuZCBzaG91bGQgYmUgcHJlc2VydmVkIHdoZW4gbW9kaWZ5aW5nIG9iamVjdHMuIE1vcmUgaW5mbzogaHR0cDovL2t1YmVybmV0ZXMuaW8vZG9jcy91c2VyLWd1aWRlL2Fubm90YXRpb25zXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLk9iamVjdE1ldGEjYW5ub3RhdGlvbnNcbiAgICovXG4gIHJlYWRvbmx5IGFubm90YXRpb25zPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGNsdXN0ZXIgd2hpY2ggdGhlIG9iamVjdCBiZWxvbmdzIHRvLiBUaGlzIGlzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggcmVzb3VyY2VzIHdpdGggc2FtZSBuYW1lIGFuZCBuYW1lc3BhY2UgaW4gZGlmZmVyZW50IGNsdXN0ZXJzLiBUaGlzIGZpZWxkIGlzIG5vdCBzZXQgYW55d2hlcmUgcmlnaHQgbm93IGFuZCBhcGlzZXJ2ZXIgaXMgZ29pbmcgdG8gaWdub3JlIGl0IGlmIHNldCBpbiBjcmVhdGUgb3IgdXBkYXRlIHJlcXVlc3QuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLk9iamVjdE1ldGEjY2x1c3Rlck5hbWVcbiAgICovXG4gIHJlYWRvbmx5IGNsdXN0ZXJOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDcmVhdGlvblRpbWVzdGFtcCBpcyBhIHRpbWVzdGFtcCByZXByZXNlbnRpbmcgdGhlIHNlcnZlciB0aW1lIHdoZW4gdGhpcyBvYmplY3Qgd2FzIGNyZWF0ZWQuIEl0IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIHNldCBpbiBoYXBwZW5zLWJlZm9yZSBvcmRlciBhY3Jvc3Mgc2VwYXJhdGUgb3BlcmF0aW9ucy4gQ2xpZW50cyBtYXkgbm90IHNldCB0aGlzIHZhbHVlLiBJdCBpcyByZXByZXNlbnRlZCBpbiBSRkMzMzM5IGZvcm0gYW5kIGlzIGluIFVUQy5cbiAgICpcbiAgICogUG9wdWxhdGVkIGJ5IHRoZSBzeXN0ZW0uIFJlYWQtb25seS4gTnVsbCBmb3IgbGlzdHMuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuT2JqZWN0TWV0YSNjcmVhdGlvblRpbWVzdGFtcFxuICAgKi9cbiAgcmVhZG9ubHkgY3JlYXRpb25UaW1lc3RhbXA/OiBEYXRlO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2Ygc2Vjb25kcyBhbGxvd2VkIGZvciB0aGlzIG9iamVjdCB0byBncmFjZWZ1bGx5IHRlcm1pbmF0ZSBiZWZvcmUgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIHN5c3RlbS4gT25seSBzZXQgd2hlbiBkZWxldGlvblRpbWVzdGFtcCBpcyBhbHNvIHNldC4gTWF5IG9ubHkgYmUgc2hvcnRlbmVkLiBSZWFkLW9ubHkuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLk9iamVjdE1ldGEjZGVsZXRpb25HcmFjZVBlcmlvZFNlY29uZHNcbiAgICovXG4gIHJlYWRvbmx5IGRlbGV0aW9uR3JhY2VQZXJpb2RTZWNvbmRzPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBEZWxldGlvblRpbWVzdGFtcCBpcyBSRkMgMzMzOSBkYXRlIGFuZCB0aW1lIGF0IHdoaWNoIHRoaXMgcmVzb3VyY2Ugd2lsbCBiZSBkZWxldGVkLiBUaGlzIGZpZWxkIGlzIHNldCBieSB0aGUgc2VydmVyIHdoZW4gYSBncmFjZWZ1bCBkZWxldGlvbiBpcyByZXF1ZXN0ZWQgYnkgdGhlIHVzZXIsIGFuZCBpcyBub3QgZGlyZWN0bHkgc2V0dGFibGUgYnkgYSBjbGllbnQuIFRoZSByZXNvdXJjZSBpcyBleHBlY3RlZCB0byBiZSBkZWxldGVkIChubyBsb25nZXIgdmlzaWJsZSBmcm9tIHJlc291cmNlIGxpc3RzLCBhbmQgbm90IHJlYWNoYWJsZSBieSBuYW1lKSBhZnRlciB0aGUgdGltZSBpbiB0aGlzIGZpZWxkLCBvbmNlIHRoZSBmaW5hbGl6ZXJzIGxpc3QgaXMgZW1wdHkuIEFzIGxvbmcgYXMgdGhlIGZpbmFsaXplcnMgbGlzdCBjb250YWlucyBpdGVtcywgZGVsZXRpb24gaXMgYmxvY2tlZC4gT25jZSB0aGUgZGVsZXRpb25UaW1lc3RhbXAgaXMgc2V0LCB0aGlzIHZhbHVlIG1heSBub3QgYmUgdW5zZXQgb3IgYmUgc2V0IGZ1cnRoZXIgaW50byB0aGUgZnV0dXJlLCBhbHRob3VnaCBpdCBtYXkgYmUgc2hvcnRlbmVkIG9yIHRoZSByZXNvdXJjZSBtYXkgYmUgZGVsZXRlZCBwcmlvciB0byB0aGlzIHRpbWUuIEZvciBleGFtcGxlLCBhIHVzZXIgbWF5IHJlcXVlc3QgdGhhdCBhIHBvZCBpcyBkZWxldGVkIGluIDMwIHNlY29uZHMuIFRoZSBLdWJlbGV0IHdpbGwgcmVhY3QgYnkgc2VuZGluZyBhIGdyYWNlZnVsIHRlcm1pbmF0aW9uIHNpZ25hbCB0byB0aGUgY29udGFpbmVycyBpbiB0aGUgcG9kLiBBZnRlciB0aGF0IDMwIHNlY29uZHMsIHRoZSBLdWJlbGV0IHdpbGwgc2VuZCBhIGhhcmQgdGVybWluYXRpb24gc2lnbmFsIChTSUdLSUxMKSB0byB0aGUgY29udGFpbmVyIGFuZCBhZnRlciBjbGVhbnVwLCByZW1vdmUgdGhlIHBvZCBmcm9tIHRoZSBBUEkuIEluIHRoZSBwcmVzZW5jZSBvZiBuZXR3b3JrIHBhcnRpdGlvbnMsIHRoaXMgb2JqZWN0IG1heSBzdGlsbCBleGlzdCBhZnRlciB0aGlzIHRpbWVzdGFtcCwgdW50aWwgYW4gYWRtaW5pc3RyYXRvciBvciBhdXRvbWF0ZWQgcHJvY2VzcyBjYW4gZGV0ZXJtaW5lIHRoZSByZXNvdXJjZSBpcyBmdWxseSB0ZXJtaW5hdGVkLiBJZiBub3Qgc2V0LCBncmFjZWZ1bCBkZWxldGlvbiBvZiB0aGUgb2JqZWN0IGhhcyBub3QgYmVlbiByZXF1ZXN0ZWQuXG4gICAqXG4gICAqIFBvcHVsYXRlZCBieSB0aGUgc3lzdGVtIHdoZW4gYSBncmFjZWZ1bCBkZWxldGlvbiBpcyByZXF1ZXN0ZWQuIFJlYWQtb25seS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5PYmplY3RNZXRhI2RlbGV0aW9uVGltZXN0YW1wXG4gICAqL1xuICByZWFkb25seSBkZWxldGlvblRpbWVzdGFtcD86IERhdGU7XG5cbiAgLyoqXG4gICAqIE11c3QgYmUgZW1wdHkgYmVmb3JlIHRoZSBvYmplY3QgaXMgZGVsZXRlZCBmcm9tIHRoZSByZWdpc3RyeS4gRWFjaCBlbnRyeSBpcyBhbiBpZGVudGlmaWVyIGZvciB0aGUgcmVzcG9uc2libGUgY29tcG9uZW50IHRoYXQgd2lsbCByZW1vdmUgdGhlIGVudHJ5IGZyb20gdGhlIGxpc3QuIElmIHRoZSBkZWxldGlvblRpbWVzdGFtcCBvZiB0aGUgb2JqZWN0IGlzIG5vbi1uaWwsIGVudHJpZXMgaW4gdGhpcyBsaXN0IGNhbiBvbmx5IGJlIHJlbW92ZWQuIEZpbmFsaXplcnMgbWF5IGJlIHByb2Nlc3NlZCBhbmQgcmVtb3ZlZCBpbiBhbnkgb3JkZXIuICBPcmRlciBpcyBOT1QgZW5mb3JjZWQgYmVjYXVzZSBpdCBpbnRyb2R1Y2VzIHNpZ25pZmljYW50IHJpc2sgb2Ygc3R1Y2sgZmluYWxpemVycy4gZmluYWxpemVycyBpcyBhIHNoYXJlZCBmaWVsZCwgYW55IGFjdG9yIHdpdGggcGVybWlzc2lvbiBjYW4gcmVvcmRlciBpdC4gSWYgdGhlIGZpbmFsaXplciBsaXN0IGlzIHByb2Nlc3NlZCBpbiBvcmRlciwgdGhlbiB0aGlzIGNhbiBsZWFkIHRvIGEgc2l0dWF0aW9uIGluIHdoaWNoIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIHRoZSBmaXJzdCBmaW5hbGl6ZXIgaW4gdGhlIGxpc3QgaXMgd2FpdGluZyBmb3IgYSBzaWduYWwgKGZpZWxkIHZhbHVlLCBleHRlcm5hbCBzeXN0ZW0sIG9yIG90aGVyKSBwcm9kdWNlZCBieSBhIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgYSBmaW5hbGl6ZXIgbGF0ZXIgaW4gdGhlIGxpc3QsIHJlc3VsdGluZyBpbiBhIGRlYWRsb2NrLiBXaXRob3V0IGVuZm9yY2VkIG9yZGVyaW5nIGZpbmFsaXplcnMgYXJlIGZyZWUgdG8gb3JkZXIgYW1vbmdzdCB0aGVtc2VsdmVzIGFuZCBhcmUgbm90IHZ1bG5lcmFibGUgdG8gb3JkZXJpbmcgY2hhbmdlcyBpbiB0aGUgbGlzdC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuT2JqZWN0TWV0YSNmaW5hbGl6ZXJzXG4gICAqL1xuICByZWFkb25seSBmaW5hbGl6ZXJzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlTmFtZSBpcyBhbiBvcHRpb25hbCBwcmVmaXgsIHVzZWQgYnkgdGhlIHNlcnZlciwgdG8gZ2VuZXJhdGUgYSB1bmlxdWUgbmFtZSBPTkxZIElGIHRoZSBOYW1lIGZpZWxkIGhhcyBub3QgYmVlbiBwcm92aWRlZC4gSWYgdGhpcyBmaWVsZCBpcyB1c2VkLCB0aGUgbmFtZSByZXR1cm5lZCB0byB0aGUgY2xpZW50IHdpbGwgYmUgZGlmZmVyZW50IHRoYW4gdGhlIG5hbWUgcGFzc2VkLiBUaGlzIHZhbHVlIHdpbGwgYWxzbyBiZSBjb21iaW5lZCB3aXRoIGEgdW5pcXVlIHN1ZmZpeC4gVGhlIHByb3ZpZGVkIHZhbHVlIGhhcyB0aGUgc2FtZSB2YWxpZGF0aW9uIHJ1bGVzIGFzIHRoZSBOYW1lIGZpZWxkLCBhbmQgbWF5IGJlIHRydW5jYXRlZCBieSB0aGUgbGVuZ3RoIG9mIHRoZSBzdWZmaXggcmVxdWlyZWQgdG8gbWFrZSB0aGUgdmFsdWUgdW5pcXVlIG9uIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIElmIHRoaXMgZmllbGQgaXMgc3BlY2lmaWVkIGFuZCB0aGUgZ2VuZXJhdGVkIG5hbWUgZXhpc3RzLCB0aGUgc2VydmVyIHdpbGwgTk9UIHJldHVybiBhIDQwOSAtIGluc3RlYWQsIGl0IHdpbGwgZWl0aGVyIHJldHVybiAyMDEgQ3JlYXRlZCBvciA1MDAgd2l0aCBSZWFzb24gU2VydmVyVGltZW91dCBpbmRpY2F0aW5nIGEgdW5pcXVlIG5hbWUgY291bGQgbm90IGJlIGZvdW5kIGluIHRoZSB0aW1lIGFsbG90dGVkLCBhbmQgdGhlIGNsaWVudCBzaG91bGQgcmV0cnkgKG9wdGlvbmFsbHkgYWZ0ZXIgdGhlIHRpbWUgaW5kaWNhdGVkIGluIHRoZSBSZXRyeS1BZnRlciBoZWFkZXIpLlxuICAgKlxuICAgKiBBcHBsaWVkIG9ubHkgaWYgTmFtZSBpcyBub3Qgc3BlY2lmaWVkLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI2lkZW1wb3RlbmN5XG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLk9iamVjdE1ldGEjZ2VuZXJhdGVOYW1lXG4gICAqL1xuICByZWFkb25seSBnZW5lcmF0ZU5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgc2VxdWVuY2UgbnVtYmVyIHJlcHJlc2VudGluZyBhIHNwZWNpZmljIGdlbmVyYXRpb24gb2YgdGhlIGRlc2lyZWQgc3RhdGUuIFBvcHVsYXRlZCBieSB0aGUgc3lzdGVtLiBSZWFkLW9ubHkuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLk9iamVjdE1ldGEjZ2VuZXJhdGlvblxuICAgKi9cbiAgcmVhZG9ubHkgZ2VuZXJhdGlvbj86IG51bWJlcjtcblxuICAvKipcbiAgICogTWFwIG9mIHN0cmluZyBrZXlzIGFuZCB2YWx1ZXMgdGhhdCBjYW4gYmUgdXNlZCB0byBvcmdhbml6ZSBhbmQgY2F0ZWdvcml6ZSAoc2NvcGUgYW5kIHNlbGVjdCkgb2JqZWN0cy4gTWF5IG1hdGNoIHNlbGVjdG9ycyBvZiByZXBsaWNhdGlvbiBjb250cm9sbGVycyBhbmQgc2VydmljZXMuIE1vcmUgaW5mbzogaHR0cDovL2t1YmVybmV0ZXMuaW8vZG9jcy91c2VyLWd1aWRlL2xhYmVsc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5PYmplY3RNZXRhI2xhYmVsc1xuICAgKi9cbiAgcmVhZG9ubHkgbGFiZWxzPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcblxuICAvKipcbiAgICogTWFuYWdlZEZpZWxkcyBtYXBzIHdvcmtmbG93LWlkIGFuZCB2ZXJzaW9uIHRvIHRoZSBzZXQgb2YgZmllbGRzIHRoYXQgYXJlIG1hbmFnZWQgYnkgdGhhdCB3b3JrZmxvdy4gVGhpcyBpcyBtb3N0bHkgZm9yIGludGVybmFsIGhvdXNla2VlcGluZywgYW5kIHVzZXJzIHR5cGljYWxseSBzaG91bGRuJ3QgbmVlZCB0byBzZXQgb3IgdW5kZXJzdGFuZCB0aGlzIGZpZWxkLiBBIHdvcmtmbG93IGNhbiBiZSB0aGUgdXNlcidzIG5hbWUsIGEgY29udHJvbGxlcidzIG5hbWUsIG9yIHRoZSBuYW1lIG9mIGEgc3BlY2lmaWMgYXBwbHkgcGF0aCBsaWtlIFwiY2ktY2RcIi4gVGhlIHNldCBvZiBmaWVsZHMgaXMgYWx3YXlzIGluIHRoZSB2ZXJzaW9uIHRoYXQgdGhlIHdvcmtmbG93IHVzZWQgd2hlbiBtb2RpZnlpbmcgdGhlIG9iamVjdC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuT2JqZWN0TWV0YSNtYW5hZ2VkRmllbGRzXG4gICAqL1xuICByZWFkb25seSBtYW5hZ2VkRmllbGRzPzogTWFuYWdlZEZpZWxkc0VudHJ5W107XG5cbiAgLyoqXG4gICAqIE5hbWUgbXVzdCBiZSB1bmlxdWUgd2l0aGluIGEgbmFtZXNwYWNlLiBJcyByZXF1aXJlZCB3aGVuIGNyZWF0aW5nIHJlc291cmNlcywgYWx0aG91Z2ggc29tZSByZXNvdXJjZXMgbWF5IGFsbG93IGEgY2xpZW50IHRvIHJlcXVlc3QgdGhlIGdlbmVyYXRpb24gb2YgYW4gYXBwcm9wcmlhdGUgbmFtZSBhdXRvbWF0aWNhbGx5LiBOYW1lIGlzIHByaW1hcmlseSBpbnRlbmRlZCBmb3IgY3JlYXRpb24gaWRlbXBvdGVuY2UgYW5kIGNvbmZpZ3VyYXRpb24gZGVmaW5pdGlvbi4gQ2Fubm90IGJlIHVwZGF0ZWQuIE1vcmUgaW5mbzogaHR0cDovL2t1YmVybmV0ZXMuaW8vZG9jcy91c2VyLWd1aWRlL2lkZW50aWZpZXJzI25hbWVzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLk9iamVjdE1ldGEjbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogTmFtZXNwYWNlIGRlZmluZXMgdGhlIHNwYWNlIHdpdGhpbiB3aGljaCBlYWNoIG5hbWUgbXVzdCBiZSB1bmlxdWUuIEFuIGVtcHR5IG5hbWVzcGFjZSBpcyBlcXVpdmFsZW50IHRvIHRoZSBcImRlZmF1bHRcIiBuYW1lc3BhY2UsIGJ1dCBcImRlZmF1bHRcIiBpcyB0aGUgY2Fub25pY2FsIHJlcHJlc2VudGF0aW9uLiBOb3QgYWxsIG9iamVjdHMgYXJlIHJlcXVpcmVkIHRvIGJlIHNjb3BlZCB0byBhIG5hbWVzcGFjZSAtIHRoZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGZvciB0aG9zZSBvYmplY3RzIHdpbGwgYmUgZW1wdHkuXG4gICAqXG4gICAqIE11c3QgYmUgYSBETlNfTEFCRUwuIENhbm5vdCBiZSB1cGRhdGVkLiBNb3JlIGluZm86IGh0dHA6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvdXNlci1ndWlkZS9uYW1lc3BhY2VzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLk9iamVjdE1ldGEjbmFtZXNwYWNlXG4gICAqL1xuICByZWFkb25seSBuYW1lc3BhY2U/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIExpc3Qgb2Ygb2JqZWN0cyBkZXBlbmRlZCBieSB0aGlzIG9iamVjdC4gSWYgQUxMIG9iamVjdHMgaW4gdGhlIGxpc3QgaGF2ZSBiZWVuIGRlbGV0ZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuIElmIHRoaXMgb2JqZWN0IGlzIG1hbmFnZWQgYnkgYSBjb250cm9sbGVyLCB0aGVuIGFuIGVudHJ5IGluIHRoaXMgbGlzdCB3aWxsIHBvaW50IHRvIHRoaXMgY29udHJvbGxlciwgd2l0aCB0aGUgY29udHJvbGxlciBmaWVsZCBzZXQgdG8gdHJ1ZS4gVGhlcmUgY2Fubm90IGJlIG1vcmUgdGhhbiBvbmUgbWFuYWdpbmcgY29udHJvbGxlci5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuT2JqZWN0TWV0YSNvd25lclJlZmVyZW5jZXNcbiAgICovXG4gIHJlYWRvbmx5IG93bmVyUmVmZXJlbmNlcz86IE93bmVyUmVmZXJlbmNlW107XG5cbiAgLyoqXG4gICAqIEFuIG9wYXF1ZSB2YWx1ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGludGVybmFsIHZlcnNpb24gb2YgdGhpcyBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBieSBjbGllbnRzIHRvIGRldGVybWluZSB3aGVuIG9iamVjdHMgaGF2ZSBjaGFuZ2VkLiBNYXkgYmUgdXNlZCBmb3Igb3B0aW1pc3RpYyBjb25jdXJyZW5jeSwgY2hhbmdlIGRldGVjdGlvbiwgYW5kIHRoZSB3YXRjaCBvcGVyYXRpb24gb24gYSByZXNvdXJjZSBvciBzZXQgb2YgcmVzb3VyY2VzLiBDbGllbnRzIG11c3QgdHJlYXQgdGhlc2UgdmFsdWVzIGFzIG9wYXF1ZSBhbmQgcGFzc2VkIHVubW9kaWZpZWQgYmFjayB0byB0aGUgc2VydmVyLiBUaGV5IG1heSBvbmx5IGJlIHZhbGlkIGZvciBhIHBhcnRpY3VsYXIgcmVzb3VyY2Ugb3Igc2V0IG9mIHJlc291cmNlcy5cbiAgICpcbiAgICogUG9wdWxhdGVkIGJ5IHRoZSBzeXN0ZW0uIFJlYWQtb25seS4gVmFsdWUgbXVzdCBiZSB0cmVhdGVkIGFzIG9wYXF1ZSBieSBjbGllbnRzIGFuZCAuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjY29uY3VycmVuY3ktY29udHJvbC1hbmQtY29uc2lzdGVuY3lcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuT2JqZWN0TWV0YSNyZXNvdXJjZVZlcnNpb25cbiAgICovXG4gIHJlYWRvbmx5IHJlc291cmNlVmVyc2lvbj86IHN0cmluZztcblxuICAvKipcbiAgICogU2VsZkxpbmsgaXMgYSBVUkwgcmVwcmVzZW50aW5nIHRoaXMgb2JqZWN0LiBQb3B1bGF0ZWQgYnkgdGhlIHN5c3RlbS4gUmVhZC1vbmx5LlxuICAgKlxuICAgKiBERVBSRUNBVEVEIEt1YmVybmV0ZXMgd2lsbCBzdG9wIHByb3BhZ2F0aW5nIHRoaXMgZmllbGQgaW4gMS4yMCByZWxlYXNlIGFuZCB0aGUgZmllbGQgaXMgcGxhbm5lZCB0byBiZSByZW1vdmVkIGluIDEuMjEgcmVsZWFzZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuT2JqZWN0TWV0YSNzZWxmTGlua1xuICAgKi9cbiAgcmVhZG9ubHkgc2VsZkxpbms/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFVJRCBpcyB0aGUgdW5pcXVlIGluIHRpbWUgYW5kIHNwYWNlIHZhbHVlIGZvciB0aGlzIG9iamVjdC4gSXQgaXMgdHlwaWNhbGx5IGdlbmVyYXRlZCBieSB0aGUgc2VydmVyIG9uIHN1Y2Nlc3NmdWwgY3JlYXRpb24gb2YgYSByZXNvdXJjZSBhbmQgaXMgbm90IGFsbG93ZWQgdG8gY2hhbmdlIG9uIFBVVCBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBQb3B1bGF0ZWQgYnkgdGhlIHN5c3RlbS4gUmVhZC1vbmx5LiBNb3JlIGluZm86IGh0dHA6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvdXNlci1ndWlkZS9pZGVudGlmaWVycyN1aWRzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLk9iamVjdE1ldGEjdWlkXG4gICAqL1xuICByZWFkb25seSB1aWQ/OiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnT2JqZWN0TWV0YScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fT2JqZWN0TWV0YShvYmo6IE9iamVjdE1ldGEgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdhbm5vdGF0aW9ucyc6ICgob2JqLmFubm90YXRpb25zKSA9PT0gdW5kZWZpbmVkKSA/IHVuZGVmaW5lZCA6IChPYmplY3QuZW50cmllcyhvYmouYW5ub3RhdGlvbnMpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSkpLFxuICAgICdjbHVzdGVyTmFtZSc6IG9iai5jbHVzdGVyTmFtZSxcbiAgICAnY3JlYXRpb25UaW1lc3RhbXAnOiBvYmouY3JlYXRpb25UaW1lc3RhbXA/LnRvSVNPU3RyaW5nKCksXG4gICAgJ2RlbGV0aW9uR3JhY2VQZXJpb2RTZWNvbmRzJzogb2JqLmRlbGV0aW9uR3JhY2VQZXJpb2RTZWNvbmRzLFxuICAgICdkZWxldGlvblRpbWVzdGFtcCc6IG9iai5kZWxldGlvblRpbWVzdGFtcD8udG9JU09TdHJpbmcoKSxcbiAgICAnZmluYWxpemVycyc6IG9iai5maW5hbGl6ZXJzPy5tYXAoeSA9PiB5KSxcbiAgICAnZ2VuZXJhdGVOYW1lJzogb2JqLmdlbmVyYXRlTmFtZSxcbiAgICAnZ2VuZXJhdGlvbic6IG9iai5nZW5lcmF0aW9uLFxuICAgICdsYWJlbHMnOiAoKG9iai5sYWJlbHMpID09PSB1bmRlZmluZWQpID8gdW5kZWZpbmVkIDogKE9iamVjdC5lbnRyaWVzKG9iai5sYWJlbHMpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSkpLFxuICAgICdtYW5hZ2VkRmllbGRzJzogb2JqLm1hbmFnZWRGaWVsZHM/Lm1hcCh5ID0+IHRvSnNvbl9NYW5hZ2VkRmllbGRzRW50cnkoeSkpLFxuICAgICduYW1lJzogb2JqLm5hbWUsXG4gICAgJ25hbWVzcGFjZSc6IG9iai5uYW1lc3BhY2UsXG4gICAgJ293bmVyUmVmZXJlbmNlcyc6IG9iai5vd25lclJlZmVyZW5jZXM/Lm1hcCh5ID0+IHRvSnNvbl9Pd25lclJlZmVyZW5jZSh5KSksXG4gICAgJ3Jlc291cmNlVmVyc2lvbic6IG9iai5yZXNvdXJjZVZlcnNpb24sXG4gICAgJ3NlbGZMaW5rJzogb2JqLnNlbGZMaW5rLFxuICAgICd1aWQnOiBvYmoudWlkLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIE11dGF0aW5nV2ViaG9vayBkZXNjcmliZXMgYW4gYWRtaXNzaW9uIHdlYmhvb2sgYW5kIHRoZSByZXNvdXJjZXMgYW5kIG9wZXJhdGlvbnMgaXQgYXBwbGllcyB0by5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYWRtaXNzaW9ucmVnaXN0cmF0aW9uLnYxLk11dGF0aW5nV2ViaG9va1xuICovXG5leHBvcnQgaW50ZXJmYWNlIE11dGF0aW5nV2ViaG9vayB7XG4gIC8qKlxuICAgKiBBZG1pc3Npb25SZXZpZXdWZXJzaW9ucyBpcyBhbiBvcmRlcmVkIGxpc3Qgb2YgcHJlZmVycmVkIGBBZG1pc3Npb25SZXZpZXdgIHZlcnNpb25zIHRoZSBXZWJob29rIGV4cGVjdHMuIEFQSSBzZXJ2ZXIgd2lsbCB0cnkgdG8gdXNlIGZpcnN0IHZlcnNpb24gaW4gdGhlIGxpc3Qgd2hpY2ggaXQgc3VwcG9ydHMuIElmIG5vbmUgb2YgdGhlIHZlcnNpb25zIHNwZWNpZmllZCBpbiB0aGlzIGxpc3Qgc3VwcG9ydGVkIGJ5IEFQSSBzZXJ2ZXIsIHZhbGlkYXRpb24gd2lsbCBmYWlsIGZvciB0aGlzIG9iamVjdC4gSWYgYSBwZXJzaXN0ZWQgd2ViaG9vayBjb25maWd1cmF0aW9uIHNwZWNpZmllcyBhbGxvd2VkIHZlcnNpb25zIGFuZCBkb2VzIG5vdCBpbmNsdWRlIGFueSB2ZXJzaW9ucyBrbm93biB0byB0aGUgQVBJIFNlcnZlciwgY2FsbHMgdG8gdGhlIHdlYmhvb2sgd2lsbCBmYWlsIGFuZCBiZSBzdWJqZWN0IHRvIHRoZSBmYWlsdXJlIHBvbGljeS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFkbWlzc2lvbnJlZ2lzdHJhdGlvbi52MS5NdXRhdGluZ1dlYmhvb2sjYWRtaXNzaW9uUmV2aWV3VmVyc2lvbnNcbiAgICovXG4gIHJlYWRvbmx5IGFkbWlzc2lvblJldmlld1ZlcnNpb25zOiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogQ2xpZW50Q29uZmlnIGRlZmluZXMgaG93IHRvIGNvbW11bmljYXRlIHdpdGggdGhlIGhvb2suIFJlcXVpcmVkXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuTXV0YXRpbmdXZWJob29rI2NsaWVudENvbmZpZ1xuICAgKi9cbiAgcmVhZG9ubHkgY2xpZW50Q29uZmlnOiBXZWJob29rQ2xpZW50Q29uZmlnO1xuXG4gIC8qKlxuICAgKiBGYWlsdXJlUG9saWN5IGRlZmluZXMgaG93IHVucmVjb2duaXplZCBlcnJvcnMgZnJvbSB0aGUgYWRtaXNzaW9uIGVuZHBvaW50IGFyZSBoYW5kbGVkIC0gYWxsb3dlZCB2YWx1ZXMgYXJlIElnbm9yZSBvciBGYWlsLiBEZWZhdWx0cyB0byBGYWlsLlxuICAgKlxuICAgKiBAZGVmYXVsdCBGYWlsLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYWRtaXNzaW9ucmVnaXN0cmF0aW9uLnYxLk11dGF0aW5nV2ViaG9vayNmYWlsdXJlUG9saWN5XG4gICAqL1xuICByZWFkb25seSBmYWlsdXJlUG9saWN5Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBtYXRjaFBvbGljeSBkZWZpbmVzIGhvdyB0aGUgXCJydWxlc1wiIGxpc3QgaXMgdXNlZCB0byBtYXRjaCBpbmNvbWluZyByZXF1ZXN0cy4gQWxsb3dlZCB2YWx1ZXMgYXJlIFwiRXhhY3RcIiBvciBcIkVxdWl2YWxlbnRcIi5cbiAgICpcbiAgICogLSBFeGFjdDogbWF0Y2ggYSByZXF1ZXN0IG9ubHkgaWYgaXQgZXhhY3RseSBtYXRjaGVzIGEgc3BlY2lmaWVkIHJ1bGUuIEZvciBleGFtcGxlLCBpZiBkZXBsb3ltZW50cyBjYW4gYmUgbW9kaWZpZWQgdmlhIGFwcHMvdjEsIGFwcHMvdjFiZXRhMSwgYW5kIGV4dGVuc2lvbnMvdjFiZXRhMSwgYnV0IFwicnVsZXNcIiBvbmx5IGluY2x1ZGVkIGBhcGlHcm91cHM6W1wiYXBwc1wiXSwgYXBpVmVyc2lvbnM6W1widjFcIl0sIHJlc291cmNlczogW1wiZGVwbG95bWVudHNcIl1gLCBhIHJlcXVlc3QgdG8gYXBwcy92MWJldGExIG9yIGV4dGVuc2lvbnMvdjFiZXRhMSB3b3VsZCBub3QgYmUgc2VudCB0byB0aGUgd2ViaG9vay5cbiAgICpcbiAgICogLSBFcXVpdmFsZW50OiBtYXRjaCBhIHJlcXVlc3QgaWYgbW9kaWZpZXMgYSByZXNvdXJjZSBsaXN0ZWQgaW4gcnVsZXMsIGV2ZW4gdmlhIGFub3RoZXIgQVBJIGdyb3VwIG9yIHZlcnNpb24uIEZvciBleGFtcGxlLCBpZiBkZXBsb3ltZW50cyBjYW4gYmUgbW9kaWZpZWQgdmlhIGFwcHMvdjEsIGFwcHMvdjFiZXRhMSwgYW5kIGV4dGVuc2lvbnMvdjFiZXRhMSwgYW5kIFwicnVsZXNcIiBvbmx5IGluY2x1ZGVkIGBhcGlHcm91cHM6W1wiYXBwc1wiXSwgYXBpVmVyc2lvbnM6W1widjFcIl0sIHJlc291cmNlczogW1wiZGVwbG95bWVudHNcIl1gLCBhIHJlcXVlc3QgdG8gYXBwcy92MWJldGExIG9yIGV4dGVuc2lvbnMvdjFiZXRhMSB3b3VsZCBiZSBjb252ZXJ0ZWQgdG8gYXBwcy92MSBhbmQgc2VudCB0byB0aGUgd2ViaG9vay5cbiAgICpcbiAgICogRGVmYXVsdHMgdG8gXCJFcXVpdmFsZW50XCJcbiAgICpcbiAgICogQGRlZmF1bHQgRXF1aXZhbGVudFwiXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuTXV0YXRpbmdXZWJob29rI21hdGNoUG9saWN5XG4gICAqL1xuICByZWFkb25seSBtYXRjaFBvbGljeT86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGFkbWlzc2lvbiB3ZWJob29rLiBOYW1lIHNob3VsZCBiZSBmdWxseSBxdWFsaWZpZWQsIGUuZy4sIGltYWdlcG9saWN5Lmt1YmVybmV0ZXMuaW8sIHdoZXJlIFwiaW1hZ2Vwb2xpY3lcIiBpcyB0aGUgbmFtZSBvZiB0aGUgd2ViaG9vaywgYW5kIGt1YmVybmV0ZXMuaW8gaXMgdGhlIG5hbWUgb2YgdGhlIG9yZ2FuaXphdGlvbi4gUmVxdWlyZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuTXV0YXRpbmdXZWJob29rI25hbWVcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogTmFtZXNwYWNlU2VsZWN0b3IgZGVjaWRlcyB3aGV0aGVyIHRvIHJ1biB0aGUgd2ViaG9vayBvbiBhbiBvYmplY3QgYmFzZWQgb24gd2hldGhlciB0aGUgbmFtZXNwYWNlIGZvciB0aGF0IG9iamVjdCBtYXRjaGVzIHRoZSBzZWxlY3Rvci4gSWYgdGhlIG9iamVjdCBpdHNlbGYgaXMgYSBuYW1lc3BhY2UsIHRoZSBtYXRjaGluZyBpcyBwZXJmb3JtZWQgb24gb2JqZWN0Lm1ldGFkYXRhLmxhYmVscy4gSWYgdGhlIG9iamVjdCBpcyBhbm90aGVyIGNsdXN0ZXIgc2NvcGVkIHJlc291cmNlLCBpdCBuZXZlciBza2lwcyB0aGUgd2ViaG9vay5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIHRvIHJ1biB0aGUgd2ViaG9vayBvbiBhbnkgb2JqZWN0cyB3aG9zZSBuYW1lc3BhY2UgaXMgbm90IGFzc29jaWF0ZWQgd2l0aCBcInJ1bmxldmVsXCIgb2YgXCIwXCIgb3IgXCIxXCI7ICB5b3Ugd2lsbCBzZXQgdGhlIHNlbGVjdG9yIGFzIGZvbGxvd3M6IFwibmFtZXNwYWNlU2VsZWN0b3JcIjoge1xuICAgKiBcIm1hdGNoRXhwcmVzc2lvbnNcIjogW1xuICAgKiB7XG4gICAqIFwia2V5XCI6IFwicnVubGV2ZWxcIixcbiAgICogXCJvcGVyYXRvclwiOiBcIk5vdEluXCIsXG4gICAqIFwidmFsdWVzXCI6IFtcbiAgICogXCIwXCIsXG4gICAqIFwiMVwiXG4gICAqIF1cbiAgICogfVxuICAgKiBdXG4gICAqIH1cbiAgICpcbiAgICogSWYgaW5zdGVhZCB5b3Ugd2FudCB0byBvbmx5IHJ1biB0aGUgd2ViaG9vayBvbiBhbnkgb2JqZWN0cyB3aG9zZSBuYW1lc3BhY2UgaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBcImVudmlyb25tZW50XCIgb2YgXCJwcm9kXCIgb3IgXCJzdGFnaW5nXCI7IHlvdSB3aWxsIHNldCB0aGUgc2VsZWN0b3IgYXMgZm9sbG93czogXCJuYW1lc3BhY2VTZWxlY3RvclwiOiB7XG4gICAqIFwibWF0Y2hFeHByZXNzaW9uc1wiOiBbXG4gICAqIHtcbiAgICogXCJrZXlcIjogXCJlbnZpcm9ubWVudFwiLFxuICAgKiBcIm9wZXJhdG9yXCI6IFwiSW5cIixcbiAgICogXCJ2YWx1ZXNcIjogW1xuICAgKiBcInByb2RcIixcbiAgICogXCJzdGFnaW5nXCJcbiAgICogXVxuICAgKiB9XG4gICAqIF1cbiAgICogfVxuICAgKlxuICAgKiBTZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvb3ZlcnZpZXcvd29ya2luZy13aXRoLW9iamVjdHMvbGFiZWxzLyBmb3IgbW9yZSBleGFtcGxlcyBvZiBsYWJlbCBzZWxlY3RvcnMuXG4gICAqXG4gICAqIERlZmF1bHQgdG8gdGhlIGVtcHR5IExhYmVsU2VsZWN0b3IsIHdoaWNoIG1hdGNoZXMgZXZlcnl0aGluZy5cbiAgICpcbiAgICogQGRlZmF1bHQgdGhlIGVtcHR5IExhYmVsU2VsZWN0b3IsIHdoaWNoIG1hdGNoZXMgZXZlcnl0aGluZy5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFkbWlzc2lvbnJlZ2lzdHJhdGlvbi52MS5NdXRhdGluZ1dlYmhvb2sjbmFtZXNwYWNlU2VsZWN0b3JcbiAgICovXG4gIHJlYWRvbmx5IG5hbWVzcGFjZVNlbGVjdG9yPzogTGFiZWxTZWxlY3RvcjtcblxuICAvKipcbiAgICogT2JqZWN0U2VsZWN0b3IgZGVjaWRlcyB3aGV0aGVyIHRvIHJ1biB0aGUgd2ViaG9vayBiYXNlZCBvbiBpZiB0aGUgb2JqZWN0IGhhcyBtYXRjaGluZyBsYWJlbHMuIG9iamVjdFNlbGVjdG9yIGlzIGV2YWx1YXRlZCBhZ2FpbnN0IGJvdGggdGhlIG9sZE9iamVjdCBhbmQgbmV3T2JqZWN0IHRoYXQgd291bGQgYmUgc2VudCB0byB0aGUgd2ViaG9vaywgYW5kIGlzIGNvbnNpZGVyZWQgdG8gbWF0Y2ggaWYgZWl0aGVyIG9iamVjdCBtYXRjaGVzIHRoZSBzZWxlY3Rvci4gQSBudWxsIG9iamVjdCAob2xkT2JqZWN0IGluIHRoZSBjYXNlIG9mIGNyZWF0ZSwgb3IgbmV3T2JqZWN0IGluIHRoZSBjYXNlIG9mIGRlbGV0ZSkgb3IgYW4gb2JqZWN0IHRoYXQgY2Fubm90IGhhdmUgbGFiZWxzIChsaWtlIGEgRGVwbG95bWVudFJvbGxiYWNrIG9yIGEgUG9kUHJveHlPcHRpb25zIG9iamVjdCkgaXMgbm90IGNvbnNpZGVyZWQgdG8gbWF0Y2guIFVzZSB0aGUgb2JqZWN0IHNlbGVjdG9yIG9ubHkgaWYgdGhlIHdlYmhvb2sgaXMgb3B0LWluLCBiZWNhdXNlIGVuZCB1c2VycyBtYXkgc2tpcCB0aGUgYWRtaXNzaW9uIHdlYmhvb2sgYnkgc2V0dGluZyB0aGUgbGFiZWxzLiBEZWZhdWx0IHRvIHRoZSBlbXB0eSBMYWJlbFNlbGVjdG9yLCB3aGljaCBtYXRjaGVzIGV2ZXJ5dGhpbmcuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRoZSBlbXB0eSBMYWJlbFNlbGVjdG9yLCB3aGljaCBtYXRjaGVzIGV2ZXJ5dGhpbmcuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuTXV0YXRpbmdXZWJob29rI29iamVjdFNlbGVjdG9yXG4gICAqL1xuICByZWFkb25seSBvYmplY3RTZWxlY3Rvcj86IExhYmVsU2VsZWN0b3I7XG5cbiAgLyoqXG4gICAqIHJlaW52b2NhdGlvblBvbGljeSBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIHdlYmhvb2sgc2hvdWxkIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBhcyBwYXJ0IG9mIGEgc2luZ2xlIGFkbWlzc2lvbiBldmFsdWF0aW9uLiBBbGxvd2VkIHZhbHVlcyBhcmUgXCJOZXZlclwiIGFuZCBcIklmTmVlZGVkXCIuXG4gICAqXG4gICAqIE5ldmVyOiB0aGUgd2ViaG9vayB3aWxsIG5vdCBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2UgaW4gYSBzaW5nbGUgYWRtaXNzaW9uIGV2YWx1YXRpb24uXG4gICAqXG4gICAqIElmTmVlZGVkOiB0aGUgd2ViaG9vayB3aWxsIGJlIGNhbGxlZCBhdCBsZWFzdCBvbmUgYWRkaXRpb25hbCB0aW1lIGFzIHBhcnQgb2YgdGhlIGFkbWlzc2lvbiBldmFsdWF0aW9uIGlmIHRoZSBvYmplY3QgYmVpbmcgYWRtaXR0ZWQgaXMgbW9kaWZpZWQgYnkgb3RoZXIgYWRtaXNzaW9uIHBsdWdpbnMgYWZ0ZXIgdGhlIGluaXRpYWwgd2ViaG9vayBjYWxsLiBXZWJob29rcyB0aGF0IHNwZWNpZnkgdGhpcyBvcHRpb24gKm11c3QqIGJlIGlkZW1wb3RlbnQsIGFibGUgdG8gcHJvY2VzcyBvYmplY3RzIHRoZXkgcHJldmlvdXNseSBhZG1pdHRlZC4gTm90ZTogKiB0aGUgbnVtYmVyIG9mIGFkZGl0aW9uYWwgaW52b2NhdGlvbnMgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgZXhhY3RseSBvbmUuICogaWYgYWRkaXRpb25hbCBpbnZvY2F0aW9ucyByZXN1bHQgaW4gZnVydGhlciBtb2RpZmljYXRpb25zIHRvIHRoZSBvYmplY3QsIHdlYmhvb2tzIGFyZSBub3QgZ3VhcmFudGVlZCB0byBiZSBpbnZva2VkIGFnYWluLiAqIHdlYmhvb2tzIHRoYXQgdXNlIHRoaXMgb3B0aW9uIG1heSBiZSByZW9yZGVyZWQgdG8gbWluaW1pemUgdGhlIG51bWJlciBvZiBhZGRpdGlvbmFsIGludm9jYXRpb25zLiAqIHRvIHZhbGlkYXRlIGFuIG9iamVjdCBhZnRlciBhbGwgbXV0YXRpb25zIGFyZSBndWFyYW50ZWVkIGNvbXBsZXRlLCB1c2UgYSB2YWxpZGF0aW5nIGFkbWlzc2lvbiB3ZWJob29rIGluc3RlYWQuXG4gICAqXG4gICAqIERlZmF1bHRzIHRvIFwiTmV2ZXJcIi5cbiAgICpcbiAgICogQGRlZmF1bHQgTmV2ZXJcIi5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFkbWlzc2lvbnJlZ2lzdHJhdGlvbi52MS5NdXRhdGluZ1dlYmhvb2sjcmVpbnZvY2F0aW9uUG9saWN5XG4gICAqL1xuICByZWFkb25seSByZWludm9jYXRpb25Qb2xpY3k/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFJ1bGVzIGRlc2NyaWJlcyB3aGF0IG9wZXJhdGlvbnMgb24gd2hhdCByZXNvdXJjZXMvc3VicmVzb3VyY2VzIHRoZSB3ZWJob29rIGNhcmVzIGFib3V0LiBUaGUgd2ViaG9vayBjYXJlcyBhYm91dCBhbiBvcGVyYXRpb24gaWYgaXQgbWF0Y2hlcyBfYW55XyBSdWxlLiBIb3dldmVyLCBpbiBvcmRlciB0byBwcmV2ZW50IFZhbGlkYXRpbmdBZG1pc3Npb25XZWJob29rcyBhbmQgTXV0YXRpbmdBZG1pc3Npb25XZWJob29rcyBmcm9tIHB1dHRpbmcgdGhlIGNsdXN0ZXIgaW4gYSBzdGF0ZSB3aGljaCBjYW5ub3QgYmUgcmVjb3ZlcmVkIGZyb20gd2l0aG91dCBjb21wbGV0ZWx5IGRpc2FibGluZyB0aGUgcGx1Z2luLCBWYWxpZGF0aW5nQWRtaXNzaW9uV2ViaG9va3MgYW5kIE11dGF0aW5nQWRtaXNzaW9uV2ViaG9va3MgYXJlIG5ldmVyIGNhbGxlZCBvbiBhZG1pc3Npb24gcmVxdWVzdHMgZm9yIFZhbGlkYXRpbmdXZWJob29rQ29uZmlndXJhdGlvbiBhbmQgTXV0YXRpbmdXZWJob29rQ29uZmlndXJhdGlvbiBvYmplY3RzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYWRtaXNzaW9ucmVnaXN0cmF0aW9uLnYxLk11dGF0aW5nV2ViaG9vayNydWxlc1xuICAgKi9cbiAgcmVhZG9ubHkgcnVsZXM/OiBSdWxlV2l0aE9wZXJhdGlvbnNbXTtcblxuICAvKipcbiAgICogU2lkZUVmZmVjdHMgc3RhdGVzIHdoZXRoZXIgdGhpcyB3ZWJob29rIGhhcyBzaWRlIGVmZmVjdHMuIEFjY2VwdGFibGUgdmFsdWVzIGFyZTogTm9uZSwgTm9uZU9uRHJ5UnVuICh3ZWJob29rcyBjcmVhdGVkIHZpYSB2MWJldGExIG1heSBhbHNvIHNwZWNpZnkgU29tZSBvciBVbmtub3duKS4gV2ViaG9va3Mgd2l0aCBzaWRlIGVmZmVjdHMgTVVTVCBpbXBsZW1lbnQgYSByZWNvbmNpbGlhdGlvbiBzeXN0ZW0sIHNpbmNlIGEgcmVxdWVzdCBtYXkgYmUgcmVqZWN0ZWQgYnkgYSBmdXR1cmUgc3RlcCBpbiB0aGUgYWRtaXNzaW9uIGNoYWluIGFuZCB0aGUgc2lkZSBlZmZlY3RzIHRoZXJlZm9yZSBuZWVkIHRvIGJlIHVuZG9uZS4gUmVxdWVzdHMgd2l0aCB0aGUgZHJ5UnVuIGF0dHJpYnV0ZSB3aWxsIGJlIGF1dG8tcmVqZWN0ZWQgaWYgdGhleSBtYXRjaCBhIHdlYmhvb2sgd2l0aCBzaWRlRWZmZWN0cyA9PSBVbmtub3duIG9yIFNvbWUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuTXV0YXRpbmdXZWJob29rI3NpZGVFZmZlY3RzXG4gICAqL1xuICByZWFkb25seSBzaWRlRWZmZWN0czogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaW1lb3V0U2Vjb25kcyBzcGVjaWZpZXMgdGhlIHRpbWVvdXQgZm9yIHRoaXMgd2ViaG9vay4gQWZ0ZXIgdGhlIHRpbWVvdXQgcGFzc2VzLCB0aGUgd2ViaG9vayBjYWxsIHdpbGwgYmUgaWdub3JlZCBvciB0aGUgQVBJIGNhbGwgd2lsbCBmYWlsIGJhc2VkIG9uIHRoZSBmYWlsdXJlIHBvbGljeS4gVGhlIHRpbWVvdXQgdmFsdWUgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDMwIHNlY29uZHMuIERlZmF1bHQgdG8gMTAgc2Vjb25kcy5cbiAgICpcbiAgICogQGRlZmF1bHQgMTAgc2Vjb25kcy5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFkbWlzc2lvbnJlZ2lzdHJhdGlvbi52MS5NdXRhdGluZ1dlYmhvb2sjdGltZW91dFNlY29uZHNcbiAgICovXG4gIHJlYWRvbmx5IHRpbWVvdXRTZWNvbmRzPzogbnVtYmVyO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ011dGF0aW5nV2ViaG9vaycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fTXV0YXRpbmdXZWJob29rKG9iajogTXV0YXRpbmdXZWJob29rIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnYWRtaXNzaW9uUmV2aWV3VmVyc2lvbnMnOiBvYmouYWRtaXNzaW9uUmV2aWV3VmVyc2lvbnM/Lm1hcCh5ID0+IHkpLFxuICAgICdjbGllbnRDb25maWcnOiB0b0pzb25fV2ViaG9va0NsaWVudENvbmZpZyhvYmouY2xpZW50Q29uZmlnKSxcbiAgICAnZmFpbHVyZVBvbGljeSc6IG9iai5mYWlsdXJlUG9saWN5LFxuICAgICdtYXRjaFBvbGljeSc6IG9iai5tYXRjaFBvbGljeSxcbiAgICAnbmFtZSc6IG9iai5uYW1lLFxuICAgICduYW1lc3BhY2VTZWxlY3Rvcic6IHRvSnNvbl9MYWJlbFNlbGVjdG9yKG9iai5uYW1lc3BhY2VTZWxlY3RvciksXG4gICAgJ29iamVjdFNlbGVjdG9yJzogdG9Kc29uX0xhYmVsU2VsZWN0b3Iob2JqLm9iamVjdFNlbGVjdG9yKSxcbiAgICAncmVpbnZvY2F0aW9uUG9saWN5Jzogb2JqLnJlaW52b2NhdGlvblBvbGljeSxcbiAgICAncnVsZXMnOiBvYmoucnVsZXM/Lm1hcCh5ID0+IHRvSnNvbl9SdWxlV2l0aE9wZXJhdGlvbnMoeSkpLFxuICAgICdzaWRlRWZmZWN0cyc6IG9iai5zaWRlRWZmZWN0cyxcbiAgICAndGltZW91dFNlY29uZHMnOiBvYmoudGltZW91dFNlY29uZHMsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogTGlzdE1ldGEgZGVzY3JpYmVzIG1ldGFkYXRhIHRoYXQgc3ludGhldGljIHJlc291cmNlcyBtdXN0IGhhdmUsIGluY2x1ZGluZyBsaXN0cyBhbmQgdmFyaW91cyBzdGF0dXMgb2JqZWN0cy4gQSByZXNvdXJjZSBtYXkgaGF2ZSBvbmx5IG9uZSBvZiB7T2JqZWN0TWV0YSwgTGlzdE1ldGF9LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLkxpc3RNZXRhXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdE1ldGEge1xuICAvKipcbiAgICogY29udGludWUgbWF5IGJlIHNldCBpZiB0aGUgdXNlciBzZXQgYSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIGl0ZW1zIHJldHVybmVkLCBhbmQgaW5kaWNhdGVzIHRoYXQgdGhlIHNlcnZlciBoYXMgbW9yZSBkYXRhIGF2YWlsYWJsZS4gVGhlIHZhbHVlIGlzIG9wYXF1ZSBhbmQgbWF5IGJlIHVzZWQgdG8gaXNzdWUgYW5vdGhlciByZXF1ZXN0IHRvIHRoZSBlbmRwb2ludCB0aGF0IHNlcnZlZCB0aGlzIGxpc3QgdG8gcmV0cmlldmUgdGhlIG5leHQgc2V0IG9mIGF2YWlsYWJsZSBvYmplY3RzLiBDb250aW51aW5nIGEgY29uc2lzdGVudCBsaXN0IG1heSBub3QgYmUgcG9zc2libGUgaWYgdGhlIHNlcnZlciBjb25maWd1cmF0aW9uIGhhcyBjaGFuZ2VkIG9yIG1vcmUgdGhhbiBhIGZldyBtaW51dGVzIGhhdmUgcGFzc2VkLiBUaGUgcmVzb3VyY2VWZXJzaW9uIGZpZWxkIHJldHVybmVkIHdoZW4gdXNpbmcgdGhpcyBjb250aW51ZSB2YWx1ZSB3aWxsIGJlIGlkZW50aWNhbCB0byB0aGUgdmFsdWUgaW4gdGhlIGZpcnN0IHJlc3BvbnNlLCB1bmxlc3MgeW91IGhhdmUgcmVjZWl2ZWQgdGhpcyB0b2tlbiBmcm9tIGFuIGVycm9yIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLkxpc3RNZXRhI2NvbnRpbnVlXG4gICAqL1xuICByZWFkb25seSBjb250aW51ZT86IHN0cmluZztcblxuICAvKipcbiAgICogcmVtYWluaW5nSXRlbUNvdW50IGlzIHRoZSBudW1iZXIgb2Ygc3Vic2VxdWVudCBpdGVtcyBpbiB0aGUgbGlzdCB3aGljaCBhcmUgbm90IGluY2x1ZGVkIGluIHRoaXMgbGlzdCByZXNwb25zZS4gSWYgdGhlIGxpc3QgcmVxdWVzdCBjb250YWluZWQgbGFiZWwgb3IgZmllbGQgc2VsZWN0b3JzLCB0aGVuIHRoZSBudW1iZXIgb2YgcmVtYWluaW5nIGl0ZW1zIGlzIHVua25vd24gYW5kIHRoZSBmaWVsZCB3aWxsIGJlIGxlZnQgdW5zZXQgYW5kIG9taXR0ZWQgZHVyaW5nIHNlcmlhbGl6YXRpb24uIElmIHRoZSBsaXN0IGlzIGNvbXBsZXRlIChlaXRoZXIgYmVjYXVzZSBpdCBpcyBub3QgY2h1bmtpbmcgb3IgYmVjYXVzZSB0aGlzIGlzIHRoZSBsYXN0IGNodW5rKSwgdGhlbiB0aGVyZSBhcmUgbm8gbW9yZSByZW1haW5pbmcgaXRlbXMgYW5kIHRoaXMgZmllbGQgd2lsbCBiZSBsZWZ0IHVuc2V0IGFuZCBvbWl0dGVkIGR1cmluZyBzZXJpYWxpemF0aW9uLiBTZXJ2ZXJzIG9sZGVyIHRoYW4gdjEuMTUgZG8gbm90IHNldCB0aGlzIGZpZWxkLiBUaGUgaW50ZW5kZWQgdXNlIG9mIHRoZSByZW1haW5pbmdJdGVtQ291bnQgaXMgKmVzdGltYXRpbmcqIHRoZSBzaXplIG9mIGEgY29sbGVjdGlvbi4gQ2xpZW50cyBzaG91bGQgbm90IHJlbHkgb24gdGhlIHJlbWFpbmluZ0l0ZW1Db3VudCB0byBiZSBzZXQgb3IgdG8gYmUgZXhhY3QuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLkxpc3RNZXRhI3JlbWFpbmluZ0l0ZW1Db3VudFxuICAgKi9cbiAgcmVhZG9ubHkgcmVtYWluaW5nSXRlbUNvdW50PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBTdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoZSBzZXJ2ZXIncyBpbnRlcm5hbCB2ZXJzaW9uIG9mIHRoaXMgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYnkgY2xpZW50cyB0byBkZXRlcm1pbmUgd2hlbiBvYmplY3RzIGhhdmUgY2hhbmdlZC4gVmFsdWUgbXVzdCBiZSB0cmVhdGVkIGFzIG9wYXF1ZSBieSBjbGllbnRzIGFuZCBwYXNzZWQgdW5tb2RpZmllZCBiYWNrIHRvIHRoZSBzZXJ2ZXIuIFBvcHVsYXRlZCBieSB0aGUgc3lzdGVtLiBSZWFkLW9ubHkuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjY29uY3VycmVuY3ktY29udHJvbC1hbmQtY29uc2lzdGVuY3lcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuTGlzdE1ldGEjcmVzb3VyY2VWZXJzaW9uXG4gICAqL1xuICByZWFkb25seSByZXNvdXJjZVZlcnNpb24/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIHNlbGZMaW5rIGlzIGEgVVJMIHJlcHJlc2VudGluZyB0aGlzIG9iamVjdC4gUG9wdWxhdGVkIGJ5IHRoZSBzeXN0ZW0uIFJlYWQtb25seS5cbiAgICpcbiAgICogREVQUkVDQVRFRCBLdWJlcm5ldGVzIHdpbGwgc3RvcCBwcm9wYWdhdGluZyB0aGlzIGZpZWxkIGluIDEuMjAgcmVsZWFzZSBhbmQgdGhlIGZpZWxkIGlzIHBsYW5uZWQgdG8gYmUgcmVtb3ZlZCBpbiAxLjIxIHJlbGVhc2UuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLkxpc3RNZXRhI3NlbGZMaW5rXG4gICAqL1xuICByZWFkb25seSBzZWxmTGluaz86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdMaXN0TWV0YScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fTGlzdE1ldGEob2JqOiBMaXN0TWV0YSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2NvbnRpbnVlJzogb2JqLmNvbnRpbnVlLFxuICAgICdyZW1haW5pbmdJdGVtQ291bnQnOiBvYmoucmVtYWluaW5nSXRlbUNvdW50LFxuICAgICdyZXNvdXJjZVZlcnNpb24nOiBvYmoucmVzb3VyY2VWZXJzaW9uLFxuICAgICdzZWxmTGluayc6IG9iai5zZWxmTGluayxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBWYWxpZGF0aW5nV2ViaG9vayBkZXNjcmliZXMgYW4gYWRtaXNzaW9uIHdlYmhvb2sgYW5kIHRoZSByZXNvdXJjZXMgYW5kIG9wZXJhdGlvbnMgaXQgYXBwbGllcyB0by5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYWRtaXNzaW9ucmVnaXN0cmF0aW9uLnYxLlZhbGlkYXRpbmdXZWJob29rXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdGluZ1dlYmhvb2sge1xuICAvKipcbiAgICogQWRtaXNzaW9uUmV2aWV3VmVyc2lvbnMgaXMgYW4gb3JkZXJlZCBsaXN0IG9mIHByZWZlcnJlZCBgQWRtaXNzaW9uUmV2aWV3YCB2ZXJzaW9ucyB0aGUgV2ViaG9vayBleHBlY3RzLiBBUEkgc2VydmVyIHdpbGwgdHJ5IHRvIHVzZSBmaXJzdCB2ZXJzaW9uIGluIHRoZSBsaXN0IHdoaWNoIGl0IHN1cHBvcnRzLiBJZiBub25lIG9mIHRoZSB2ZXJzaW9ucyBzcGVjaWZpZWQgaW4gdGhpcyBsaXN0IHN1cHBvcnRlZCBieSBBUEkgc2VydmVyLCB2YWxpZGF0aW9uIHdpbGwgZmFpbCBmb3IgdGhpcyBvYmplY3QuIElmIGEgcGVyc2lzdGVkIHdlYmhvb2sgY29uZmlndXJhdGlvbiBzcGVjaWZpZXMgYWxsb3dlZCB2ZXJzaW9ucyBhbmQgZG9lcyBub3QgaW5jbHVkZSBhbnkgdmVyc2lvbnMga25vd24gdG8gdGhlIEFQSSBTZXJ2ZXIsIGNhbGxzIHRvIHRoZSB3ZWJob29rIHdpbGwgZmFpbCBhbmQgYmUgc3ViamVjdCB0byB0aGUgZmFpbHVyZSBwb2xpY3kuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuVmFsaWRhdGluZ1dlYmhvb2sjYWRtaXNzaW9uUmV2aWV3VmVyc2lvbnNcbiAgICovXG4gIHJlYWRvbmx5IGFkbWlzc2lvblJldmlld1ZlcnNpb25zOiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogQ2xpZW50Q29uZmlnIGRlZmluZXMgaG93IHRvIGNvbW11bmljYXRlIHdpdGggdGhlIGhvb2suIFJlcXVpcmVkXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuVmFsaWRhdGluZ1dlYmhvb2sjY2xpZW50Q29uZmlnXG4gICAqL1xuICByZWFkb25seSBjbGllbnRDb25maWc6IFdlYmhvb2tDbGllbnRDb25maWc7XG5cbiAgLyoqXG4gICAqIEZhaWx1cmVQb2xpY3kgZGVmaW5lcyBob3cgdW5yZWNvZ25pemVkIGVycm9ycyBmcm9tIHRoZSBhZG1pc3Npb24gZW5kcG9pbnQgYXJlIGhhbmRsZWQgLSBhbGxvd2VkIHZhbHVlcyBhcmUgSWdub3JlIG9yIEZhaWwuIERlZmF1bHRzIHRvIEZhaWwuXG4gICAqXG4gICAqIEBkZWZhdWx0IEZhaWwuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuVmFsaWRhdGluZ1dlYmhvb2sjZmFpbHVyZVBvbGljeVxuICAgKi9cbiAgcmVhZG9ubHkgZmFpbHVyZVBvbGljeT86IHN0cmluZztcblxuICAvKipcbiAgICogbWF0Y2hQb2xpY3kgZGVmaW5lcyBob3cgdGhlIFwicnVsZXNcIiBsaXN0IGlzIHVzZWQgdG8gbWF0Y2ggaW5jb21pbmcgcmVxdWVzdHMuIEFsbG93ZWQgdmFsdWVzIGFyZSBcIkV4YWN0XCIgb3IgXCJFcXVpdmFsZW50XCIuXG4gICAqXG4gICAqIC0gRXhhY3Q6IG1hdGNoIGEgcmVxdWVzdCBvbmx5IGlmIGl0IGV4YWN0bHkgbWF0Y2hlcyBhIHNwZWNpZmllZCBydWxlLiBGb3IgZXhhbXBsZSwgaWYgZGVwbG95bWVudHMgY2FuIGJlIG1vZGlmaWVkIHZpYSBhcHBzL3YxLCBhcHBzL3YxYmV0YTEsIGFuZCBleHRlbnNpb25zL3YxYmV0YTEsIGJ1dCBcInJ1bGVzXCIgb25seSBpbmNsdWRlZCBgYXBpR3JvdXBzOltcImFwcHNcIl0sIGFwaVZlcnNpb25zOltcInYxXCJdLCByZXNvdXJjZXM6IFtcImRlcGxveW1lbnRzXCJdYCwgYSByZXF1ZXN0IHRvIGFwcHMvdjFiZXRhMSBvciBleHRlbnNpb25zL3YxYmV0YTEgd291bGQgbm90IGJlIHNlbnQgdG8gdGhlIHdlYmhvb2suXG4gICAqXG4gICAqIC0gRXF1aXZhbGVudDogbWF0Y2ggYSByZXF1ZXN0IGlmIG1vZGlmaWVzIGEgcmVzb3VyY2UgbGlzdGVkIGluIHJ1bGVzLCBldmVuIHZpYSBhbm90aGVyIEFQSSBncm91cCBvciB2ZXJzaW9uLiBGb3IgZXhhbXBsZSwgaWYgZGVwbG95bWVudHMgY2FuIGJlIG1vZGlmaWVkIHZpYSBhcHBzL3YxLCBhcHBzL3YxYmV0YTEsIGFuZCBleHRlbnNpb25zL3YxYmV0YTEsIGFuZCBcInJ1bGVzXCIgb25seSBpbmNsdWRlZCBgYXBpR3JvdXBzOltcImFwcHNcIl0sIGFwaVZlcnNpb25zOltcInYxXCJdLCByZXNvdXJjZXM6IFtcImRlcGxveW1lbnRzXCJdYCwgYSByZXF1ZXN0IHRvIGFwcHMvdjFiZXRhMSBvciBleHRlbnNpb25zL3YxYmV0YTEgd291bGQgYmUgY29udmVydGVkIHRvIGFwcHMvdjEgYW5kIHNlbnQgdG8gdGhlIHdlYmhvb2suXG4gICAqXG4gICAqIERlZmF1bHRzIHRvIFwiRXF1aXZhbGVudFwiXG4gICAqXG4gICAqIEBkZWZhdWx0IEVxdWl2YWxlbnRcIlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYWRtaXNzaW9ucmVnaXN0cmF0aW9uLnYxLlZhbGlkYXRpbmdXZWJob29rI21hdGNoUG9saWN5XG4gICAqL1xuICByZWFkb25seSBtYXRjaFBvbGljeT86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGFkbWlzc2lvbiB3ZWJob29rLiBOYW1lIHNob3VsZCBiZSBmdWxseSBxdWFsaWZpZWQsIGUuZy4sIGltYWdlcG9saWN5Lmt1YmVybmV0ZXMuaW8sIHdoZXJlIFwiaW1hZ2Vwb2xpY3lcIiBpcyB0aGUgbmFtZSBvZiB0aGUgd2ViaG9vaywgYW5kIGt1YmVybmV0ZXMuaW8gaXMgdGhlIG5hbWUgb2YgdGhlIG9yZ2FuaXphdGlvbi4gUmVxdWlyZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuVmFsaWRhdGluZ1dlYmhvb2sjbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBOYW1lc3BhY2VTZWxlY3RvciBkZWNpZGVzIHdoZXRoZXIgdG8gcnVuIHRoZSB3ZWJob29rIG9uIGFuIG9iamVjdCBiYXNlZCBvbiB3aGV0aGVyIHRoZSBuYW1lc3BhY2UgZm9yIHRoYXQgb2JqZWN0IG1hdGNoZXMgdGhlIHNlbGVjdG9yLiBJZiB0aGUgb2JqZWN0IGl0c2VsZiBpcyBhIG5hbWVzcGFjZSwgdGhlIG1hdGNoaW5nIGlzIHBlcmZvcm1lZCBvbiBvYmplY3QubWV0YWRhdGEubGFiZWxzLiBJZiB0aGUgb2JqZWN0IGlzIGFub3RoZXIgY2x1c3RlciBzY29wZWQgcmVzb3VyY2UsIGl0IG5ldmVyIHNraXBzIHRoZSB3ZWJob29rLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgdG8gcnVuIHRoZSB3ZWJob29rIG9uIGFueSBvYmplY3RzIHdob3NlIG5hbWVzcGFjZSBpcyBub3QgYXNzb2NpYXRlZCB3aXRoIFwicnVubGV2ZWxcIiBvZiBcIjBcIiBvciBcIjFcIjsgIHlvdSB3aWxsIHNldCB0aGUgc2VsZWN0b3IgYXMgZm9sbG93czogXCJuYW1lc3BhY2VTZWxlY3RvclwiOiB7XG4gICAqIFwibWF0Y2hFeHByZXNzaW9uc1wiOiBbXG4gICAqIHtcbiAgICogXCJrZXlcIjogXCJydW5sZXZlbFwiLFxuICAgKiBcIm9wZXJhdG9yXCI6IFwiTm90SW5cIixcbiAgICogXCJ2YWx1ZXNcIjogW1xuICAgKiBcIjBcIixcbiAgICogXCIxXCJcbiAgICogXVxuICAgKiB9XG4gICAqIF1cbiAgICogfVxuICAgKlxuICAgKiBJZiBpbnN0ZWFkIHlvdSB3YW50IHRvIG9ubHkgcnVuIHRoZSB3ZWJob29rIG9uIGFueSBvYmplY3RzIHdob3NlIG5hbWVzcGFjZSBpcyBhc3NvY2lhdGVkIHdpdGggdGhlIFwiZW52aXJvbm1lbnRcIiBvZiBcInByb2RcIiBvciBcInN0YWdpbmdcIjsgeW91IHdpbGwgc2V0IHRoZSBzZWxlY3RvciBhcyBmb2xsb3dzOiBcIm5hbWVzcGFjZVNlbGVjdG9yXCI6IHtcbiAgICogXCJtYXRjaEV4cHJlc3Npb25zXCI6IFtcbiAgICoge1xuICAgKiBcImtleVwiOiBcImVudmlyb25tZW50XCIsXG4gICAqIFwib3BlcmF0b3JcIjogXCJJblwiLFxuICAgKiBcInZhbHVlc1wiOiBbXG4gICAqIFwicHJvZFwiLFxuICAgKiBcInN0YWdpbmdcIlxuICAgKiBdXG4gICAqIH1cbiAgICogXVxuICAgKiB9XG4gICAqXG4gICAqIFNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9vdmVydmlldy93b3JraW5nLXdpdGgtb2JqZWN0cy9sYWJlbHMgZm9yIG1vcmUgZXhhbXBsZXMgb2YgbGFiZWwgc2VsZWN0b3JzLlxuICAgKlxuICAgKiBEZWZhdWx0IHRvIHRoZSBlbXB0eSBMYWJlbFNlbGVjdG9yLCB3aGljaCBtYXRjaGVzIGV2ZXJ5dGhpbmcuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRoZSBlbXB0eSBMYWJlbFNlbGVjdG9yLCB3aGljaCBtYXRjaGVzIGV2ZXJ5dGhpbmcuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuVmFsaWRhdGluZ1dlYmhvb2sjbmFtZXNwYWNlU2VsZWN0b3JcbiAgICovXG4gIHJlYWRvbmx5IG5hbWVzcGFjZVNlbGVjdG9yPzogTGFiZWxTZWxlY3RvcjtcblxuICAvKipcbiAgICogT2JqZWN0U2VsZWN0b3IgZGVjaWRlcyB3aGV0aGVyIHRvIHJ1biB0aGUgd2ViaG9vayBiYXNlZCBvbiBpZiB0aGUgb2JqZWN0IGhhcyBtYXRjaGluZyBsYWJlbHMuIG9iamVjdFNlbGVjdG9yIGlzIGV2YWx1YXRlZCBhZ2FpbnN0IGJvdGggdGhlIG9sZE9iamVjdCBhbmQgbmV3T2JqZWN0IHRoYXQgd291bGQgYmUgc2VudCB0byB0aGUgd2ViaG9vaywgYW5kIGlzIGNvbnNpZGVyZWQgdG8gbWF0Y2ggaWYgZWl0aGVyIG9iamVjdCBtYXRjaGVzIHRoZSBzZWxlY3Rvci4gQSBudWxsIG9iamVjdCAob2xkT2JqZWN0IGluIHRoZSBjYXNlIG9mIGNyZWF0ZSwgb3IgbmV3T2JqZWN0IGluIHRoZSBjYXNlIG9mIGRlbGV0ZSkgb3IgYW4gb2JqZWN0IHRoYXQgY2Fubm90IGhhdmUgbGFiZWxzIChsaWtlIGEgRGVwbG95bWVudFJvbGxiYWNrIG9yIGEgUG9kUHJveHlPcHRpb25zIG9iamVjdCkgaXMgbm90IGNvbnNpZGVyZWQgdG8gbWF0Y2guIFVzZSB0aGUgb2JqZWN0IHNlbGVjdG9yIG9ubHkgaWYgdGhlIHdlYmhvb2sgaXMgb3B0LWluLCBiZWNhdXNlIGVuZCB1c2VycyBtYXkgc2tpcCB0aGUgYWRtaXNzaW9uIHdlYmhvb2sgYnkgc2V0dGluZyB0aGUgbGFiZWxzLiBEZWZhdWx0IHRvIHRoZSBlbXB0eSBMYWJlbFNlbGVjdG9yLCB3aGljaCBtYXRjaGVzIGV2ZXJ5dGhpbmcuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRoZSBlbXB0eSBMYWJlbFNlbGVjdG9yLCB3aGljaCBtYXRjaGVzIGV2ZXJ5dGhpbmcuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuVmFsaWRhdGluZ1dlYmhvb2sjb2JqZWN0U2VsZWN0b3JcbiAgICovXG4gIHJlYWRvbmx5IG9iamVjdFNlbGVjdG9yPzogTGFiZWxTZWxlY3RvcjtcblxuICAvKipcbiAgICogUnVsZXMgZGVzY3JpYmVzIHdoYXQgb3BlcmF0aW9ucyBvbiB3aGF0IHJlc291cmNlcy9zdWJyZXNvdXJjZXMgdGhlIHdlYmhvb2sgY2FyZXMgYWJvdXQuIFRoZSB3ZWJob29rIGNhcmVzIGFib3V0IGFuIG9wZXJhdGlvbiBpZiBpdCBtYXRjaGVzIF9hbnlfIFJ1bGUuIEhvd2V2ZXIsIGluIG9yZGVyIHRvIHByZXZlbnQgVmFsaWRhdGluZ0FkbWlzc2lvbldlYmhvb2tzIGFuZCBNdXRhdGluZ0FkbWlzc2lvbldlYmhvb2tzIGZyb20gcHV0dGluZyB0aGUgY2x1c3RlciBpbiBhIHN0YXRlIHdoaWNoIGNhbm5vdCBiZSByZWNvdmVyZWQgZnJvbSB3aXRob3V0IGNvbXBsZXRlbHkgZGlzYWJsaW5nIHRoZSBwbHVnaW4sIFZhbGlkYXRpbmdBZG1pc3Npb25XZWJob29rcyBhbmQgTXV0YXRpbmdBZG1pc3Npb25XZWJob29rcyBhcmUgbmV2ZXIgY2FsbGVkIG9uIGFkbWlzc2lvbiByZXF1ZXN0cyBmb3IgVmFsaWRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uIGFuZCBNdXRhdGluZ1dlYmhvb2tDb25maWd1cmF0aW9uIG9iamVjdHMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuVmFsaWRhdGluZ1dlYmhvb2sjcnVsZXNcbiAgICovXG4gIHJlYWRvbmx5IHJ1bGVzPzogUnVsZVdpdGhPcGVyYXRpb25zW107XG5cbiAgLyoqXG4gICAqIFNpZGVFZmZlY3RzIHN0YXRlcyB3aGV0aGVyIHRoaXMgd2ViaG9vayBoYXMgc2lkZSBlZmZlY3RzLiBBY2NlcHRhYmxlIHZhbHVlcyBhcmU6IE5vbmUsIE5vbmVPbkRyeVJ1biAod2ViaG9va3MgY3JlYXRlZCB2aWEgdjFiZXRhMSBtYXkgYWxzbyBzcGVjaWZ5IFNvbWUgb3IgVW5rbm93bikuIFdlYmhvb2tzIHdpdGggc2lkZSBlZmZlY3RzIE1VU1QgaW1wbGVtZW50IGEgcmVjb25jaWxpYXRpb24gc3lzdGVtLCBzaW5jZSBhIHJlcXVlc3QgbWF5IGJlIHJlamVjdGVkIGJ5IGEgZnV0dXJlIHN0ZXAgaW4gdGhlIGFkbWlzc2lvbiBjaGFpbiBhbmQgdGhlIHNpZGUgZWZmZWN0cyB0aGVyZWZvcmUgbmVlZCB0byBiZSB1bmRvbmUuIFJlcXVlc3RzIHdpdGggdGhlIGRyeVJ1biBhdHRyaWJ1dGUgd2lsbCBiZSBhdXRvLXJlamVjdGVkIGlmIHRoZXkgbWF0Y2ggYSB3ZWJob29rIHdpdGggc2lkZUVmZmVjdHMgPT0gVW5rbm93biBvciBTb21lLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYWRtaXNzaW9ucmVnaXN0cmF0aW9uLnYxLlZhbGlkYXRpbmdXZWJob29rI3NpZGVFZmZlY3RzXG4gICAqL1xuICByZWFkb25seSBzaWRlRWZmZWN0czogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaW1lb3V0U2Vjb25kcyBzcGVjaWZpZXMgdGhlIHRpbWVvdXQgZm9yIHRoaXMgd2ViaG9vay4gQWZ0ZXIgdGhlIHRpbWVvdXQgcGFzc2VzLCB0aGUgd2ViaG9vayBjYWxsIHdpbGwgYmUgaWdub3JlZCBvciB0aGUgQVBJIGNhbGwgd2lsbCBmYWlsIGJhc2VkIG9uIHRoZSBmYWlsdXJlIHBvbGljeS4gVGhlIHRpbWVvdXQgdmFsdWUgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDMwIHNlY29uZHMuIERlZmF1bHQgdG8gMTAgc2Vjb25kcy5cbiAgICpcbiAgICogQGRlZmF1bHQgMTAgc2Vjb25kcy5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFkbWlzc2lvbnJlZ2lzdHJhdGlvbi52MS5WYWxpZGF0aW5nV2ViaG9vayN0aW1lb3V0U2Vjb25kc1xuICAgKi9cbiAgcmVhZG9ubHkgdGltZW91dFNlY29uZHM/OiBudW1iZXI7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnVmFsaWRhdGluZ1dlYmhvb2snIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1ZhbGlkYXRpbmdXZWJob29rKG9iajogVmFsaWRhdGluZ1dlYmhvb2sgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdhZG1pc3Npb25SZXZpZXdWZXJzaW9ucyc6IG9iai5hZG1pc3Npb25SZXZpZXdWZXJzaW9ucz8ubWFwKHkgPT4geSksXG4gICAgJ2NsaWVudENvbmZpZyc6IHRvSnNvbl9XZWJob29rQ2xpZW50Q29uZmlnKG9iai5jbGllbnRDb25maWcpLFxuICAgICdmYWlsdXJlUG9saWN5Jzogb2JqLmZhaWx1cmVQb2xpY3ksXG4gICAgJ21hdGNoUG9saWN5Jzogb2JqLm1hdGNoUG9saWN5LFxuICAgICduYW1lJzogb2JqLm5hbWUsXG4gICAgJ25hbWVzcGFjZVNlbGVjdG9yJzogdG9Kc29uX0xhYmVsU2VsZWN0b3Iob2JqLm5hbWVzcGFjZVNlbGVjdG9yKSxcbiAgICAnb2JqZWN0U2VsZWN0b3InOiB0b0pzb25fTGFiZWxTZWxlY3RvcihvYmoub2JqZWN0U2VsZWN0b3IpLFxuICAgICdydWxlcyc6IG9iai5ydWxlcz8ubWFwKHkgPT4gdG9Kc29uX1J1bGVXaXRoT3BlcmF0aW9ucyh5KSksXG4gICAgJ3NpZGVFZmZlY3RzJzogb2JqLnNpZGVFZmZlY3RzLFxuICAgICd0aW1lb3V0U2Vjb25kcyc6IG9iai50aW1lb3V0U2Vjb25kcyxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBEYWVtb25TZXRTcGVjIGlzIHRoZSBzcGVjaWZpY2F0aW9uIG9mIGEgZGFlbW9uIHNldC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5EYWVtb25TZXRTcGVjXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGFlbW9uU2V0U3BlYyB7XG4gIC8qKlxuICAgKiBUaGUgbWluaW11bSBudW1iZXIgb2Ygc2Vjb25kcyBmb3Igd2hpY2ggYSBuZXdseSBjcmVhdGVkIERhZW1vblNldCBwb2Qgc2hvdWxkIGJlIHJlYWR5IHdpdGhvdXQgYW55IG9mIGl0cyBjb250YWluZXIgY3Jhc2hpbmcsIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGF2YWlsYWJsZS4gRGVmYXVsdHMgdG8gMCAocG9kIHdpbGwgYmUgY29uc2lkZXJlZCBhdmFpbGFibGUgYXMgc29vbiBhcyBpdCBpcyByZWFkeSkuXG4gICAqXG4gICAqIEBkZWZhdWx0IDAgKHBvZCB3aWxsIGJlIGNvbnNpZGVyZWQgYXZhaWxhYmxlIGFzIHNvb24gYXMgaXQgaXMgcmVhZHkpLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5EYWVtb25TZXRTcGVjI21pblJlYWR5U2Vjb25kc1xuICAgKi9cbiAgcmVhZG9ubHkgbWluUmVhZHlTZWNvbmRzPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIG9sZCBoaXN0b3J5IHRvIHJldGFpbiB0byBhbGxvdyByb2xsYmFjay4gVGhpcyBpcyBhIHBvaW50ZXIgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBleHBsaWNpdCB6ZXJvIGFuZCBub3Qgc3BlY2lmaWVkLiBEZWZhdWx0cyB0byAxMC5cbiAgICpcbiAgICogQGRlZmF1bHQgMTAuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLkRhZW1vblNldFNwZWMjcmV2aXNpb25IaXN0b3J5TGltaXRcbiAgICovXG4gIHJlYWRvbmx5IHJldmlzaW9uSGlzdG9yeUxpbWl0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBBIGxhYmVsIHF1ZXJ5IG92ZXIgcG9kcyB0aGF0IGFyZSBtYW5hZ2VkIGJ5IHRoZSBkYWVtb24gc2V0LiBNdXN0IG1hdGNoIGluIG9yZGVyIHRvIGJlIGNvbnRyb2xsZWQuIEl0IG11c3QgbWF0Y2ggdGhlIHBvZCB0ZW1wbGF0ZSdzIGxhYmVscy4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9vdmVydmlldy93b3JraW5nLXdpdGgtb2JqZWN0cy9sYWJlbHMvI2xhYmVsLXNlbGVjdG9yc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5EYWVtb25TZXRTcGVjI3NlbGVjdG9yXG4gICAqL1xuICByZWFkb25seSBzZWxlY3RvcjogTGFiZWxTZWxlY3RvcjtcblxuICAvKipcbiAgICogQW4gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBwb2QgdGhhdCB3aWxsIGJlIGNyZWF0ZWQuIFRoZSBEYWVtb25TZXQgd2lsbCBjcmVhdGUgZXhhY3RseSBvbmUgY29weSBvZiB0aGlzIHBvZCBvbiBldmVyeSBub2RlIHRoYXQgbWF0Y2hlcyB0aGUgdGVtcGxhdGUncyBub2RlIHNlbGVjdG9yIChvciBvbiBldmVyeSBub2RlIGlmIG5vIG5vZGUgc2VsZWN0b3IgaXMgc3BlY2lmaWVkKS4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy93b3JrbG9hZHMvY29udHJvbGxlcnMvcmVwbGljYXRpb25jb250cm9sbGVyI3BvZC10ZW1wbGF0ZVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5EYWVtb25TZXRTcGVjI3RlbXBsYXRlXG4gICAqL1xuICByZWFkb25seSB0ZW1wbGF0ZTogUG9kVGVtcGxhdGVTcGVjO1xuXG4gIC8qKlxuICAgKiBBbiB1cGRhdGUgc3RyYXRlZ3kgdG8gcmVwbGFjZSBleGlzdGluZyBEYWVtb25TZXQgcG9kcyB3aXRoIG5ldyBwb2RzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5EYWVtb25TZXRTcGVjI3VwZGF0ZVN0cmF0ZWd5XG4gICAqL1xuICByZWFkb25seSB1cGRhdGVTdHJhdGVneT86IERhZW1vblNldFVwZGF0ZVN0cmF0ZWd5O1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0RhZW1vblNldFNwZWMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0RhZW1vblNldFNwZWMob2JqOiBEYWVtb25TZXRTcGVjIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWluUmVhZHlTZWNvbmRzJzogb2JqLm1pblJlYWR5U2Vjb25kcyxcbiAgICAncmV2aXNpb25IaXN0b3J5TGltaXQnOiBvYmoucmV2aXNpb25IaXN0b3J5TGltaXQsXG4gICAgJ3NlbGVjdG9yJzogdG9Kc29uX0xhYmVsU2VsZWN0b3Iob2JqLnNlbGVjdG9yKSxcbiAgICAndGVtcGxhdGUnOiB0b0pzb25fUG9kVGVtcGxhdGVTcGVjKG9iai50ZW1wbGF0ZSksXG4gICAgJ3VwZGF0ZVN0cmF0ZWd5JzogdG9Kc29uX0RhZW1vblNldFVwZGF0ZVN0cmF0ZWd5KG9iai51cGRhdGVTdHJhdGVneSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogRGVwbG95bWVudFNwZWMgaXMgdGhlIHNwZWNpZmljYXRpb24gb2YgdGhlIGRlc2lyZWQgYmVoYXZpb3Igb2YgdGhlIERlcGxveW1lbnQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuRGVwbG95bWVudFNwZWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZXBsb3ltZW50U3BlYyB7XG4gIC8qKlxuICAgKiBNaW5pbXVtIG51bWJlciBvZiBzZWNvbmRzIGZvciB3aGljaCBhIG5ld2x5IGNyZWF0ZWQgcG9kIHNob3VsZCBiZSByZWFkeSB3aXRob3V0IGFueSBvZiBpdHMgY29udGFpbmVyIGNyYXNoaW5nLCBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhdmFpbGFibGUuIERlZmF1bHRzIHRvIDAgKHBvZCB3aWxsIGJlIGNvbnNpZGVyZWQgYXZhaWxhYmxlIGFzIHNvb24gYXMgaXQgaXMgcmVhZHkpXG4gICAqXG4gICAqIEBkZWZhdWx0IDAgKHBvZCB3aWxsIGJlIGNvbnNpZGVyZWQgYXZhaWxhYmxlIGFzIHNvb24gYXMgaXQgaXMgcmVhZHkpXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLkRlcGxveW1lbnRTcGVjI21pblJlYWR5U2Vjb25kc1xuICAgKi9cbiAgcmVhZG9ubHkgbWluUmVhZHlTZWNvbmRzPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgZGVwbG95bWVudCBpcyBwYXVzZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLkRlcGxveW1lbnRTcGVjI3BhdXNlZFxuICAgKi9cbiAgcmVhZG9ubHkgcGF1c2VkPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gdGltZSBpbiBzZWNvbmRzIGZvciBhIGRlcGxveW1lbnQgdG8gbWFrZSBwcm9ncmVzcyBiZWZvcmUgaXQgaXMgY29uc2lkZXJlZCB0byBiZSBmYWlsZWQuIFRoZSBkZXBsb3ltZW50IGNvbnRyb2xsZXIgd2lsbCBjb250aW51ZSB0byBwcm9jZXNzIGZhaWxlZCBkZXBsb3ltZW50cyBhbmQgYSBjb25kaXRpb24gd2l0aCBhIFByb2dyZXNzRGVhZGxpbmVFeGNlZWRlZCByZWFzb24gd2lsbCBiZSBzdXJmYWNlZCBpbiB0aGUgZGVwbG95bWVudCBzdGF0dXMuIE5vdGUgdGhhdCBwcm9ncmVzcyB3aWxsIG5vdCBiZSBlc3RpbWF0ZWQgZHVyaW5nIHRoZSB0aW1lIGEgZGVwbG95bWVudCBpcyBwYXVzZWQuIERlZmF1bHRzIHRvIDYwMHMuXG4gICAqXG4gICAqIEBkZWZhdWx0IDYwMHMuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLkRlcGxveW1lbnRTcGVjI3Byb2dyZXNzRGVhZGxpbmVTZWNvbmRzXG4gICAqL1xuICByZWFkb25seSBwcm9ncmVzc0RlYWRsaW5lU2Vjb25kcz86IG51bWJlcjtcblxuICAvKipcbiAgICogTnVtYmVyIG9mIGRlc2lyZWQgcG9kcy4gVGhpcyBpcyBhIHBvaW50ZXIgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBleHBsaWNpdCB6ZXJvIGFuZCBub3Qgc3BlY2lmaWVkLiBEZWZhdWx0cyB0byAxLlxuICAgKlxuICAgKiBAZGVmYXVsdCAxLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5EZXBsb3ltZW50U3BlYyNyZXBsaWNhc1xuICAgKi9cbiAgcmVhZG9ubHkgcmVwbGljYXM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2Ygb2xkIFJlcGxpY2FTZXRzIHRvIHJldGFpbiB0byBhbGxvdyByb2xsYmFjay4gVGhpcyBpcyBhIHBvaW50ZXIgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBleHBsaWNpdCB6ZXJvIGFuZCBub3Qgc3BlY2lmaWVkLiBEZWZhdWx0cyB0byAxMC5cbiAgICpcbiAgICogQGRlZmF1bHQgMTAuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLkRlcGxveW1lbnRTcGVjI3JldmlzaW9uSGlzdG9yeUxpbWl0XG4gICAqL1xuICByZWFkb25seSByZXZpc2lvbkhpc3RvcnlMaW1pdD86IG51bWJlcjtcblxuICAvKipcbiAgICogTGFiZWwgc2VsZWN0b3IgZm9yIHBvZHMuIEV4aXN0aW5nIFJlcGxpY2FTZXRzIHdob3NlIHBvZHMgYXJlIHNlbGVjdGVkIGJ5IHRoaXMgd2lsbCBiZSB0aGUgb25lcyBhZmZlY3RlZCBieSB0aGlzIGRlcGxveW1lbnQuIEl0IG11c3QgbWF0Y2ggdGhlIHBvZCB0ZW1wbGF0ZSdzIGxhYmVscy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuRGVwbG95bWVudFNwZWMjc2VsZWN0b3JcbiAgICovXG4gIHJlYWRvbmx5IHNlbGVjdG9yOiBMYWJlbFNlbGVjdG9yO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVwbG95bWVudCBzdHJhdGVneSB0byB1c2UgdG8gcmVwbGFjZSBleGlzdGluZyBwb2RzIHdpdGggbmV3IG9uZXMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLkRlcGxveW1lbnRTcGVjI3N0cmF0ZWd5XG4gICAqL1xuICByZWFkb25seSBzdHJhdGVneT86IERlcGxveW1lbnRTdHJhdGVneTtcblxuICAvKipcbiAgICogVGVtcGxhdGUgZGVzY3JpYmVzIHRoZSBwb2RzIHRoYXQgd2lsbCBiZSBjcmVhdGVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5EZXBsb3ltZW50U3BlYyN0ZW1wbGF0ZVxuICAgKi9cbiAgcmVhZG9ubHkgdGVtcGxhdGU6IFBvZFRlbXBsYXRlU3BlYztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdEZXBsb3ltZW50U3BlYycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fRGVwbG95bWVudFNwZWMob2JqOiBEZXBsb3ltZW50U3BlYyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21pblJlYWR5U2Vjb25kcyc6IG9iai5taW5SZWFkeVNlY29uZHMsXG4gICAgJ3BhdXNlZCc6IG9iai5wYXVzZWQsXG4gICAgJ3Byb2dyZXNzRGVhZGxpbmVTZWNvbmRzJzogb2JqLnByb2dyZXNzRGVhZGxpbmVTZWNvbmRzLFxuICAgICdyZXBsaWNhcyc6IG9iai5yZXBsaWNhcyxcbiAgICAncmV2aXNpb25IaXN0b3J5TGltaXQnOiBvYmoucmV2aXNpb25IaXN0b3J5TGltaXQsXG4gICAgJ3NlbGVjdG9yJzogdG9Kc29uX0xhYmVsU2VsZWN0b3Iob2JqLnNlbGVjdG9yKSxcbiAgICAnc3RyYXRlZ3knOiB0b0pzb25fRGVwbG95bWVudFN0cmF0ZWd5KG9iai5zdHJhdGVneSksXG4gICAgJ3RlbXBsYXRlJzogdG9Kc29uX1BvZFRlbXBsYXRlU3BlYyhvYmoudGVtcGxhdGUpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFJlcGxpY2FTZXRTcGVjIGlzIHRoZSBzcGVjaWZpY2F0aW9uIG9mIGEgUmVwbGljYVNldC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5SZXBsaWNhU2V0U3BlY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlcGxpY2FTZXRTcGVjIHtcbiAgLyoqXG4gICAqIE1pbmltdW0gbnVtYmVyIG9mIHNlY29uZHMgZm9yIHdoaWNoIGEgbmV3bHkgY3JlYXRlZCBwb2Qgc2hvdWxkIGJlIHJlYWR5IHdpdGhvdXQgYW55IG9mIGl0cyBjb250YWluZXIgY3Jhc2hpbmcsIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGF2YWlsYWJsZS4gRGVmYXVsdHMgdG8gMCAocG9kIHdpbGwgYmUgY29uc2lkZXJlZCBhdmFpbGFibGUgYXMgc29vbiBhcyBpdCBpcyByZWFkeSlcbiAgICpcbiAgICogQGRlZmF1bHQgMCAocG9kIHdpbGwgYmUgY29uc2lkZXJlZCBhdmFpbGFibGUgYXMgc29vbiBhcyBpdCBpcyByZWFkeSlcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuUmVwbGljYVNldFNwZWMjbWluUmVhZHlTZWNvbmRzXG4gICAqL1xuICByZWFkb25seSBtaW5SZWFkeVNlY29uZHM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFJlcGxpY2FzIGlzIHRoZSBudW1iZXIgb2YgZGVzaXJlZCByZXBsaWNhcy4gVGhpcyBpcyBhIHBvaW50ZXIgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBleHBsaWNpdCB6ZXJvIGFuZCB1bnNwZWNpZmllZC4gRGVmYXVsdHMgdG8gMS4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy93b3JrbG9hZHMvY29udHJvbGxlcnMvcmVwbGljYXRpb25jb250cm9sbGVyLyN3aGF0LWlzLWEtcmVwbGljYXRpb25jb250cm9sbGVyXG4gICAqXG4gICAqIEBkZWZhdWx0IDEuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL2NvbnRyb2xsZXJzL3JlcGxpY2F0aW9uY29udHJvbGxlci8jd2hhdC1pcy1hLXJlcGxpY2F0aW9uY29udHJvbGxlclxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5SZXBsaWNhU2V0U3BlYyNyZXBsaWNhc1xuICAgKi9cbiAgcmVhZG9ubHkgcmVwbGljYXM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFNlbGVjdG9yIGlzIGEgbGFiZWwgcXVlcnkgb3ZlciBwb2RzIHRoYXQgc2hvdWxkIG1hdGNoIHRoZSByZXBsaWNhIGNvdW50LiBMYWJlbCBrZXlzIGFuZCB2YWx1ZXMgdGhhdCBtdXN0IG1hdGNoIGluIG9yZGVyIHRvIGJlIGNvbnRyb2xsZWQgYnkgdGhpcyByZXBsaWNhIHNldC4gSXQgbXVzdCBtYXRjaCB0aGUgcG9kIHRlbXBsYXRlJ3MgbGFiZWxzLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL292ZXJ2aWV3L3dvcmtpbmctd2l0aC1vYmplY3RzL2xhYmVscy8jbGFiZWwtc2VsZWN0b3JzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLlJlcGxpY2FTZXRTcGVjI3NlbGVjdG9yXG4gICAqL1xuICByZWFkb25seSBzZWxlY3RvcjogTGFiZWxTZWxlY3RvcjtcblxuICAvKipcbiAgICogVGVtcGxhdGUgaXMgdGhlIG9iamVjdCB0aGF0IGRlc2NyaWJlcyB0aGUgcG9kIHRoYXQgd2lsbCBiZSBjcmVhdGVkIGlmIGluc3VmZmljaWVudCByZXBsaWNhcyBhcmUgZGV0ZWN0ZWQuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL2NvbnRyb2xsZXJzL3JlcGxpY2F0aW9uY29udHJvbGxlciNwb2QtdGVtcGxhdGVcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuUmVwbGljYVNldFNwZWMjdGVtcGxhdGVcbiAgICovXG4gIHJlYWRvbmx5IHRlbXBsYXRlPzogUG9kVGVtcGxhdGVTcGVjO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1JlcGxpY2FTZXRTcGVjJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9SZXBsaWNhU2V0U3BlYyhvYmo6IFJlcGxpY2FTZXRTcGVjIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWluUmVhZHlTZWNvbmRzJzogb2JqLm1pblJlYWR5U2Vjb25kcyxcbiAgICAncmVwbGljYXMnOiBvYmoucmVwbGljYXMsXG4gICAgJ3NlbGVjdG9yJzogdG9Kc29uX0xhYmVsU2VsZWN0b3Iob2JqLnNlbGVjdG9yKSxcbiAgICAndGVtcGxhdGUnOiB0b0pzb25fUG9kVGVtcGxhdGVTcGVjKG9iai50ZW1wbGF0ZSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQSBTdGF0ZWZ1bFNldFNwZWMgaXMgdGhlIHNwZWNpZmljYXRpb24gb2YgYSBTdGF0ZWZ1bFNldC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5TdGF0ZWZ1bFNldFNwZWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdGF0ZWZ1bFNldFNwZWMge1xuICAvKipcbiAgICogTWluaW11bSBudW1iZXIgb2Ygc2Vjb25kcyBmb3Igd2hpY2ggYSBuZXdseSBjcmVhdGVkIHBvZCBzaG91bGQgYmUgcmVhZHkgd2l0aG91dCBhbnkgb2YgaXRzIGNvbnRhaW5lciBjcmFzaGluZyBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhdmFpbGFibGUuIERlZmF1bHRzIHRvIDAgKHBvZCB3aWxsIGJlIGNvbnNpZGVyZWQgYXZhaWxhYmxlIGFzIHNvb24gYXMgaXQgaXMgcmVhZHkpIFRoaXMgaXMgYW4gYWxwaGEgZmllbGQgYW5kIHJlcXVpcmVzIGVuYWJsaW5nIFN0YXRlZnVsU2V0TWluUmVhZHlTZWNvbmRzIGZlYXR1cmUgZ2F0ZS5cbiAgICpcbiAgICogQGRlZmF1bHQgMCAocG9kIHdpbGwgYmUgY29uc2lkZXJlZCBhdmFpbGFibGUgYXMgc29vbiBhcyBpdCBpcyByZWFkeSkgVGhpcyBpcyBhbiBhbHBoYSBmaWVsZCBhbmQgcmVxdWlyZXMgZW5hYmxpbmcgU3RhdGVmdWxTZXRNaW5SZWFkeVNlY29uZHMgZmVhdHVyZSBnYXRlLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5TdGF0ZWZ1bFNldFNwZWMjbWluUmVhZHlTZWNvbmRzXG4gICAqL1xuICByZWFkb25seSBtaW5SZWFkeVNlY29uZHM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIHBvZE1hbmFnZW1lbnRQb2xpY3kgY29udHJvbHMgaG93IHBvZHMgYXJlIGNyZWF0ZWQgZHVyaW5nIGluaXRpYWwgc2NhbGUgdXAsIHdoZW4gcmVwbGFjaW5nIHBvZHMgb24gbm9kZXMsIG9yIHdoZW4gc2NhbGluZyBkb3duLiBUaGUgZGVmYXVsdCBwb2xpY3kgaXMgYE9yZGVyZWRSZWFkeWAsIHdoZXJlIHBvZHMgYXJlIGNyZWF0ZWQgaW4gaW5jcmVhc2luZyBvcmRlciAocG9kLTAsIHRoZW4gcG9kLTEsIGV0YykgYW5kIHRoZSBjb250cm9sbGVyIHdpbGwgd2FpdCB1bnRpbCBlYWNoIHBvZCBpcyByZWFkeSBiZWZvcmUgY29udGludWluZy4gV2hlbiBzY2FsaW5nIGRvd24sIHRoZSBwb2RzIGFyZSByZW1vdmVkIGluIHRoZSBvcHBvc2l0ZSBvcmRlci4gVGhlIGFsdGVybmF0aXZlIHBvbGljeSBpcyBgUGFyYWxsZWxgIHdoaWNoIHdpbGwgY3JlYXRlIHBvZHMgaW4gcGFyYWxsZWwgdG8gbWF0Y2ggdGhlIGRlc2lyZWQgc2NhbGUgd2l0aG91dCB3YWl0aW5nLCBhbmQgb24gc2NhbGUgZG93biB3aWxsIGRlbGV0ZSBhbGwgcG9kcyBhdCBvbmNlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5TdGF0ZWZ1bFNldFNwZWMjcG9kTWFuYWdlbWVudFBvbGljeVxuICAgKi9cbiAgcmVhZG9ubHkgcG9kTWFuYWdlbWVudFBvbGljeT86IHN0cmluZztcblxuICAvKipcbiAgICogcmVwbGljYXMgaXMgdGhlIGRlc2lyZWQgbnVtYmVyIG9mIHJlcGxpY2FzIG9mIHRoZSBnaXZlbiBUZW1wbGF0ZS4gVGhlc2UgYXJlIHJlcGxpY2FzIGluIHRoZSBzZW5zZSB0aGF0IHRoZXkgYXJlIGluc3RhbnRpYXRpb25zIG9mIHRoZSBzYW1lIFRlbXBsYXRlLCBidXQgaW5kaXZpZHVhbCByZXBsaWNhcyBhbHNvIGhhdmUgYSBjb25zaXN0ZW50IGlkZW50aXR5LiBJZiB1bnNwZWNpZmllZCwgZGVmYXVsdHMgdG8gMS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuU3RhdGVmdWxTZXRTcGVjI3JlcGxpY2FzXG4gICAqL1xuICByZWFkb25seSByZXBsaWNhcz86IG51bWJlcjtcblxuICAvKipcbiAgICogcmV2aXNpb25IaXN0b3J5TGltaXQgaXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJldmlzaW9ucyB0aGF0IHdpbGwgYmUgbWFpbnRhaW5lZCBpbiB0aGUgU3RhdGVmdWxTZXQncyByZXZpc2lvbiBoaXN0b3J5LiBUaGUgcmV2aXNpb24gaGlzdG9yeSBjb25zaXN0cyBvZiBhbGwgcmV2aXNpb25zIG5vdCByZXByZXNlbnRlZCBieSBhIGN1cnJlbnRseSBhcHBsaWVkIFN0YXRlZnVsU2V0U3BlYyB2ZXJzaW9uLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAxMC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuU3RhdGVmdWxTZXRTcGVjI3JldmlzaW9uSGlzdG9yeUxpbWl0XG4gICAqL1xuICByZWFkb25seSByZXZpc2lvbkhpc3RvcnlMaW1pdD86IG51bWJlcjtcblxuICAvKipcbiAgICogc2VsZWN0b3IgaXMgYSBsYWJlbCBxdWVyeSBvdmVyIHBvZHMgdGhhdCBzaG91bGQgbWF0Y2ggdGhlIHJlcGxpY2EgY291bnQuIEl0IG11c3QgbWF0Y2ggdGhlIHBvZCB0ZW1wbGF0ZSdzIGxhYmVscy4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9vdmVydmlldy93b3JraW5nLXdpdGgtb2JqZWN0cy9sYWJlbHMvI2xhYmVsLXNlbGVjdG9yc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5TdGF0ZWZ1bFNldFNwZWMjc2VsZWN0b3JcbiAgICovXG4gIHJlYWRvbmx5IHNlbGVjdG9yOiBMYWJlbFNlbGVjdG9yO1xuXG4gIC8qKlxuICAgKiBzZXJ2aWNlTmFtZSBpcyB0aGUgbmFtZSBvZiB0aGUgc2VydmljZSB0aGF0IGdvdmVybnMgdGhpcyBTdGF0ZWZ1bFNldC4gVGhpcyBzZXJ2aWNlIG11c3QgZXhpc3QgYmVmb3JlIHRoZSBTdGF0ZWZ1bFNldCwgYW5kIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgbmV0d29yayBpZGVudGl0eSBvZiB0aGUgc2V0LiBQb2RzIGdldCBETlMvaG9zdG5hbWVzIHRoYXQgZm9sbG93IHRoZSBwYXR0ZXJuOiBwb2Qtc3BlY2lmaWMtc3RyaW5nLnNlcnZpY2VOYW1lLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwgd2hlcmUgXCJwb2Qtc3BlY2lmaWMtc3RyaW5nXCIgaXMgbWFuYWdlZCBieSB0aGUgU3RhdGVmdWxTZXQgY29udHJvbGxlci5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuU3RhdGVmdWxTZXRTcGVjI3NlcnZpY2VOYW1lXG4gICAqL1xuICByZWFkb25seSBzZXJ2aWNlTmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiB0ZW1wbGF0ZSBpcyB0aGUgb2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBwb2QgdGhhdCB3aWxsIGJlIGNyZWF0ZWQgaWYgaW5zdWZmaWNpZW50IHJlcGxpY2FzIGFyZSBkZXRlY3RlZC4gRWFjaCBwb2Qgc3RhbXBlZCBvdXQgYnkgdGhlIFN0YXRlZnVsU2V0IHdpbGwgZnVsZmlsbCB0aGlzIFRlbXBsYXRlLCBidXQgaGF2ZSBhIHVuaXF1ZSBpZGVudGl0eSBmcm9tIHRoZSByZXN0IG9mIHRoZSBTdGF0ZWZ1bFNldC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuU3RhdGVmdWxTZXRTcGVjI3RlbXBsYXRlXG4gICAqL1xuICByZWFkb25seSB0ZW1wbGF0ZTogUG9kVGVtcGxhdGVTcGVjO1xuXG4gIC8qKlxuICAgKiB1cGRhdGVTdHJhdGVneSBpbmRpY2F0ZXMgdGhlIFN0YXRlZnVsU2V0VXBkYXRlU3RyYXRlZ3kgdGhhdCB3aWxsIGJlIGVtcGxveWVkIHRvIHVwZGF0ZSBQb2RzIGluIHRoZSBTdGF0ZWZ1bFNldCB3aGVuIGEgcmV2aXNpb24gaXMgbWFkZSB0byBUZW1wbGF0ZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuU3RhdGVmdWxTZXRTcGVjI3VwZGF0ZVN0cmF0ZWd5XG4gICAqL1xuICByZWFkb25seSB1cGRhdGVTdHJhdGVneT86IFN0YXRlZnVsU2V0VXBkYXRlU3RyYXRlZ3k7XG5cbiAgLyoqXG4gICAqIHZvbHVtZUNsYWltVGVtcGxhdGVzIGlzIGEgbGlzdCBvZiBjbGFpbXMgdGhhdCBwb2RzIGFyZSBhbGxvd2VkIHRvIHJlZmVyZW5jZS4gVGhlIFN0YXRlZnVsU2V0IGNvbnRyb2xsZXIgaXMgcmVzcG9uc2libGUgZm9yIG1hcHBpbmcgbmV0d29yayBpZGVudGl0aWVzIHRvIGNsYWltcyBpbiBhIHdheSB0aGF0IG1haW50YWlucyB0aGUgaWRlbnRpdHkgb2YgYSBwb2QuIEV2ZXJ5IGNsYWltIGluIHRoaXMgbGlzdCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIG1hdGNoaW5nIChieSBuYW1lKSB2b2x1bWVNb3VudCBpbiBvbmUgY29udGFpbmVyIGluIHRoZSB0ZW1wbGF0ZS4gQSBjbGFpbSBpbiB0aGlzIGxpc3QgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGFueSB2b2x1bWVzIGluIHRoZSB0ZW1wbGF0ZSwgd2l0aCB0aGUgc2FtZSBuYW1lLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5TdGF0ZWZ1bFNldFNwZWMjdm9sdW1lQ2xhaW1UZW1wbGF0ZXNcbiAgICovXG4gIHJlYWRvbmx5IHZvbHVtZUNsYWltVGVtcGxhdGVzPzogS3ViZVBlcnNpc3RlbnRWb2x1bWVDbGFpbVByb3BzW107XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnU3RhdGVmdWxTZXRTcGVjJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9TdGF0ZWZ1bFNldFNwZWMob2JqOiBTdGF0ZWZ1bFNldFNwZWMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtaW5SZWFkeVNlY29uZHMnOiBvYmoubWluUmVhZHlTZWNvbmRzLFxuICAgICdwb2RNYW5hZ2VtZW50UG9saWN5Jzogb2JqLnBvZE1hbmFnZW1lbnRQb2xpY3ksXG4gICAgJ3JlcGxpY2FzJzogb2JqLnJlcGxpY2FzLFxuICAgICdyZXZpc2lvbkhpc3RvcnlMaW1pdCc6IG9iai5yZXZpc2lvbkhpc3RvcnlMaW1pdCxcbiAgICAnc2VsZWN0b3InOiB0b0pzb25fTGFiZWxTZWxlY3RvcihvYmouc2VsZWN0b3IpLFxuICAgICdzZXJ2aWNlTmFtZSc6IG9iai5zZXJ2aWNlTmFtZSxcbiAgICAndGVtcGxhdGUnOiB0b0pzb25fUG9kVGVtcGxhdGVTcGVjKG9iai50ZW1wbGF0ZSksXG4gICAgJ3VwZGF0ZVN0cmF0ZWd5JzogdG9Kc29uX1N0YXRlZnVsU2V0VXBkYXRlU3RyYXRlZ3kob2JqLnVwZGF0ZVN0cmF0ZWd5KSxcbiAgICAndm9sdW1lQ2xhaW1UZW1wbGF0ZXMnOiBvYmoudm9sdW1lQ2xhaW1UZW1wbGF0ZXM/Lm1hcCh5ID0+IHRvSnNvbl9LdWJlUGVyc2lzdGVudFZvbHVtZUNsYWltUHJvcHMoeSkpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFRva2VuUmVxdWVzdFNwZWMgY29udGFpbnMgY2xpZW50IHByb3ZpZGVkIHBhcmFtZXRlcnMgb2YgYSB0b2tlbiByZXF1ZXN0LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRoZW50aWNhdGlvbi52MS5Ub2tlblJlcXVlc3RTcGVjXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVG9rZW5SZXF1ZXN0U3BlYyB7XG4gIC8qKlxuICAgKiBBdWRpZW5jZXMgYXJlIHRoZSBpbnRlbmRlbmQgYXVkaWVuY2VzIG9mIHRoZSB0b2tlbi4gQSByZWNpcGllbnQgb2YgYSB0b2tlbiBtdXN0IGlkZW50aXRmeSB0aGVtc2VsZiB3aXRoIGFuIGlkZW50aWZpZXIgaW4gdGhlIGxpc3Qgb2YgYXVkaWVuY2VzIG9mIHRoZSB0b2tlbiwgYW5kIG90aGVyd2lzZSBzaG91bGQgcmVqZWN0IHRoZSB0b2tlbi4gQSB0b2tlbiBpc3N1ZWQgZm9yIG11bHRpcGxlIGF1ZGllbmNlcyBtYXkgYmUgdXNlZCB0byBhdXRoZW50aWNhdGUgYWdhaW5zdCBhbnkgb2YgdGhlIGF1ZGllbmNlcyBsaXN0ZWQgYnV0IGltcGxpZXMgYSBoaWdoIGRlZ3JlZSBvZiB0cnVzdCBiZXR3ZWVuIHRoZSB0YXJnZXQgYXVkaWVuY2VzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0aGVudGljYXRpb24udjEuVG9rZW5SZXF1ZXN0U3BlYyNhdWRpZW5jZXNcbiAgICovXG4gIHJlYWRvbmx5IGF1ZGllbmNlczogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIEJvdW5kT2JqZWN0UmVmIGlzIGEgcmVmZXJlbmNlIHRvIGFuIG9iamVjdCB0aGF0IHRoZSB0b2tlbiB3aWxsIGJlIGJvdW5kIHRvLiBUaGUgdG9rZW4gd2lsbCBvbmx5IGJlIHZhbGlkIGZvciBhcyBsb25nIGFzIHRoZSBib3VuZCBvYmplY3QgZXhpc3RzLiBOT1RFOiBUaGUgQVBJIHNlcnZlcidzIFRva2VuUmV2aWV3IGVuZHBvaW50IHdpbGwgdmFsaWRhdGUgdGhlIEJvdW5kT2JqZWN0UmVmLCBidXQgb3RoZXIgYXVkaWVuY2VzIG1heSBub3QuIEtlZXAgRXhwaXJhdGlvblNlY29uZHMgc21hbGwgaWYgeW91IHdhbnQgcHJvbXB0IHJldm9jYXRpb24uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRoZW50aWNhdGlvbi52MS5Ub2tlblJlcXVlc3RTcGVjI2JvdW5kT2JqZWN0UmVmXG4gICAqL1xuICByZWFkb25seSBib3VuZE9iamVjdFJlZj86IEJvdW5kT2JqZWN0UmVmZXJlbmNlO1xuXG4gIC8qKlxuICAgKiBFeHBpcmF0aW9uU2Vjb25kcyBpcyB0aGUgcmVxdWVzdGVkIGR1cmF0aW9uIG9mIHZhbGlkaXR5IG9mIHRoZSByZXF1ZXN0LiBUaGUgdG9rZW4gaXNzdWVyIG1heSByZXR1cm4gYSB0b2tlbiB3aXRoIGEgZGlmZmVyZW50IHZhbGlkaXR5IGR1cmF0aW9uIHNvIGEgY2xpZW50IG5lZWRzIHRvIGNoZWNrIHRoZSAnZXhwaXJhdGlvbicgZmllbGQgaW4gYSByZXNwb25zZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dGhlbnRpY2F0aW9uLnYxLlRva2VuUmVxdWVzdFNwZWMjZXhwaXJhdGlvblNlY29uZHNcbiAgICovXG4gIHJlYWRvbmx5IGV4cGlyYXRpb25TZWNvbmRzPzogbnVtYmVyO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1Rva2VuUmVxdWVzdFNwZWMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1Rva2VuUmVxdWVzdFNwZWMob2JqOiBUb2tlblJlcXVlc3RTcGVjIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnYXVkaWVuY2VzJzogb2JqLmF1ZGllbmNlcz8ubWFwKHkgPT4geSksXG4gICAgJ2JvdW5kT2JqZWN0UmVmJzogdG9Kc29uX0JvdW5kT2JqZWN0UmVmZXJlbmNlKG9iai5ib3VuZE9iamVjdFJlZiksXG4gICAgJ2V4cGlyYXRpb25TZWNvbmRzJzogb2JqLmV4cGlyYXRpb25TZWNvbmRzLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFRva2VuUmV2aWV3U3BlYyBpcyBhIGRlc2NyaXB0aW9uIG9mIHRoZSB0b2tlbiBhdXRoZW50aWNhdGlvbiByZXF1ZXN0LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRoZW50aWNhdGlvbi52MS5Ub2tlblJldmlld1NwZWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUb2tlblJldmlld1NwZWMge1xuICAvKipcbiAgICogQXVkaWVuY2VzIGlzIGEgbGlzdCBvZiB0aGUgaWRlbnRpZmllcnMgdGhhdCB0aGUgcmVzb3VyY2Ugc2VydmVyIHByZXNlbnRlZCB3aXRoIHRoZSB0b2tlbiBpZGVudGlmaWVzIGFzLiBBdWRpZW5jZS1hd2FyZSB0b2tlbiBhdXRoZW50aWNhdG9ycyB3aWxsIHZlcmlmeSB0aGF0IHRoZSB0b2tlbiB3YXMgaW50ZW5kZWQgZm9yIGF0IGxlYXN0IG9uZSBvZiB0aGUgYXVkaWVuY2VzIGluIHRoaXMgbGlzdC4gSWYgbm8gYXVkaWVuY2VzIGFyZSBwcm92aWRlZCwgdGhlIGF1ZGllbmNlIHdpbGwgZGVmYXVsdCB0byB0aGUgYXVkaWVuY2Ugb2YgdGhlIEt1YmVybmV0ZXMgYXBpc2VydmVyLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0aGVudGljYXRpb24udjEuVG9rZW5SZXZpZXdTcGVjI2F1ZGllbmNlc1xuICAgKi9cbiAgcmVhZG9ubHkgYXVkaWVuY2VzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIFRva2VuIGlzIHRoZSBvcGFxdWUgYmVhcmVyIHRva2VuLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0aGVudGljYXRpb24udjEuVG9rZW5SZXZpZXdTcGVjI3Rva2VuXG4gICAqL1xuICByZWFkb25seSB0b2tlbj86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdUb2tlblJldmlld1NwZWMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1Rva2VuUmV2aWV3U3BlYyhvYmo6IFRva2VuUmV2aWV3U3BlYyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2F1ZGllbmNlcyc6IG9iai5hdWRpZW5jZXM/Lm1hcCh5ID0+IHkpLFxuICAgICd0b2tlbic6IG9iai50b2tlbixcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBTdWJqZWN0QWNjZXNzUmV2aWV3U3BlYyBpcyBhIGRlc2NyaXB0aW9uIG9mIHRoZSBhY2Nlc3MgcmVxdWVzdC4gIEV4YWN0bHkgb25lIG9mIFJlc291cmNlQXV0aG9yaXphdGlvbkF0dHJpYnV0ZXMgYW5kIE5vblJlc291cmNlQXV0aG9yaXphdGlvbkF0dHJpYnV0ZXMgbXVzdCBiZSBzZXRcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0aG9yaXphdGlvbi52MS5TdWJqZWN0QWNjZXNzUmV2aWV3U3BlY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFN1YmplY3RBY2Nlc3NSZXZpZXdTcGVjIHtcbiAgLyoqXG4gICAqIEV4dHJhIGNvcnJlc3BvbmRzIHRvIHRoZSB1c2VyLkluZm8uR2V0RXh0cmEoKSBtZXRob2QgZnJvbSB0aGUgYXV0aGVudGljYXRvci4gIFNpbmNlIHRoYXQgaXMgaW5wdXQgdG8gdGhlIGF1dGhvcml6ZXIgaXQgbmVlZHMgYSByZWZsZWN0aW9uIGhlcmUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRob3JpemF0aW9uLnYxLlN1YmplY3RBY2Nlc3NSZXZpZXdTcGVjI2V4dHJhXG4gICAqL1xuICByZWFkb25seSBleHRyYT86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nW10gfTtcblxuICAvKipcbiAgICogR3JvdXBzIGlzIHRoZSBncm91cHMgeW91J3JlIHRlc3RpbmcgZm9yLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0aG9yaXphdGlvbi52MS5TdWJqZWN0QWNjZXNzUmV2aWV3U3BlYyNncm91cHNcbiAgICovXG4gIHJlYWRvbmx5IGdyb3Vwcz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBOb25SZXNvdXJjZUF0dHJpYnV0ZXMgZGVzY3JpYmVzIGluZm9ybWF0aW9uIGZvciBhIG5vbi1yZXNvdXJjZSBhY2Nlc3MgcmVxdWVzdFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0aG9yaXphdGlvbi52MS5TdWJqZWN0QWNjZXNzUmV2aWV3U3BlYyNub25SZXNvdXJjZUF0dHJpYnV0ZXNcbiAgICovXG4gIHJlYWRvbmx5IG5vblJlc291cmNlQXR0cmlidXRlcz86IE5vblJlc291cmNlQXR0cmlidXRlcztcblxuICAvKipcbiAgICogUmVzb3VyY2VBdXRob3JpemF0aW9uQXR0cmlidXRlcyBkZXNjcmliZXMgaW5mb3JtYXRpb24gZm9yIGEgcmVzb3VyY2UgYWNjZXNzIHJlcXVlc3RcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dGhvcml6YXRpb24udjEuU3ViamVjdEFjY2Vzc1Jldmlld1NwZWMjcmVzb3VyY2VBdHRyaWJ1dGVzXG4gICAqL1xuICByZWFkb25seSByZXNvdXJjZUF0dHJpYnV0ZXM/OiBSZXNvdXJjZUF0dHJpYnV0ZXM7XG5cbiAgLyoqXG4gICAqIFVJRCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVxdWVzdGluZyB1c2VyLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0aG9yaXphdGlvbi52MS5TdWJqZWN0QWNjZXNzUmV2aWV3U3BlYyN1aWRcbiAgICovXG4gIHJlYWRvbmx5IHVpZD86IHN0cmluZztcblxuICAvKipcbiAgICogVXNlciBpcyB0aGUgdXNlciB5b3UncmUgdGVzdGluZyBmb3IuIElmIHlvdSBzcGVjaWZ5IFwiVXNlclwiIGJ1dCBub3QgXCJHcm91cHNcIiwgdGhlbiBpcyBpdCBpbnRlcnByZXRlZCBhcyBcIldoYXQgaWYgVXNlciB3ZXJlIG5vdCBhIG1lbWJlciBvZiBhbnkgZ3JvdXBzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRob3JpemF0aW9uLnYxLlN1YmplY3RBY2Nlc3NSZXZpZXdTcGVjI3VzZXJcbiAgICovXG4gIHJlYWRvbmx5IHVzZXI/OiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnU3ViamVjdEFjY2Vzc1Jldmlld1NwZWMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1N1YmplY3RBY2Nlc3NSZXZpZXdTcGVjKG9iajogU3ViamVjdEFjY2Vzc1Jldmlld1NwZWMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdleHRyYSc6ICgob2JqLmV4dHJhKSA9PT0gdW5kZWZpbmVkKSA/IHVuZGVmaW5lZCA6IChPYmplY3QuZW50cmllcyhvYmouZXh0cmEpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdPy5tYXAoeSA9PiB5KSB9KSwge30pKSxcbiAgICAnZ3JvdXBzJzogb2JqLmdyb3Vwcz8ubWFwKHkgPT4geSksXG4gICAgJ25vblJlc291cmNlQXR0cmlidXRlcyc6IHRvSnNvbl9Ob25SZXNvdXJjZUF0dHJpYnV0ZXMob2JqLm5vblJlc291cmNlQXR0cmlidXRlcyksXG4gICAgJ3Jlc291cmNlQXR0cmlidXRlcyc6IHRvSnNvbl9SZXNvdXJjZUF0dHJpYnV0ZXMob2JqLnJlc291cmNlQXR0cmlidXRlcyksXG4gICAgJ3VpZCc6IG9iai51aWQsXG4gICAgJ3VzZXInOiBvYmoudXNlcixcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBTZWxmU3ViamVjdEFjY2Vzc1Jldmlld1NwZWMgaXMgYSBkZXNjcmlwdGlvbiBvZiB0aGUgYWNjZXNzIHJlcXVlc3QuICBFeGFjdGx5IG9uZSBvZiBSZXNvdXJjZUF1dGhvcml6YXRpb25BdHRyaWJ1dGVzIGFuZCBOb25SZXNvdXJjZUF1dGhvcml6YXRpb25BdHRyaWJ1dGVzIG11c3QgYmUgc2V0XG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dGhvcml6YXRpb24udjEuU2VsZlN1YmplY3RBY2Nlc3NSZXZpZXdTcGVjXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VsZlN1YmplY3RBY2Nlc3NSZXZpZXdTcGVjIHtcbiAgLyoqXG4gICAqIE5vblJlc291cmNlQXR0cmlidXRlcyBkZXNjcmliZXMgaW5mb3JtYXRpb24gZm9yIGEgbm9uLXJlc291cmNlIGFjY2VzcyByZXF1ZXN0XG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRob3JpemF0aW9uLnYxLlNlbGZTdWJqZWN0QWNjZXNzUmV2aWV3U3BlYyNub25SZXNvdXJjZUF0dHJpYnV0ZXNcbiAgICovXG4gIHJlYWRvbmx5IG5vblJlc291cmNlQXR0cmlidXRlcz86IE5vblJlc291cmNlQXR0cmlidXRlcztcblxuICAvKipcbiAgICogUmVzb3VyY2VBdXRob3JpemF0aW9uQXR0cmlidXRlcyBkZXNjcmliZXMgaW5mb3JtYXRpb24gZm9yIGEgcmVzb3VyY2UgYWNjZXNzIHJlcXVlc3RcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dGhvcml6YXRpb24udjEuU2VsZlN1YmplY3RBY2Nlc3NSZXZpZXdTcGVjI3Jlc291cmNlQXR0cmlidXRlc1xuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VBdHRyaWJ1dGVzPzogUmVzb3VyY2VBdHRyaWJ1dGVzO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1NlbGZTdWJqZWN0QWNjZXNzUmV2aWV3U3BlYycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fU2VsZlN1YmplY3RBY2Nlc3NSZXZpZXdTcGVjKG9iajogU2VsZlN1YmplY3RBY2Nlc3NSZXZpZXdTcGVjIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbm9uUmVzb3VyY2VBdHRyaWJ1dGVzJzogdG9Kc29uX05vblJlc291cmNlQXR0cmlidXRlcyhvYmoubm9uUmVzb3VyY2VBdHRyaWJ1dGVzKSxcbiAgICAncmVzb3VyY2VBdHRyaWJ1dGVzJzogdG9Kc29uX1Jlc291cmNlQXR0cmlidXRlcyhvYmoucmVzb3VyY2VBdHRyaWJ1dGVzKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBTZWxmU3ViamVjdFJ1bGVzUmV2aWV3U3BlYyBkZWZpbmVzIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBTZWxmU3ViamVjdFJ1bGVzUmV2aWV3LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRob3JpemF0aW9uLnYxLlNlbGZTdWJqZWN0UnVsZXNSZXZpZXdTcGVjXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VsZlN1YmplY3RSdWxlc1Jldmlld1NwZWMge1xuICAvKipcbiAgICogTmFtZXNwYWNlIHRvIGV2YWx1YXRlIHJ1bGVzIGZvci4gUmVxdWlyZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRob3JpemF0aW9uLnYxLlNlbGZTdWJqZWN0UnVsZXNSZXZpZXdTcGVjI25hbWVzcGFjZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZXNwYWNlPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1NlbGZTdWJqZWN0UnVsZXNSZXZpZXdTcGVjJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9TZWxmU3ViamVjdFJ1bGVzUmV2aWV3U3BlYyhvYmo6IFNlbGZTdWJqZWN0UnVsZXNSZXZpZXdTcGVjIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbmFtZXNwYWNlJzogb2JqLm5hbWVzcGFjZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBzcGVjaWZpY2F0aW9uIG9mIGEgaG9yaXpvbnRhbCBwb2QgYXV0b3NjYWxlci5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjEuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJTcGVjXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJTcGVjIHtcbiAgLyoqXG4gICAqIHVwcGVyIGxpbWl0IGZvciB0aGUgbnVtYmVyIG9mIHBvZHMgdGhhdCBjYW4gYmUgc2V0IGJ5IHRoZSBhdXRvc2NhbGVyOyBjYW5ub3QgYmUgc21hbGxlciB0aGFuIE1pblJlcGxpY2FzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjEuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJTcGVjI21heFJlcGxpY2FzXG4gICAqL1xuICByZWFkb25seSBtYXhSZXBsaWNhczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBtaW5SZXBsaWNhcyBpcyB0aGUgbG93ZXIgbGltaXQgZm9yIHRoZSBudW1iZXIgb2YgcmVwbGljYXMgdG8gd2hpY2ggdGhlIGF1dG9zY2FsZXIgY2FuIHNjYWxlIGRvd24uICBJdCBkZWZhdWx0cyB0byAxIHBvZC4gIG1pblJlcGxpY2FzIGlzIGFsbG93ZWQgdG8gYmUgMCBpZiB0aGUgYWxwaGEgZmVhdHVyZSBnYXRlIEhQQVNjYWxlVG9aZXJvIGlzIGVuYWJsZWQgYW5kIGF0IGxlYXN0IG9uZSBPYmplY3Qgb3IgRXh0ZXJuYWwgbWV0cmljIGlzIGNvbmZpZ3VyZWQuICBTY2FsaW5nIGlzIGFjdGl2ZSBhcyBsb25nIGFzIGF0IGxlYXN0IG9uZSBtZXRyaWMgdmFsdWUgaXMgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjEuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJTcGVjI21pblJlcGxpY2FzXG4gICAqL1xuICByZWFkb25seSBtaW5SZXBsaWNhcz86IG51bWJlcjtcblxuICAvKipcbiAgICogcmVmZXJlbmNlIHRvIHNjYWxlZCByZXNvdXJjZTsgaG9yaXpvbnRhbCBwb2QgYXV0b3NjYWxlciB3aWxsIGxlYXJuIHRoZSBjdXJyZW50IHJlc291cmNlIGNvbnN1bXB0aW9uIGFuZCB3aWxsIHNldCB0aGUgZGVzaXJlZCBudW1iZXIgb2YgcG9kcyBieSB1c2luZyBpdHMgU2NhbGUgc3VicmVzb3VyY2UuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MS5Ib3Jpem9udGFsUG9kQXV0b3NjYWxlclNwZWMjc2NhbGVUYXJnZXRSZWZcbiAgICovXG4gIHJlYWRvbmx5IHNjYWxlVGFyZ2V0UmVmOiBDcm9zc1ZlcnNpb25PYmplY3RSZWZlcmVuY2U7XG5cbiAgLyoqXG4gICAqIHRhcmdldCBhdmVyYWdlIENQVSB1dGlsaXphdGlvbiAocmVwcmVzZW50ZWQgYXMgYSBwZXJjZW50YWdlIG9mIHJlcXVlc3RlZCBDUFUpIG92ZXIgYWxsIHRoZSBwb2RzOyBpZiBub3Qgc3BlY2lmaWVkIHRoZSBkZWZhdWx0IGF1dG9zY2FsaW5nIHBvbGljeSB3aWxsIGJlIHVzZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MS5Ib3Jpem9udGFsUG9kQXV0b3NjYWxlclNwZWMjdGFyZ2V0Q1BVVXRpbGl6YXRpb25QZXJjZW50YWdlXG4gICAqL1xuICByZWFkb25seSB0YXJnZXRDcHVVdGlsaXphdGlvblBlcmNlbnRhZ2U/OiBudW1iZXI7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJTcGVjJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Ib3Jpem9udGFsUG9kQXV0b3NjYWxlclNwZWMob2JqOiBIb3Jpem9udGFsUG9kQXV0b3NjYWxlclNwZWMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtYXhSZXBsaWNhcyc6IG9iai5tYXhSZXBsaWNhcyxcbiAgICAnbWluUmVwbGljYXMnOiBvYmoubWluUmVwbGljYXMsXG4gICAgJ3NjYWxlVGFyZ2V0UmVmJzogdG9Kc29uX0Nyb3NzVmVyc2lvbk9iamVjdFJlZmVyZW5jZShvYmouc2NhbGVUYXJnZXRSZWYpLFxuICAgICd0YXJnZXRDUFVVdGlsaXphdGlvblBlcmNlbnRhZ2UnOiBvYmoudGFyZ2V0Q3B1VXRpbGl6YXRpb25QZXJjZW50YWdlLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFNjYWxlU3BlYyBkZXNjcmliZXMgdGhlIGF0dHJpYnV0ZXMgb2YgYSBzY2FsZSBzdWJyZXNvdXJjZS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjEuU2NhbGVTcGVjXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2NhbGVTcGVjIHtcbiAgLyoqXG4gICAqIGRlc2lyZWQgbnVtYmVyIG9mIGluc3RhbmNlcyBmb3IgdGhlIHNjYWxlZCBvYmplY3QuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MS5TY2FsZVNwZWMjcmVwbGljYXNcbiAgICovXG4gIHJlYWRvbmx5IHJlcGxpY2FzPzogbnVtYmVyO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1NjYWxlU3BlYycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fU2NhbGVTcGVjKG9iajogU2NhbGVTcGVjIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAncmVwbGljYXMnOiBvYmoucmVwbGljYXMsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJTcGVjIGRlc2NyaWJlcyB0aGUgZGVzaXJlZCBmdW5jdGlvbmFsaXR5IG9mIHRoZSBIb3Jpem9udGFsUG9kQXV0b3NjYWxlci5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMS5Ib3Jpem9udGFsUG9kQXV0b3NjYWxlclNwZWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIb3Jpem9udGFsUG9kQXV0b3NjYWxlclNwZWNWMkJldGExIHtcbiAgLyoqXG4gICAqIG1heFJlcGxpY2FzIGlzIHRoZSB1cHBlciBsaW1pdCBmb3IgdGhlIG51bWJlciBvZiByZXBsaWNhcyB0byB3aGljaCB0aGUgYXV0b3NjYWxlciBjYW4gc2NhbGUgdXAuIEl0IGNhbm5vdCBiZSBsZXNzIHRoYXQgbWluUmVwbGljYXMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGExLkhvcml6b250YWxQb2RBdXRvc2NhbGVyU3BlYyNtYXhSZXBsaWNhc1xuICAgKi9cbiAgcmVhZG9ubHkgbWF4UmVwbGljYXM6IG51bWJlcjtcblxuICAvKipcbiAgICogbWV0cmljcyBjb250YWlucyB0aGUgc3BlY2lmaWNhdGlvbnMgZm9yIHdoaWNoIHRvIHVzZSB0byBjYWxjdWxhdGUgdGhlIGRlc2lyZWQgcmVwbGljYSBjb3VudCAodGhlIG1heGltdW0gcmVwbGljYSBjb3VudCBhY3Jvc3MgYWxsIG1ldHJpY3Mgd2lsbCBiZSB1c2VkKS4gIFRoZSBkZXNpcmVkIHJlcGxpY2EgY291bnQgaXMgY2FsY3VsYXRlZCBtdWx0aXBseWluZyB0aGUgcmF0aW8gYmV0d2VlbiB0aGUgdGFyZ2V0IHZhbHVlIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBieSB0aGUgY3VycmVudCBudW1iZXIgb2YgcG9kcy4gIEVyZ28sIG1ldHJpY3MgdXNlZCBtdXN0IGRlY3JlYXNlIGFzIHRoZSBwb2QgY291bnQgaXMgaW5jcmVhc2VkLCBhbmQgdmljZS12ZXJzYS4gIFNlZSB0aGUgaW5kaXZpZHVhbCBtZXRyaWMgc291cmNlIHR5cGVzIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGhvdyBlYWNoIHR5cGUgb2YgbWV0cmljIG11c3QgcmVzcG9uZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTEuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJTcGVjI21ldHJpY3NcbiAgICovXG4gIHJlYWRvbmx5IG1ldHJpY3M/OiBNZXRyaWNTcGVjVjJCZXRhMVtdO1xuXG4gIC8qKlxuICAgKiBtaW5SZXBsaWNhcyBpcyB0aGUgbG93ZXIgbGltaXQgZm9yIHRoZSBudW1iZXIgb2YgcmVwbGljYXMgdG8gd2hpY2ggdGhlIGF1dG9zY2FsZXIgY2FuIHNjYWxlIGRvd24uICBJdCBkZWZhdWx0cyB0byAxIHBvZC4gIG1pblJlcGxpY2FzIGlzIGFsbG93ZWQgdG8gYmUgMCBpZiB0aGUgYWxwaGEgZmVhdHVyZSBnYXRlIEhQQVNjYWxlVG9aZXJvIGlzIGVuYWJsZWQgYW5kIGF0IGxlYXN0IG9uZSBPYmplY3Qgb3IgRXh0ZXJuYWwgbWV0cmljIGlzIGNvbmZpZ3VyZWQuICBTY2FsaW5nIGlzIGFjdGl2ZSBhcyBsb25nIGFzIGF0IGxlYXN0IG9uZSBtZXRyaWMgdmFsdWUgaXMgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMS5Ib3Jpem9udGFsUG9kQXV0b3NjYWxlclNwZWMjbWluUmVwbGljYXNcbiAgICovXG4gIHJlYWRvbmx5IG1pblJlcGxpY2FzPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBzY2FsZVRhcmdldFJlZiBwb2ludHMgdG8gdGhlIHRhcmdldCByZXNvdXJjZSB0byBzY2FsZSwgYW5kIGlzIHVzZWQgdG8gdGhlIHBvZHMgZm9yIHdoaWNoIG1ldHJpY3Mgc2hvdWxkIGJlIGNvbGxlY3RlZCwgYXMgd2VsbCBhcyB0byBhY3R1YWxseSBjaGFuZ2UgdGhlIHJlcGxpY2EgY291bnQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGExLkhvcml6b250YWxQb2RBdXRvc2NhbGVyU3BlYyNzY2FsZVRhcmdldFJlZlxuICAgKi9cbiAgcmVhZG9ubHkgc2NhbGVUYXJnZXRSZWY6IENyb3NzVmVyc2lvbk9iamVjdFJlZmVyZW5jZVYyQmV0YTE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJTcGVjVjJCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJTcGVjVjJCZXRhMShvYmo6IEhvcml6b250YWxQb2RBdXRvc2NhbGVyU3BlY1YyQmV0YTEgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtYXhSZXBsaWNhcyc6IG9iai5tYXhSZXBsaWNhcyxcbiAgICAnbWV0cmljcyc6IG9iai5tZXRyaWNzPy5tYXAoeSA9PiB0b0pzb25fTWV0cmljU3BlY1YyQmV0YTEoeSkpLFxuICAgICdtaW5SZXBsaWNhcyc6IG9iai5taW5SZXBsaWNhcyxcbiAgICAnc2NhbGVUYXJnZXRSZWYnOiB0b0pzb25fQ3Jvc3NWZXJzaW9uT2JqZWN0UmVmZXJlbmNlVjJCZXRhMShvYmouc2NhbGVUYXJnZXRSZWYpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEhvcml6b250YWxQb2RBdXRvc2NhbGVyU3BlYyBkZXNjcmliZXMgdGhlIGRlc2lyZWQgZnVuY3Rpb25hbGl0eSBvZiB0aGUgSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXIuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJTcGVjXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJTcGVjVjJCZXRhMiB7XG4gIC8qKlxuICAgKiBiZWhhdmlvciBjb25maWd1cmVzIHRoZSBzY2FsaW5nIGJlaGF2aW9yIG9mIHRoZSB0YXJnZXQgaW4gYm90aCBVcCBhbmQgRG93biBkaXJlY3Rpb25zIChzY2FsZVVwIGFuZCBzY2FsZURvd24gZmllbGRzIHJlc3BlY3RpdmVseSkuIElmIG5vdCBzZXQsIHRoZSBkZWZhdWx0IEhQQVNjYWxpbmdSdWxlcyBmb3Igc2NhbGUgdXAgYW5kIHNjYWxlIGRvd24gYXJlIHVzZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGEyLkhvcml6b250YWxQb2RBdXRvc2NhbGVyU3BlYyNiZWhhdmlvclxuICAgKi9cbiAgcmVhZG9ubHkgYmVoYXZpb3I/OiBIb3Jpem9udGFsUG9kQXV0b3NjYWxlckJlaGF2aW9yVjJCZXRhMjtcblxuICAvKipcbiAgICogbWF4UmVwbGljYXMgaXMgdGhlIHVwcGVyIGxpbWl0IGZvciB0aGUgbnVtYmVyIG9mIHJlcGxpY2FzIHRvIHdoaWNoIHRoZSBhdXRvc2NhbGVyIGNhbiBzY2FsZSB1cC4gSXQgY2Fubm90IGJlIGxlc3MgdGhhdCBtaW5SZXBsaWNhcy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJTcGVjI21heFJlcGxpY2FzXG4gICAqL1xuICByZWFkb25seSBtYXhSZXBsaWNhczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBtZXRyaWNzIGNvbnRhaW5zIHRoZSBzcGVjaWZpY2F0aW9ucyBmb3Igd2hpY2ggdG8gdXNlIHRvIGNhbGN1bGF0ZSB0aGUgZGVzaXJlZCByZXBsaWNhIGNvdW50ICh0aGUgbWF4aW11bSByZXBsaWNhIGNvdW50IGFjcm9zcyBhbGwgbWV0cmljcyB3aWxsIGJlIHVzZWQpLiAgVGhlIGRlc2lyZWQgcmVwbGljYSBjb3VudCBpcyBjYWxjdWxhdGVkIG11bHRpcGx5aW5nIHRoZSByYXRpbyBiZXR3ZWVuIHRoZSB0YXJnZXQgdmFsdWUgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGJ5IHRoZSBjdXJyZW50IG51bWJlciBvZiBwb2RzLiAgRXJnbywgbWV0cmljcyB1c2VkIG11c3QgZGVjcmVhc2UgYXMgdGhlIHBvZCBjb3VudCBpcyBpbmNyZWFzZWQsIGFuZCB2aWNlLXZlcnNhLiAgU2VlIHRoZSBpbmRpdmlkdWFsIG1ldHJpYyBzb3VyY2UgdHlwZXMgZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgaG93IGVhY2ggdHlwZSBvZiBtZXRyaWMgbXVzdCByZXNwb25kLiBJZiBub3Qgc2V0LCB0aGUgZGVmYXVsdCBtZXRyaWMgd2lsbCBiZSBzZXQgdG8gODAlIGF2ZXJhZ2UgQ1BVIHV0aWxpemF0aW9uLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMi5Ib3Jpem9udGFsUG9kQXV0b3NjYWxlclNwZWMjbWV0cmljc1xuICAgKi9cbiAgcmVhZG9ubHkgbWV0cmljcz86IE1ldHJpY1NwZWNWMkJldGEyW107XG5cbiAgLyoqXG4gICAqIG1pblJlcGxpY2FzIGlzIHRoZSBsb3dlciBsaW1pdCBmb3IgdGhlIG51bWJlciBvZiByZXBsaWNhcyB0byB3aGljaCB0aGUgYXV0b3NjYWxlciBjYW4gc2NhbGUgZG93bi4gIEl0IGRlZmF1bHRzIHRvIDEgcG9kLiAgbWluUmVwbGljYXMgaXMgYWxsb3dlZCB0byBiZSAwIGlmIHRoZSBhbHBoYSBmZWF0dXJlIGdhdGUgSFBBU2NhbGVUb1plcm8gaXMgZW5hYmxlZCBhbmQgYXQgbGVhc3Qgb25lIE9iamVjdCBvciBFeHRlcm5hbCBtZXRyaWMgaXMgY29uZmlndXJlZC4gIFNjYWxpbmcgaXMgYWN0aXZlIGFzIGxvbmcgYXMgYXQgbGVhc3Qgb25lIG1ldHJpYyB2YWx1ZSBpcyBhdmFpbGFibGUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGEyLkhvcml6b250YWxQb2RBdXRvc2NhbGVyU3BlYyNtaW5SZXBsaWNhc1xuICAgKi9cbiAgcmVhZG9ubHkgbWluUmVwbGljYXM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIHNjYWxlVGFyZ2V0UmVmIHBvaW50cyB0byB0aGUgdGFyZ2V0IHJlc291cmNlIHRvIHNjYWxlLCBhbmQgaXMgdXNlZCB0byB0aGUgcG9kcyBmb3Igd2hpY2ggbWV0cmljcyBzaG91bGQgYmUgY29sbGVjdGVkLCBhcyB3ZWxsIGFzIHRvIGFjdHVhbGx5IGNoYW5nZSB0aGUgcmVwbGljYSBjb3VudC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJTcGVjI3NjYWxlVGFyZ2V0UmVmXG4gICAqL1xuICByZWFkb25seSBzY2FsZVRhcmdldFJlZjogQ3Jvc3NWZXJzaW9uT2JqZWN0UmVmZXJlbmNlVjJCZXRhMjtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdIb3Jpem9udGFsUG9kQXV0b3NjYWxlclNwZWNWMkJldGEyJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Ib3Jpem9udGFsUG9kQXV0b3NjYWxlclNwZWNWMkJldGEyKG9iajogSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJTcGVjVjJCZXRhMiB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2JlaGF2aW9yJzogdG9Kc29uX0hvcml6b250YWxQb2RBdXRvc2NhbGVyQmVoYXZpb3JWMkJldGEyKG9iai5iZWhhdmlvciksXG4gICAgJ21heFJlcGxpY2FzJzogb2JqLm1heFJlcGxpY2FzLFxuICAgICdtZXRyaWNzJzogb2JqLm1ldHJpY3M/Lm1hcCh5ID0+IHRvSnNvbl9NZXRyaWNTcGVjVjJCZXRhMih5KSksXG4gICAgJ21pblJlcGxpY2FzJzogb2JqLm1pblJlcGxpY2FzLFxuICAgICdzY2FsZVRhcmdldFJlZic6IHRvSnNvbl9Dcm9zc1ZlcnNpb25PYmplY3RSZWZlcmVuY2VWMkJldGEyKG9iai5zY2FsZVRhcmdldFJlZiksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQ3JvbkpvYlNwZWMgZGVzY3JpYmVzIGhvdyB0aGUgam9iIGV4ZWN1dGlvbiB3aWxsIGxvb2sgbGlrZSBhbmQgd2hlbiBpdCB3aWxsIGFjdHVhbGx5IHJ1bi5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYmF0Y2gudjEuQ3JvbkpvYlNwZWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDcm9uSm9iU3BlYyB7XG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgaG93IHRvIHRyZWF0IGNvbmN1cnJlbnQgZXhlY3V0aW9ucyBvZiBhIEpvYi4gVmFsaWQgdmFsdWVzIGFyZTogLSBcIkFsbG93XCIgKGRlZmF1bHQpOiBhbGxvd3MgQ3JvbkpvYnMgdG8gcnVuIGNvbmN1cnJlbnRseTsgLSBcIkZvcmJpZFwiOiBmb3JiaWRzIGNvbmN1cnJlbnQgcnVucywgc2tpcHBpbmcgbmV4dCBydW4gaWYgcHJldmlvdXMgcnVuIGhhc24ndCBmaW5pc2hlZCB5ZXQ7IC0gXCJSZXBsYWNlXCI6IGNhbmNlbHMgY3VycmVudGx5IHJ1bm5pbmcgam9iIGFuZCByZXBsYWNlcyBpdCB3aXRoIGEgbmV3IG9uZVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYmF0Y2gudjEuQ3JvbkpvYlNwZWMjY29uY3VycmVuY3lQb2xpY3lcbiAgICovXG4gIHJlYWRvbmx5IGNvbmN1cnJlbmN5UG9saWN5Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGZhaWxlZCBmaW5pc2hlZCBqb2JzIHRvIHJldGFpbi4gVmFsdWUgbXVzdCBiZSBub24tbmVnYXRpdmUgaW50ZWdlci4gRGVmYXVsdHMgdG8gMS5cbiAgICpcbiAgICogQGRlZmF1bHQgMS5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmJhdGNoLnYxLkNyb25Kb2JTcGVjI2ZhaWxlZEpvYnNIaXN0b3J5TGltaXRcbiAgICovXG4gIHJlYWRvbmx5IGZhaWxlZEpvYnNIaXN0b3J5TGltaXQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgam9iIHRoYXQgd2lsbCBiZSBjcmVhdGVkIHdoZW4gZXhlY3V0aW5nIGEgQ3JvbkpvYi5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmJhdGNoLnYxLkNyb25Kb2JTcGVjI2pvYlRlbXBsYXRlXG4gICAqL1xuICByZWFkb25seSBqb2JUZW1wbGF0ZTogSm9iVGVtcGxhdGVTcGVjO1xuXG4gIC8qKlxuICAgKiBUaGUgc2NoZWR1bGUgaW4gQ3JvbiBmb3JtYXQsIHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Dcm9uLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYmF0Y2gudjEuQ3JvbkpvYlNwZWMjc2NoZWR1bGVcbiAgICovXG4gIHJlYWRvbmx5IHNjaGVkdWxlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGRlYWRsaW5lIGluIHNlY29uZHMgZm9yIHN0YXJ0aW5nIHRoZSBqb2IgaWYgaXQgbWlzc2VzIHNjaGVkdWxlZCB0aW1lIGZvciBhbnkgcmVhc29uLiAgTWlzc2VkIGpvYnMgZXhlY3V0aW9ucyB3aWxsIGJlIGNvdW50ZWQgYXMgZmFpbGVkIG9uZXMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5iYXRjaC52MS5Dcm9uSm9iU3BlYyNzdGFydGluZ0RlYWRsaW5lU2Vjb25kc1xuICAgKi9cbiAgcmVhZG9ubHkgc3RhcnRpbmdEZWFkbGluZVNlY29uZHM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2Ygc3VjY2Vzc2Z1bCBmaW5pc2hlZCBqb2JzIHRvIHJldGFpbi4gVmFsdWUgbXVzdCBiZSBub24tbmVnYXRpdmUgaW50ZWdlci4gRGVmYXVsdHMgdG8gMy5cbiAgICpcbiAgICogQGRlZmF1bHQgMy5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmJhdGNoLnYxLkNyb25Kb2JTcGVjI3N1Y2Nlc3NmdWxKb2JzSGlzdG9yeUxpbWl0XG4gICAqL1xuICByZWFkb25seSBzdWNjZXNzZnVsSm9ic0hpc3RvcnlMaW1pdD86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhpcyBmbGFnIHRlbGxzIHRoZSBjb250cm9sbGVyIHRvIHN1c3BlbmQgc3Vic2VxdWVudCBleGVjdXRpb25zLCBpdCBkb2VzIG5vdCBhcHBseSB0byBhbHJlYWR5IHN0YXJ0ZWQgZXhlY3V0aW9ucy4gIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZS5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmJhdGNoLnYxLkNyb25Kb2JTcGVjI3N1c3BlbmRcbiAgICovXG4gIHJlYWRvbmx5IHN1c3BlbmQ/OiBib29sZWFuO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0Nyb25Kb2JTcGVjJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Dcm9uSm9iU3BlYyhvYmo6IENyb25Kb2JTcGVjIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnY29uY3VycmVuY3lQb2xpY3knOiBvYmouY29uY3VycmVuY3lQb2xpY3ksXG4gICAgJ2ZhaWxlZEpvYnNIaXN0b3J5TGltaXQnOiBvYmouZmFpbGVkSm9ic0hpc3RvcnlMaW1pdCxcbiAgICAnam9iVGVtcGxhdGUnOiB0b0pzb25fSm9iVGVtcGxhdGVTcGVjKG9iai5qb2JUZW1wbGF0ZSksXG4gICAgJ3NjaGVkdWxlJzogb2JqLnNjaGVkdWxlLFxuICAgICdzdGFydGluZ0RlYWRsaW5lU2Vjb25kcyc6IG9iai5zdGFydGluZ0RlYWRsaW5lU2Vjb25kcyxcbiAgICAnc3VjY2Vzc2Z1bEpvYnNIaXN0b3J5TGltaXQnOiBvYmouc3VjY2Vzc2Z1bEpvYnNIaXN0b3J5TGltaXQsXG4gICAgJ3N1c3BlbmQnOiBvYmouc3VzcGVuZCxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBKb2JTcGVjIGRlc2NyaWJlcyBob3cgdGhlIGpvYiBleGVjdXRpb24gd2lsbCBsb29rIGxpa2UuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmJhdGNoLnYxLkpvYlNwZWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBKb2JTcGVjIHtcbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgZHVyYXRpb24gaW4gc2Vjb25kcyByZWxhdGl2ZSB0byB0aGUgc3RhcnRUaW1lIHRoYXQgdGhlIGpvYiBtYXkgYmUgY29udGludW91c2x5IGFjdGl2ZSBiZWZvcmUgdGhlIHN5c3RlbSB0cmllcyB0byB0ZXJtaW5hdGUgaXQ7IHZhbHVlIG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlci4gSWYgYSBKb2IgaXMgc3VzcGVuZGVkIChhdCBjcmVhdGlvbiBvciB0aHJvdWdoIGFuIHVwZGF0ZSksIHRoaXMgdGltZXIgd2lsbCBlZmZlY3RpdmVseSBiZSBzdG9wcGVkIGFuZCByZXNldCB3aGVuIHRoZSBKb2IgaXMgcmVzdW1lZCBhZ2Fpbi5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmJhdGNoLnYxLkpvYlNwZWMjYWN0aXZlRGVhZGxpbmVTZWNvbmRzXG4gICAqL1xuICByZWFkb25seSBhY3RpdmVEZWFkbGluZVNlY29uZHM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIHJldHJpZXMgYmVmb3JlIG1hcmtpbmcgdGhpcyBqb2IgZmFpbGVkLiBEZWZhdWx0cyB0byA2XG4gICAqXG4gICAqIEBkZWZhdWx0IDZcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmJhdGNoLnYxLkpvYlNwZWMjYmFja29mZkxpbWl0XG4gICAqL1xuICByZWFkb25seSBiYWNrb2ZmTGltaXQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIENvbXBsZXRpb25Nb2RlIHNwZWNpZmllcyBob3cgUG9kIGNvbXBsZXRpb25zIGFyZSB0cmFja2VkLiBJdCBjYW4gYmUgYE5vbkluZGV4ZWRgIChkZWZhdWx0KSBvciBgSW5kZXhlZGAuXG4gICAqXG4gICAqIGBOb25JbmRleGVkYCBtZWFucyB0aGF0IHRoZSBKb2IgaXMgY29uc2lkZXJlZCBjb21wbGV0ZSB3aGVuIHRoZXJlIGhhdmUgYmVlbiAuc3BlYy5jb21wbGV0aW9ucyBzdWNjZXNzZnVsbHkgY29tcGxldGVkIFBvZHMuIEVhY2ggUG9kIGNvbXBsZXRpb24gaXMgaG9tb2xvZ291cyB0byBlYWNoIG90aGVyLlxuICAgKlxuICAgKiBgSW5kZXhlZGAgbWVhbnMgdGhhdCB0aGUgUG9kcyBvZiBhIEpvYiBnZXQgYW4gYXNzb2NpYXRlZCBjb21wbGV0aW9uIGluZGV4IGZyb20gMCB0byAoLnNwZWMuY29tcGxldGlvbnMgLSAxKSwgYXZhaWxhYmxlIGluIHRoZSBhbm5vdGF0aW9uIGJhdGNoLmt1YmVybmV0ZXMuaW8vam9iLWNvbXBsZXRpb24taW5kZXguIFRoZSBKb2IgaXMgY29uc2lkZXJlZCBjb21wbGV0ZSB3aGVuIHRoZXJlIGlzIG9uZSBzdWNjZXNzZnVsbHkgY29tcGxldGVkIFBvZCBmb3IgZWFjaCBpbmRleC4gV2hlbiB2YWx1ZSBpcyBgSW5kZXhlZGAsIC5zcGVjLmNvbXBsZXRpb25zIG11c3QgYmUgc3BlY2lmaWVkIGFuZCBgLnNwZWMucGFyYWxsZWxpc21gIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDEwXjUuIEluIGFkZGl0aW9uLCBUaGUgUG9kIG5hbWUgdGFrZXMgdGhlIGZvcm0gYCQoam9iLW5hbWUpLSQoaW5kZXgpLSQocmFuZG9tLXN0cmluZylgLCB0aGUgUG9kIGhvc3RuYW1lIHRha2VzIHRoZSBmb3JtIGAkKGpvYi1uYW1lKS0kKGluZGV4KWAuXG4gICAqXG4gICAqIFRoaXMgZmllbGQgaXMgYmV0YS1sZXZlbC4gTW9yZSBjb21wbGV0aW9uIG1vZGVzIGNhbiBiZSBhZGRlZCBpbiB0aGUgZnV0dXJlLiBJZiB0aGUgSm9iIGNvbnRyb2xsZXIgb2JzZXJ2ZXMgYSBtb2RlIHRoYXQgaXQgZG9lc24ndCByZWNvZ25pemUsIHRoZSBjb250cm9sbGVyIHNraXBzIHVwZGF0ZXMgZm9yIHRoZSBKb2IuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5iYXRjaC52MS5Kb2JTcGVjI2NvbXBsZXRpb25Nb2RlXG4gICAqL1xuICByZWFkb25seSBjb21wbGV0aW9uTW9kZT86IHN0cmluZztcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBkZXNpcmVkIG51bWJlciBvZiBzdWNjZXNzZnVsbHkgZmluaXNoZWQgcG9kcyB0aGUgam9iIHNob3VsZCBiZSBydW4gd2l0aC4gIFNldHRpbmcgdG8gbmlsIG1lYW5zIHRoYXQgdGhlIHN1Y2Nlc3Mgb2YgYW55IHBvZCBzaWduYWxzIHRoZSBzdWNjZXNzIG9mIGFsbCBwb2RzLCBhbmQgYWxsb3dzIHBhcmFsbGVsaXNtIHRvIGhhdmUgYW55IHBvc2l0aXZlIHZhbHVlLiAgU2V0dGluZyB0byAxIG1lYW5zIHRoYXQgcGFyYWxsZWxpc20gaXMgbGltaXRlZCB0byAxIGFuZCB0aGUgc3VjY2VzcyBvZiB0aGF0IHBvZCBzaWduYWxzIHRoZSBzdWNjZXNzIG9mIHRoZSBqb2IuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL2NvbnRyb2xsZXJzL2pvYnMtcnVuLXRvLWNvbXBsZXRpb24vXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5iYXRjaC52MS5Kb2JTcGVjI2NvbXBsZXRpb25zXG4gICAqL1xuICByZWFkb25seSBjb21wbGV0aW9ucz86IG51bWJlcjtcblxuICAvKipcbiAgICogbWFudWFsU2VsZWN0b3IgY29udHJvbHMgZ2VuZXJhdGlvbiBvZiBwb2QgbGFiZWxzIGFuZCBwb2Qgc2VsZWN0b3JzLiBMZWF2ZSBgbWFudWFsU2VsZWN0b3JgIHVuc2V0IHVubGVzcyB5b3UgYXJlIGNlcnRhaW4gd2hhdCB5b3UgYXJlIGRvaW5nLiBXaGVuIGZhbHNlIG9yIHVuc2V0LCB0aGUgc3lzdGVtIHBpY2sgbGFiZWxzIHVuaXF1ZSB0byB0aGlzIGpvYiBhbmQgYXBwZW5kcyB0aG9zZSBsYWJlbHMgdG8gdGhlIHBvZCB0ZW1wbGF0ZS4gIFdoZW4gdHJ1ZSwgdGhlIHVzZXIgaXMgcmVzcG9uc2libGUgZm9yIHBpY2tpbmcgdW5pcXVlIGxhYmVscyBhbmQgc3BlY2lmeWluZyB0aGUgc2VsZWN0b3IuICBGYWlsdXJlIHRvIHBpY2sgYSB1bmlxdWUgbGFiZWwgbWF5IGNhdXNlIHRoaXMgYW5kIG90aGVyIGpvYnMgdG8gbm90IGZ1bmN0aW9uIGNvcnJlY3RseS4gIEhvd2V2ZXIsIFlvdSBtYXkgc2VlIGBtYW51YWxTZWxlY3Rvcj10cnVlYCBpbiBqb2JzIHRoYXQgd2VyZSBjcmVhdGVkIHdpdGggdGhlIG9sZCBgZXh0ZW5zaW9ucy92MWJldGExYCBBUEkuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL2NvbnRyb2xsZXJzL2pvYnMtcnVuLXRvLWNvbXBsZXRpb24vI3NwZWNpZnlpbmcteW91ci1vd24tcG9kLXNlbGVjdG9yXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5iYXRjaC52MS5Kb2JTcGVjI21hbnVhbFNlbGVjdG9yXG4gICAqL1xuICByZWFkb25seSBtYW51YWxTZWxlY3Rvcj86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgbWF4aW11bSBkZXNpcmVkIG51bWJlciBvZiBwb2RzIHRoZSBqb2Igc2hvdWxkIHJ1biBhdCBhbnkgZ2l2ZW4gdGltZS4gVGhlIGFjdHVhbCBudW1iZXIgb2YgcG9kcyBydW5uaW5nIGluIHN0ZWFkeSBzdGF0ZSB3aWxsIGJlIGxlc3MgdGhhbiB0aGlzIG51bWJlciB3aGVuICgoLnNwZWMuY29tcGxldGlvbnMgLSAuc3RhdHVzLnN1Y2Nlc3NmdWwpIDwgLnNwZWMucGFyYWxsZWxpc20pLCBpLmUuIHdoZW4gdGhlIHdvcmsgbGVmdCB0byBkbyBpcyBsZXNzIHRoYW4gbWF4IHBhcmFsbGVsaXNtLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3dvcmtsb2Fkcy9jb250cm9sbGVycy9qb2JzLXJ1bi10by1jb21wbGV0aW9uL1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYmF0Y2gudjEuSm9iU3BlYyNwYXJhbGxlbGlzbVxuICAgKi9cbiAgcmVhZG9ubHkgcGFyYWxsZWxpc20/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEEgbGFiZWwgcXVlcnkgb3ZlciBwb2RzIHRoYXQgc2hvdWxkIG1hdGNoIHRoZSBwb2QgY291bnQuIE5vcm1hbGx5LCB0aGUgc3lzdGVtIHNldHMgdGhpcyBmaWVsZCBmb3IgeW91LiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL292ZXJ2aWV3L3dvcmtpbmctd2l0aC1vYmplY3RzL2xhYmVscy8jbGFiZWwtc2VsZWN0b3JzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5iYXRjaC52MS5Kb2JTcGVjI3NlbGVjdG9yXG4gICAqL1xuICByZWFkb25seSBzZWxlY3Rvcj86IExhYmVsU2VsZWN0b3I7XG5cbiAgLyoqXG4gICAqIFN1c3BlbmQgc3BlY2lmaWVzIHdoZXRoZXIgdGhlIEpvYiBjb250cm9sbGVyIHNob3VsZCBjcmVhdGUgUG9kcyBvciBub3QuIElmIGEgSm9iIGlzIGNyZWF0ZWQgd2l0aCBzdXNwZW5kIHNldCB0byB0cnVlLCBubyBQb2RzIGFyZSBjcmVhdGVkIGJ5IHRoZSBKb2IgY29udHJvbGxlci4gSWYgYSBKb2IgaXMgc3VzcGVuZGVkIGFmdGVyIGNyZWF0aW9uIChpLmUuIHRoZSBmbGFnIGdvZXMgZnJvbSBmYWxzZSB0byB0cnVlKSwgdGhlIEpvYiBjb250cm9sbGVyIHdpbGwgZGVsZXRlIGFsbCBhY3RpdmUgUG9kcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBKb2IuIFVzZXJzIG11c3QgZGVzaWduIHRoZWlyIHdvcmtsb2FkIHRvIGdyYWNlZnVsbHkgaGFuZGxlIHRoaXMuIFN1c3BlbmRpbmcgYSBKb2Igd2lsbCByZXNldCB0aGUgU3RhcnRUaW1lIGZpZWxkIG9mIHRoZSBKb2IsIGVmZmVjdGl2ZWx5IHJlc2V0dGluZyB0aGUgQWN0aXZlRGVhZGxpbmVTZWNvbmRzIHRpbWVyIHRvby4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqXG4gICAqIFRoaXMgZmllbGQgaXMgYmV0YS1sZXZlbCwgZ2F0ZWQgYnkgU3VzcGVuZEpvYiBmZWF0dXJlIGZsYWcgKGVuYWJsZWQgYnkgZGVmYXVsdCkuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYmF0Y2gudjEuSm9iU3BlYyNzdXNwZW5kXG4gICAqL1xuICByZWFkb25seSBzdXNwZW5kPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBwb2QgdGhhdCB3aWxsIGJlIGNyZWF0ZWQgd2hlbiBleGVjdXRpbmcgYSBqb2IuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL2NvbnRyb2xsZXJzL2pvYnMtcnVuLXRvLWNvbXBsZXRpb24vXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5iYXRjaC52MS5Kb2JTcGVjI3RlbXBsYXRlXG4gICAqL1xuICByZWFkb25seSB0ZW1wbGF0ZTogUG9kVGVtcGxhdGVTcGVjO1xuXG4gIC8qKlxuICAgKiB0dGxTZWNvbmRzQWZ0ZXJGaW5pc2hlZCBsaW1pdHMgdGhlIGxpZmV0aW1lIG9mIGEgSm9iIHRoYXQgaGFzIGZpbmlzaGVkIGV4ZWN1dGlvbiAoZWl0aGVyIENvbXBsZXRlIG9yIEZhaWxlZCkuIElmIHRoaXMgZmllbGQgaXMgc2V0LCB0dGxTZWNvbmRzQWZ0ZXJGaW5pc2hlZCBhZnRlciB0aGUgSm9iIGZpbmlzaGVzLCBpdCBpcyBlbGlnaWJsZSB0byBiZSBhdXRvbWF0aWNhbGx5IGRlbGV0ZWQuIFdoZW4gdGhlIEpvYiBpcyBiZWluZyBkZWxldGVkLCBpdHMgbGlmZWN5Y2xlIGd1YXJhbnRlZXMgKGUuZy4gZmluYWxpemVycykgd2lsbCBiZSBob25vcmVkLiBJZiB0aGlzIGZpZWxkIGlzIHVuc2V0LCB0aGUgSm9iIHdvbid0IGJlIGF1dG9tYXRpY2FsbHkgZGVsZXRlZC4gSWYgdGhpcyBmaWVsZCBpcyBzZXQgdG8gemVybywgdGhlIEpvYiBiZWNvbWVzIGVsaWdpYmxlIHRvIGJlIGRlbGV0ZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgZmluaXNoZXMuIFRoaXMgZmllbGQgaXMgYWxwaGEtbGV2ZWwgYW5kIGlzIG9ubHkgaG9ub3JlZCBieSBzZXJ2ZXJzIHRoYXQgZW5hYmxlIHRoZSBUVExBZnRlckZpbmlzaGVkIGZlYXR1cmUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5iYXRjaC52MS5Kb2JTcGVjI3R0bFNlY29uZHNBZnRlckZpbmlzaGVkXG4gICAqL1xuICByZWFkb25seSB0dGxTZWNvbmRzQWZ0ZXJGaW5pc2hlZD86IG51bWJlcjtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdKb2JTcGVjJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Kb2JTcGVjKG9iajogSm9iU3BlYyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2FjdGl2ZURlYWRsaW5lU2Vjb25kcyc6IG9iai5hY3RpdmVEZWFkbGluZVNlY29uZHMsXG4gICAgJ2JhY2tvZmZMaW1pdCc6IG9iai5iYWNrb2ZmTGltaXQsXG4gICAgJ2NvbXBsZXRpb25Nb2RlJzogb2JqLmNvbXBsZXRpb25Nb2RlLFxuICAgICdjb21wbGV0aW9ucyc6IG9iai5jb21wbGV0aW9ucyxcbiAgICAnbWFudWFsU2VsZWN0b3InOiBvYmoubWFudWFsU2VsZWN0b3IsXG4gICAgJ3BhcmFsbGVsaXNtJzogb2JqLnBhcmFsbGVsaXNtLFxuICAgICdzZWxlY3Rvcic6IHRvSnNvbl9MYWJlbFNlbGVjdG9yKG9iai5zZWxlY3RvciksXG4gICAgJ3N1c3BlbmQnOiBvYmouc3VzcGVuZCxcbiAgICAndGVtcGxhdGUnOiB0b0pzb25fUG9kVGVtcGxhdGVTcGVjKG9iai50ZW1wbGF0ZSksXG4gICAgJ3R0bFNlY29uZHNBZnRlckZpbmlzaGVkJzogb2JqLnR0bFNlY29uZHNBZnRlckZpbmlzaGVkLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIENyb25Kb2JTcGVjIGRlc2NyaWJlcyBob3cgdGhlIGpvYiBleGVjdXRpb24gd2lsbCBsb29rIGxpa2UgYW5kIHdoZW4gaXQgd2lsbCBhY3R1YWxseSBydW4uXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmJhdGNoLnYxYmV0YTEuQ3JvbkpvYlNwZWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDcm9uSm9iU3BlY1YxQmV0YTEge1xuICAvKipcbiAgICogU3BlY2lmaWVzIGhvdyB0byB0cmVhdCBjb25jdXJyZW50IGV4ZWN1dGlvbnMgb2YgYSBKb2IuIFZhbGlkIHZhbHVlcyBhcmU6IC0gXCJBbGxvd1wiIChkZWZhdWx0KTogYWxsb3dzIENyb25Kb2JzIHRvIHJ1biBjb25jdXJyZW50bHk7IC0gXCJGb3JiaWRcIjogZm9yYmlkcyBjb25jdXJyZW50IHJ1bnMsIHNraXBwaW5nIG5leHQgcnVuIGlmIHByZXZpb3VzIHJ1biBoYXNuJ3QgZmluaXNoZWQgeWV0OyAtIFwiUmVwbGFjZVwiOiBjYW5jZWxzIGN1cnJlbnRseSBydW5uaW5nIGpvYiBhbmQgcmVwbGFjZXMgaXQgd2l0aCBhIG5ldyBvbmVcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmJhdGNoLnYxYmV0YTEuQ3JvbkpvYlNwZWMjY29uY3VycmVuY3lQb2xpY3lcbiAgICovXG4gIHJlYWRvbmx5IGNvbmN1cnJlbmN5UG9saWN5Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGZhaWxlZCBmaW5pc2hlZCBqb2JzIHRvIHJldGFpbi4gVGhpcyBpcyBhIHBvaW50ZXIgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBleHBsaWNpdCB6ZXJvIGFuZCBub3Qgc3BlY2lmaWVkLiBEZWZhdWx0cyB0byAxLlxuICAgKlxuICAgKiBAZGVmYXVsdCAxLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYmF0Y2gudjFiZXRhMS5Dcm9uSm9iU3BlYyNmYWlsZWRKb2JzSGlzdG9yeUxpbWl0XG4gICAqL1xuICByZWFkb25seSBmYWlsZWRKb2JzSGlzdG9yeUxpbWl0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGpvYiB0aGF0IHdpbGwgYmUgY3JlYXRlZCB3aGVuIGV4ZWN1dGluZyBhIENyb25Kb2IuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5iYXRjaC52MWJldGExLkNyb25Kb2JTcGVjI2pvYlRlbXBsYXRlXG4gICAqL1xuICByZWFkb25seSBqb2JUZW1wbGF0ZTogSm9iVGVtcGxhdGVTcGVjVjFCZXRhMTtcblxuICAvKipcbiAgICogVGhlIHNjaGVkdWxlIGluIENyb24gZm9ybWF0LCBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3Jvbi5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmJhdGNoLnYxYmV0YTEuQ3JvbkpvYlNwZWMjc2NoZWR1bGVcbiAgICovXG4gIHJlYWRvbmx5IHNjaGVkdWxlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGRlYWRsaW5lIGluIHNlY29uZHMgZm9yIHN0YXJ0aW5nIHRoZSBqb2IgaWYgaXQgbWlzc2VzIHNjaGVkdWxlZCB0aW1lIGZvciBhbnkgcmVhc29uLiAgTWlzc2VkIGpvYnMgZXhlY3V0aW9ucyB3aWxsIGJlIGNvdW50ZWQgYXMgZmFpbGVkIG9uZXMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5iYXRjaC52MWJldGExLkNyb25Kb2JTcGVjI3N0YXJ0aW5nRGVhZGxpbmVTZWNvbmRzXG4gICAqL1xuICByZWFkb25seSBzdGFydGluZ0RlYWRsaW5lU2Vjb25kcz86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBzdWNjZXNzZnVsIGZpbmlzaGVkIGpvYnMgdG8gcmV0YWluLiBUaGlzIGlzIGEgcG9pbnRlciB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIGV4cGxpY2l0IHplcm8gYW5kIG5vdCBzcGVjaWZpZWQuIERlZmF1bHRzIHRvIDMuXG4gICAqXG4gICAqIEBkZWZhdWx0IDMuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5iYXRjaC52MWJldGExLkNyb25Kb2JTcGVjI3N1Y2Nlc3NmdWxKb2JzSGlzdG9yeUxpbWl0XG4gICAqL1xuICByZWFkb25seSBzdWNjZXNzZnVsSm9ic0hpc3RvcnlMaW1pdD86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhpcyBmbGFnIHRlbGxzIHRoZSBjb250cm9sbGVyIHRvIHN1c3BlbmQgc3Vic2VxdWVudCBleGVjdXRpb25zLCBpdCBkb2VzIG5vdCBhcHBseSB0byBhbHJlYWR5IHN0YXJ0ZWQgZXhlY3V0aW9ucy4gIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZS5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmJhdGNoLnYxYmV0YTEuQ3JvbkpvYlNwZWMjc3VzcGVuZFxuICAgKi9cbiAgcmVhZG9ubHkgc3VzcGVuZD86IGJvb2xlYW47XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnQ3JvbkpvYlNwZWNWMUJldGExJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Dcm9uSm9iU3BlY1YxQmV0YTEob2JqOiBDcm9uSm9iU3BlY1YxQmV0YTEgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdjb25jdXJyZW5jeVBvbGljeSc6IG9iai5jb25jdXJyZW5jeVBvbGljeSxcbiAgICAnZmFpbGVkSm9ic0hpc3RvcnlMaW1pdCc6IG9iai5mYWlsZWRKb2JzSGlzdG9yeUxpbWl0LFxuICAgICdqb2JUZW1wbGF0ZSc6IHRvSnNvbl9Kb2JUZW1wbGF0ZVNwZWNWMUJldGExKG9iai5qb2JUZW1wbGF0ZSksXG4gICAgJ3NjaGVkdWxlJzogb2JqLnNjaGVkdWxlLFxuICAgICdzdGFydGluZ0RlYWRsaW5lU2Vjb25kcyc6IG9iai5zdGFydGluZ0RlYWRsaW5lU2Vjb25kcyxcbiAgICAnc3VjY2Vzc2Z1bEpvYnNIaXN0b3J5TGltaXQnOiBvYmouc3VjY2Vzc2Z1bEpvYnNIaXN0b3J5TGltaXQsXG4gICAgJ3N1c3BlbmQnOiBvYmouc3VzcGVuZCxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBDZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0U3BlYyBjb250YWlucyB0aGUgY2VydGlmaWNhdGUgcmVxdWVzdC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY2VydGlmaWNhdGVzLnYxLkNlcnRpZmljYXRlU2lnbmluZ1JlcXVlc3RTcGVjXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdFNwZWMge1xuICAvKipcbiAgICogZXhwaXJhdGlvblNlY29uZHMgaXMgdGhlIHJlcXVlc3RlZCBkdXJhdGlvbiBvZiB2YWxpZGl0eSBvZiB0aGUgaXNzdWVkIGNlcnRpZmljYXRlLiBUaGUgY2VydGlmaWNhdGUgc2lnbmVyIG1heSBpc3N1ZSBhIGNlcnRpZmljYXRlIHdpdGggYSBkaWZmZXJlbnQgdmFsaWRpdHkgZHVyYXRpb24gc28gYSBjbGllbnQgbXVzdCBjaGVjayB0aGUgZGVsdGEgYmV0d2VlbiB0aGUgbm90QmVmb3JlIGFuZCBhbmQgbm90QWZ0ZXIgZmllbGRzIGluIHRoZSBpc3N1ZWQgY2VydGlmaWNhdGUgdG8gZGV0ZXJtaW5lIHRoZSBhY3R1YWwgZHVyYXRpb24uXG4gICAqXG4gICAqIFRoZSB2MS4yMisgaW4tdHJlZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIHdlbGwta25vd24gS3ViZXJuZXRlcyBzaWduZXJzIHdpbGwgaG9ub3IgdGhpcyBmaWVsZCBhcyBsb25nIGFzIHRoZSByZXF1ZXN0ZWQgZHVyYXRpb24gaXMgbm90IGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBkdXJhdGlvbiB0aGV5IHdpbGwgaG9ub3IgcGVyIHRoZSAtLWNsdXN0ZXItc2lnbmluZy1kdXJhdGlvbiBDTEkgZmxhZyB0byB0aGUgS3ViZXJuZXRlcyBjb250cm9sbGVyIG1hbmFnZXIuXG4gICAqXG4gICAqIENlcnRpZmljYXRlIHNpZ25lcnMgbWF5IG5vdCBob25vciB0aGlzIGZpZWxkIGZvciB2YXJpb3VzIHJlYXNvbnM6XG4gICAqXG4gICAqIDEuIE9sZCBzaWduZXIgdGhhdCBpcyB1bmF3YXJlIG9mIHRoZSBmaWVsZCAoc3VjaCBhcyB0aGUgaW4tdHJlZVxuICAgKiBpbXBsZW1lbnRhdGlvbnMgcHJpb3IgdG8gdjEuMjIpXG4gICAqIDIuIFNpZ25lciB3aG9zZSBjb25maWd1cmVkIG1heGltdW0gaXMgc2hvcnRlciB0aGFuIHRoZSByZXF1ZXN0ZWQgZHVyYXRpb25cbiAgICogMy4gU2lnbmVyIHdob3NlIGNvbmZpZ3VyZWQgbWluaW11bSBpcyBsb25nZXIgdGhhbiB0aGUgcmVxdWVzdGVkIGR1cmF0aW9uXG4gICAqXG4gICAqIFRoZSBtaW5pbXVtIHZhbGlkIHZhbHVlIGZvciBleHBpcmF0aW9uU2Vjb25kcyBpcyA2MDAsIGkuZS4gMTAgbWludXRlcy5cbiAgICpcbiAgICogQXMgb2YgdjEuMjIsIHRoaXMgZmllbGQgaXMgYmV0YSBhbmQgaXMgY29udHJvbGxlZCB2aWEgdGhlIENTUkR1cmF0aW9uIGZlYXR1cmUgZ2F0ZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNlcnRpZmljYXRlcy52MS5DZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0U3BlYyNleHBpcmF0aW9uU2Vjb25kc1xuICAgKi9cbiAgcmVhZG9ubHkgZXhwaXJhdGlvblNlY29uZHM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIGV4dHJhIGNvbnRhaW5zIGV4dHJhIGF0dHJpYnV0ZXMgb2YgdGhlIHVzZXIgdGhhdCBjcmVhdGVkIHRoZSBDZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0LiBQb3B1bGF0ZWQgYnkgdGhlIEFQSSBzZXJ2ZXIgb24gY3JlYXRpb24gYW5kIGltbXV0YWJsZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNlcnRpZmljYXRlcy52MS5DZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0U3BlYyNleHRyYVxuICAgKi9cbiAgcmVhZG9ubHkgZXh0cmE/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZ1tdIH07XG5cbiAgLyoqXG4gICAqIGdyb3VwcyBjb250YWlucyBncm91cCBtZW1iZXJzaGlwIG9mIHRoZSB1c2VyIHRoYXQgY3JlYXRlZCB0aGUgQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdC4gUG9wdWxhdGVkIGJ5IHRoZSBBUEkgc2VydmVyIG9uIGNyZWF0aW9uIGFuZCBpbW11dGFibGUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jZXJ0aWZpY2F0ZXMudjEuQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdFNwZWMjZ3JvdXBzXG4gICAqL1xuICByZWFkb25seSBncm91cHM/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogcmVxdWVzdCBjb250YWlucyBhbiB4NTA5IGNlcnRpZmljYXRlIHNpZ25pbmcgcmVxdWVzdCBlbmNvZGVkIGluIGEgXCJDRVJUSUZJQ0FURSBSRVFVRVNUXCIgUEVNIGJsb2NrLiBXaGVuIHNlcmlhbGl6ZWQgYXMgSlNPTiBvciBZQU1MLCB0aGUgZGF0YSBpcyBhZGRpdGlvbmFsbHkgYmFzZTY0LWVuY29kZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jZXJ0aWZpY2F0ZXMudjEuQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdFNwZWMjcmVxdWVzdFxuICAgKi9cbiAgcmVhZG9ubHkgcmVxdWVzdDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBzaWduZXJOYW1lIGluZGljYXRlcyB0aGUgcmVxdWVzdGVkIHNpZ25lciwgYW5kIGlzIGEgcXVhbGlmaWVkIG5hbWUuXG4gICAqXG4gICAqIExpc3Qvd2F0Y2ggcmVxdWVzdHMgZm9yIENlcnRpZmljYXRlU2lnbmluZ1JlcXVlc3RzIGNhbiBmaWx0ZXIgb24gdGhpcyBmaWVsZCB1c2luZyBhIFwic3BlYy5zaWduZXJOYW1lPU5BTUVcIiBmaWVsZFNlbGVjdG9yLlxuICAgKlxuICAgKiBXZWxsLWtub3duIEt1YmVybmV0ZXMgc2lnbmVycyBhcmU6XG4gICAqIDEuIFwia3ViZXJuZXRlcy5pby9rdWJlLWFwaXNlcnZlci1jbGllbnRcIjogaXNzdWVzIGNsaWVudCBjZXJ0aWZpY2F0ZXMgdGhhdCBjYW4gYmUgdXNlZCB0byBhdXRoZW50aWNhdGUgdG8ga3ViZS1hcGlzZXJ2ZXIuXG4gICAqIFJlcXVlc3RzIGZvciB0aGlzIHNpZ25lciBhcmUgbmV2ZXIgYXV0by1hcHByb3ZlZCBieSBrdWJlLWNvbnRyb2xsZXItbWFuYWdlciwgY2FuIGJlIGlzc3VlZCBieSB0aGUgXCJjc3JzaWduaW5nXCIgY29udHJvbGxlciBpbiBrdWJlLWNvbnRyb2xsZXItbWFuYWdlci5cbiAgICogMi4gXCJrdWJlcm5ldGVzLmlvL2t1YmUtYXBpc2VydmVyLWNsaWVudC1rdWJlbGV0XCI6IGlzc3VlcyBjbGllbnQgY2VydGlmaWNhdGVzIHRoYXQga3ViZWxldHMgdXNlIHRvIGF1dGhlbnRpY2F0ZSB0byBrdWJlLWFwaXNlcnZlci5cbiAgICogUmVxdWVzdHMgZm9yIHRoaXMgc2lnbmVyIGNhbiBiZSBhdXRvLWFwcHJvdmVkIGJ5IHRoZSBcImNzcmFwcHJvdmluZ1wiIGNvbnRyb2xsZXIgaW4ga3ViZS1jb250cm9sbGVyLW1hbmFnZXIsIGFuZCBjYW4gYmUgaXNzdWVkIGJ5IHRoZSBcImNzcnNpZ25pbmdcIiBjb250cm9sbGVyIGluIGt1YmUtY29udHJvbGxlci1tYW5hZ2VyLlxuICAgKiAzLiBcImt1YmVybmV0ZXMuaW8va3ViZWxldC1zZXJ2aW5nXCIgaXNzdWVzIHNlcnZpbmcgY2VydGlmaWNhdGVzIHRoYXQga3ViZWxldHMgdXNlIHRvIHNlcnZlIFRMUyBlbmRwb2ludHMsIHdoaWNoIGt1YmUtYXBpc2VydmVyIGNhbiBjb25uZWN0IHRvIHNlY3VyZWx5LlxuICAgKiBSZXF1ZXN0cyBmb3IgdGhpcyBzaWduZXIgYXJlIG5ldmVyIGF1dG8tYXBwcm92ZWQgYnkga3ViZS1jb250cm9sbGVyLW1hbmFnZXIsIGFuZCBjYW4gYmUgaXNzdWVkIGJ5IHRoZSBcImNzcnNpZ25pbmdcIiBjb250cm9sbGVyIGluIGt1YmUtY29udHJvbGxlci1tYW5hZ2VyLlxuICAgKlxuICAgKiBNb3JlIGRldGFpbHMgYXJlIGF2YWlsYWJsZSBhdCBodHRwczovL2s4cy5pby9kb2NzL3JlZmVyZW5jZS9hY2Nlc3MtYXV0aG4tYXV0aHovY2VydGlmaWNhdGUtc2lnbmluZy1yZXF1ZXN0cy8ja3ViZXJuZXRlcy1zaWduZXJzXG4gICAqXG4gICAqIEN1c3RvbSBzaWduZXJOYW1lcyBjYW4gYWxzbyBiZSBzcGVjaWZpZWQuIFRoZSBzaWduZXIgZGVmaW5lczpcbiAgICogMS4gVHJ1c3QgZGlzdHJpYnV0aW9uOiBob3cgdHJ1c3QgKENBIGJ1bmRsZXMpIGFyZSBkaXN0cmlidXRlZC5cbiAgICogMi4gUGVybWl0dGVkIHN1YmplY3RzOiBhbmQgYmVoYXZpb3Igd2hlbiBhIGRpc2FsbG93ZWQgc3ViamVjdCBpcyByZXF1ZXN0ZWQuXG4gICAqIDMuIFJlcXVpcmVkLCBwZXJtaXR0ZWQsIG9yIGZvcmJpZGRlbiB4NTA5IGV4dGVuc2lvbnMgaW4gdGhlIHJlcXVlc3QgKGluY2x1ZGluZyB3aGV0aGVyIHN1YmplY3RBbHROYW1lcyBhcmUgYWxsb3dlZCwgd2hpY2ggdHlwZXMsIHJlc3RyaWN0aW9ucyBvbiBhbGxvd2VkIHZhbHVlcykgYW5kIGJlaGF2aW9yIHdoZW4gYSBkaXNhbGxvd2VkIGV4dGVuc2lvbiBpcyByZXF1ZXN0ZWQuXG4gICAqIDQuIFJlcXVpcmVkLCBwZXJtaXR0ZWQsIG9yIGZvcmJpZGRlbiBrZXkgdXNhZ2VzIC8gZXh0ZW5kZWQga2V5IHVzYWdlcy5cbiAgICogNS4gRXhwaXJhdGlvbi9jZXJ0aWZpY2F0ZSBsaWZldGltZTogd2hldGhlciBpdCBpcyBmaXhlZCBieSB0aGUgc2lnbmVyLCBjb25maWd1cmFibGUgYnkgdGhlIGFkbWluLlxuICAgKiA2LiBXaGV0aGVyIG9yIG5vdCByZXF1ZXN0cyBmb3IgQ0EgY2VydGlmaWNhdGVzIGFyZSBhbGxvd2VkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY2VydGlmaWNhdGVzLnYxLkNlcnRpZmljYXRlU2lnbmluZ1JlcXVlc3RTcGVjI3NpZ25lck5hbWVcbiAgICovXG4gIHJlYWRvbmx5IHNpZ25lck5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogdWlkIGNvbnRhaW5zIHRoZSB1aWQgb2YgdGhlIHVzZXIgdGhhdCBjcmVhdGVkIHRoZSBDZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0LiBQb3B1bGF0ZWQgYnkgdGhlIEFQSSBzZXJ2ZXIgb24gY3JlYXRpb24gYW5kIGltbXV0YWJsZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNlcnRpZmljYXRlcy52MS5DZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0U3BlYyN1aWRcbiAgICovXG4gIHJlYWRvbmx5IHVpZD86IHN0cmluZztcblxuICAvKipcbiAgICogdXNhZ2VzIHNwZWNpZmllcyBhIHNldCBvZiBrZXkgdXNhZ2VzIHJlcXVlc3RlZCBpbiB0aGUgaXNzdWVkIGNlcnRpZmljYXRlLlxuICAgKlxuICAgKiBSZXF1ZXN0cyBmb3IgVExTIGNsaWVudCBjZXJ0aWZpY2F0ZXMgdHlwaWNhbGx5IHJlcXVlc3Q6IFwiZGlnaXRhbCBzaWduYXR1cmVcIiwgXCJrZXkgZW5jaXBoZXJtZW50XCIsIFwiY2xpZW50IGF1dGhcIi5cbiAgICpcbiAgICogUmVxdWVzdHMgZm9yIFRMUyBzZXJ2aW5nIGNlcnRpZmljYXRlcyB0eXBpY2FsbHkgcmVxdWVzdDogXCJrZXkgZW5jaXBoZXJtZW50XCIsIFwiZGlnaXRhbCBzaWduYXR1cmVcIiwgXCJzZXJ2ZXIgYXV0aFwiLlxuICAgKlxuICAgKiBWYWxpZCB2YWx1ZXMgYXJlOlxuICAgKiBcInNpZ25pbmdcIiwgXCJkaWdpdGFsIHNpZ25hdHVyZVwiLCBcImNvbnRlbnQgY29tbWl0bWVudFwiLFxuICAgKiBcImtleSBlbmNpcGhlcm1lbnRcIiwgXCJrZXkgYWdyZWVtZW50XCIsIFwiZGF0YSBlbmNpcGhlcm1lbnRcIixcbiAgICogXCJjZXJ0IHNpZ25cIiwgXCJjcmwgc2lnblwiLCBcImVuY2lwaGVyIG9ubHlcIiwgXCJkZWNpcGhlciBvbmx5XCIsIFwiYW55XCIsXG4gICAqIFwic2VydmVyIGF1dGhcIiwgXCJjbGllbnQgYXV0aFwiLFxuICAgKiBcImNvZGUgc2lnbmluZ1wiLCBcImVtYWlsIHByb3RlY3Rpb25cIiwgXCJzL21pbWVcIixcbiAgICogXCJpcHNlYyBlbmQgc3lzdGVtXCIsIFwiaXBzZWMgdHVubmVsXCIsIFwiaXBzZWMgdXNlclwiLFxuICAgKiBcInRpbWVzdGFtcGluZ1wiLCBcIm9jc3Agc2lnbmluZ1wiLCBcIm1pY3Jvc29mdCBzZ2NcIiwgXCJuZXRzY2FwZSBzZ2NcIlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY2VydGlmaWNhdGVzLnYxLkNlcnRpZmljYXRlU2lnbmluZ1JlcXVlc3RTcGVjI3VzYWdlc1xuICAgKi9cbiAgcmVhZG9ubHkgdXNhZ2VzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIHVzZXJuYW1lIGNvbnRhaW5zIHRoZSBuYW1lIG9mIHRoZSB1c2VyIHRoYXQgY3JlYXRlZCB0aGUgQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdC4gUG9wdWxhdGVkIGJ5IHRoZSBBUEkgc2VydmVyIG9uIGNyZWF0aW9uIGFuZCBpbW11dGFibGUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jZXJ0aWZpY2F0ZXMudjEuQ2VydGlmaWNhdGVTaWduaW5nUmVxdWVzdFNwZWMjdXNlcm5hbWVcbiAgICovXG4gIHJlYWRvbmx5IHVzZXJuYW1lPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0NlcnRpZmljYXRlU2lnbmluZ1JlcXVlc3RTcGVjJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9DZXJ0aWZpY2F0ZVNpZ25pbmdSZXF1ZXN0U3BlYyhvYmo6IENlcnRpZmljYXRlU2lnbmluZ1JlcXVlc3RTcGVjIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZXhwaXJhdGlvblNlY29uZHMnOiBvYmouZXhwaXJhdGlvblNlY29uZHMsXG4gICAgJ2V4dHJhJzogKChvYmouZXh0cmEpID09PSB1bmRlZmluZWQpID8gdW5kZWZpbmVkIDogKE9iamVjdC5lbnRyaWVzKG9iai5leHRyYSkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0/Lm1hcCh5ID0+IHkpIH0pLCB7fSkpLFxuICAgICdncm91cHMnOiBvYmouZ3JvdXBzPy5tYXAoeSA9PiB5KSxcbiAgICAncmVxdWVzdCc6IG9iai5yZXF1ZXN0LFxuICAgICdzaWduZXJOYW1lJzogb2JqLnNpZ25lck5hbWUsXG4gICAgJ3VpZCc6IG9iai51aWQsXG4gICAgJ3VzYWdlcyc6IG9iai51c2FnZXM/Lm1hcCh5ID0+IHkpLFxuICAgICd1c2VybmFtZSc6IG9iai51c2VybmFtZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBMZWFzZVNwZWMgaXMgYSBzcGVjaWZpY2F0aW9uIG9mIGEgTGVhc2UuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvb3JkaW5hdGlvbi52MS5MZWFzZVNwZWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMZWFzZVNwZWMge1xuICAvKipcbiAgICogYWNxdWlyZVRpbWUgaXMgYSB0aW1lIHdoZW4gdGhlIGN1cnJlbnQgbGVhc2Ugd2FzIGFjcXVpcmVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29vcmRpbmF0aW9uLnYxLkxlYXNlU3BlYyNhY3F1aXJlVGltZVxuICAgKi9cbiAgcmVhZG9ubHkgYWNxdWlyZVRpbWU/OiBEYXRlO1xuXG4gIC8qKlxuICAgKiBob2xkZXJJZGVudGl0eSBjb250YWlucyB0aGUgaWRlbnRpdHkgb2YgdGhlIGhvbGRlciBvZiBhIGN1cnJlbnQgbGVhc2UuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb29yZGluYXRpb24udjEuTGVhc2VTcGVjI2hvbGRlcklkZW50aXR5XG4gICAqL1xuICByZWFkb25seSBob2xkZXJJZGVudGl0eT86IHN0cmluZztcblxuICAvKipcbiAgICogbGVhc2VEdXJhdGlvblNlY29uZHMgaXMgYSBkdXJhdGlvbiB0aGF0IGNhbmRpZGF0ZXMgZm9yIGEgbGVhc2UgbmVlZCB0byB3YWl0IHRvIGZvcmNlIGFjcXVpcmUgaXQuIFRoaXMgaXMgbWVhc3VyZSBhZ2FpbnN0IHRpbWUgb2YgbGFzdCBvYnNlcnZlZCBSZW5ld1RpbWUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb29yZGluYXRpb24udjEuTGVhc2VTcGVjI2xlYXNlRHVyYXRpb25TZWNvbmRzXG4gICAqL1xuICByZWFkb25seSBsZWFzZUR1cmF0aW9uU2Vjb25kcz86IG51bWJlcjtcblxuICAvKipcbiAgICogbGVhc2VUcmFuc2l0aW9ucyBpcyB0aGUgbnVtYmVyIG9mIHRyYW5zaXRpb25zIG9mIGEgbGVhc2UgYmV0d2VlbiBob2xkZXJzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29vcmRpbmF0aW9uLnYxLkxlYXNlU3BlYyNsZWFzZVRyYW5zaXRpb25zXG4gICAqL1xuICByZWFkb25seSBsZWFzZVRyYW5zaXRpb25zPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiByZW5ld1RpbWUgaXMgYSB0aW1lIHdoZW4gdGhlIGN1cnJlbnQgaG9sZGVyIG9mIGEgbGVhc2UgaGFzIGxhc3QgdXBkYXRlZCB0aGUgbGVhc2UuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb29yZGluYXRpb24udjEuTGVhc2VTcGVjI3JlbmV3VGltZVxuICAgKi9cbiAgcmVhZG9ubHkgcmVuZXdUaW1lPzogRGF0ZTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdMZWFzZVNwZWMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0xlYXNlU3BlYyhvYmo6IExlYXNlU3BlYyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2FjcXVpcmVUaW1lJzogb2JqLmFjcXVpcmVUaW1lPy50b0lTT1N0cmluZygpLFxuICAgICdob2xkZXJJZGVudGl0eSc6IG9iai5ob2xkZXJJZGVudGl0eSxcbiAgICAnbGVhc2VEdXJhdGlvblNlY29uZHMnOiBvYmoubGVhc2VEdXJhdGlvblNlY29uZHMsXG4gICAgJ2xlYXNlVHJhbnNpdGlvbnMnOiBvYmoubGVhc2VUcmFuc2l0aW9ucyxcbiAgICAncmVuZXdUaW1lJzogb2JqLnJlbmV3VGltZT8udG9JU09TdHJpbmcoKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBPYmplY3RSZWZlcmVuY2UgY29udGFpbnMgZW5vdWdoIGluZm9ybWF0aW9uIHRvIGxldCB5b3UgaW5zcGVjdCBvciBtb2RpZnkgdGhlIHJlZmVycmVkIG9iamVjdC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5PYmplY3RSZWZlcmVuY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBPYmplY3RSZWZlcmVuY2Uge1xuICAvKipcbiAgICogQVBJIHZlcnNpb24gb2YgdGhlIHJlZmVyZW50LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5PYmplY3RSZWZlcmVuY2UjYXBpVmVyc2lvblxuICAgKi9cbiAgcmVhZG9ubHkgYXBpVmVyc2lvbj86IHN0cmluZztcblxuICAvKipcbiAgICogSWYgcmVmZXJyaW5nIHRvIGEgcGllY2Ugb2YgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gZW50aXJlIG9iamVjdCwgdGhpcyBzdHJpbmcgc2hvdWxkIGNvbnRhaW4gYSB2YWxpZCBKU09OL0dvIGZpZWxkIGFjY2VzcyBzdGF0ZW1lbnQsIHN1Y2ggYXMgZGVzaXJlZFN0YXRlLm1hbmlmZXN0LmNvbnRhaW5lcnNbMl0uIEZvciBleGFtcGxlLCBpZiB0aGUgb2JqZWN0IHJlZmVyZW5jZSBpcyB0byBhIGNvbnRhaW5lciB3aXRoaW4gYSBwb2QsIHRoaXMgd291bGQgdGFrZSBvbiBhIHZhbHVlIGxpa2U6IFwic3BlYy5jb250YWluZXJze25hbWV9XCIgKHdoZXJlIFwibmFtZVwiIHJlZmVycyB0byB0aGUgbmFtZSBvZiB0aGUgY29udGFpbmVyIHRoYXQgdHJpZ2dlcmVkIHRoZSBldmVudCkgb3IgaWYgbm8gY29udGFpbmVyIG5hbWUgaXMgc3BlY2lmaWVkIFwic3BlYy5jb250YWluZXJzWzJdXCIgKGNvbnRhaW5lciB3aXRoIGluZGV4IDIgaW4gdGhpcyBwb2QpLiBUaGlzIHN5bnRheCBpcyBjaG9zZW4gb25seSB0byBoYXZlIHNvbWUgd2VsbC1kZWZpbmVkIHdheSBvZiByZWZlcmVuY2luZyBhIHBhcnQgb2YgYW4gb2JqZWN0LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5PYmplY3RSZWZlcmVuY2UjZmllbGRQYXRoXG4gICAqL1xuICByZWFkb25seSBmaWVsZFBhdGg/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEtpbmQgb2YgdGhlIHJlZmVyZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3R5cGVzLWtpbmRzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLk9iamVjdFJlZmVyZW5jZSNraW5kXG4gICAqL1xuICByZWFkb25seSBraW5kPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSByZWZlcmVudC4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9vdmVydmlldy93b3JraW5nLXdpdGgtb2JqZWN0cy9uYW1lcy8jbmFtZXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuT2JqZWN0UmVmZXJlbmNlI25hbWVcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE5hbWVzcGFjZSBvZiB0aGUgcmVmZXJlbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvb3ZlcnZpZXcvd29ya2luZy13aXRoLW9iamVjdHMvbmFtZXNwYWNlcy9cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuT2JqZWN0UmVmZXJlbmNlI25hbWVzcGFjZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZXNwYWNlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpYyByZXNvdXJjZVZlcnNpb24gdG8gd2hpY2ggdGhpcyByZWZlcmVuY2UgaXMgbWFkZSwgaWYgYW55LiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI2NvbmN1cnJlbmN5LWNvbnRyb2wtYW5kLWNvbnNpc3RlbmN5XG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLk9iamVjdFJlZmVyZW5jZSNyZXNvdXJjZVZlcnNpb25cbiAgICovXG4gIHJlYWRvbmx5IHJlc291cmNlVmVyc2lvbj86IHN0cmluZztcblxuICAvKipcbiAgICogVUlEIG9mIHRoZSByZWZlcmVudC4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9vdmVydmlldy93b3JraW5nLXdpdGgtb2JqZWN0cy9uYW1lcy8jdWlkc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5PYmplY3RSZWZlcmVuY2UjdWlkXG4gICAqL1xuICByZWFkb25seSB1aWQ/OiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnT2JqZWN0UmVmZXJlbmNlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9PYmplY3RSZWZlcmVuY2Uob2JqOiBPYmplY3RSZWZlcmVuY2UgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdhcGlWZXJzaW9uJzogb2JqLmFwaVZlcnNpb24sXG4gICAgJ2ZpZWxkUGF0aCc6IG9iai5maWVsZFBhdGgsXG4gICAgJ2tpbmQnOiBvYmoua2luZCxcbiAgICAnbmFtZSc6IG9iai5uYW1lLFxuICAgICduYW1lc3BhY2UnOiBvYmoubmFtZXNwYWNlLFxuICAgICdyZXNvdXJjZVZlcnNpb24nOiBvYmoucmVzb3VyY2VWZXJzaW9uLFxuICAgICd1aWQnOiBvYmoudWlkLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBjb25kaXRpb24gb2YgYSBjb21wb25lbnQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ29tcG9uZW50Q29uZGl0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcG9uZW50Q29uZGl0aW9uIHtcbiAgLyoqXG4gICAqIENvbmRpdGlvbiBlcnJvciBjb2RlIGZvciBhIGNvbXBvbmVudC4gRm9yIGV4YW1wbGUsIGEgaGVhbHRoIGNoZWNrIGVycm9yIGNvZGUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbXBvbmVudENvbmRpdGlvbiNlcnJvclxuICAgKi9cbiAgcmVhZG9ubHkgZXJyb3I/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE1lc3NhZ2UgYWJvdXQgdGhlIGNvbmRpdGlvbiBmb3IgYSBjb21wb25lbnQuIEZvciBleGFtcGxlLCBpbmZvcm1hdGlvbiBhYm91dCBhIGhlYWx0aCBjaGVjay5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ29tcG9uZW50Q29uZGl0aW9uI21lc3NhZ2VcbiAgICovXG4gIHJlYWRvbmx5IG1lc3NhZ2U/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFN0YXR1cyBvZiB0aGUgY29uZGl0aW9uIGZvciBhIGNvbXBvbmVudC4gVmFsaWQgdmFsdWVzIGZvciBcIkhlYWx0aHlcIjogXCJUcnVlXCIsIFwiRmFsc2VcIiwgb3IgXCJVbmtub3duXCIuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbXBvbmVudENvbmRpdGlvbiNzdGF0dXNcbiAgICovXG4gIHJlYWRvbmx5IHN0YXR1czogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUeXBlIG9mIGNvbmRpdGlvbiBmb3IgYSBjb21wb25lbnQuIFZhbGlkIHZhbHVlOiBcIkhlYWx0aHlcIlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db21wb25lbnRDb25kaXRpb24jdHlwZVxuICAgKi9cbiAgcmVhZG9ubHkgdHlwZTogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0NvbXBvbmVudENvbmRpdGlvbicgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fQ29tcG9uZW50Q29uZGl0aW9uKG9iajogQ29tcG9uZW50Q29uZGl0aW9uIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZXJyb3InOiBvYmouZXJyb3IsXG4gICAgJ21lc3NhZ2UnOiBvYmoubWVzc2FnZSxcbiAgICAnc3RhdHVzJzogb2JqLnN0YXR1cyxcbiAgICAndHlwZSc6IG9iai50eXBlLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEVuZHBvaW50U3Vic2V0IGlzIGEgZ3JvdXAgb2YgYWRkcmVzc2VzIHdpdGggYSBjb21tb24gc2V0IG9mIHBvcnRzLiBUaGUgZXhwYW5kZWQgc2V0IG9mIGVuZHBvaW50cyBpcyB0aGUgQ2FydGVzaWFuIHByb2R1Y3Qgb2YgQWRkcmVzc2VzIHggUG9ydHMuIEZvciBleGFtcGxlLCBnaXZlbjpcbiAqIHtcbiAqIEFkZHJlc3NlczogW3tcImlwXCI6IFwiMTAuMTAuMS4xXCJ9LCB7XCJpcFwiOiBcIjEwLjEwLjIuMlwifV0sXG4gKiBQb3J0czogICAgIFt7XCJuYW1lXCI6IFwiYVwiLCBcInBvcnRcIjogODY3NX0sIHtcIm5hbWVcIjogXCJiXCIsIFwicG9ydFwiOiAzMDl9XVxuICogfVxuICogVGhlIHJlc3VsdGluZyBzZXQgb2YgZW5kcG9pbnRzIGNhbiBiZSB2aWV3ZWQgYXM6XG4gKiBhOiBbIDEwLjEwLjEuMTo4Njc1LCAxMC4xMC4yLjI6ODY3NSBdLFxuICogYjogWyAxMC4xMC4xLjE6MzA5LCAxMC4xMC4yLjI6MzA5IF1cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FbmRwb2ludFN1YnNldFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVuZHBvaW50U3Vic2V0IHtcbiAgLyoqXG4gICAqIElQIGFkZHJlc3NlcyB3aGljaCBvZmZlciB0aGUgcmVsYXRlZCBwb3J0cyB0aGF0IGFyZSBtYXJrZWQgYXMgcmVhZHkuIFRoZXNlIGVuZHBvaW50cyBzaG91bGQgYmUgY29uc2lkZXJlZCBzYWZlIGZvciBsb2FkIGJhbGFuY2VycyBhbmQgY2xpZW50cyB0byB1dGlsaXplLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FbmRwb2ludFN1YnNldCNhZGRyZXNzZXNcbiAgICovXG4gIHJlYWRvbmx5IGFkZHJlc3Nlcz86IEVuZHBvaW50QWRkcmVzc1tdO1xuXG4gIC8qKlxuICAgKiBJUCBhZGRyZXNzZXMgd2hpY2ggb2ZmZXIgdGhlIHJlbGF0ZWQgcG9ydHMgYnV0IGFyZSBub3QgY3VycmVudGx5IG1hcmtlZCBhcyByZWFkeSBiZWNhdXNlIHRoZXkgaGF2ZSBub3QgeWV0IGZpbmlzaGVkIHN0YXJ0aW5nLCBoYXZlIHJlY2VudGx5IGZhaWxlZCBhIHJlYWRpbmVzcyBjaGVjaywgb3IgaGF2ZSByZWNlbnRseSBmYWlsZWQgYSBsaXZlbmVzcyBjaGVjay5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRW5kcG9pbnRTdWJzZXQjbm90UmVhZHlBZGRyZXNzZXNcbiAgICovXG4gIHJlYWRvbmx5IG5vdFJlYWR5QWRkcmVzc2VzPzogRW5kcG9pbnRBZGRyZXNzW107XG5cbiAgLyoqXG4gICAqIFBvcnQgbnVtYmVycyBhdmFpbGFibGUgb24gdGhlIHJlbGF0ZWQgSVAgYWRkcmVzc2VzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FbmRwb2ludFN1YnNldCNwb3J0c1xuICAgKi9cbiAgcmVhZG9ubHkgcG9ydHM/OiBFbmRwb2ludFBvcnRbXTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdFbmRwb2ludFN1YnNldCcgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fRW5kcG9pbnRTdWJzZXQob2JqOiBFbmRwb2ludFN1YnNldCB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2FkZHJlc3Nlcyc6IG9iai5hZGRyZXNzZXM/Lm1hcCh5ID0+IHRvSnNvbl9FbmRwb2ludEFkZHJlc3MoeSkpLFxuICAgICdub3RSZWFkeUFkZHJlc3Nlcyc6IG9iai5ub3RSZWFkeUFkZHJlc3Nlcz8ubWFwKHkgPT4gdG9Kc29uX0VuZHBvaW50QWRkcmVzcyh5KSksXG4gICAgJ3BvcnRzJzogb2JqLnBvcnRzPy5tYXAoeSA9PiB0b0pzb25fRW5kcG9pbnRQb3J0KHkpKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBFdmVudFNvdXJjZSBjb250YWlucyBpbmZvcm1hdGlvbiBmb3IgYW4gZXZlbnQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRXZlbnRTb3VyY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFdmVudFNvdXJjZSB7XG4gIC8qKlxuICAgKiBDb21wb25lbnQgZnJvbSB3aGljaCB0aGUgZXZlbnQgaXMgZ2VuZXJhdGVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FdmVudFNvdXJjZSNjb21wb25lbnRcbiAgICovXG4gIHJlYWRvbmx5IGNvbXBvbmVudD86IHN0cmluZztcblxuICAvKipcbiAgICogTm9kZSBuYW1lIG9uIHdoaWNoIHRoZSBldmVudCBpcyBnZW5lcmF0ZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkV2ZW50U291cmNlI2hvc3RcbiAgICovXG4gIHJlYWRvbmx5IGhvc3Q/OiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnRXZlbnRTb3VyY2UnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0V2ZW50U291cmNlKG9iajogRXZlbnRTb3VyY2UgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdjb21wb25lbnQnOiBvYmouY29tcG9uZW50LFxuICAgICdob3N0Jzogb2JqLmhvc3QsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogRXZlbnRTZXJpZXMgY29udGFpbiBpbmZvcm1hdGlvbiBvbiBzZXJpZXMgb2YgZXZlbnRzLCBpLmUuIHRoaW5nIHRoYXQgd2FzL2lzIGhhcHBlbmluZyBjb250aW51b3VzbHkgZm9yIHNvbWUgdGltZS4gSG93IG9mdGVuIHRvIHVwZGF0ZSB0aGUgRXZlbnRTZXJpZXMgaXMgdXAgdG8gdGhlIGV2ZW50IHJlcG9ydGVycy4gVGhlIGRlZmF1bHQgZXZlbnQgcmVwb3J0ZXIgaW4gXCJrOHMuaW8vY2xpZW50LWdvL3Rvb2xzL2V2ZW50cy9ldmVudF9icm9hZGNhc3Rlci5nb1wiIHNob3dzIGhvdyB0aGlzIHN0cnVjdCBpcyB1cGRhdGVkIG9uIGhlYXJ0YmVhdHMgYW5kIGNhbiBndWlkZSBjdXN0b21pemVkIHJlcG9ydGVyIGltcGxlbWVudGF0aW9ucy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuZXZlbnRzLnYxLkV2ZW50U2VyaWVzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRTZXJpZXMge1xuICAvKipcbiAgICogY291bnQgaXMgdGhlIG51bWJlciBvZiBvY2N1cnJlbmNlcyBpbiB0aGlzIHNlcmllcyB1cCB0byB0aGUgbGFzdCBoZWFydGJlYXQgdGltZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmV2ZW50cy52MS5FdmVudFNlcmllcyNjb3VudFxuICAgKi9cbiAgcmVhZG9ubHkgY291bnQ6IG51bWJlcjtcblxuICAvKipcbiAgICogbGFzdE9ic2VydmVkVGltZSBpcyB0aGUgdGltZSB3aGVuIGxhc3QgRXZlbnQgZnJvbSB0aGUgc2VyaWVzIHdhcyBzZWVuIGJlZm9yZSBsYXN0IGhlYXJ0YmVhdC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmV2ZW50cy52MS5FdmVudFNlcmllcyNsYXN0T2JzZXJ2ZWRUaW1lXG4gICAqL1xuICByZWFkb25seSBsYXN0T2JzZXJ2ZWRUaW1lOiBEYXRlO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0V2ZW50U2VyaWVzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9FdmVudFNlcmllcyhvYmo6IEV2ZW50U2VyaWVzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnY291bnQnOiBvYmouY291bnQsXG4gICAgJ2xhc3RPYnNlcnZlZFRpbWUnOiBvYmoubGFzdE9ic2VydmVkVGltZT8udG9JU09TdHJpbmcoKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBMaW1pdFJhbmdlU3BlYyBkZWZpbmVzIGEgbWluL21heCB1c2FnZSBsaW1pdCBmb3IgcmVzb3VyY2VzIHRoYXQgbWF0Y2ggb24ga2luZC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5MaW1pdFJhbmdlU3BlY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIExpbWl0UmFuZ2VTcGVjIHtcbiAgLyoqXG4gICAqIExpbWl0cyBpcyB0aGUgbGlzdCBvZiBMaW1pdFJhbmdlSXRlbSBvYmplY3RzIHRoYXQgYXJlIGVuZm9yY2VkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5MaW1pdFJhbmdlU3BlYyNsaW1pdHNcbiAgICovXG4gIHJlYWRvbmx5IGxpbWl0czogTGltaXRSYW5nZUl0ZW1bXTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdMaW1pdFJhbmdlU3BlYycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fTGltaXRSYW5nZVNwZWMob2JqOiBMaW1pdFJhbmdlU3BlYyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2xpbWl0cyc6IG9iai5saW1pdHM/Lm1hcCh5ID0+IHRvSnNvbl9MaW1pdFJhbmdlSXRlbSh5KSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogTmFtZXNwYWNlU3BlYyBkZXNjcmliZXMgdGhlIGF0dHJpYnV0ZXMgb24gYSBOYW1lc3BhY2UuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTmFtZXNwYWNlU3BlY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIE5hbWVzcGFjZVNwZWMge1xuICAvKipcbiAgICogRmluYWxpemVycyBpcyBhbiBvcGFxdWUgbGlzdCBvZiB2YWx1ZXMgdGhhdCBtdXN0IGJlIGVtcHR5IHRvIHBlcm1hbmVudGx5IHJlbW92ZSBvYmplY3QgZnJvbSBzdG9yYWdlLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL3Rhc2tzL2FkbWluaXN0ZXItY2x1c3Rlci9uYW1lc3BhY2VzL1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5OYW1lc3BhY2VTcGVjI2ZpbmFsaXplcnNcbiAgICovXG4gIHJlYWRvbmx5IGZpbmFsaXplcnM/OiBzdHJpbmdbXTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdOYW1lc3BhY2VTcGVjJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9OYW1lc3BhY2VTcGVjKG9iajogTmFtZXNwYWNlU3BlYyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2ZpbmFsaXplcnMnOiBvYmouZmluYWxpemVycz8ubWFwKHkgPT4geSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogTm9kZVNwZWMgZGVzY3JpYmVzIHRoZSBhdHRyaWJ1dGVzIHRoYXQgYSBub2RlIGlzIGNyZWF0ZWQgd2l0aC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Ob2RlU3BlY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIE5vZGVTcGVjIHtcbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQuIElmIHNwZWNpZmllZCwgdGhlIHNvdXJjZSBvZiB0aGUgbm9kZSdzIGNvbmZpZ3VyYXRpb24uIFRoZSBEeW5hbWljS3ViZWxldENvbmZpZyBmZWF0dXJlIGdhdGUgbXVzdCBiZSBlbmFibGVkIGZvciB0aGUgS3ViZWxldCB0byB1c2UgdGhpcyBmaWVsZC4gVGhpcyBmaWVsZCBpcyBkZXByZWNhdGVkIGFzIG9mIDEuMjI6IGh0dHBzOi8vZ2l0Lms4cy5pby9lbmhhbmNlbWVudHMva2Vwcy9zaWctbm9kZS8yODEtZHluYW1pYy1rdWJlbGV0LWNvbmZpZ3VyYXRpb25cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTm9kZVNwZWMjY29uZmlnU291cmNlXG4gICAqL1xuICByZWFkb25seSBjb25maWdTb3VyY2U/OiBOb2RlQ29uZmlnU291cmNlO1xuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkLiBOb3QgYWxsIGt1YmVsZXRzIHdpbGwgc2V0IHRoaXMgZmllbGQuIFJlbW92ZSBmaWVsZCBhZnRlciAxLjEzLiBzZWU6IGh0dHBzOi8vaXNzdWVzLms4cy5pby82MTk2NlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Ob2RlU3BlYyNleHRlcm5hbElEXG4gICAqL1xuICByZWFkb25seSBleHRlcm5hbElkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBQb2RDSURSIHJlcHJlc2VudHMgdGhlIHBvZCBJUCByYW5nZSBhc3NpZ25lZCB0byB0aGUgbm9kZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTm9kZVNwZWMjcG9kQ0lEUlxuICAgKi9cbiAgcmVhZG9ubHkgcG9kQ2lkcj86IHN0cmluZztcblxuICAvKipcbiAgICogcG9kQ0lEUnMgcmVwcmVzZW50cyB0aGUgSVAgcmFuZ2VzIGFzc2lnbmVkIHRvIHRoZSBub2RlIGZvciB1c2FnZSBieSBQb2RzIG9uIHRoYXQgbm9kZS4gSWYgdGhpcyBmaWVsZCBpcyBzcGVjaWZpZWQsIHRoZSAwdGggZW50cnkgbXVzdCBtYXRjaCB0aGUgcG9kQ0lEUiBmaWVsZC4gSXQgbWF5IGNvbnRhaW4gYXQgbW9zdCAxIHZhbHVlIGZvciBlYWNoIG9mIElQdjQgYW5kIElQdjYuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLk5vZGVTcGVjI3BvZENJRFJzXG4gICAqL1xuICByZWFkb25seSBwb2RDaWRScz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBJRCBvZiB0aGUgbm9kZSBhc3NpZ25lZCBieSB0aGUgY2xvdWQgcHJvdmlkZXIgaW4gdGhlIGZvcm1hdDogPFByb3ZpZGVyTmFtZT46Ly88UHJvdmlkZXJTcGVjaWZpY05vZGVJRD5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTm9kZVNwZWMjcHJvdmlkZXJJRFxuICAgKi9cbiAgcmVhZG9ubHkgcHJvdmlkZXJJZD86IHN0cmluZztcblxuICAvKipcbiAgICogSWYgc3BlY2lmaWVkLCB0aGUgbm9kZSdzIHRhaW50cy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTm9kZVNwZWMjdGFpbnRzXG4gICAqL1xuICByZWFkb25seSB0YWludHM/OiBUYWludFtdO1xuXG4gIC8qKlxuICAgKiBVbnNjaGVkdWxhYmxlIGNvbnRyb2xzIG5vZGUgc2NoZWR1bGFiaWxpdHkgb2YgbmV3IHBvZHMuIEJ5IGRlZmF1bHQsIG5vZGUgaXMgc2NoZWR1bGFibGUuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvbm9kZXMvbm9kZS8jbWFudWFsLW5vZGUtYWRtaW5pc3RyYXRpb25cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTm9kZVNwZWMjdW5zY2hlZHVsYWJsZVxuICAgKi9cbiAgcmVhZG9ubHkgdW5zY2hlZHVsYWJsZT86IGJvb2xlYW47XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnTm9kZVNwZWMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX05vZGVTcGVjKG9iajogTm9kZVNwZWMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdjb25maWdTb3VyY2UnOiB0b0pzb25fTm9kZUNvbmZpZ1NvdXJjZShvYmouY29uZmlnU291cmNlKSxcbiAgICAnZXh0ZXJuYWxJRCc6IG9iai5leHRlcm5hbElkLFxuICAgICdwb2RDSURSJzogb2JqLnBvZENpZHIsXG4gICAgJ3BvZENJRFJzJzogb2JqLnBvZENpZFJzPy5tYXAoeSA9PiB5KSxcbiAgICAncHJvdmlkZXJJRCc6IG9iai5wcm92aWRlcklkLFxuICAgICd0YWludHMnOiBvYmoudGFpbnRzPy5tYXAoeSA9PiB0b0pzb25fVGFpbnQoeSkpLFxuICAgICd1bnNjaGVkdWxhYmxlJzogb2JqLnVuc2NoZWR1bGFibGUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUGVyc2lzdGVudFZvbHVtZVNwZWMgaXMgdGhlIHNwZWNpZmljYXRpb24gb2YgYSBwZXJzaXN0ZW50IHZvbHVtZS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lU3BlY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFBlcnNpc3RlbnRWb2x1bWVTcGVjIHtcbiAgLyoqXG4gICAqIEFjY2Vzc01vZGVzIGNvbnRhaW5zIGFsbCB3YXlzIHRoZSB2b2x1bWUgY2FuIGJlIG1vdW50ZWQuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvc3RvcmFnZS9wZXJzaXN0ZW50LXZvbHVtZXMjYWNjZXNzLW1vZGVzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVTcGVjI2FjY2Vzc01vZGVzXG4gICAqL1xuICByZWFkb25seSBhY2Nlc3NNb2Rlcz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBBV1NFbGFzdGljQmxvY2tTdG9yZSByZXByZXNlbnRzIGFuIEFXUyBEaXNrIHJlc291cmNlIHRoYXQgaXMgYXR0YWNoZWQgdG8gYSBrdWJlbGV0J3MgaG9zdCBtYWNoaW5lIGFuZCB0aGVuIGV4cG9zZWQgdG8gdGhlIHBvZC4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3ZvbHVtZXMjYXdzZWxhc3RpY2Jsb2Nrc3RvcmVcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZVNwZWMjYXdzRWxhc3RpY0Jsb2NrU3RvcmVcbiAgICovXG4gIHJlYWRvbmx5IGF3c0VsYXN0aWNCbG9ja1N0b3JlPzogQXdzRWxhc3RpY0Jsb2NrU3RvcmVWb2x1bWVTb3VyY2U7XG5cbiAgLyoqXG4gICAqIEF6dXJlRGlzayByZXByZXNlbnRzIGFuIEF6dXJlIERhdGEgRGlzayBtb3VudCBvbiB0aGUgaG9zdCBhbmQgYmluZCBtb3VudCB0byB0aGUgcG9kLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lU3BlYyNhenVyZURpc2tcbiAgICovXG4gIHJlYWRvbmx5IGF6dXJlRGlzaz86IEF6dXJlRGlza1ZvbHVtZVNvdXJjZTtcblxuICAvKipcbiAgICogQXp1cmVGaWxlIHJlcHJlc2VudHMgYW4gQXp1cmUgRmlsZSBTZXJ2aWNlIG1vdW50IG9uIHRoZSBob3N0IGFuZCBiaW5kIG1vdW50IHRvIHRoZSBwb2QuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVTcGVjI2F6dXJlRmlsZVxuICAgKi9cbiAgcmVhZG9ubHkgYXp1cmVGaWxlPzogQXp1cmVGaWxlUGVyc2lzdGVudFZvbHVtZVNvdXJjZTtcblxuICAvKipcbiAgICogQSBkZXNjcmlwdGlvbiBvZiB0aGUgcGVyc2lzdGVudCB2b2x1bWUncyByZXNvdXJjZXMgYW5kIGNhcGFjaXR5LiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2UvcGVyc2lzdGVudC12b2x1bWVzI2NhcGFjaXR5XG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVTcGVjI2NhcGFjaXR5XG4gICAqL1xuICByZWFkb25seSBjYXBhY2l0eT86IHsgW2tleTogc3RyaW5nXTogUXVhbnRpdHkgfTtcblxuICAvKipcbiAgICogQ2VwaEZTIHJlcHJlc2VudHMgYSBDZXBoIEZTIG1vdW50IG9uIHRoZSBob3N0IHRoYXQgc2hhcmVzIGEgcG9kJ3MgbGlmZXRpbWVcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZVNwZWMjY2VwaGZzXG4gICAqL1xuICByZWFkb25seSBjZXBoZnM/OiBDZXBoRnNQZXJzaXN0ZW50Vm9sdW1lU291cmNlO1xuXG4gIC8qKlxuICAgKiBDaW5kZXIgcmVwcmVzZW50cyBhIGNpbmRlciB2b2x1bWUgYXR0YWNoZWQgYW5kIG1vdW50ZWQgb24ga3ViZWxldHMgaG9zdCBtYWNoaW5lLiBNb3JlIGluZm86IGh0dHBzOi8vZXhhbXBsZXMuazhzLmlvL215c3FsLWNpbmRlci1wZC9SRUFETUUubWRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZVNwZWMjY2luZGVyXG4gICAqL1xuICByZWFkb25seSBjaW5kZXI/OiBDaW5kZXJQZXJzaXN0ZW50Vm9sdW1lU291cmNlO1xuXG4gIC8qKlxuICAgKiBDbGFpbVJlZiBpcyBwYXJ0IG9mIGEgYmktZGlyZWN0aW9uYWwgYmluZGluZyBiZXR3ZWVuIFBlcnNpc3RlbnRWb2x1bWUgYW5kIFBlcnNpc3RlbnRWb2x1bWVDbGFpbS4gRXhwZWN0ZWQgdG8gYmUgbm9uLW5pbCB3aGVuIGJvdW5kLiBjbGFpbS5Wb2x1bWVOYW1lIGlzIHRoZSBhdXRob3JpdGF0aXZlIGJpbmQgYmV0d2VlbiBQViBhbmQgUFZDLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2UvcGVyc2lzdGVudC12b2x1bWVzI2JpbmRpbmdcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZVNwZWMjY2xhaW1SZWZcbiAgICovXG4gIHJlYWRvbmx5IGNsYWltUmVmPzogT2JqZWN0UmVmZXJlbmNlO1xuXG4gIC8qKlxuICAgKiBDU0kgcmVwcmVzZW50cyBzdG9yYWdlIHRoYXQgaXMgaGFuZGxlZCBieSBhbiBleHRlcm5hbCBDU0kgZHJpdmVyIChCZXRhIGZlYXR1cmUpLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lU3BlYyNjc2lcbiAgICovXG4gIHJlYWRvbmx5IGNzaT86IENzaVBlcnNpc3RlbnRWb2x1bWVTb3VyY2U7XG5cbiAgLyoqXG4gICAqIEZDIHJlcHJlc2VudHMgYSBGaWJyZSBDaGFubmVsIHJlc291cmNlIHRoYXQgaXMgYXR0YWNoZWQgdG8gYSBrdWJlbGV0J3MgaG9zdCBtYWNoaW5lIGFuZCB0aGVuIGV4cG9zZWQgdG8gdGhlIHBvZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZVNwZWMjZmNcbiAgICovXG4gIHJlYWRvbmx5IGZjPzogRmNWb2x1bWVTb3VyY2U7XG5cbiAgLyoqXG4gICAqIEZsZXhWb2x1bWUgcmVwcmVzZW50cyBhIGdlbmVyaWMgdm9sdW1lIHJlc291cmNlIHRoYXQgaXMgcHJvdmlzaW9uZWQvYXR0YWNoZWQgdXNpbmcgYW4gZXhlYyBiYXNlZCBwbHVnaW4uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVTcGVjI2ZsZXhWb2x1bWVcbiAgICovXG4gIHJlYWRvbmx5IGZsZXhWb2x1bWU/OiBGbGV4UGVyc2lzdGVudFZvbHVtZVNvdXJjZTtcblxuICAvKipcbiAgICogRmxvY2tlciByZXByZXNlbnRzIGEgRmxvY2tlciB2b2x1bWUgYXR0YWNoZWQgdG8gYSBrdWJlbGV0J3MgaG9zdCBtYWNoaW5lIGFuZCBleHBvc2VkIHRvIHRoZSBwb2QgZm9yIGl0cyB1c2FnZS4gVGhpcyBkZXBlbmRzIG9uIHRoZSBGbG9ja2VyIGNvbnRyb2wgc2VydmljZSBiZWluZyBydW5uaW5nXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVTcGVjI2Zsb2NrZXJcbiAgICovXG4gIHJlYWRvbmx5IGZsb2NrZXI/OiBGbG9ja2VyVm9sdW1lU291cmNlO1xuXG4gIC8qKlxuICAgKiBHQ0VQZXJzaXN0ZW50RGlzayByZXByZXNlbnRzIGEgR0NFIERpc2sgcmVzb3VyY2UgdGhhdCBpcyBhdHRhY2hlZCB0byBhIGt1YmVsZXQncyBob3N0IG1hY2hpbmUgYW5kIHRoZW4gZXhwb3NlZCB0byB0aGUgcG9kLiBQcm92aXNpb25lZCBieSBhbiBhZG1pbi4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3ZvbHVtZXMjZ2NlcGVyc2lzdGVudGRpc2tcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZVNwZWMjZ2NlUGVyc2lzdGVudERpc2tcbiAgICovXG4gIHJlYWRvbmx5IGdjZVBlcnNpc3RlbnREaXNrPzogR2NlUGVyc2lzdGVudERpc2tWb2x1bWVTb3VyY2U7XG5cbiAgLyoqXG4gICAqIEdsdXN0ZXJmcyByZXByZXNlbnRzIGEgR2x1c3RlcmZzIHZvbHVtZSB0aGF0IGlzIGF0dGFjaGVkIHRvIGEgaG9zdCBhbmQgZXhwb3NlZCB0byB0aGUgcG9kLiBQcm92aXNpb25lZCBieSBhbiBhZG1pbi4gTW9yZSBpbmZvOiBodHRwczovL2V4YW1wbGVzLms4cy5pby92b2x1bWVzL2dsdXN0ZXJmcy9SRUFETUUubWRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZVNwZWMjZ2x1c3RlcmZzXG4gICAqL1xuICByZWFkb25seSBnbHVzdGVyZnM/OiBHbHVzdGVyZnNQZXJzaXN0ZW50Vm9sdW1lU291cmNlO1xuXG4gIC8qKlxuICAgKiBIb3N0UGF0aCByZXByZXNlbnRzIGEgZGlyZWN0b3J5IG9uIHRoZSBob3N0LiBQcm92aXNpb25lZCBieSBhIGRldmVsb3BlciBvciB0ZXN0ZXIuIFRoaXMgaXMgdXNlZnVsIGZvciBzaW5nbGUtbm9kZSBkZXZlbG9wbWVudCBhbmQgdGVzdGluZyBvbmx5ISBPbi1ob3N0IHN0b3JhZ2UgaXMgbm90IHN1cHBvcnRlZCBpbiBhbnkgd2F5IGFuZCBXSUxMIE5PVCBXT1JLIGluIGEgbXVsdGktbm9kZSBjbHVzdGVyLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2Uvdm9sdW1lcyNob3N0cGF0aFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lU3BlYyNob3N0UGF0aFxuICAgKi9cbiAgcmVhZG9ubHkgaG9zdFBhdGg/OiBIb3N0UGF0aFZvbHVtZVNvdXJjZTtcblxuICAvKipcbiAgICogSVNDU0kgcmVwcmVzZW50cyBhbiBJU0NTSSBEaXNrIHJlc291cmNlIHRoYXQgaXMgYXR0YWNoZWQgdG8gYSBrdWJlbGV0J3MgaG9zdCBtYWNoaW5lIGFuZCB0aGVuIGV4cG9zZWQgdG8gdGhlIHBvZC4gUHJvdmlzaW9uZWQgYnkgYW4gYWRtaW4uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVTcGVjI2lzY3NpXG4gICAqL1xuICByZWFkb25seSBpc2NzaT86IElzY3NpUGVyc2lzdGVudFZvbHVtZVNvdXJjZTtcblxuICAvKipcbiAgICogTG9jYWwgcmVwcmVzZW50cyBkaXJlY3RseS1hdHRhY2hlZCBzdG9yYWdlIHdpdGggbm9kZSBhZmZpbml0eVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lU3BlYyNsb2NhbFxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYWw/OiBMb2NhbFZvbHVtZVNvdXJjZTtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIG1vdW50IG9wdGlvbnMsIGUuZy4gW1wicm9cIiwgXCJzb2Z0XCJdLiBOb3QgdmFsaWRhdGVkIC0gbW91bnQgd2lsbCBzaW1wbHkgZmFpbCBpZiBvbmUgaXMgaW52YWxpZC4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3BlcnNpc3RlbnQtdm9sdW1lcy8jbW91bnQtb3B0aW9uc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lU3BlYyNtb3VudE9wdGlvbnNcbiAgICovXG4gIHJlYWRvbmx5IG1vdW50T3B0aW9ucz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBORlMgcmVwcmVzZW50cyBhbiBORlMgbW91bnQgb24gdGhlIGhvc3QuIFByb3Zpc2lvbmVkIGJ5IGFuIGFkbWluLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2Uvdm9sdW1lcyNuZnNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZVNwZWMjbmZzXG4gICAqL1xuICByZWFkb25seSBuZnM/OiBOZnNWb2x1bWVTb3VyY2U7XG5cbiAgLyoqXG4gICAqIE5vZGVBZmZpbml0eSBkZWZpbmVzIGNvbnN0cmFpbnRzIHRoYXQgbGltaXQgd2hhdCBub2RlcyB0aGlzIHZvbHVtZSBjYW4gYmUgYWNjZXNzZWQgZnJvbS4gVGhpcyBmaWVsZCBpbmZsdWVuY2VzIHRoZSBzY2hlZHVsaW5nIG9mIHBvZHMgdGhhdCB1c2UgdGhpcyB2b2x1bWUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVTcGVjI25vZGVBZmZpbml0eVxuICAgKi9cbiAgcmVhZG9ubHkgbm9kZUFmZmluaXR5PzogVm9sdW1lTm9kZUFmZmluaXR5O1xuXG4gIC8qKlxuICAgKiBXaGF0IGhhcHBlbnMgdG8gYSBwZXJzaXN0ZW50IHZvbHVtZSB3aGVuIHJlbGVhc2VkIGZyb20gaXRzIGNsYWltLiBWYWxpZCBvcHRpb25zIGFyZSBSZXRhaW4gKGRlZmF1bHQgZm9yIG1hbnVhbGx5IGNyZWF0ZWQgUGVyc2lzdGVudFZvbHVtZXMpLCBEZWxldGUgKGRlZmF1bHQgZm9yIGR5bmFtaWNhbGx5IHByb3Zpc2lvbmVkIFBlcnNpc3RlbnRWb2x1bWVzKSwgYW5kIFJlY3ljbGUgKGRlcHJlY2F0ZWQpLiBSZWN5Y2xlIG11c3QgYmUgc3VwcG9ydGVkIGJ5IHRoZSB2b2x1bWUgcGx1Z2luIHVuZGVybHlpbmcgdGhpcyBQZXJzaXN0ZW50Vm9sdW1lLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2UvcGVyc2lzdGVudC12b2x1bWVzI3JlY2xhaW1pbmdcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZVNwZWMjcGVyc2lzdGVudFZvbHVtZVJlY2xhaW1Qb2xpY3lcbiAgICovXG4gIHJlYWRvbmx5IHBlcnNpc3RlbnRWb2x1bWVSZWNsYWltUG9saWN5Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBQaG90b25QZXJzaXN0ZW50RGlzayByZXByZXNlbnRzIGEgUGhvdG9uQ29udHJvbGxlciBwZXJzaXN0ZW50IGRpc2sgYXR0YWNoZWQgYW5kIG1vdW50ZWQgb24ga3ViZWxldHMgaG9zdCBtYWNoaW5lXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVTcGVjI3Bob3RvblBlcnNpc3RlbnREaXNrXG4gICAqL1xuICByZWFkb25seSBwaG90b25QZXJzaXN0ZW50RGlzaz86IFBob3RvblBlcnNpc3RlbnREaXNrVm9sdW1lU291cmNlO1xuXG4gIC8qKlxuICAgKiBQb3J0d29yeFZvbHVtZSByZXByZXNlbnRzIGEgcG9ydHdvcnggdm9sdW1lIGF0dGFjaGVkIGFuZCBtb3VudGVkIG9uIGt1YmVsZXRzIGhvc3QgbWFjaGluZVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lU3BlYyNwb3J0d29yeFZvbHVtZVxuICAgKi9cbiAgcmVhZG9ubHkgcG9ydHdvcnhWb2x1bWU/OiBQb3J0d29yeFZvbHVtZVNvdXJjZTtcblxuICAvKipcbiAgICogUXVvYnl0ZSByZXByZXNlbnRzIGEgUXVvYnl0ZSBtb3VudCBvbiB0aGUgaG9zdCB0aGF0IHNoYXJlcyBhIHBvZCdzIGxpZmV0aW1lXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVTcGVjI3F1b2J5dGVcbiAgICovXG4gIHJlYWRvbmx5IHF1b2J5dGU/OiBRdW9ieXRlVm9sdW1lU291cmNlO1xuXG4gIC8qKlxuICAgKiBSQkQgcmVwcmVzZW50cyBhIFJhZG9zIEJsb2NrIERldmljZSBtb3VudCBvbiB0aGUgaG9zdCB0aGF0IHNoYXJlcyBhIHBvZCdzIGxpZmV0aW1lLiBNb3JlIGluZm86IGh0dHBzOi8vZXhhbXBsZXMuazhzLmlvL3ZvbHVtZXMvcmJkL1JFQURNRS5tZFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lU3BlYyNyYmRcbiAgICovXG4gIHJlYWRvbmx5IHJiZD86IFJiZFBlcnNpc3RlbnRWb2x1bWVTb3VyY2U7XG5cbiAgLyoqXG4gICAqIFNjYWxlSU8gcmVwcmVzZW50cyBhIFNjYWxlSU8gcGVyc2lzdGVudCB2b2x1bWUgYXR0YWNoZWQgYW5kIG1vdW50ZWQgb24gS3ViZXJuZXRlcyBub2Rlcy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZVNwZWMjc2NhbGVJT1xuICAgKi9cbiAgcmVhZG9ubHkgc2NhbGVJbz86IFNjYWxlSW9QZXJzaXN0ZW50Vm9sdW1lU291cmNlO1xuXG4gIC8qKlxuICAgKiBOYW1lIG9mIFN0b3JhZ2VDbGFzcyB0byB3aGljaCB0aGlzIHBlcnNpc3RlbnQgdm9sdW1lIGJlbG9uZ3MuIEVtcHR5IHZhbHVlIG1lYW5zIHRoYXQgdGhpcyB2b2x1bWUgZG9lcyBub3QgYmVsb25nIHRvIGFueSBTdG9yYWdlQ2xhc3MuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVTcGVjI3N0b3JhZ2VDbGFzc05hbWVcbiAgICovXG4gIHJlYWRvbmx5IHN0b3JhZ2VDbGFzc05hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFN0b3JhZ2VPUyByZXByZXNlbnRzIGEgU3RvcmFnZU9TIHZvbHVtZSB0aGF0IGlzIGF0dGFjaGVkIHRvIHRoZSBrdWJlbGV0J3MgaG9zdCBtYWNoaW5lIGFuZCBtb3VudGVkIGludG8gdGhlIHBvZCBNb3JlIGluZm86IGh0dHBzOi8vZXhhbXBsZXMuazhzLmlvL3ZvbHVtZXMvc3RvcmFnZW9zL1JFQURNRS5tZFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lU3BlYyNzdG9yYWdlb3NcbiAgICovXG4gIHJlYWRvbmx5IHN0b3JhZ2Vvcz86IFN0b3JhZ2VPc1BlcnNpc3RlbnRWb2x1bWVTb3VyY2U7XG5cbiAgLyoqXG4gICAqIHZvbHVtZU1vZGUgZGVmaW5lcyBpZiBhIHZvbHVtZSBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIHdpdGggYSBmb3JtYXR0ZWQgZmlsZXN5c3RlbSBvciB0byByZW1haW4gaW4gcmF3IGJsb2NrIHN0YXRlLiBWYWx1ZSBvZiBGaWxlc3lzdGVtIGlzIGltcGxpZWQgd2hlbiBub3QgaW5jbHVkZWQgaW4gc3BlYy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZVNwZWMjdm9sdW1lTW9kZVxuICAgKi9cbiAgcmVhZG9ubHkgdm9sdW1lTW9kZT86IHN0cmluZztcblxuICAvKipcbiAgICogVnNwaGVyZVZvbHVtZSByZXByZXNlbnRzIGEgdlNwaGVyZSB2b2x1bWUgYXR0YWNoZWQgYW5kIG1vdW50ZWQgb24ga3ViZWxldHMgaG9zdCBtYWNoaW5lXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVTcGVjI3ZzcGhlcmVWb2x1bWVcbiAgICovXG4gIHJlYWRvbmx5IHZzcGhlcmVWb2x1bWU/OiBWc3BoZXJlVmlydHVhbERpc2tWb2x1bWVTb3VyY2U7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnUGVyc2lzdGVudFZvbHVtZVNwZWMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1BlcnNpc3RlbnRWb2x1bWVTcGVjKG9iajogUGVyc2lzdGVudFZvbHVtZVNwZWMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdhY2Nlc3NNb2Rlcyc6IG9iai5hY2Nlc3NNb2Rlcz8ubWFwKHkgPT4geSksXG4gICAgJ2F3c0VsYXN0aWNCbG9ja1N0b3JlJzogdG9Kc29uX0F3c0VsYXN0aWNCbG9ja1N0b3JlVm9sdW1lU291cmNlKG9iai5hd3NFbGFzdGljQmxvY2tTdG9yZSksXG4gICAgJ2F6dXJlRGlzayc6IHRvSnNvbl9BenVyZURpc2tWb2x1bWVTb3VyY2Uob2JqLmF6dXJlRGlzayksXG4gICAgJ2F6dXJlRmlsZSc6IHRvSnNvbl9BenVyZUZpbGVQZXJzaXN0ZW50Vm9sdW1lU291cmNlKG9iai5henVyZUZpbGUpLFxuICAgICdjYXBhY2l0eSc6ICgob2JqLmNhcGFjaXR5KSA9PT0gdW5kZWZpbmVkKSA/IHVuZGVmaW5lZCA6IChPYmplY3QuZW50cmllcyhvYmouY2FwYWNpdHkpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdPy52YWx1ZSB9KSwge30pKSxcbiAgICAnY2VwaGZzJzogdG9Kc29uX0NlcGhGc1BlcnNpc3RlbnRWb2x1bWVTb3VyY2Uob2JqLmNlcGhmcyksXG4gICAgJ2NpbmRlcic6IHRvSnNvbl9DaW5kZXJQZXJzaXN0ZW50Vm9sdW1lU291cmNlKG9iai5jaW5kZXIpLFxuICAgICdjbGFpbVJlZic6IHRvSnNvbl9PYmplY3RSZWZlcmVuY2Uob2JqLmNsYWltUmVmKSxcbiAgICAnY3NpJzogdG9Kc29uX0NzaVBlcnNpc3RlbnRWb2x1bWVTb3VyY2Uob2JqLmNzaSksXG4gICAgJ2ZjJzogdG9Kc29uX0ZjVm9sdW1lU291cmNlKG9iai5mYyksXG4gICAgJ2ZsZXhWb2x1bWUnOiB0b0pzb25fRmxleFBlcnNpc3RlbnRWb2x1bWVTb3VyY2Uob2JqLmZsZXhWb2x1bWUpLFxuICAgICdmbG9ja2VyJzogdG9Kc29uX0Zsb2NrZXJWb2x1bWVTb3VyY2Uob2JqLmZsb2NrZXIpLFxuICAgICdnY2VQZXJzaXN0ZW50RGlzayc6IHRvSnNvbl9HY2VQZXJzaXN0ZW50RGlza1ZvbHVtZVNvdXJjZShvYmouZ2NlUGVyc2lzdGVudERpc2spLFxuICAgICdnbHVzdGVyZnMnOiB0b0pzb25fR2x1c3RlcmZzUGVyc2lzdGVudFZvbHVtZVNvdXJjZShvYmouZ2x1c3RlcmZzKSxcbiAgICAnaG9zdFBhdGgnOiB0b0pzb25fSG9zdFBhdGhWb2x1bWVTb3VyY2Uob2JqLmhvc3RQYXRoKSxcbiAgICAnaXNjc2knOiB0b0pzb25fSXNjc2lQZXJzaXN0ZW50Vm9sdW1lU291cmNlKG9iai5pc2NzaSksXG4gICAgJ2xvY2FsJzogdG9Kc29uX0xvY2FsVm9sdW1lU291cmNlKG9iai5sb2NhbCksXG4gICAgJ21vdW50T3B0aW9ucyc6IG9iai5tb3VudE9wdGlvbnM/Lm1hcCh5ID0+IHkpLFxuICAgICduZnMnOiB0b0pzb25fTmZzVm9sdW1lU291cmNlKG9iai5uZnMpLFxuICAgICdub2RlQWZmaW5pdHknOiB0b0pzb25fVm9sdW1lTm9kZUFmZmluaXR5KG9iai5ub2RlQWZmaW5pdHkpLFxuICAgICdwZXJzaXN0ZW50Vm9sdW1lUmVjbGFpbVBvbGljeSc6IG9iai5wZXJzaXN0ZW50Vm9sdW1lUmVjbGFpbVBvbGljeSxcbiAgICAncGhvdG9uUGVyc2lzdGVudERpc2snOiB0b0pzb25fUGhvdG9uUGVyc2lzdGVudERpc2tWb2x1bWVTb3VyY2Uob2JqLnBob3RvblBlcnNpc3RlbnREaXNrKSxcbiAgICAncG9ydHdvcnhWb2x1bWUnOiB0b0pzb25fUG9ydHdvcnhWb2x1bWVTb3VyY2Uob2JqLnBvcnR3b3J4Vm9sdW1lKSxcbiAgICAncXVvYnl0ZSc6IHRvSnNvbl9RdW9ieXRlVm9sdW1lU291cmNlKG9iai5xdW9ieXRlKSxcbiAgICAncmJkJzogdG9Kc29uX1JiZFBlcnNpc3RlbnRWb2x1bWVTb3VyY2Uob2JqLnJiZCksXG4gICAgJ3NjYWxlSU8nOiB0b0pzb25fU2NhbGVJb1BlcnNpc3RlbnRWb2x1bWVTb3VyY2Uob2JqLnNjYWxlSW8pLFxuICAgICdzdG9yYWdlQ2xhc3NOYW1lJzogb2JqLnN0b3JhZ2VDbGFzc05hbWUsXG4gICAgJ3N0b3JhZ2Vvcyc6IHRvSnNvbl9TdG9yYWdlT3NQZXJzaXN0ZW50Vm9sdW1lU291cmNlKG9iai5zdG9yYWdlb3MpLFxuICAgICd2b2x1bWVNb2RlJzogb2JqLnZvbHVtZU1vZGUsXG4gICAgJ3ZzcGhlcmVWb2x1bWUnOiB0b0pzb25fVnNwaGVyZVZpcnR1YWxEaXNrVm9sdW1lU291cmNlKG9iai52c3BoZXJlVm9sdW1lKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBQZXJzaXN0ZW50Vm9sdW1lQ2xhaW1TcGVjIGRlc2NyaWJlcyB0aGUgY29tbW9uIGF0dHJpYnV0ZXMgb2Ygc3RvcmFnZSBkZXZpY2VzIGFuZCBhbGxvd3MgYSBTb3VyY2UgZm9yIHByb3ZpZGVyLXNwZWNpZmljIGF0dHJpYnV0ZXNcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lQ2xhaW1TcGVjXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGVyc2lzdGVudFZvbHVtZUNsYWltU3BlYyB7XG4gIC8qKlxuICAgKiBBY2Nlc3NNb2RlcyBjb250YWlucyB0aGUgZGVzaXJlZCBhY2Nlc3MgbW9kZXMgdGhlIHZvbHVtZSBzaG91bGQgaGF2ZS4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3BlcnNpc3RlbnQtdm9sdW1lcyNhY2Nlc3MtbW9kZXMtMVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lQ2xhaW1TcGVjI2FjY2Vzc01vZGVzXG4gICAqL1xuICByZWFkb25seSBhY2Nlc3NNb2Rlcz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZpZWxkIGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgZWl0aGVyOiAqIEFuIGV4aXN0aW5nIFZvbHVtZVNuYXBzaG90IG9iamVjdCAoc25hcHNob3Quc3RvcmFnZS5rOHMuaW8vVm9sdW1lU25hcHNob3QpICogQW4gZXhpc3RpbmcgUFZDIChQZXJzaXN0ZW50Vm9sdW1lQ2xhaW0pIElmIHRoZSBwcm92aXNpb25lciBvciBhbiBleHRlcm5hbCBjb250cm9sbGVyIGNhbiBzdXBwb3J0IHRoZSBzcGVjaWZpZWQgZGF0YSBzb3VyY2UsIGl0IHdpbGwgY3JlYXRlIGEgbmV3IHZvbHVtZSBiYXNlZCBvbiB0aGUgY29udGVudHMgb2YgdGhlIHNwZWNpZmllZCBkYXRhIHNvdXJjZS4gSWYgdGhlIEFueVZvbHVtZURhdGFTb3VyY2UgZmVhdHVyZSBnYXRlIGlzIGVuYWJsZWQsIHRoaXMgZmllbGQgd2lsbCBhbHdheXMgaGF2ZSB0aGUgc2FtZSBjb250ZW50cyBhcyB0aGUgRGF0YVNvdXJjZVJlZiBmaWVsZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZUNsYWltU3BlYyNkYXRhU291cmNlXG4gICAqL1xuICByZWFkb25seSBkYXRhU291cmNlPzogVHlwZWRMb2NhbE9iamVjdFJlZmVyZW5jZTtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBvYmplY3QgZnJvbSB3aGljaCB0byBwb3B1bGF0ZSB0aGUgdm9sdW1lIHdpdGggZGF0YSwgaWYgYSBub24tZW1wdHkgdm9sdW1lIGlzIGRlc2lyZWQuIFRoaXMgbWF5IGJlIGFueSBsb2NhbCBvYmplY3QgZnJvbSBhIG5vbi1lbXB0eSBBUEkgZ3JvdXAgKG5vbiBjb3JlIG9iamVjdCkgb3IgYSBQZXJzaXN0ZW50Vm9sdW1lQ2xhaW0gb2JqZWN0LiBXaGVuIHRoaXMgZmllbGQgaXMgc3BlY2lmaWVkLCB2b2x1bWUgYmluZGluZyB3aWxsIG9ubHkgc3VjY2VlZCBpZiB0aGUgdHlwZSBvZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBtYXRjaGVzIHNvbWUgaW5zdGFsbGVkIHZvbHVtZSBwb3B1bGF0b3Igb3IgZHluYW1pYyBwcm92aXNpb25lci4gVGhpcyBmaWVsZCB3aWxsIHJlcGxhY2UgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIERhdGFTb3VyY2UgZmllbGQgYW5kIGFzIHN1Y2ggaWYgYm90aCBmaWVsZHMgYXJlIG5vbi1lbXB0eSwgdGhleSBtdXN0IGhhdmUgdGhlIHNhbWUgdmFsdWUuIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYm90aCBmaWVsZHMgKERhdGFTb3VyY2UgYW5kIERhdGFTb3VyY2VSZWYpIHdpbGwgYmUgc2V0IHRvIHRoZSBzYW1lIHZhbHVlIGF1dG9tYXRpY2FsbHkgaWYgb25lIG9mIHRoZW0gaXMgZW1wdHkgYW5kIHRoZSBvdGhlciBpcyBub24tZW1wdHkuIFRoZXJlIGFyZSB0d28gaW1wb3J0YW50IGRpZmZlcmVuY2VzIGJldHdlZW4gRGF0YVNvdXJjZSBhbmQgRGF0YVNvdXJjZVJlZjogKiBXaGlsZSBEYXRhU291cmNlIG9ubHkgYWxsb3dzIHR3byBzcGVjaWZpYyB0eXBlcyBvZiBvYmplY3RzLCBEYXRhU291cmNlUmVmXG4gICAqIGFsbG93cyBhbnkgbm9uLWNvcmUgb2JqZWN0LCBhcyB3ZWxsIGFzIFBlcnNpc3RlbnRWb2x1bWVDbGFpbSBvYmplY3RzLlxuICAgKiAqIFdoaWxlIERhdGFTb3VyY2UgaWdub3JlcyBkaXNhbGxvd2VkIHZhbHVlcyAoZHJvcHBpbmcgdGhlbSksIERhdGFTb3VyY2VSZWZcbiAgICogcHJlc2VydmVzIGFsbCB2YWx1ZXMsIGFuZCBnZW5lcmF0ZXMgYW4gZXJyb3IgaWYgYSBkaXNhbGxvd2VkIHZhbHVlIGlzXG4gICAqIHNwZWNpZmllZC5cbiAgICogKEFscGhhKSBVc2luZyB0aGlzIGZpZWxkIHJlcXVpcmVzIHRoZSBBbnlWb2x1bWVEYXRhU291cmNlIGZlYXR1cmUgZ2F0ZSB0byBiZSBlbmFibGVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lQ2xhaW1TcGVjI2RhdGFTb3VyY2VSZWZcbiAgICovXG4gIHJlYWRvbmx5IGRhdGFTb3VyY2VSZWY/OiBUeXBlZExvY2FsT2JqZWN0UmVmZXJlbmNlO1xuXG4gIC8qKlxuICAgKiBSZXNvdXJjZXMgcmVwcmVzZW50cyB0aGUgbWluaW11bSByZXNvdXJjZXMgdGhlIHZvbHVtZSBzaG91bGQgaGF2ZS4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3BlcnNpc3RlbnQtdm9sdW1lcyNyZXNvdXJjZXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZUNsYWltU3BlYyNyZXNvdXJjZXNcbiAgICovXG4gIHJlYWRvbmx5IHJlc291cmNlcz86IFJlc291cmNlUmVxdWlyZW1lbnRzO1xuXG4gIC8qKlxuICAgKiBBIGxhYmVsIHF1ZXJ5IG92ZXIgdm9sdW1lcyB0byBjb25zaWRlciBmb3IgYmluZGluZy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZUNsYWltU3BlYyNzZWxlY3RvclxuICAgKi9cbiAgcmVhZG9ubHkgc2VsZWN0b3I/OiBMYWJlbFNlbGVjdG9yO1xuXG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBTdG9yYWdlQ2xhc3MgcmVxdWlyZWQgYnkgdGhlIGNsYWltLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2UvcGVyc2lzdGVudC12b2x1bWVzI2NsYXNzLTFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZUNsYWltU3BlYyNzdG9yYWdlQ2xhc3NOYW1lXG4gICAqL1xuICByZWFkb25seSBzdG9yYWdlQ2xhc3NOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiB2b2x1bWVNb2RlIGRlZmluZXMgd2hhdCB0eXBlIG9mIHZvbHVtZSBpcyByZXF1aXJlZCBieSB0aGUgY2xhaW0uIFZhbHVlIG9mIEZpbGVzeXN0ZW0gaXMgaW1wbGllZCB3aGVuIG5vdCBpbmNsdWRlZCBpbiBjbGFpbSBzcGVjLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lQ2xhaW1TcGVjI3ZvbHVtZU1vZGVcbiAgICovXG4gIHJlYWRvbmx5IHZvbHVtZU1vZGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFZvbHVtZU5hbWUgaXMgdGhlIGJpbmRpbmcgcmVmZXJlbmNlIHRvIHRoZSBQZXJzaXN0ZW50Vm9sdW1lIGJhY2tpbmcgdGhpcyBjbGFpbS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZUNsYWltU3BlYyN2b2x1bWVOYW1lXG4gICAqL1xuICByZWFkb25seSB2b2x1bWVOYW1lPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1BlcnNpc3RlbnRWb2x1bWVDbGFpbVNwZWMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1BlcnNpc3RlbnRWb2x1bWVDbGFpbVNwZWMob2JqOiBQZXJzaXN0ZW50Vm9sdW1lQ2xhaW1TcGVjIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnYWNjZXNzTW9kZXMnOiBvYmouYWNjZXNzTW9kZXM/Lm1hcCh5ID0+IHkpLFxuICAgICdkYXRhU291cmNlJzogdG9Kc29uX1R5cGVkTG9jYWxPYmplY3RSZWZlcmVuY2Uob2JqLmRhdGFTb3VyY2UpLFxuICAgICdkYXRhU291cmNlUmVmJzogdG9Kc29uX1R5cGVkTG9jYWxPYmplY3RSZWZlcmVuY2Uob2JqLmRhdGFTb3VyY2VSZWYpLFxuICAgICdyZXNvdXJjZXMnOiB0b0pzb25fUmVzb3VyY2VSZXF1aXJlbWVudHMob2JqLnJlc291cmNlcyksXG4gICAgJ3NlbGVjdG9yJzogdG9Kc29uX0xhYmVsU2VsZWN0b3Iob2JqLnNlbGVjdG9yKSxcbiAgICAnc3RvcmFnZUNsYXNzTmFtZSc6IG9iai5zdG9yYWdlQ2xhc3NOYW1lLFxuICAgICd2b2x1bWVNb2RlJzogb2JqLnZvbHVtZU1vZGUsXG4gICAgJ3ZvbHVtZU5hbWUnOiBvYmoudm9sdW1lTmFtZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBQb2RTcGVjIGlzIGEgZGVzY3JpcHRpb24gb2YgYSBwb2QuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kU3BlY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFBvZFNwZWMge1xuICAvKipcbiAgICogT3B0aW9uYWwgZHVyYXRpb24gaW4gc2Vjb25kcyB0aGUgcG9kIG1heSBiZSBhY3RpdmUgb24gdGhlIG5vZGUgcmVsYXRpdmUgdG8gU3RhcnRUaW1lIGJlZm9yZSB0aGUgc3lzdGVtIHdpbGwgYWN0aXZlbHkgdHJ5IHRvIG1hcmsgaXQgZmFpbGVkIGFuZCBraWxsIGFzc29jaWF0ZWQgY29udGFpbmVycy4gVmFsdWUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZFNwZWMjYWN0aXZlRGVhZGxpbmVTZWNvbmRzXG4gICAqL1xuICByZWFkb25seSBhY3RpdmVEZWFkbGluZVNlY29uZHM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIElmIHNwZWNpZmllZCwgdGhlIHBvZCdzIHNjaGVkdWxpbmcgY29uc3RyYWludHNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kU3BlYyNhZmZpbml0eVxuICAgKi9cbiAgcmVhZG9ubHkgYWZmaW5pdHk/OiBBZmZpbml0eTtcblxuICAvKipcbiAgICogQXV0b21vdW50U2VydmljZUFjY291bnRUb2tlbiBpbmRpY2F0ZXMgd2hldGhlciBhIHNlcnZpY2UgYWNjb3VudCB0b2tlbiBzaG91bGQgYmUgYXV0b21hdGljYWxseSBtb3VudGVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RTcGVjI2F1dG9tb3VudFNlcnZpY2VBY2NvdW50VG9rZW5cbiAgICovXG4gIHJlYWRvbmx5IGF1dG9tb3VudFNlcnZpY2VBY2NvdW50VG9rZW4/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGNvbnRhaW5lcnMgYmVsb25naW5nIHRvIHRoZSBwb2QuIENvbnRhaW5lcnMgY2Fubm90IGN1cnJlbnRseSBiZSBhZGRlZCBvciByZW1vdmVkLiBUaGVyZSBtdXN0IGJlIGF0IGxlYXN0IG9uZSBjb250YWluZXIgaW4gYSBQb2QuIENhbm5vdCBiZSB1cGRhdGVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RTcGVjI2NvbnRhaW5lcnNcbiAgICovXG4gIHJlYWRvbmx5IGNvbnRhaW5lcnM6IENvbnRhaW5lcltdO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIEROUyBwYXJhbWV0ZXJzIG9mIGEgcG9kLiBQYXJhbWV0ZXJzIHNwZWNpZmllZCBoZXJlIHdpbGwgYmUgbWVyZ2VkIHRvIHRoZSBnZW5lcmF0ZWQgRE5TIGNvbmZpZ3VyYXRpb24gYmFzZWQgb24gRE5TUG9saWN5LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RTcGVjI2Ruc0NvbmZpZ1xuICAgKi9cbiAgcmVhZG9ubHkgZG5zQ29uZmlnPzogUG9kRG5zQ29uZmlnO1xuXG4gIC8qKlxuICAgKiBTZXQgRE5TIHBvbGljeSBmb3IgdGhlIHBvZC4gRGVmYXVsdHMgdG8gXCJDbHVzdGVyRmlyc3RcIi4gVmFsaWQgdmFsdWVzIGFyZSAnQ2x1c3RlckZpcnN0V2l0aEhvc3ROZXQnLCAnQ2x1c3RlckZpcnN0JywgJ0RlZmF1bHQnIG9yICdOb25lJy4gRE5TIHBhcmFtZXRlcnMgZ2l2ZW4gaW4gRE5TQ29uZmlnIHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlIHBvbGljeSBzZWxlY3RlZCB3aXRoIEROU1BvbGljeS4gVG8gaGF2ZSBETlMgb3B0aW9ucyBzZXQgYWxvbmcgd2l0aCBob3N0TmV0d29yaywgeW91IGhhdmUgdG8gc3BlY2lmeSBETlMgcG9saWN5IGV4cGxpY2l0bHkgdG8gJ0NsdXN0ZXJGaXJzdFdpdGhIb3N0TmV0Jy5cbiAgICpcbiAgICogQGRlZmF1bHQgQ2x1c3RlckZpcnN0XCIuIFZhbGlkIHZhbHVlcyBhcmUgJ0NsdXN0ZXJGaXJzdFdpdGhIb3N0TmV0JywgJ0NsdXN0ZXJGaXJzdCcsICdEZWZhdWx0JyBvciAnTm9uZScuIEROUyBwYXJhbWV0ZXJzIGdpdmVuIGluIEROU0NvbmZpZyB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZSBwb2xpY3kgc2VsZWN0ZWQgd2l0aCBETlNQb2xpY3kuIFRvIGhhdmUgRE5TIG9wdGlvbnMgc2V0IGFsb25nIHdpdGggaG9zdE5ldHdvcmssIHlvdSBoYXZlIHRvIHNwZWNpZnkgRE5TIHBvbGljeSBleHBsaWNpdGx5IHRvICdDbHVzdGVyRmlyc3RXaXRoSG9zdE5ldCcuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZFNwZWMjZG5zUG9saWN5XG4gICAqL1xuICByZWFkb25seSBkbnNQb2xpY3k/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEVuYWJsZVNlcnZpY2VMaW5rcyBpbmRpY2F0ZXMgd2hldGhlciBpbmZvcm1hdGlvbiBhYm91dCBzZXJ2aWNlcyBzaG91bGQgYmUgaW5qZWN0ZWQgaW50byBwb2QncyBlbnZpcm9ubWVudCB2YXJpYWJsZXMsIG1hdGNoaW5nIHRoZSBzeW50YXggb2YgRG9ja2VyIGxpbmtzLiBPcHRpb25hbDogRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZS5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kU3BlYyNlbmFibGVTZXJ2aWNlTGlua3NcbiAgICovXG4gIHJlYWRvbmx5IGVuYWJsZVNlcnZpY2VMaW5rcz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgZXBoZW1lcmFsIGNvbnRhaW5lcnMgcnVuIGluIHRoaXMgcG9kLiBFcGhlbWVyYWwgY29udGFpbmVycyBtYXkgYmUgcnVuIGluIGFuIGV4aXN0aW5nIHBvZCB0byBwZXJmb3JtIHVzZXItaW5pdGlhdGVkIGFjdGlvbnMgc3VjaCBhcyBkZWJ1Z2dpbmcuIFRoaXMgbGlzdCBjYW5ub3QgYmUgc3BlY2lmaWVkIHdoZW4gY3JlYXRpbmcgYSBwb2QsIGFuZCBpdCBjYW5ub3QgYmUgbW9kaWZpZWQgYnkgdXBkYXRpbmcgdGhlIHBvZCBzcGVjLiBJbiBvcmRlciB0byBhZGQgYW4gZXBoZW1lcmFsIGNvbnRhaW5lciB0byBhbiBleGlzdGluZyBwb2QsIHVzZSB0aGUgcG9kJ3MgZXBoZW1lcmFsY29udGFpbmVycyBzdWJyZXNvdXJjZS4gVGhpcyBmaWVsZCBpcyBhbHBoYS1sZXZlbCBhbmQgaXMgb25seSBob25vcmVkIGJ5IHNlcnZlcnMgdGhhdCBlbmFibGUgdGhlIEVwaGVtZXJhbENvbnRhaW5lcnMgZmVhdHVyZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kU3BlYyNlcGhlbWVyYWxDb250YWluZXJzXG4gICAqL1xuICByZWFkb25seSBlcGhlbWVyYWxDb250YWluZXJzPzogRXBoZW1lcmFsQ29udGFpbmVyW107XG5cbiAgLyoqXG4gICAqIEhvc3RBbGlhc2VzIGlzIGFuIG9wdGlvbmFsIGxpc3Qgb2YgaG9zdHMgYW5kIElQcyB0aGF0IHdpbGwgYmUgaW5qZWN0ZWQgaW50byB0aGUgcG9kJ3MgaG9zdHMgZmlsZSBpZiBzcGVjaWZpZWQuIFRoaXMgaXMgb25seSB2YWxpZCBmb3Igbm9uLWhvc3ROZXR3b3JrIHBvZHMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZFNwZWMjaG9zdEFsaWFzZXNcbiAgICovXG4gIHJlYWRvbmx5IGhvc3RBbGlhc2VzPzogSG9zdEFsaWFzW107XG5cbiAgLyoqXG4gICAqIFVzZSB0aGUgaG9zdCdzIGlwYyBuYW1lc3BhY2UuIE9wdGlvbmFsOiBEZWZhdWx0IHRvIGZhbHNlLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZS5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kU3BlYyNob3N0SVBDXG4gICAqL1xuICByZWFkb25seSBob3N0SXBjPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSG9zdCBuZXR3b3JraW5nIHJlcXVlc3RlZCBmb3IgdGhpcyBwb2QuIFVzZSB0aGUgaG9zdCdzIG5ldHdvcmsgbmFtZXNwYWNlLiBJZiB0aGlzIG9wdGlvbiBpcyBzZXQsIHRoZSBwb3J0cyB0aGF0IHdpbGwgYmUgdXNlZCBtdXN0IGJlIHNwZWNpZmllZC4gRGVmYXVsdCB0byBmYWxzZS5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2UuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZFNwZWMjaG9zdE5ldHdvcmtcbiAgICovXG4gIHJlYWRvbmx5IGhvc3ROZXR3b3JrPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogVXNlIHRoZSBob3N0J3MgcGlkIG5hbWVzcGFjZS4gT3B0aW9uYWw6IERlZmF1bHQgdG8gZmFsc2UuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RTcGVjI2hvc3RQSURcbiAgICovXG4gIHJlYWRvbmx5IGhvc3RQaWQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGhvc3RuYW1lIG9mIHRoZSBQb2QgSWYgbm90IHNwZWNpZmllZCwgdGhlIHBvZCdzIGhvc3RuYW1lIHdpbGwgYmUgc2V0IHRvIGEgc3lzdGVtLWRlZmluZWQgdmFsdWUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZFNwZWMjaG9zdG5hbWVcbiAgICovXG4gIHJlYWRvbmx5IGhvc3RuYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBJbWFnZVB1bGxTZWNyZXRzIGlzIGFuIG9wdGlvbmFsIGxpc3Qgb2YgcmVmZXJlbmNlcyB0byBzZWNyZXRzIGluIHRoZSBzYW1lIG5hbWVzcGFjZSB0byB1c2UgZm9yIHB1bGxpbmcgYW55IG9mIHRoZSBpbWFnZXMgdXNlZCBieSB0aGlzIFBvZFNwZWMuIElmIHNwZWNpZmllZCwgdGhlc2Ugc2VjcmV0cyB3aWxsIGJlIHBhc3NlZCB0byBpbmRpdmlkdWFsIHB1bGxlciBpbXBsZW1lbnRhdGlvbnMgZm9yIHRoZW0gdG8gdXNlLiBGb3IgZXhhbXBsZSwgaW4gdGhlIGNhc2Ugb2YgZG9ja2VyLCBvbmx5IERvY2tlckNvbmZpZyB0eXBlIHNlY3JldHMgYXJlIGhvbm9yZWQuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvY29udGFpbmVycy9pbWFnZXMjc3BlY2lmeWluZy1pbWFnZXB1bGxzZWNyZXRzLW9uLWEtcG9kXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZFNwZWMjaW1hZ2VQdWxsU2VjcmV0c1xuICAgKi9cbiAgcmVhZG9ubHkgaW1hZ2VQdWxsU2VjcmV0cz86IExvY2FsT2JqZWN0UmVmZXJlbmNlW107XG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgaW5pdGlhbGl6YXRpb24gY29udGFpbmVycyBiZWxvbmdpbmcgdG8gdGhlIHBvZC4gSW5pdCBjb250YWluZXJzIGFyZSBleGVjdXRlZCBpbiBvcmRlciBwcmlvciB0byBjb250YWluZXJzIGJlaW5nIHN0YXJ0ZWQuIElmIGFueSBpbml0IGNvbnRhaW5lciBmYWlscywgdGhlIHBvZCBpcyBjb25zaWRlcmVkIHRvIGhhdmUgZmFpbGVkIGFuZCBpcyBoYW5kbGVkIGFjY29yZGluZyB0byBpdHMgcmVzdGFydFBvbGljeS4gVGhlIG5hbWUgZm9yIGFuIGluaXQgY29udGFpbmVyIG9yIG5vcm1hbCBjb250YWluZXIgbXVzdCBiZSB1bmlxdWUgYW1vbmcgYWxsIGNvbnRhaW5lcnMuIEluaXQgY29udGFpbmVycyBtYXkgbm90IGhhdmUgTGlmZWN5Y2xlIGFjdGlvbnMsIFJlYWRpbmVzcyBwcm9iZXMsIExpdmVuZXNzIHByb2Jlcywgb3IgU3RhcnR1cCBwcm9iZXMuIFRoZSByZXNvdXJjZVJlcXVpcmVtZW50cyBvZiBhbiBpbml0IGNvbnRhaW5lciBhcmUgdGFrZW4gaW50byBhY2NvdW50IGR1cmluZyBzY2hlZHVsaW5nIGJ5IGZpbmRpbmcgdGhlIGhpZ2hlc3QgcmVxdWVzdC9saW1pdCBmb3IgZWFjaCByZXNvdXJjZSB0eXBlLCBhbmQgdGhlbiB1c2luZyB0aGUgbWF4IG9mIG9mIHRoYXQgdmFsdWUgb3IgdGhlIHN1bSBvZiB0aGUgbm9ybWFsIGNvbnRhaW5lcnMuIExpbWl0cyBhcmUgYXBwbGllZCB0byBpbml0IGNvbnRhaW5lcnMgaW4gYSBzaW1pbGFyIGZhc2hpb24uIEluaXQgY29udGFpbmVycyBjYW5ub3QgY3VycmVudGx5IGJlIGFkZGVkIG9yIHJlbW92ZWQuIENhbm5vdCBiZSB1cGRhdGVkLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3dvcmtsb2Fkcy9wb2RzL2luaXQtY29udGFpbmVycy9cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kU3BlYyNpbml0Q29udGFpbmVyc1xuICAgKi9cbiAgcmVhZG9ubHkgaW5pdENvbnRhaW5lcnM/OiBDb250YWluZXJbXTtcblxuICAvKipcbiAgICogTm9kZU5hbWUgaXMgYSByZXF1ZXN0IHRvIHNjaGVkdWxlIHRoaXMgcG9kIG9udG8gYSBzcGVjaWZpYyBub2RlLiBJZiBpdCBpcyBub24tZW1wdHksIHRoZSBzY2hlZHVsZXIgc2ltcGx5IHNjaGVkdWxlcyB0aGlzIHBvZCBvbnRvIHRoYXQgbm9kZSwgYXNzdW1pbmcgdGhhdCBpdCBmaXRzIHJlc291cmNlIHJlcXVpcmVtZW50cy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kU3BlYyNub2RlTmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbm9kZU5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE5vZGVTZWxlY3RvciBpcyBhIHNlbGVjdG9yIHdoaWNoIG11c3QgYmUgdHJ1ZSBmb3IgdGhlIHBvZCB0byBmaXQgb24gYSBub2RlLiBTZWxlY3RvciB3aGljaCBtdXN0IG1hdGNoIGEgbm9kZSdzIGxhYmVscyBmb3IgdGhlIHBvZCB0byBiZSBzY2hlZHVsZWQgb24gdGhhdCBub2RlLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL2NvbmZpZ3VyYXRpb24vYXNzaWduLXBvZC1ub2RlL1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RTcGVjI25vZGVTZWxlY3RvclxuICAgKi9cbiAgcmVhZG9ubHkgbm9kZVNlbGVjdG9yPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcblxuICAvKipcbiAgICogT3ZlcmhlYWQgcmVwcmVzZW50cyB0aGUgcmVzb3VyY2Ugb3ZlcmhlYWQgYXNzb2NpYXRlZCB3aXRoIHJ1bm5pbmcgYSBwb2QgZm9yIGEgZ2l2ZW4gUnVudGltZUNsYXNzLiBUaGlzIGZpZWxkIHdpbGwgYmUgYXV0b3BvcHVsYXRlZCBhdCBhZG1pc3Npb24gdGltZSBieSB0aGUgUnVudGltZUNsYXNzIGFkbWlzc2lvbiBjb250cm9sbGVyLiBJZiB0aGUgUnVudGltZUNsYXNzIGFkbWlzc2lvbiBjb250cm9sbGVyIGlzIGVuYWJsZWQsIG92ZXJoZWFkIG11c3Qgbm90IGJlIHNldCBpbiBQb2QgY3JlYXRlIHJlcXVlc3RzLiBUaGUgUnVudGltZUNsYXNzIGFkbWlzc2lvbiBjb250cm9sbGVyIHdpbGwgcmVqZWN0IFBvZCBjcmVhdGUgcmVxdWVzdHMgd2hpY2ggaGF2ZSB0aGUgb3ZlcmhlYWQgYWxyZWFkeSBzZXQuIElmIFJ1bnRpbWVDbGFzcyBpcyBjb25maWd1cmVkIGFuZCBzZWxlY3RlZCBpbiB0aGUgUG9kU3BlYywgT3ZlcmhlYWQgd2lsbCBiZSBzZXQgdG8gdGhlIHZhbHVlIGRlZmluZWQgaW4gdGhlIGNvcnJlc3BvbmRpbmcgUnVudGltZUNsYXNzLCBvdGhlcndpc2UgaXQgd2lsbCByZW1haW4gdW5zZXQgYW5kIHRyZWF0ZWQgYXMgemVyby4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vZW5oYW5jZW1lbnRzL2tlcHMvc2lnLW5vZGUvNjg4LXBvZC1vdmVyaGVhZC9SRUFETUUubWQgVGhpcyBmaWVsZCBpcyBiZXRhLWxldmVsIGFzIG9mIEt1YmVybmV0ZXMgdjEuMTgsIGFuZCBpcyBvbmx5IGhvbm9yZWQgYnkgc2VydmVycyB0aGF0IGVuYWJsZSB0aGUgUG9kT3ZlcmhlYWQgZmVhdHVyZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kU3BlYyNvdmVyaGVhZFxuICAgKi9cbiAgcmVhZG9ubHkgb3ZlcmhlYWQ/OiB7IFtrZXk6IHN0cmluZ106IFF1YW50aXR5IH07XG5cbiAgLyoqXG4gICAqIFByZWVtcHRpb25Qb2xpY3kgaXMgdGhlIFBvbGljeSBmb3IgcHJlZW1wdGluZyBwb2RzIHdpdGggbG93ZXIgcHJpb3JpdHkuIE9uZSBvZiBOZXZlciwgUHJlZW1wdExvd2VyUHJpb3JpdHkuIERlZmF1bHRzIHRvIFByZWVtcHRMb3dlclByaW9yaXR5IGlmIHVuc2V0LiBUaGlzIGZpZWxkIGlzIGJldGEtbGV2ZWwsIGdhdGVkIGJ5IHRoZSBOb25QcmVlbXB0aW5nUHJpb3JpdHkgZmVhdHVyZS1nYXRlLlxuICAgKlxuICAgKiBAZGVmYXVsdCBQcmVlbXB0TG93ZXJQcmlvcml0eSBpZiB1bnNldC4gVGhpcyBmaWVsZCBpcyBiZXRhLWxldmVsLCBnYXRlZCBieSB0aGUgTm9uUHJlZW1wdGluZ1ByaW9yaXR5IGZlYXR1cmUtZ2F0ZS5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kU3BlYyNwcmVlbXB0aW9uUG9saWN5XG4gICAqL1xuICByZWFkb25seSBwcmVlbXB0aW9uUG9saWN5Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcHJpb3JpdHkgdmFsdWUuIFZhcmlvdXMgc3lzdGVtIGNvbXBvbmVudHMgdXNlIHRoaXMgZmllbGQgdG8gZmluZCB0aGUgcHJpb3JpdHkgb2YgdGhlIHBvZC4gV2hlbiBQcmlvcml0eSBBZG1pc3Npb24gQ29udHJvbGxlciBpcyBlbmFibGVkLCBpdCBwcmV2ZW50cyB1c2VycyBmcm9tIHNldHRpbmcgdGhpcyBmaWVsZC4gVGhlIGFkbWlzc2lvbiBjb250cm9sbGVyIHBvcHVsYXRlcyB0aGlzIGZpZWxkIGZyb20gUHJpb3JpdHlDbGFzc05hbWUuIFRoZSBoaWdoZXIgdGhlIHZhbHVlLCB0aGUgaGlnaGVyIHRoZSBwcmlvcml0eS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kU3BlYyNwcmlvcml0eVxuICAgKi9cbiAgcmVhZG9ubHkgcHJpb3JpdHk/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIElmIHNwZWNpZmllZCwgaW5kaWNhdGVzIHRoZSBwb2QncyBwcmlvcml0eS4gXCJzeXN0ZW0tbm9kZS1jcml0aWNhbFwiIGFuZCBcInN5c3RlbS1jbHVzdGVyLWNyaXRpY2FsXCIgYXJlIHR3byBzcGVjaWFsIGtleXdvcmRzIHdoaWNoIGluZGljYXRlIHRoZSBoaWdoZXN0IHByaW9yaXRpZXMgd2l0aCB0aGUgZm9ybWVyIGJlaW5nIHRoZSBoaWdoZXN0IHByaW9yaXR5LiBBbnkgb3RoZXIgbmFtZSBtdXN0IGJlIGRlZmluZWQgYnkgY3JlYXRpbmcgYSBQcmlvcml0eUNsYXNzIG9iamVjdCB3aXRoIHRoYXQgbmFtZS4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHBvZCBwcmlvcml0eSB3aWxsIGJlIGRlZmF1bHQgb3IgemVybyBpZiB0aGVyZSBpcyBubyBkZWZhdWx0LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RTcGVjI3ByaW9yaXR5Q2xhc3NOYW1lXG4gICAqL1xuICByZWFkb25seSBwcmlvcml0eUNsYXNzTmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogSWYgc3BlY2lmaWVkLCBhbGwgcmVhZGluZXNzIGdhdGVzIHdpbGwgYmUgZXZhbHVhdGVkIGZvciBwb2QgcmVhZGluZXNzLiBBIHBvZCBpcyByZWFkeSB3aGVuIGFsbCBpdHMgY29udGFpbmVycyBhcmUgcmVhZHkgQU5EIGFsbCBjb25kaXRpb25zIHNwZWNpZmllZCBpbiB0aGUgcmVhZGluZXNzIGdhdGVzIGhhdmUgc3RhdHVzIGVxdWFsIHRvIFwiVHJ1ZVwiIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2VuaGFuY2VtZW50cy9rZXBzL3NpZy1uZXR3b3JrLzU4MC1wb2QtcmVhZGluZXNzLWdhdGVzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZFNwZWMjcmVhZGluZXNzR2F0ZXNcbiAgICovXG4gIHJlYWRvbmx5IHJlYWRpbmVzc0dhdGVzPzogUG9kUmVhZGluZXNzR2F0ZVtdO1xuXG4gIC8qKlxuICAgKiBSZXN0YXJ0IHBvbGljeSBmb3IgYWxsIGNvbnRhaW5lcnMgd2l0aGluIHRoZSBwb2QuIE9uZSBvZiBBbHdheXMsIE9uRmFpbHVyZSwgTmV2ZXIuIERlZmF1bHQgdG8gQWx3YXlzLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3dvcmtsb2Fkcy9wb2RzL3BvZC1saWZlY3ljbGUvI3Jlc3RhcnQtcG9saWN5XG4gICAqXG4gICAqIEBkZWZhdWx0IEFsd2F5cy4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy93b3JrbG9hZHMvcG9kcy9wb2QtbGlmZWN5Y2xlLyNyZXN0YXJ0LXBvbGljeVxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RTcGVjI3Jlc3RhcnRQb2xpY3lcbiAgICovXG4gIHJlYWRvbmx5IHJlc3RhcnRQb2xpY3k/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFJ1bnRpbWVDbGFzc05hbWUgcmVmZXJzIHRvIGEgUnVudGltZUNsYXNzIG9iamVjdCBpbiB0aGUgbm9kZS5rOHMuaW8gZ3JvdXAsIHdoaWNoIHNob3VsZCBiZSB1c2VkIHRvIHJ1biB0aGlzIHBvZC4gIElmIG5vIFJ1bnRpbWVDbGFzcyByZXNvdXJjZSBtYXRjaGVzIHRoZSBuYW1lZCBjbGFzcywgdGhlIHBvZCB3aWxsIG5vdCBiZSBydW4uIElmIHVuc2V0IG9yIGVtcHR5LCB0aGUgXCJsZWdhY3lcIiBSdW50aW1lQ2xhc3Mgd2lsbCBiZSB1c2VkLCB3aGljaCBpcyBhbiBpbXBsaWNpdCBjbGFzcyB3aXRoIGFuIGVtcHR5IGRlZmluaXRpb24gdGhhdCB1c2VzIHRoZSBkZWZhdWx0IHJ1bnRpbWUgaGFuZGxlci4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vZW5oYW5jZW1lbnRzL2tlcHMvc2lnLW5vZGUvNTg1LXJ1bnRpbWUtY2xhc3MgVGhpcyBpcyBhIGJldGEgZmVhdHVyZSBhcyBvZiBLdWJlcm5ldGVzIHYxLjE0LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RTcGVjI3J1bnRpbWVDbGFzc05hbWVcbiAgICovXG4gIHJlYWRvbmx5IHJ1bnRpbWVDbGFzc05hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIElmIHNwZWNpZmllZCwgdGhlIHBvZCB3aWxsIGJlIGRpc3BhdGNoZWQgYnkgc3BlY2lmaWVkIHNjaGVkdWxlci4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHBvZCB3aWxsIGJlIGRpc3BhdGNoZWQgYnkgZGVmYXVsdCBzY2hlZHVsZXIuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZFNwZWMjc2NoZWR1bGVyTmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgc2NoZWR1bGVyTmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogU2VjdXJpdHlDb250ZXh0IGhvbGRzIHBvZC1sZXZlbCBzZWN1cml0eSBhdHRyaWJ1dGVzIGFuZCBjb21tb24gY29udGFpbmVyIHNldHRpbmdzLiBPcHRpb25hbDogRGVmYXVsdHMgdG8gZW1wdHkuICBTZWUgdHlwZSBkZXNjcmlwdGlvbiBmb3IgZGVmYXVsdCB2YWx1ZXMgb2YgZWFjaCBmaWVsZC5cbiAgICpcbiAgICogQGRlZmF1bHQgZW1wdHkuICBTZWUgdHlwZSBkZXNjcmlwdGlvbiBmb3IgZGVmYXVsdCB2YWx1ZXMgb2YgZWFjaCBmaWVsZC5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kU3BlYyNzZWN1cml0eUNvbnRleHRcbiAgICovXG4gIHJlYWRvbmx5IHNlY3VyaXR5Q29udGV4dD86IFBvZFNlY3VyaXR5Q29udGV4dDtcblxuICAvKipcbiAgICogRGVwcmVjYXRlZFNlcnZpY2VBY2NvdW50IGlzIGEgZGVwcmVjaWF0ZWQgYWxpYXMgZm9yIFNlcnZpY2VBY2NvdW50TmFtZS4gRGVwcmVjYXRlZDogVXNlIHNlcnZpY2VBY2NvdW50TmFtZSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RTcGVjI3NlcnZpY2VBY2NvdW50XG4gICAqL1xuICByZWFkb25seSBzZXJ2aWNlQWNjb3VudD86IHN0cmluZztcblxuICAvKipcbiAgICogU2VydmljZUFjY291bnROYW1lIGlzIHRoZSBuYW1lIG9mIHRoZSBTZXJ2aWNlQWNjb3VudCB0byB1c2UgdG8gcnVuIHRoaXMgcG9kLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL3Rhc2tzL2NvbmZpZ3VyZS1wb2QtY29udGFpbmVyL2NvbmZpZ3VyZS1zZXJ2aWNlLWFjY291bnQvXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZFNwZWMjc2VydmljZUFjY291bnROYW1lXG4gICAqL1xuICByZWFkb25seSBzZXJ2aWNlQWNjb3VudE5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIElmIHRydWUgdGhlIHBvZCdzIGhvc3RuYW1lIHdpbGwgYmUgY29uZmlndXJlZCBhcyB0aGUgcG9kJ3MgRlFETiwgcmF0aGVyIHRoYW4gdGhlIGxlYWYgbmFtZSAodGhlIGRlZmF1bHQpLiBJbiBMaW51eCBjb250YWluZXJzLCB0aGlzIG1lYW5zIHNldHRpbmcgdGhlIEZRRE4gaW4gdGhlIGhvc3RuYW1lIGZpZWxkIG9mIHRoZSBrZXJuZWwgKHRoZSBub2RlbmFtZSBmaWVsZCBvZiBzdHJ1Y3QgdXRzbmFtZSkuIEluIFdpbmRvd3MgY29udGFpbmVycywgdGhpcyBtZWFucyBzZXR0aW5nIHRoZSByZWdpc3RyeSB2YWx1ZSBvZiBob3N0bmFtZSBmb3IgdGhlIHJlZ2lzdHJ5IGtleSBIS0VZX0xPQ0FMX01BQ0hJTkVcXFNZU1RFTVxcQ3VycmVudENvbnRyb2xTZXRcXFNlcnZpY2VzXFxUY3BpcFxcUGFyYW1ldGVycyB0byBGUUROLiBJZiBhIHBvZCBkb2VzIG5vdCBoYXZlIEZRRE4sIHRoaXMgaGFzIG5vIGVmZmVjdC4gRGVmYXVsdCB0byBmYWxzZS5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2UuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZFNwZWMjc2V0SG9zdG5hbWVBc0ZRRE5cbiAgICovXG4gIHJlYWRvbmx5IHNldEhvc3RuYW1lQXNGcWRuPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogU2hhcmUgYSBzaW5nbGUgcHJvY2VzcyBuYW1lc3BhY2UgYmV0d2VlbiBhbGwgb2YgdGhlIGNvbnRhaW5lcnMgaW4gYSBwb2QuIFdoZW4gdGhpcyBpcyBzZXQgY29udGFpbmVycyB3aWxsIGJlIGFibGUgdG8gdmlldyBhbmQgc2lnbmFsIHByb2Nlc3NlcyBmcm9tIG90aGVyIGNvbnRhaW5lcnMgaW4gdGhlIHNhbWUgcG9kLCBhbmQgdGhlIGZpcnN0IHByb2Nlc3MgaW4gZWFjaCBjb250YWluZXIgd2lsbCBub3QgYmUgYXNzaWduZWQgUElEIDEuIEhvc3RQSUQgYW5kIFNoYXJlUHJvY2Vzc05hbWVzcGFjZSBjYW5ub3QgYm90aCBiZSBzZXQuIE9wdGlvbmFsOiBEZWZhdWx0IHRvIGZhbHNlLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZS5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kU3BlYyNzaGFyZVByb2Nlc3NOYW1lc3BhY2VcbiAgICovXG4gIHJlYWRvbmx5IHNoYXJlUHJvY2Vzc05hbWVzcGFjZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIElmIHNwZWNpZmllZCwgdGhlIGZ1bGx5IHF1YWxpZmllZCBQb2QgaG9zdG5hbWUgd2lsbCBiZSBcIjxob3N0bmFtZT4uPHN1YmRvbWFpbj4uPHBvZCBuYW1lc3BhY2U+LnN2Yy48Y2x1c3RlciBkb21haW4+XCIuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBwb2Qgd2lsbCBub3QgaGF2ZSBhIGRvbWFpbm5hbWUgYXQgYWxsLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RTcGVjI3N1YmRvbWFpblxuICAgKi9cbiAgcmVhZG9ubHkgc3ViZG9tYWluPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBkdXJhdGlvbiBpbiBzZWNvbmRzIHRoZSBwb2QgbmVlZHMgdG8gdGVybWluYXRlIGdyYWNlZnVsbHkuIE1heSBiZSBkZWNyZWFzZWQgaW4gZGVsZXRlIHJlcXVlc3QuIFZhbHVlIG11c3QgYmUgbm9uLW5lZ2F0aXZlIGludGVnZXIuIFRoZSB2YWx1ZSB6ZXJvIGluZGljYXRlcyBzdG9wIGltbWVkaWF0ZWx5IHZpYSB0aGUga2lsbCBzaWduYWwgKG5vIG9wcG9ydHVuaXR5IHRvIHNodXQgZG93bikuIElmIHRoaXMgdmFsdWUgaXMgbmlsLCB0aGUgZGVmYXVsdCBncmFjZSBwZXJpb2Qgd2lsbCBiZSB1c2VkIGluc3RlYWQuIFRoZSBncmFjZSBwZXJpb2QgaXMgdGhlIGR1cmF0aW9uIGluIHNlY29uZHMgYWZ0ZXIgdGhlIHByb2Nlc3NlcyBydW5uaW5nIGluIHRoZSBwb2QgYXJlIHNlbnQgYSB0ZXJtaW5hdGlvbiBzaWduYWwgYW5kIHRoZSB0aW1lIHdoZW4gdGhlIHByb2Nlc3NlcyBhcmUgZm9yY2libHkgaGFsdGVkIHdpdGggYSBraWxsIHNpZ25hbC4gU2V0IHRoaXMgdmFsdWUgbG9uZ2VyIHRoYW4gdGhlIGV4cGVjdGVkIGNsZWFudXAgdGltZSBmb3IgeW91ciBwcm9jZXNzLiBEZWZhdWx0cyB0byAzMCBzZWNvbmRzLlxuICAgKlxuICAgKiBAZGVmYXVsdCAzMCBzZWNvbmRzLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RTcGVjI3Rlcm1pbmF0aW9uR3JhY2VQZXJpb2RTZWNvbmRzXG4gICAqL1xuICByZWFkb25seSB0ZXJtaW5hdGlvbkdyYWNlUGVyaW9kU2Vjb25kcz86IG51bWJlcjtcblxuICAvKipcbiAgICogSWYgc3BlY2lmaWVkLCB0aGUgcG9kJ3MgdG9sZXJhdGlvbnMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZFNwZWMjdG9sZXJhdGlvbnNcbiAgICovXG4gIHJlYWRvbmx5IHRvbGVyYXRpb25zPzogVG9sZXJhdGlvbltdO1xuXG4gIC8qKlxuICAgKiBUb3BvbG9neVNwcmVhZENvbnN0cmFpbnRzIGRlc2NyaWJlcyBob3cgYSBncm91cCBvZiBwb2RzIG91Z2h0IHRvIHNwcmVhZCBhY3Jvc3MgdG9wb2xvZ3kgZG9tYWlucy4gU2NoZWR1bGVyIHdpbGwgc2NoZWR1bGUgcG9kcyBpbiBhIHdheSB3aGljaCBhYmlkZXMgYnkgdGhlIGNvbnN0cmFpbnRzLiBBbGwgdG9wb2xvZ3lTcHJlYWRDb25zdHJhaW50cyBhcmUgQU5EZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZFNwZWMjdG9wb2xvZ3lTcHJlYWRDb25zdHJhaW50c1xuICAgKi9cbiAgcmVhZG9ubHkgdG9wb2xvZ3lTcHJlYWRDb25zdHJhaW50cz86IFRvcG9sb2d5U3ByZWFkQ29uc3RyYWludFtdO1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIHZvbHVtZXMgdGhhdCBjYW4gYmUgbW91bnRlZCBieSBjb250YWluZXJzIGJlbG9uZ2luZyB0byB0aGUgcG9kLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2Uvdm9sdW1lc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RTcGVjI3ZvbHVtZXNcbiAgICovXG4gIHJlYWRvbmx5IHZvbHVtZXM/OiBWb2x1bWVbXTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdQb2RTcGVjJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Qb2RTcGVjKG9iajogUG9kU3BlYyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2FjdGl2ZURlYWRsaW5lU2Vjb25kcyc6IG9iai5hY3RpdmVEZWFkbGluZVNlY29uZHMsXG4gICAgJ2FmZmluaXR5JzogdG9Kc29uX0FmZmluaXR5KG9iai5hZmZpbml0eSksXG4gICAgJ2F1dG9tb3VudFNlcnZpY2VBY2NvdW50VG9rZW4nOiBvYmouYXV0b21vdW50U2VydmljZUFjY291bnRUb2tlbixcbiAgICAnY29udGFpbmVycyc6IG9iai5jb250YWluZXJzPy5tYXAoeSA9PiB0b0pzb25fQ29udGFpbmVyKHkpKSxcbiAgICAnZG5zQ29uZmlnJzogdG9Kc29uX1BvZERuc0NvbmZpZyhvYmouZG5zQ29uZmlnKSxcbiAgICAnZG5zUG9saWN5Jzogb2JqLmRuc1BvbGljeSxcbiAgICAnZW5hYmxlU2VydmljZUxpbmtzJzogb2JqLmVuYWJsZVNlcnZpY2VMaW5rcyxcbiAgICAnZXBoZW1lcmFsQ29udGFpbmVycyc6IG9iai5lcGhlbWVyYWxDb250YWluZXJzPy5tYXAoeSA9PiB0b0pzb25fRXBoZW1lcmFsQ29udGFpbmVyKHkpKSxcbiAgICAnaG9zdEFsaWFzZXMnOiBvYmouaG9zdEFsaWFzZXM/Lm1hcCh5ID0+IHRvSnNvbl9Ib3N0QWxpYXMoeSkpLFxuICAgICdob3N0SVBDJzogb2JqLmhvc3RJcGMsXG4gICAgJ2hvc3ROZXR3b3JrJzogb2JqLmhvc3ROZXR3b3JrLFxuICAgICdob3N0UElEJzogb2JqLmhvc3RQaWQsXG4gICAgJ2hvc3RuYW1lJzogb2JqLmhvc3RuYW1lLFxuICAgICdpbWFnZVB1bGxTZWNyZXRzJzogb2JqLmltYWdlUHVsbFNlY3JldHM/Lm1hcCh5ID0+IHRvSnNvbl9Mb2NhbE9iamVjdFJlZmVyZW5jZSh5KSksXG4gICAgJ2luaXRDb250YWluZXJzJzogb2JqLmluaXRDb250YWluZXJzPy5tYXAoeSA9PiB0b0pzb25fQ29udGFpbmVyKHkpKSxcbiAgICAnbm9kZU5hbWUnOiBvYmoubm9kZU5hbWUsXG4gICAgJ25vZGVTZWxlY3Rvcic6ICgob2JqLm5vZGVTZWxlY3RvcikgPT09IHVuZGVmaW5lZCkgPyB1bmRlZmluZWQgOiAoT2JqZWN0LmVudHJpZXMob2JqLm5vZGVTZWxlY3RvcikucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KSksXG4gICAgJ292ZXJoZWFkJzogKChvYmoub3ZlcmhlYWQpID09PSB1bmRlZmluZWQpID8gdW5kZWZpbmVkIDogKE9iamVjdC5lbnRyaWVzKG9iai5vdmVyaGVhZCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0/LnZhbHVlIH0pLCB7fSkpLFxuICAgICdwcmVlbXB0aW9uUG9saWN5Jzogb2JqLnByZWVtcHRpb25Qb2xpY3ksXG4gICAgJ3ByaW9yaXR5Jzogb2JqLnByaW9yaXR5LFxuICAgICdwcmlvcml0eUNsYXNzTmFtZSc6IG9iai5wcmlvcml0eUNsYXNzTmFtZSxcbiAgICAncmVhZGluZXNzR2F0ZXMnOiBvYmoucmVhZGluZXNzR2F0ZXM/Lm1hcCh5ID0+IHRvSnNvbl9Qb2RSZWFkaW5lc3NHYXRlKHkpKSxcbiAgICAncmVzdGFydFBvbGljeSc6IG9iai5yZXN0YXJ0UG9saWN5LFxuICAgICdydW50aW1lQ2xhc3NOYW1lJzogb2JqLnJ1bnRpbWVDbGFzc05hbWUsXG4gICAgJ3NjaGVkdWxlck5hbWUnOiBvYmouc2NoZWR1bGVyTmFtZSxcbiAgICAnc2VjdXJpdHlDb250ZXh0JzogdG9Kc29uX1BvZFNlY3VyaXR5Q29udGV4dChvYmouc2VjdXJpdHlDb250ZXh0KSxcbiAgICAnc2VydmljZUFjY291bnQnOiBvYmouc2VydmljZUFjY291bnQsXG4gICAgJ3NlcnZpY2VBY2NvdW50TmFtZSc6IG9iai5zZXJ2aWNlQWNjb3VudE5hbWUsXG4gICAgJ3NldEhvc3RuYW1lQXNGUUROJzogb2JqLnNldEhvc3RuYW1lQXNGcWRuLFxuICAgICdzaGFyZVByb2Nlc3NOYW1lc3BhY2UnOiBvYmouc2hhcmVQcm9jZXNzTmFtZXNwYWNlLFxuICAgICdzdWJkb21haW4nOiBvYmouc3ViZG9tYWluLFxuICAgICd0ZXJtaW5hdGlvbkdyYWNlUGVyaW9kU2Vjb25kcyc6IG9iai50ZXJtaW5hdGlvbkdyYWNlUGVyaW9kU2Vjb25kcyxcbiAgICAndG9sZXJhdGlvbnMnOiBvYmoudG9sZXJhdGlvbnM/Lm1hcCh5ID0+IHRvSnNvbl9Ub2xlcmF0aW9uKHkpKSxcbiAgICAndG9wb2xvZ3lTcHJlYWRDb25zdHJhaW50cyc6IG9iai50b3BvbG9neVNwcmVhZENvbnN0cmFpbnRzPy5tYXAoeSA9PiB0b0pzb25fVG9wb2xvZ3lTcHJlYWRDb25zdHJhaW50KHkpKSxcbiAgICAndm9sdW1lcyc6IG9iai52b2x1bWVzPy5tYXAoeSA9PiB0b0pzb25fVm9sdW1lKHkpKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBQb2RUZW1wbGF0ZVNwZWMgZGVzY3JpYmVzIHRoZSBkYXRhIGEgcG9kIHNob3VsZCBoYXZlIHdoZW4gY3JlYXRlZCBmcm9tIGEgdGVtcGxhdGVcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RUZW1wbGF0ZVNwZWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQb2RUZW1wbGF0ZVNwZWMge1xuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0J3MgbWV0YWRhdGEuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kVGVtcGxhdGVTcGVjI21ldGFkYXRhXG4gICAqL1xuICByZWFkb25seSBtZXRhZGF0YT86IE9iamVjdE1ldGE7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb24gb2YgdGhlIGRlc2lyZWQgYmVoYXZpb3Igb2YgdGhlIHBvZC4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNzcGVjLWFuZC1zdGF0dXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kVGVtcGxhdGVTcGVjI3NwZWNcbiAgICovXG4gIHJlYWRvbmx5IHNwZWM/OiBQb2RTcGVjO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1BvZFRlbXBsYXRlU3BlYycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fUG9kVGVtcGxhdGVTcGVjKG9iajogUG9kVGVtcGxhdGVTcGVjIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0YWRhdGEnOiB0b0pzb25fT2JqZWN0TWV0YShvYmoubWV0YWRhdGEpLFxuICAgICdzcGVjJzogdG9Kc29uX1BvZFNwZWMob2JqLnNwZWMpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFJlcGxpY2F0aW9uQ29udHJvbGxlclNwZWMgaXMgdGhlIHNwZWNpZmljYXRpb24gb2YgYSByZXBsaWNhdGlvbiBjb250cm9sbGVyLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlJlcGxpY2F0aW9uQ29udHJvbGxlclNwZWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXBsaWNhdGlvbkNvbnRyb2xsZXJTcGVjIHtcbiAgLyoqXG4gICAqIE1pbmltdW0gbnVtYmVyIG9mIHNlY29uZHMgZm9yIHdoaWNoIGEgbmV3bHkgY3JlYXRlZCBwb2Qgc2hvdWxkIGJlIHJlYWR5IHdpdGhvdXQgYW55IG9mIGl0cyBjb250YWluZXIgY3Jhc2hpbmcsIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGF2YWlsYWJsZS4gRGVmYXVsdHMgdG8gMCAocG9kIHdpbGwgYmUgY29uc2lkZXJlZCBhdmFpbGFibGUgYXMgc29vbiBhcyBpdCBpcyByZWFkeSlcbiAgICpcbiAgICogQGRlZmF1bHQgMCAocG9kIHdpbGwgYmUgY29uc2lkZXJlZCBhdmFpbGFibGUgYXMgc29vbiBhcyBpdCBpcyByZWFkeSlcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUmVwbGljYXRpb25Db250cm9sbGVyU3BlYyNtaW5SZWFkeVNlY29uZHNcbiAgICovXG4gIHJlYWRvbmx5IG1pblJlYWR5U2Vjb25kcz86IG51bWJlcjtcblxuICAvKipcbiAgICogUmVwbGljYXMgaXMgdGhlIG51bWJlciBvZiBkZXNpcmVkIHJlcGxpY2FzLiBUaGlzIGlzIGEgcG9pbnRlciB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIGV4cGxpY2l0IHplcm8gYW5kIHVuc3BlY2lmaWVkLiBEZWZhdWx0cyB0byAxLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3dvcmtsb2Fkcy9jb250cm9sbGVycy9yZXBsaWNhdGlvbmNvbnRyb2xsZXIjd2hhdC1pcy1hLXJlcGxpY2F0aW9uY29udHJvbGxlclxuICAgKlxuICAgKiBAZGVmYXVsdCAxLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3dvcmtsb2Fkcy9jb250cm9sbGVycy9yZXBsaWNhdGlvbmNvbnRyb2xsZXIjd2hhdC1pcy1hLXJlcGxpY2F0aW9uY29udHJvbGxlclxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5SZXBsaWNhdGlvbkNvbnRyb2xsZXJTcGVjI3JlcGxpY2FzXG4gICAqL1xuICByZWFkb25seSByZXBsaWNhcz86IG51bWJlcjtcblxuICAvKipcbiAgICogU2VsZWN0b3IgaXMgYSBsYWJlbCBxdWVyeSBvdmVyIHBvZHMgdGhhdCBzaG91bGQgbWF0Y2ggdGhlIFJlcGxpY2FzIGNvdW50LiBJZiBTZWxlY3RvciBpcyBlbXB0eSwgaXQgaXMgZGVmYXVsdGVkIHRvIHRoZSBsYWJlbHMgcHJlc2VudCBvbiB0aGUgUG9kIHRlbXBsYXRlLiBMYWJlbCBrZXlzIGFuZCB2YWx1ZXMgdGhhdCBtdXN0IG1hdGNoIGluIG9yZGVyIHRvIGJlIGNvbnRyb2xsZWQgYnkgdGhpcyByZXBsaWNhdGlvbiBjb250cm9sbGVyLCBpZiBlbXB0eSBkZWZhdWx0ZWQgdG8gbGFiZWxzIG9uIFBvZCB0ZW1wbGF0ZS4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9vdmVydmlldy93b3JraW5nLXdpdGgtb2JqZWN0cy9sYWJlbHMvI2xhYmVsLXNlbGVjdG9yc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5SZXBsaWNhdGlvbkNvbnRyb2xsZXJTcGVjI3NlbGVjdG9yXG4gICAqL1xuICByZWFkb25seSBzZWxlY3Rvcj86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG5cbiAgLyoqXG4gICAqIFRlbXBsYXRlIGlzIHRoZSBvYmplY3QgdGhhdCBkZXNjcmliZXMgdGhlIHBvZCB0aGF0IHdpbGwgYmUgY3JlYXRlZCBpZiBpbnN1ZmZpY2llbnQgcmVwbGljYXMgYXJlIGRldGVjdGVkLiBUaGlzIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBhIFRlbXBsYXRlUmVmLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3dvcmtsb2Fkcy9jb250cm9sbGVycy9yZXBsaWNhdGlvbmNvbnRyb2xsZXIjcG9kLXRlbXBsYXRlXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlJlcGxpY2F0aW9uQ29udHJvbGxlclNwZWMjdGVtcGxhdGVcbiAgICovXG4gIHJlYWRvbmx5IHRlbXBsYXRlPzogUG9kVGVtcGxhdGVTcGVjO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1JlcGxpY2F0aW9uQ29udHJvbGxlclNwZWMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1JlcGxpY2F0aW9uQ29udHJvbGxlclNwZWMob2JqOiBSZXBsaWNhdGlvbkNvbnRyb2xsZXJTcGVjIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWluUmVhZHlTZWNvbmRzJzogb2JqLm1pblJlYWR5U2Vjb25kcyxcbiAgICAncmVwbGljYXMnOiBvYmoucmVwbGljYXMsXG4gICAgJ3NlbGVjdG9yJzogKChvYmouc2VsZWN0b3IpID09PSB1bmRlZmluZWQpID8gdW5kZWZpbmVkIDogKE9iamVjdC5lbnRyaWVzKG9iai5zZWxlY3RvcikucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KSksXG4gICAgJ3RlbXBsYXRlJzogdG9Kc29uX1BvZFRlbXBsYXRlU3BlYyhvYmoudGVtcGxhdGUpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFJlc291cmNlUXVvdGFTcGVjIGRlZmluZXMgdGhlIGRlc2lyZWQgaGFyZCBsaW1pdHMgdG8gZW5mb3JjZSBmb3IgUXVvdGEuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUmVzb3VyY2VRdW90YVNwZWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNvdXJjZVF1b3RhU3BlYyB7XG4gIC8qKlxuICAgKiBoYXJkIGlzIHRoZSBzZXQgb2YgZGVzaXJlZCBoYXJkIGxpbWl0cyBmb3IgZWFjaCBuYW1lZCByZXNvdXJjZS4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9wb2xpY3kvcmVzb3VyY2UtcXVvdGFzL1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5SZXNvdXJjZVF1b3RhU3BlYyNoYXJkXG4gICAqL1xuICByZWFkb25seSBoYXJkPzogeyBba2V5OiBzdHJpbmddOiBRdWFudGl0eSB9O1xuXG4gIC8qKlxuICAgKiBzY29wZVNlbGVjdG9yIGlzIGFsc28gYSBjb2xsZWN0aW9uIG9mIGZpbHRlcnMgbGlrZSBzY29wZXMgdGhhdCBtdXN0IG1hdGNoIGVhY2ggb2JqZWN0IHRyYWNrZWQgYnkgYSBxdW90YSBidXQgZXhwcmVzc2VkIHVzaW5nIFNjb3BlU2VsZWN0b3JPcGVyYXRvciBpbiBjb21iaW5hdGlvbiB3aXRoIHBvc3NpYmxlIHZhbHVlcy4gRm9yIGEgcmVzb3VyY2UgdG8gbWF0Y2gsIGJvdGggc2NvcGVzIEFORCBzY29wZVNlbGVjdG9yIChpZiBzcGVjaWZpZWQgaW4gc3BlYyksIG11c3QgYmUgbWF0Y2hlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUmVzb3VyY2VRdW90YVNwZWMjc2NvcGVTZWxlY3RvclxuICAgKi9cbiAgcmVhZG9ubHkgc2NvcGVTZWxlY3Rvcj86IFNjb3BlU2VsZWN0b3I7XG5cbiAgLyoqXG4gICAqIEEgY29sbGVjdGlvbiBvZiBmaWx0ZXJzIHRoYXQgbXVzdCBtYXRjaCBlYWNoIG9iamVjdCB0cmFja2VkIGJ5IGEgcXVvdGEuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBxdW90YSBtYXRjaGVzIGFsbCBvYmplY3RzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5SZXNvdXJjZVF1b3RhU3BlYyNzY29wZXNcbiAgICovXG4gIHJlYWRvbmx5IHNjb3Blcz86IHN0cmluZ1tdO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1Jlc291cmNlUXVvdGFTcGVjJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9SZXNvdXJjZVF1b3RhU3BlYyhvYmo6IFJlc291cmNlUXVvdGFTcGVjIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaGFyZCc6ICgob2JqLmhhcmQpID09PSB1bmRlZmluZWQpID8gdW5kZWZpbmVkIDogKE9iamVjdC5lbnRyaWVzKG9iai5oYXJkKS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXT8udmFsdWUgfSksIHt9KSksXG4gICAgJ3Njb3BlU2VsZWN0b3InOiB0b0pzb25fU2NvcGVTZWxlY3RvcihvYmouc2NvcGVTZWxlY3RvciksXG4gICAgJ3Njb3Blcyc6IG9iai5zY29wZXM/Lm1hcCh5ID0+IHkpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFNlcnZpY2VTcGVjIGRlc2NyaWJlcyB0aGUgYXR0cmlidXRlcyB0aGF0IGEgdXNlciBjcmVhdGVzIG9uIGEgc2VydmljZS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZXJ2aWNlU3BlY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZpY2VTcGVjIHtcbiAgLyoqXG4gICAqIGFsbG9jYXRlTG9hZEJhbGFuY2VyTm9kZVBvcnRzIGRlZmluZXMgaWYgTm9kZVBvcnRzIHdpbGwgYmUgYXV0b21hdGljYWxseSBhbGxvY2F0ZWQgZm9yIHNlcnZpY2VzIHdpdGggdHlwZSBMb2FkQmFsYW5jZXIuICBEZWZhdWx0IGlzIFwidHJ1ZVwiLiBJdCBtYXkgYmUgc2V0IHRvIFwiZmFsc2VcIiBpZiB0aGUgY2x1c3RlciBsb2FkLWJhbGFuY2VyIGRvZXMgbm90IHJlbHkgb24gTm9kZVBvcnRzLiAgSWYgdGhlIGNhbGxlciByZXF1ZXN0cyBzcGVjaWZpYyBOb2RlUG9ydHMgKGJ5IHNwZWNpZnlpbmcgYSB2YWx1ZSksIHRob3NlIHJlcXVlc3RzIHdpbGwgYmUgcmVzcGVjdGVkLCByZWdhcmRsZXNzIG9mIHRoaXMgZmllbGQuIFRoaXMgZmllbGQgbWF5IG9ubHkgYmUgc2V0IGZvciBzZXJ2aWNlcyB3aXRoIHR5cGUgTG9hZEJhbGFuY2VyIGFuZCB3aWxsIGJlIGNsZWFyZWQgaWYgdGhlIHR5cGUgaXMgY2hhbmdlZCB0byBhbnkgb3RoZXIgdHlwZS4gVGhpcyBmaWVsZCBpcyBiZXRhLWxldmVsIGFuZCBpcyBvbmx5IGhvbm9yZWQgYnkgc2VydmVycyB0aGF0IGVuYWJsZSB0aGUgU2VydmljZUxCTm9kZVBvcnRDb250cm9sIGZlYXR1cmUuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcIi4gSXQgbWF5IGJlIHNldCB0byBcImZhbHNlXCIgaWYgdGhlIGNsdXN0ZXIgbG9hZC1iYWxhbmNlciBkb2VzIG5vdCByZWx5IG9uIE5vZGVQb3J0cy4gIElmIHRoZSBjYWxsZXIgcmVxdWVzdHMgc3BlY2lmaWMgTm9kZVBvcnRzIChieSBzcGVjaWZ5aW5nIGEgdmFsdWUpLCB0aG9zZSByZXF1ZXN0cyB3aWxsIGJlIHJlc3BlY3RlZCwgcmVnYXJkbGVzcyBvZiB0aGlzIGZpZWxkLiBUaGlzIGZpZWxkIG1heSBvbmx5IGJlIHNldCBmb3Igc2VydmljZXMgd2l0aCB0eXBlIExvYWRCYWxhbmNlciBhbmQgd2lsbCBiZSBjbGVhcmVkIGlmIHRoZSB0eXBlIGlzIGNoYW5nZWQgdG8gYW55IG90aGVyIHR5cGUuIFRoaXMgZmllbGQgaXMgYmV0YS1sZXZlbCBhbmQgaXMgb25seSBob25vcmVkIGJ5IHNlcnZlcnMgdGhhdCBlbmFibGUgdGhlIFNlcnZpY2VMQk5vZGVQb3J0Q29udHJvbCBmZWF0dXJlLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZXJ2aWNlU3BlYyNhbGxvY2F0ZUxvYWRCYWxhbmNlck5vZGVQb3J0c1xuICAgKi9cbiAgcmVhZG9ubHkgYWxsb2NhdGVMb2FkQmFsYW5jZXJOb2RlUG9ydHM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBjbHVzdGVySVAgaXMgdGhlIElQIGFkZHJlc3Mgb2YgdGhlIHNlcnZpY2UgYW5kIGlzIHVzdWFsbHkgYXNzaWduZWQgcmFuZG9tbHkuIElmIGFuIGFkZHJlc3MgaXMgc3BlY2lmaWVkIG1hbnVhbGx5LCBpcyBpbi1yYW5nZSAoYXMgcGVyIHN5c3RlbSBjb25maWd1cmF0aW9uKSwgYW5kIGlzIG5vdCBpbiB1c2UsIGl0IHdpbGwgYmUgYWxsb2NhdGVkIHRvIHRoZSBzZXJ2aWNlOyBvdGhlcndpc2UgY3JlYXRpb24gb2YgdGhlIHNlcnZpY2Ugd2lsbCBmYWlsLiBUaGlzIGZpZWxkIG1heSBub3QgYmUgY2hhbmdlZCB0aHJvdWdoIHVwZGF0ZXMgdW5sZXNzIHRoZSB0eXBlIGZpZWxkIGlzIGFsc28gYmVpbmcgY2hhbmdlZCB0byBFeHRlcm5hbE5hbWUgKHdoaWNoIHJlcXVpcmVzIHRoaXMgZmllbGQgdG8gYmUgYmxhbmspIG9yIHRoZSB0eXBlIGZpZWxkIGlzIGJlaW5nIGNoYW5nZWQgZnJvbSBFeHRlcm5hbE5hbWUgKGluIHdoaWNoIGNhc2UgdGhpcyBmaWVsZCBtYXkgb3B0aW9uYWxseSBiZSBzcGVjaWZpZWQsIGFzIGRlc2NyaWJlIGFib3ZlKS4gIFZhbGlkIHZhbHVlcyBhcmUgXCJOb25lXCIsIGVtcHR5IHN0cmluZyAoXCJcIiksIG9yIGEgdmFsaWQgSVAgYWRkcmVzcy4gU2V0dGluZyB0aGlzIHRvIFwiTm9uZVwiIG1ha2VzIGEgXCJoZWFkbGVzcyBzZXJ2aWNlXCIgKG5vIHZpcnR1YWwgSVApLCB3aGljaCBpcyB1c2VmdWwgd2hlbiBkaXJlY3QgZW5kcG9pbnQgY29ubmVjdGlvbnMgYXJlIHByZWZlcnJlZCBhbmQgcHJveHlpbmcgaXMgbm90IHJlcXVpcmVkLiAgT25seSBhcHBsaWVzIHRvIHR5cGVzIENsdXN0ZXJJUCwgTm9kZVBvcnQsIGFuZCBMb2FkQmFsYW5jZXIuIElmIHRoaXMgZmllbGQgaXMgc3BlY2lmaWVkIHdoZW4gY3JlYXRpbmcgYSBTZXJ2aWNlIG9mIHR5cGUgRXh0ZXJuYWxOYW1lLCBjcmVhdGlvbiB3aWxsIGZhaWwuIFRoaXMgZmllbGQgd2lsbCBiZSB3aXBlZCB3aGVuIHVwZGF0aW5nIGEgU2VydmljZSB0byB0eXBlIEV4dGVybmFsTmFtZS4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zZXJ2aWNlcy1uZXR3b3JraW5nL3NlcnZpY2UvI3ZpcnR1YWwtaXBzLWFuZC1zZXJ2aWNlLXByb3hpZXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZVNwZWMjY2x1c3RlcklQXG4gICAqL1xuICByZWFkb25seSBjbHVzdGVySXA/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIENsdXN0ZXJJUHMgaXMgYSBsaXN0IG9mIElQIGFkZHJlc3NlcyBhc3NpZ25lZCB0byB0aGlzIHNlcnZpY2UsIGFuZCBhcmUgdXN1YWxseSBhc3NpZ25lZCByYW5kb21seS4gIElmIGFuIGFkZHJlc3MgaXMgc3BlY2lmaWVkIG1hbnVhbGx5LCBpcyBpbi1yYW5nZSAoYXMgcGVyIHN5c3RlbSBjb25maWd1cmF0aW9uKSwgYW5kIGlzIG5vdCBpbiB1c2UsIGl0IHdpbGwgYmUgYWxsb2NhdGVkIHRvIHRoZSBzZXJ2aWNlOyBvdGhlcndpc2UgY3JlYXRpb24gb2YgdGhlIHNlcnZpY2Ugd2lsbCBmYWlsLiBUaGlzIGZpZWxkIG1heSBub3QgYmUgY2hhbmdlZCB0aHJvdWdoIHVwZGF0ZXMgdW5sZXNzIHRoZSB0eXBlIGZpZWxkIGlzIGFsc28gYmVpbmcgY2hhbmdlZCB0byBFeHRlcm5hbE5hbWUgKHdoaWNoIHJlcXVpcmVzIHRoaXMgZmllbGQgdG8gYmUgZW1wdHkpIG9yIHRoZSB0eXBlIGZpZWxkIGlzIGJlaW5nIGNoYW5nZWQgZnJvbSBFeHRlcm5hbE5hbWUgKGluIHdoaWNoIGNhc2UgdGhpcyBmaWVsZCBtYXkgb3B0aW9uYWxseSBiZSBzcGVjaWZpZWQsIGFzIGRlc2NyaWJlIGFib3ZlKS4gIFZhbGlkIHZhbHVlcyBhcmUgXCJOb25lXCIsIGVtcHR5IHN0cmluZyAoXCJcIiksIG9yIGEgdmFsaWQgSVAgYWRkcmVzcy4gIFNldHRpbmcgdGhpcyB0byBcIk5vbmVcIiBtYWtlcyBhIFwiaGVhZGxlc3Mgc2VydmljZVwiIChubyB2aXJ0dWFsIElQKSwgd2hpY2ggaXMgdXNlZnVsIHdoZW4gZGlyZWN0IGVuZHBvaW50IGNvbm5lY3Rpb25zIGFyZSBwcmVmZXJyZWQgYW5kIHByb3h5aW5nIGlzIG5vdCByZXF1aXJlZC4gIE9ubHkgYXBwbGllcyB0byB0eXBlcyBDbHVzdGVySVAsIE5vZGVQb3J0LCBhbmQgTG9hZEJhbGFuY2VyLiBJZiB0aGlzIGZpZWxkIGlzIHNwZWNpZmllZCB3aGVuIGNyZWF0aW5nIGEgU2VydmljZSBvZiB0eXBlIEV4dGVybmFsTmFtZSwgY3JlYXRpb24gd2lsbCBmYWlsLiBUaGlzIGZpZWxkIHdpbGwgYmUgd2lwZWQgd2hlbiB1cGRhdGluZyBhIFNlcnZpY2UgdG8gdHlwZSBFeHRlcm5hbE5hbWUuICBJZiB0aGlzIGZpZWxkIGlzIG5vdCBzcGVjaWZpZWQsIGl0IHdpbGwgYmUgaW5pdGlhbGl6ZWQgZnJvbSB0aGUgY2x1c3RlcklQIGZpZWxkLiAgSWYgdGhpcyBmaWVsZCBpcyBzcGVjaWZpZWQsIGNsaWVudHMgbXVzdCBlbnN1cmUgdGhhdCBjbHVzdGVySVBzWzBdIGFuZCBjbHVzdGVySVAgaGF2ZSB0aGUgc2FtZSB2YWx1ZS5cbiAgICpcbiAgICogVW5sZXNzIHRoZSBcIklQdjZEdWFsU3RhY2tcIiBmZWF0dXJlIGdhdGUgaXMgZW5hYmxlZCwgdGhpcyBmaWVsZCBpcyBsaW1pdGVkIHRvIG9uZSB2YWx1ZSwgd2hpY2ggbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgY2x1c3RlcklQIGZpZWxkLiAgSWYgdGhlIGZlYXR1cmUgZ2F0ZSBpcyBlbmFibGVkLCB0aGlzIGZpZWxkIG1heSBob2xkIGEgbWF4aW11bSBvZiB0d28gZW50cmllcyAoZHVhbC1zdGFjayBJUHMsIGluIGVpdGhlciBvcmRlcikuICBUaGVzZSBJUHMgbXVzdCBjb3JyZXNwb25kIHRvIHRoZSB2YWx1ZXMgb2YgdGhlIGlwRmFtaWxpZXMgZmllbGQuIEJvdGggY2x1c3RlcklQcyBhbmQgaXBGYW1pbGllcyBhcmUgZ292ZXJuZWQgYnkgdGhlIGlwRmFtaWx5UG9saWN5IGZpZWxkLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3NlcnZpY2VzLW5ldHdvcmtpbmcvc2VydmljZS8jdmlydHVhbC1pcHMtYW5kLXNlcnZpY2UtcHJveGllc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZXJ2aWNlU3BlYyNjbHVzdGVySVBzXG4gICAqL1xuICByZWFkb25seSBjbHVzdGVySVBzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIGV4dGVybmFsSVBzIGlzIGEgbGlzdCBvZiBJUCBhZGRyZXNzZXMgZm9yIHdoaWNoIG5vZGVzIGluIHRoZSBjbHVzdGVyIHdpbGwgYWxzbyBhY2NlcHQgdHJhZmZpYyBmb3IgdGhpcyBzZXJ2aWNlLiAgVGhlc2UgSVBzIGFyZSBub3QgbWFuYWdlZCBieSBLdWJlcm5ldGVzLiAgVGhlIHVzZXIgaXMgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIHRoYXQgdHJhZmZpYyBhcnJpdmVzIGF0IGEgbm9kZSB3aXRoIHRoaXMgSVAuICBBIGNvbW1vbiBleGFtcGxlIGlzIGV4dGVybmFsIGxvYWQtYmFsYW5jZXJzIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIHRoZSBLdWJlcm5ldGVzIHN5c3RlbS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZVNwZWMjZXh0ZXJuYWxJUHNcbiAgICovXG4gIHJlYWRvbmx5IGV4dGVybmFsSVBzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIGV4dGVybmFsTmFtZSBpcyB0aGUgZXh0ZXJuYWwgcmVmZXJlbmNlIHRoYXQgZGlzY292ZXJ5IG1lY2hhbmlzbXMgd2lsbCByZXR1cm4gYXMgYW4gYWxpYXMgZm9yIHRoaXMgc2VydmljZSAoZS5nLiBhIEROUyBDTkFNRSByZWNvcmQpLiBObyBwcm94eWluZyB3aWxsIGJlIGludm9sdmVkLiAgTXVzdCBiZSBhIGxvd2VyY2FzZSBSRkMtMTEyMyBob3N0bmFtZSAoaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzExMjMpIGFuZCByZXF1aXJlcyBgdHlwZWAgdG8gYmUgXCJFeHRlcm5hbE5hbWVcIi5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZVNwZWMjZXh0ZXJuYWxOYW1lXG4gICAqL1xuICByZWFkb25seSBleHRlcm5hbE5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGV4dGVybmFsVHJhZmZpY1BvbGljeSBkZW5vdGVzIGlmIHRoaXMgU2VydmljZSBkZXNpcmVzIHRvIHJvdXRlIGV4dGVybmFsIHRyYWZmaWMgdG8gbm9kZS1sb2NhbCBvciBjbHVzdGVyLXdpZGUgZW5kcG9pbnRzLiBcIkxvY2FsXCIgcHJlc2VydmVzIHRoZSBjbGllbnQgc291cmNlIElQIGFuZCBhdm9pZHMgYSBzZWNvbmQgaG9wIGZvciBMb2FkQmFsYW5jZXIgYW5kIE5vZGVwb3J0IHR5cGUgc2VydmljZXMsIGJ1dCByaXNrcyBwb3RlbnRpYWxseSBpbWJhbGFuY2VkIHRyYWZmaWMgc3ByZWFkaW5nLiBcIkNsdXN0ZXJcIiBvYnNjdXJlcyB0aGUgY2xpZW50IHNvdXJjZSBJUCBhbmQgbWF5IGNhdXNlIGEgc2Vjb25kIGhvcCB0byBhbm90aGVyIG5vZGUsIGJ1dCBzaG91bGQgaGF2ZSBnb29kIG92ZXJhbGwgbG9hZC1zcHJlYWRpbmcuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlcnZpY2VTcGVjI2V4dGVybmFsVHJhZmZpY1BvbGljeVxuICAgKi9cbiAgcmVhZG9ubHkgZXh0ZXJuYWxUcmFmZmljUG9saWN5Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBoZWFsdGhDaGVja05vZGVQb3J0IHNwZWNpZmllcyB0aGUgaGVhbHRoY2hlY2sgbm9kZVBvcnQgZm9yIHRoZSBzZXJ2aWNlLiBUaGlzIG9ubHkgYXBwbGllcyB3aGVuIHR5cGUgaXMgc2V0IHRvIExvYWRCYWxhbmNlciBhbmQgZXh0ZXJuYWxUcmFmZmljUG9saWN5IGlzIHNldCB0byBMb2NhbC4gSWYgYSB2YWx1ZSBpcyBzcGVjaWZpZWQsIGlzIGluLXJhbmdlLCBhbmQgaXMgbm90IGluIHVzZSwgaXQgd2lsbCBiZSB1c2VkLiAgSWYgbm90IHNwZWNpZmllZCwgYSB2YWx1ZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYWxsb2NhdGVkLiAgRXh0ZXJuYWwgc3lzdGVtcyAoZS5nLiBsb2FkLWJhbGFuY2VycykgY2FuIHVzZSB0aGlzIHBvcnQgdG8gZGV0ZXJtaW5lIGlmIGEgZ2l2ZW4gbm9kZSBob2xkcyBlbmRwb2ludHMgZm9yIHRoaXMgc2VydmljZSBvciBub3QuICBJZiB0aGlzIGZpZWxkIGlzIHNwZWNpZmllZCB3aGVuIGNyZWF0aW5nIGEgU2VydmljZSB3aGljaCBkb2VzIG5vdCBuZWVkIGl0LCBjcmVhdGlvbiB3aWxsIGZhaWwuIFRoaXMgZmllbGQgd2lsbCBiZSB3aXBlZCB3aGVuIHVwZGF0aW5nIGEgU2VydmljZSB0byBubyBsb25nZXIgbmVlZCBpdCAoZS5nLiBjaGFuZ2luZyB0eXBlKS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZVNwZWMjaGVhbHRoQ2hlY2tOb2RlUG9ydFxuICAgKi9cbiAgcmVhZG9ubHkgaGVhbHRoQ2hlY2tOb2RlUG9ydD86IG51bWJlcjtcblxuICAvKipcbiAgICogSW50ZXJuYWxUcmFmZmljUG9saWN5IHNwZWNpZmllcyBpZiB0aGUgY2x1c3RlciBpbnRlcm5hbCB0cmFmZmljIHNob3VsZCBiZSByb3V0ZWQgdG8gYWxsIGVuZHBvaW50cyBvciBub2RlLWxvY2FsIGVuZHBvaW50cyBvbmx5LiBcIkNsdXN0ZXJcIiByb3V0ZXMgaW50ZXJuYWwgdHJhZmZpYyB0byBhIFNlcnZpY2UgdG8gYWxsIGVuZHBvaW50cy4gXCJMb2NhbFwiIHJvdXRlcyB0cmFmZmljIHRvIG5vZGUtbG9jYWwgZW5kcG9pbnRzIG9ubHksIHRyYWZmaWMgaXMgZHJvcHBlZCBpZiBubyBub2RlLWxvY2FsIGVuZHBvaW50cyBhcmUgcmVhZHkuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIFwiQ2x1c3RlclwiLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZXJ2aWNlU3BlYyNpbnRlcm5hbFRyYWZmaWNQb2xpY3lcbiAgICovXG4gIHJlYWRvbmx5IGludGVybmFsVHJhZmZpY1BvbGljeT86IHN0cmluZztcblxuICAvKipcbiAgICogSVBGYW1pbGllcyBpcyBhIGxpc3Qgb2YgSVAgZmFtaWxpZXMgKGUuZy4gSVB2NCwgSVB2NikgYXNzaWduZWQgdG8gdGhpcyBzZXJ2aWNlLCBhbmQgaXMgZ2F0ZWQgYnkgdGhlIFwiSVB2NkR1YWxTdGFja1wiIGZlYXR1cmUgZ2F0ZS4gIFRoaXMgZmllbGQgaXMgdXN1YWxseSBhc3NpZ25lZCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIGNsdXN0ZXIgY29uZmlndXJhdGlvbiBhbmQgdGhlIGlwRmFtaWx5UG9saWN5IGZpZWxkLiBJZiB0aGlzIGZpZWxkIGlzIHNwZWNpZmllZCBtYW51YWxseSwgdGhlIHJlcXVlc3RlZCBmYW1pbHkgaXMgYXZhaWxhYmxlIGluIHRoZSBjbHVzdGVyLCBhbmQgaXBGYW1pbHlQb2xpY3kgYWxsb3dzIGl0LCBpdCB3aWxsIGJlIHVzZWQ7IG90aGVyd2lzZSBjcmVhdGlvbiBvZiB0aGUgc2VydmljZSB3aWxsIGZhaWwuICBUaGlzIGZpZWxkIGlzIGNvbmRpdGlvbmFsbHkgbXV0YWJsZTogaXQgYWxsb3dzIGZvciBhZGRpbmcgb3IgcmVtb3ZpbmcgYSBzZWNvbmRhcnkgSVAgZmFtaWx5LCBidXQgaXQgZG9lcyBub3QgYWxsb3cgY2hhbmdpbmcgdGhlIHByaW1hcnkgSVAgZmFtaWx5IG9mIHRoZSBTZXJ2aWNlLiAgVmFsaWQgdmFsdWVzIGFyZSBcIklQdjRcIiBhbmQgXCJJUHY2XCIuICBUaGlzIGZpZWxkIG9ubHkgYXBwbGllcyB0byBTZXJ2aWNlcyBvZiB0eXBlcyBDbHVzdGVySVAsIE5vZGVQb3J0LCBhbmQgTG9hZEJhbGFuY2VyLCBhbmQgZG9lcyBhcHBseSB0byBcImhlYWRsZXNzXCIgc2VydmljZXMuICBUaGlzIGZpZWxkIHdpbGwgYmUgd2lwZWQgd2hlbiB1cGRhdGluZyBhIFNlcnZpY2UgdG8gdHlwZSBFeHRlcm5hbE5hbWUuXG4gICAqXG4gICAqIFRoaXMgZmllbGQgbWF5IGhvbGQgYSBtYXhpbXVtIG9mIHR3byBlbnRyaWVzIChkdWFsLXN0YWNrIGZhbWlsaWVzLCBpbiBlaXRoZXIgb3JkZXIpLiAgVGhlc2UgZmFtaWxpZXMgbXVzdCBjb3JyZXNwb25kIHRvIHRoZSB2YWx1ZXMgb2YgdGhlIGNsdXN0ZXJJUHMgZmllbGQsIGlmIHNwZWNpZmllZC4gQm90aCBjbHVzdGVySVBzIGFuZCBpcEZhbWlsaWVzIGFyZSBnb3Zlcm5lZCBieSB0aGUgaXBGYW1pbHlQb2xpY3kgZmllbGQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlcnZpY2VTcGVjI2lwRmFtaWxpZXNcbiAgICovXG4gIHJlYWRvbmx5IGlwRmFtaWxpZXM/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogSVBGYW1pbHlQb2xpY3kgcmVwcmVzZW50cyB0aGUgZHVhbC1zdGFjay1uZXNzIHJlcXVlc3RlZCBvciByZXF1aXJlZCBieSB0aGlzIFNlcnZpY2UsIGFuZCBpcyBnYXRlZCBieSB0aGUgXCJJUHY2RHVhbFN0YWNrXCIgZmVhdHVyZSBnYXRlLiAgSWYgdGhlcmUgaXMgbm8gdmFsdWUgcHJvdmlkZWQsIHRoZW4gdGhpcyBmaWVsZCB3aWxsIGJlIHNldCB0byBTaW5nbGVTdGFjay4gU2VydmljZXMgY2FuIGJlIFwiU2luZ2xlU3RhY2tcIiAoYSBzaW5nbGUgSVAgZmFtaWx5KSwgXCJQcmVmZXJEdWFsU3RhY2tcIiAodHdvIElQIGZhbWlsaWVzIG9uIGR1YWwtc3RhY2sgY29uZmlndXJlZCBjbHVzdGVycyBvciBhIHNpbmdsZSBJUCBmYW1pbHkgb24gc2luZ2xlLXN0YWNrIGNsdXN0ZXJzKSwgb3IgXCJSZXF1aXJlRHVhbFN0YWNrXCIgKHR3byBJUCBmYW1pbGllcyBvbiBkdWFsLXN0YWNrIGNvbmZpZ3VyZWQgY2x1c3RlcnMsIG90aGVyd2lzZSBmYWlsKS4gVGhlIGlwRmFtaWxpZXMgYW5kIGNsdXN0ZXJJUHMgZmllbGRzIGRlcGVuZCBvbiB0aGUgdmFsdWUgb2YgdGhpcyBmaWVsZC4gIFRoaXMgZmllbGQgd2lsbCBiZSB3aXBlZCB3aGVuIHVwZGF0aW5nIGEgc2VydmljZSB0byB0eXBlIEV4dGVybmFsTmFtZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZVNwZWMjaXBGYW1pbHlQb2xpY3lcbiAgICovXG4gIHJlYWRvbmx5IGlwRmFtaWx5UG9saWN5Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBsb2FkQmFsYW5jZXJDbGFzcyBpcyB0aGUgY2xhc3Mgb2YgdGhlIGxvYWQgYmFsYW5jZXIgaW1wbGVtZW50YXRpb24gdGhpcyBTZXJ2aWNlIGJlbG9uZ3MgdG8uIElmIHNwZWNpZmllZCwgdGhlIHZhbHVlIG9mIHRoaXMgZmllbGQgbXVzdCBiZSBhIGxhYmVsLXN0eWxlIGlkZW50aWZpZXIsIHdpdGggYW4gb3B0aW9uYWwgcHJlZml4LCBlLmcuIFwiaW50ZXJuYWwtdmlwXCIgb3IgXCJleGFtcGxlLmNvbS9pbnRlcm5hbC12aXBcIi4gVW5wcmVmaXhlZCBuYW1lcyBhcmUgcmVzZXJ2ZWQgZm9yIGVuZC11c2Vycy4gVGhpcyBmaWVsZCBjYW4gb25seSBiZSBzZXQgd2hlbiB0aGUgU2VydmljZSB0eXBlIGlzICdMb2FkQmFsYW5jZXInLiBJZiBub3Qgc2V0LCB0aGUgZGVmYXVsdCBsb2FkIGJhbGFuY2VyIGltcGxlbWVudGF0aW9uIGlzIHVzZWQsIHRvZGF5IHRoaXMgaXMgdHlwaWNhbGx5IGRvbmUgdGhyb3VnaCB0aGUgY2xvdWQgcHJvdmlkZXIgaW50ZWdyYXRpb24sIGJ1dCBzaG91bGQgYXBwbHkgZm9yIGFueSBkZWZhdWx0IGltcGxlbWVudGF0aW9uLiBJZiBzZXQsIGl0IGlzIGFzc3VtZWQgdGhhdCBhIGxvYWQgYmFsYW5jZXIgaW1wbGVtZW50YXRpb24gaXMgd2F0Y2hpbmcgZm9yIFNlcnZpY2VzIHdpdGggYSBtYXRjaGluZyBjbGFzcy4gQW55IGRlZmF1bHQgbG9hZCBiYWxhbmNlciBpbXBsZW1lbnRhdGlvbiAoZS5nLiBjbG91ZCBwcm92aWRlcnMpIHNob3VsZCBpZ25vcmUgU2VydmljZXMgdGhhdCBzZXQgdGhpcyBmaWVsZC4gVGhpcyBmaWVsZCBjYW4gb25seSBiZSBzZXQgd2hlbiBjcmVhdGluZyBvciB1cGRhdGluZyBhIFNlcnZpY2UgdG8gdHlwZSAnTG9hZEJhbGFuY2VyJy4gT25jZSBzZXQsIGl0IGNhbiBub3QgYmUgY2hhbmdlZC4gVGhpcyBmaWVsZCB3aWxsIGJlIHdpcGVkIHdoZW4gYSBzZXJ2aWNlIGlzIHVwZGF0ZWQgdG8gYSBub24gJ0xvYWRCYWxhbmNlcicgdHlwZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZVNwZWMjbG9hZEJhbGFuY2VyQ2xhc3NcbiAgICovXG4gIHJlYWRvbmx5IGxvYWRCYWxhbmNlckNsYXNzPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBPbmx5IGFwcGxpZXMgdG8gU2VydmljZSBUeXBlOiBMb2FkQmFsYW5jZXIgTG9hZEJhbGFuY2VyIHdpbGwgZ2V0IGNyZWF0ZWQgd2l0aCB0aGUgSVAgc3BlY2lmaWVkIGluIHRoaXMgZmllbGQuIFRoaXMgZmVhdHVyZSBkZXBlbmRzIG9uIHdoZXRoZXIgdGhlIHVuZGVybHlpbmcgY2xvdWQtcHJvdmlkZXIgc3VwcG9ydHMgc3BlY2lmeWluZyB0aGUgbG9hZEJhbGFuY2VySVAgd2hlbiBhIGxvYWQgYmFsYW5jZXIgaXMgY3JlYXRlZC4gVGhpcyBmaWVsZCB3aWxsIGJlIGlnbm9yZWQgaWYgdGhlIGNsb3VkLXByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgdGhlIGZlYXR1cmUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlcnZpY2VTcGVjI2xvYWRCYWxhbmNlcklQXG4gICAqL1xuICByZWFkb25seSBsb2FkQmFsYW5jZXJJcD86IHN0cmluZztcblxuICAvKipcbiAgICogSWYgc3BlY2lmaWVkIGFuZCBzdXBwb3J0ZWQgYnkgdGhlIHBsYXRmb3JtLCB0aGlzIHdpbGwgcmVzdHJpY3QgdHJhZmZpYyB0aHJvdWdoIHRoZSBjbG91ZC1wcm92aWRlciBsb2FkLWJhbGFuY2VyIHdpbGwgYmUgcmVzdHJpY3RlZCB0byB0aGUgc3BlY2lmaWVkIGNsaWVudCBJUHMuIFRoaXMgZmllbGQgd2lsbCBiZSBpZ25vcmVkIGlmIHRoZSBjbG91ZC1wcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBmZWF0dXJlLlwiIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvdGFza3MvYWNjZXNzLWFwcGxpY2F0aW9uLWNsdXN0ZXIvY3JlYXRlLWV4dGVybmFsLWxvYWQtYmFsYW5jZXIvXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlcnZpY2VTcGVjI2xvYWRCYWxhbmNlclNvdXJjZVJhbmdlc1xuICAgKi9cbiAgcmVhZG9ubHkgbG9hZEJhbGFuY2VyU291cmNlUmFuZ2VzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIHBvcnRzIHRoYXQgYXJlIGV4cG9zZWQgYnkgdGhpcyBzZXJ2aWNlLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3NlcnZpY2VzLW5ldHdvcmtpbmcvc2VydmljZS8jdmlydHVhbC1pcHMtYW5kLXNlcnZpY2UtcHJveGllc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZXJ2aWNlU3BlYyNwb3J0c1xuICAgKi9cbiAgcmVhZG9ubHkgcG9ydHM/OiBTZXJ2aWNlUG9ydFtdO1xuXG4gIC8qKlxuICAgKiBwdWJsaXNoTm90UmVhZHlBZGRyZXNzZXMgaW5kaWNhdGVzIHRoYXQgYW55IGFnZW50IHdoaWNoIGRlYWxzIHdpdGggZW5kcG9pbnRzIGZvciB0aGlzIFNlcnZpY2Ugc2hvdWxkIGRpc3JlZ2FyZCBhbnkgaW5kaWNhdGlvbnMgb2YgcmVhZHkvbm90LXJlYWR5LiBUaGUgcHJpbWFyeSB1c2UgY2FzZSBmb3Igc2V0dGluZyB0aGlzIGZpZWxkIGlzIGZvciBhIFN0YXRlZnVsU2V0J3MgSGVhZGxlc3MgU2VydmljZSB0byBwcm9wYWdhdGUgU1JWIEROUyByZWNvcmRzIGZvciBpdHMgUG9kcyBmb3IgdGhlIHB1cnBvc2Ugb2YgcGVlciBkaXNjb3ZlcnkuIFRoZSBLdWJlcm5ldGVzIGNvbnRyb2xsZXJzIHRoYXQgZ2VuZXJhdGUgRW5kcG9pbnRzIGFuZCBFbmRwb2ludFNsaWNlIHJlc291cmNlcyBmb3IgU2VydmljZXMgaW50ZXJwcmV0IHRoaXMgdG8gbWVhbiB0aGF0IGFsbCBlbmRwb2ludHMgYXJlIGNvbnNpZGVyZWQgXCJyZWFkeVwiIGV2ZW4gaWYgdGhlIFBvZHMgdGhlbXNlbHZlcyBhcmUgbm90LiBBZ2VudHMgd2hpY2ggY29uc3VtZSBvbmx5IEt1YmVybmV0ZXMgZ2VuZXJhdGVkIGVuZHBvaW50cyB0aHJvdWdoIHRoZSBFbmRwb2ludHMgb3IgRW5kcG9pbnRTbGljZSByZXNvdXJjZXMgY2FuIHNhZmVseSBhc3N1bWUgdGhpcyBiZWhhdmlvci5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZVNwZWMjcHVibGlzaE5vdFJlYWR5QWRkcmVzc2VzXG4gICAqL1xuICByZWFkb25seSBwdWJsaXNoTm90UmVhZHlBZGRyZXNzZXM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBSb3V0ZSBzZXJ2aWNlIHRyYWZmaWMgdG8gcG9kcyB3aXRoIGxhYmVsIGtleXMgYW5kIHZhbHVlcyBtYXRjaGluZyB0aGlzIHNlbGVjdG9yLiBJZiBlbXB0eSBvciBub3QgcHJlc2VudCwgdGhlIHNlcnZpY2UgaXMgYXNzdW1lZCB0byBoYXZlIGFuIGV4dGVybmFsIHByb2Nlc3MgbWFuYWdpbmcgaXRzIGVuZHBvaW50cywgd2hpY2ggS3ViZXJuZXRlcyB3aWxsIG5vdCBtb2RpZnkuIE9ubHkgYXBwbGllcyB0byB0eXBlcyBDbHVzdGVySVAsIE5vZGVQb3J0LCBhbmQgTG9hZEJhbGFuY2VyLiBJZ25vcmVkIGlmIHR5cGUgaXMgRXh0ZXJuYWxOYW1lLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3NlcnZpY2VzLW5ldHdvcmtpbmcvc2VydmljZS9cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZVNwZWMjc2VsZWN0b3JcbiAgICovXG4gIHJlYWRvbmx5IHNlbGVjdG9yPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcblxuICAvKipcbiAgICogU3VwcG9ydHMgXCJDbGllbnRJUFwiIGFuZCBcIk5vbmVcIi4gVXNlZCB0byBtYWludGFpbiBzZXNzaW9uIGFmZmluaXR5LiBFbmFibGUgY2xpZW50IElQIGJhc2VkIHNlc3Npb24gYWZmaW5pdHkuIE11c3QgYmUgQ2xpZW50SVAgb3IgTm9uZS4gRGVmYXVsdHMgdG8gTm9uZS4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zZXJ2aWNlcy1uZXR3b3JraW5nL3NlcnZpY2UvI3ZpcnR1YWwtaXBzLWFuZC1zZXJ2aWNlLXByb3hpZXNcbiAgICpcbiAgICogQGRlZmF1bHQgTm9uZS4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zZXJ2aWNlcy1uZXR3b3JraW5nL3NlcnZpY2UvI3ZpcnR1YWwtaXBzLWFuZC1zZXJ2aWNlLXByb3hpZXNcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZVNwZWMjc2Vzc2lvbkFmZmluaXR5XG4gICAqL1xuICByZWFkb25seSBzZXNzaW9uQWZmaW5pdHk/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIHNlc3Npb25BZmZpbml0eUNvbmZpZyBjb250YWlucyB0aGUgY29uZmlndXJhdGlvbnMgb2Ygc2Vzc2lvbiBhZmZpbml0eS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZVNwZWMjc2Vzc2lvbkFmZmluaXR5Q29uZmlnXG4gICAqL1xuICByZWFkb25seSBzZXNzaW9uQWZmaW5pdHlDb25maWc/OiBTZXNzaW9uQWZmaW5pdHlDb25maWc7XG5cbiAgLyoqXG4gICAqIHR5cGUgZGV0ZXJtaW5lcyBob3cgdGhlIFNlcnZpY2UgaXMgZXhwb3NlZC4gRGVmYXVsdHMgdG8gQ2x1c3RlcklQLiBWYWxpZCBvcHRpb25zIGFyZSBFeHRlcm5hbE5hbWUsIENsdXN0ZXJJUCwgTm9kZVBvcnQsIGFuZCBMb2FkQmFsYW5jZXIuIFwiQ2x1c3RlcklQXCIgYWxsb2NhdGVzIGEgY2x1c3Rlci1pbnRlcm5hbCBJUCBhZGRyZXNzIGZvciBsb2FkLWJhbGFuY2luZyB0byBlbmRwb2ludHMuIEVuZHBvaW50cyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgc2VsZWN0b3Igb3IgaWYgdGhhdCBpcyBub3Qgc3BlY2lmaWVkLCBieSBtYW51YWwgY29uc3RydWN0aW9uIG9mIGFuIEVuZHBvaW50cyBvYmplY3Qgb3IgRW5kcG9pbnRTbGljZSBvYmplY3RzLiBJZiBjbHVzdGVySVAgaXMgXCJOb25lXCIsIG5vIHZpcnR1YWwgSVAgaXMgYWxsb2NhdGVkIGFuZCB0aGUgZW5kcG9pbnRzIGFyZSBwdWJsaXNoZWQgYXMgYSBzZXQgb2YgZW5kcG9pbnRzIHJhdGhlciB0aGFuIGEgdmlydHVhbCBJUC4gXCJOb2RlUG9ydFwiIGJ1aWxkcyBvbiBDbHVzdGVySVAgYW5kIGFsbG9jYXRlcyBhIHBvcnQgb24gZXZlcnkgbm9kZSB3aGljaCByb3V0ZXMgdG8gdGhlIHNhbWUgZW5kcG9pbnRzIGFzIHRoZSBjbHVzdGVySVAuIFwiTG9hZEJhbGFuY2VyXCIgYnVpbGRzIG9uIE5vZGVQb3J0IGFuZCBjcmVhdGVzIGFuIGV4dGVybmFsIGxvYWQtYmFsYW5jZXIgKGlmIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBjbG91ZCkgd2hpY2ggcm91dGVzIHRvIHRoZSBzYW1lIGVuZHBvaW50cyBhcyB0aGUgY2x1c3RlcklQLiBcIkV4dGVybmFsTmFtZVwiIGFsaWFzZXMgdGhpcyBzZXJ2aWNlIHRvIHRoZSBzcGVjaWZpZWQgZXh0ZXJuYWxOYW1lLiBTZXZlcmFsIG90aGVyIGZpZWxkcyBkbyBub3QgYXBwbHkgdG8gRXh0ZXJuYWxOYW1lIHNlcnZpY2VzLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3NlcnZpY2VzLW5ldHdvcmtpbmcvc2VydmljZS8jcHVibGlzaGluZy1zZXJ2aWNlcy1zZXJ2aWNlLXR5cGVzXG4gICAqXG4gICAqIEBkZWZhdWx0IENsdXN0ZXJJUC4gVmFsaWQgb3B0aW9ucyBhcmUgRXh0ZXJuYWxOYW1lLCBDbHVzdGVySVAsIE5vZGVQb3J0LCBhbmQgTG9hZEJhbGFuY2VyLiBcIkNsdXN0ZXJJUFwiIGFsbG9jYXRlcyBhIGNsdXN0ZXItaW50ZXJuYWwgSVAgYWRkcmVzcyBmb3IgbG9hZC1iYWxhbmNpbmcgdG8gZW5kcG9pbnRzLiBFbmRwb2ludHMgYXJlIGRldGVybWluZWQgYnkgdGhlIHNlbGVjdG9yIG9yIGlmIHRoYXQgaXMgbm90IHNwZWNpZmllZCwgYnkgbWFudWFsIGNvbnN0cnVjdGlvbiBvZiBhbiBFbmRwb2ludHMgb2JqZWN0IG9yIEVuZHBvaW50U2xpY2Ugb2JqZWN0cy4gSWYgY2x1c3RlcklQIGlzIFwiTm9uZVwiLCBubyB2aXJ0dWFsIElQIGlzIGFsbG9jYXRlZCBhbmQgdGhlIGVuZHBvaW50cyBhcmUgcHVibGlzaGVkIGFzIGEgc2V0IG9mIGVuZHBvaW50cyByYXRoZXIgdGhhbiBhIHZpcnR1YWwgSVAuIFwiTm9kZVBvcnRcIiBidWlsZHMgb24gQ2x1c3RlcklQIGFuZCBhbGxvY2F0ZXMgYSBwb3J0IG9uIGV2ZXJ5IG5vZGUgd2hpY2ggcm91dGVzIHRvIHRoZSBzYW1lIGVuZHBvaW50cyBhcyB0aGUgY2x1c3RlcklQLiBcIkxvYWRCYWxhbmNlclwiIGJ1aWxkcyBvbiBOb2RlUG9ydCBhbmQgY3JlYXRlcyBhbiBleHRlcm5hbCBsb2FkLWJhbGFuY2VyIChpZiBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgY2xvdWQpIHdoaWNoIHJvdXRlcyB0byB0aGUgc2FtZSBlbmRwb2ludHMgYXMgdGhlIGNsdXN0ZXJJUC4gXCJFeHRlcm5hbE5hbWVcIiBhbGlhc2VzIHRoaXMgc2VydmljZSB0byB0aGUgc3BlY2lmaWVkIGV4dGVybmFsTmFtZS4gU2V2ZXJhbCBvdGhlciBmaWVsZHMgZG8gbm90IGFwcGx5IHRvIEV4dGVybmFsTmFtZSBzZXJ2aWNlcy4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zZXJ2aWNlcy1uZXR3b3JraW5nL3NlcnZpY2UvI3B1Ymxpc2hpbmctc2VydmljZXMtc2VydmljZS10eXBlc1xuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZXJ2aWNlU3BlYyN0eXBlXG4gICAqL1xuICByZWFkb25seSB0eXBlPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1NlcnZpY2VTcGVjJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9TZXJ2aWNlU3BlYyhvYmo6IFNlcnZpY2VTcGVjIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnYWxsb2NhdGVMb2FkQmFsYW5jZXJOb2RlUG9ydHMnOiBvYmouYWxsb2NhdGVMb2FkQmFsYW5jZXJOb2RlUG9ydHMsXG4gICAgJ2NsdXN0ZXJJUCc6IG9iai5jbHVzdGVySXAsXG4gICAgJ2NsdXN0ZXJJUHMnOiBvYmouY2x1c3RlcklQcz8ubWFwKHkgPT4geSksXG4gICAgJ2V4dGVybmFsSVBzJzogb2JqLmV4dGVybmFsSVBzPy5tYXAoeSA9PiB5KSxcbiAgICAnZXh0ZXJuYWxOYW1lJzogb2JqLmV4dGVybmFsTmFtZSxcbiAgICAnZXh0ZXJuYWxUcmFmZmljUG9saWN5Jzogb2JqLmV4dGVybmFsVHJhZmZpY1BvbGljeSxcbiAgICAnaGVhbHRoQ2hlY2tOb2RlUG9ydCc6IG9iai5oZWFsdGhDaGVja05vZGVQb3J0LFxuICAgICdpbnRlcm5hbFRyYWZmaWNQb2xpY3knOiBvYmouaW50ZXJuYWxUcmFmZmljUG9saWN5LFxuICAgICdpcEZhbWlsaWVzJzogb2JqLmlwRmFtaWxpZXM/Lm1hcCh5ID0+IHkpLFxuICAgICdpcEZhbWlseVBvbGljeSc6IG9iai5pcEZhbWlseVBvbGljeSxcbiAgICAnbG9hZEJhbGFuY2VyQ2xhc3MnOiBvYmoubG9hZEJhbGFuY2VyQ2xhc3MsXG4gICAgJ2xvYWRCYWxhbmNlcklQJzogb2JqLmxvYWRCYWxhbmNlcklwLFxuICAgICdsb2FkQmFsYW5jZXJTb3VyY2VSYW5nZXMnOiBvYmoubG9hZEJhbGFuY2VyU291cmNlUmFuZ2VzPy5tYXAoeSA9PiB5KSxcbiAgICAncG9ydHMnOiBvYmoucG9ydHM/Lm1hcCh5ID0+IHRvSnNvbl9TZXJ2aWNlUG9ydCh5KSksXG4gICAgJ3B1Ymxpc2hOb3RSZWFkeUFkZHJlc3Nlcyc6IG9iai5wdWJsaXNoTm90UmVhZHlBZGRyZXNzZXMsXG4gICAgJ3NlbGVjdG9yJzogKChvYmouc2VsZWN0b3IpID09PSB1bmRlZmluZWQpID8gdW5kZWZpbmVkIDogKE9iamVjdC5lbnRyaWVzKG9iai5zZWxlY3RvcikucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KSksXG4gICAgJ3Nlc3Npb25BZmZpbml0eSc6IG9iai5zZXNzaW9uQWZmaW5pdHksXG4gICAgJ3Nlc3Npb25BZmZpbml0eUNvbmZpZyc6IHRvSnNvbl9TZXNzaW9uQWZmaW5pdHlDb25maWcob2JqLnNlc3Npb25BZmZpbml0eUNvbmZpZyksXG4gICAgJ3R5cGUnOiBvYmoudHlwZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBMb2NhbE9iamVjdFJlZmVyZW5jZSBjb250YWlucyBlbm91Z2ggaW5mb3JtYXRpb24gdG8gbGV0IHlvdSBsb2NhdGUgdGhlIHJlZmVyZW5jZWQgb2JqZWN0IGluc2lkZSB0aGUgc2FtZSBuYW1lc3BhY2UuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTG9jYWxPYmplY3RSZWZlcmVuY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMb2NhbE9iamVjdFJlZmVyZW5jZSB7XG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSByZWZlcmVudC4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9vdmVydmlldy93b3JraW5nLXdpdGgtb2JqZWN0cy9uYW1lcy8jbmFtZXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTG9jYWxPYmplY3RSZWZlcmVuY2UjbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdMb2NhbE9iamVjdFJlZmVyZW5jZScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fTG9jYWxPYmplY3RSZWZlcmVuY2Uob2JqOiBMb2NhbE9iamVjdFJlZmVyZW5jZSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ25hbWUnOiBvYmoubmFtZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBFbmRwb2ludCByZXByZXNlbnRzIGEgc2luZ2xlIGxvZ2ljYWwgXCJiYWNrZW5kXCIgaW1wbGVtZW50aW5nIGEgc2VydmljZS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuZGlzY292ZXJ5LnYxLkVuZHBvaW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRW5kcG9pbnQge1xuICAvKipcbiAgICogYWRkcmVzc2VzIG9mIHRoaXMgZW5kcG9pbnQuIFRoZSBjb250ZW50cyBvZiB0aGlzIGZpZWxkIGFyZSBpbnRlcnByZXRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgRW5kcG9pbnRTbGljZSBhZGRyZXNzVHlwZSBmaWVsZC4gQ29uc3VtZXJzIG11c3QgaGFuZGxlIGRpZmZlcmVudCB0eXBlcyBvZiBhZGRyZXNzZXMgaW4gdGhlIGNvbnRleHQgb2YgdGhlaXIgb3duIGNhcGFiaWxpdGllcy4gVGhpcyBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGFkZHJlc3MgYnV0IG5vIG1vcmUgdGhhbiAxMDAuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjEuRW5kcG9pbnQjYWRkcmVzc2VzXG4gICAqL1xuICByZWFkb25seSBhZGRyZXNzZXM6IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBjb25kaXRpb25zIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgZW5kcG9pbnQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjEuRW5kcG9pbnQjY29uZGl0aW9uc1xuICAgKi9cbiAgcmVhZG9ubHkgY29uZGl0aW9ucz86IEVuZHBvaW50Q29uZGl0aW9ucztcblxuICAvKipcbiAgICogZGVwcmVjYXRlZFRvcG9sb2d5IGNvbnRhaW5zIHRvcG9sb2d5IGluZm9ybWF0aW9uIHBhcnQgb2YgdGhlIHYxYmV0YTEgQVBJLiBUaGlzIGZpZWxkIGlzIGRlcHJlY2F0ZWQsIGFuZCB3aWxsIGJlIHJlbW92ZWQgd2hlbiB0aGUgdjFiZXRhMSBBUEkgaXMgcmVtb3ZlZCAobm8gc29vbmVyIHRoYW4ga3ViZXJuZXRlcyB2MS4yNCkuICBXaGlsZSB0aGlzIGZpZWxkIGNhbiBob2xkIHZhbHVlcywgaXQgaXMgbm90IHdyaXRhYmxlIHRocm91Z2ggdGhlIHYxIEFQSSwgYW5kIGFueSBhdHRlbXB0cyB0byB3cml0ZSB0byBpdCB3aWxsIGJlIHNpbGVudGx5IGlnbm9yZWQuIFRvcG9sb2d5IGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiB0aGUgem9uZSBhbmQgbm9kZU5hbWUgZmllbGRzIGluc3RlYWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjEuRW5kcG9pbnQjZGVwcmVjYXRlZFRvcG9sb2d5XG4gICAqL1xuICByZWFkb25seSBkZXByZWNhdGVkVG9wb2xvZ3k/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXG4gIC8qKlxuICAgKiBoaW50cyBjb250YWlucyBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggaG93IGFuIGVuZHBvaW50IHNob3VsZCBiZSBjb25zdW1lZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmRpc2NvdmVyeS52MS5FbmRwb2ludCNoaW50c1xuICAgKi9cbiAgcmVhZG9ubHkgaGludHM/OiBFbmRwb2ludEhpbnRzO1xuXG4gIC8qKlxuICAgKiBob3N0bmFtZSBvZiB0aGlzIGVuZHBvaW50LiBUaGlzIGZpZWxkIG1heSBiZSB1c2VkIGJ5IGNvbnN1bWVycyBvZiBlbmRwb2ludHMgdG8gZGlzdGluZ3Vpc2ggZW5kcG9pbnRzIGZyb20gZWFjaCBvdGhlciAoZS5nLiBpbiBETlMgbmFtZXMpLiBNdWx0aXBsZSBlbmRwb2ludHMgd2hpY2ggdXNlIHRoZSBzYW1lIGhvc3RuYW1lIHNob3VsZCBiZSBjb25zaWRlcmVkIGZ1bmdpYmxlIChlLmcuIG11bHRpcGxlIEEgdmFsdWVzIGluIEROUykuIE11c3QgYmUgbG93ZXJjYXNlIGFuZCBwYXNzIEROUyBMYWJlbCAoUkZDIDExMjMpIHZhbGlkYXRpb24uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjEuRW5kcG9pbnQjaG9zdG5hbWVcbiAgICovXG4gIHJlYWRvbmx5IGhvc3RuYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBub2RlTmFtZSByZXByZXNlbnRzIHRoZSBuYW1lIG9mIHRoZSBOb2RlIGhvc3RpbmcgdGhpcyBlbmRwb2ludC4gVGhpcyBjYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgZW5kcG9pbnRzIGxvY2FsIHRvIGEgTm9kZS4gVGhpcyBmaWVsZCBjYW4gYmUgZW5hYmxlZCB3aXRoIHRoZSBFbmRwb2ludFNsaWNlTm9kZU5hbWUgZmVhdHVyZSBnYXRlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZGlzY292ZXJ5LnYxLkVuZHBvaW50I25vZGVOYW1lXG4gICAqL1xuICByZWFkb25seSBub2RlTmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogdGFyZ2V0UmVmIGlzIGEgcmVmZXJlbmNlIHRvIGEgS3ViZXJuZXRlcyBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoaXMgZW5kcG9pbnQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjEuRW5kcG9pbnQjdGFyZ2V0UmVmXG4gICAqL1xuICByZWFkb25seSB0YXJnZXRSZWY/OiBPYmplY3RSZWZlcmVuY2U7XG5cbiAgLyoqXG4gICAqIHpvbmUgaXMgdGhlIG5hbWUgb2YgdGhlIFpvbmUgdGhpcyBlbmRwb2ludCBleGlzdHMgaW4uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjEuRW5kcG9pbnQjem9uZVxuICAgKi9cbiAgcmVhZG9ubHkgem9uZT86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdFbmRwb2ludCcgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fRW5kcG9pbnQob2JqOiBFbmRwb2ludCB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2FkZHJlc3Nlcyc6IG9iai5hZGRyZXNzZXM/Lm1hcCh5ID0+IHkpLFxuICAgICdjb25kaXRpb25zJzogdG9Kc29uX0VuZHBvaW50Q29uZGl0aW9ucyhvYmouY29uZGl0aW9ucyksXG4gICAgJ2RlcHJlY2F0ZWRUb3BvbG9neSc6ICgob2JqLmRlcHJlY2F0ZWRUb3BvbG9neSkgPT09IHVuZGVmaW5lZCkgPyB1bmRlZmluZWQgOiAoT2JqZWN0LmVudHJpZXMob2JqLmRlcHJlY2F0ZWRUb3BvbG9neSkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KSksXG4gICAgJ2hpbnRzJzogdG9Kc29uX0VuZHBvaW50SGludHMob2JqLmhpbnRzKSxcbiAgICAnaG9zdG5hbWUnOiBvYmouaG9zdG5hbWUsXG4gICAgJ25vZGVOYW1lJzogb2JqLm5vZGVOYW1lLFxuICAgICd0YXJnZXRSZWYnOiB0b0pzb25fT2JqZWN0UmVmZXJlbmNlKG9iai50YXJnZXRSZWYpLFxuICAgICd6b25lJzogb2JqLnpvbmUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogRW5kcG9pbnRQb3J0IGlzIGEgdHVwbGUgdGhhdCBkZXNjcmliZXMgYSBzaW5nbGUgcG9ydC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FbmRwb2ludFBvcnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFbmRwb2ludFBvcnQge1xuICAvKipcbiAgICogVGhlIGFwcGxpY2F0aW9uIHByb3RvY29sIGZvciB0aGlzIHBvcnQuIFRoaXMgZmllbGQgZm9sbG93cyBzdGFuZGFyZCBLdWJlcm5ldGVzIGxhYmVsIHN5bnRheC4gVW4tcHJlZml4ZWQgbmFtZXMgYXJlIHJlc2VydmVkIGZvciBJQU5BIHN0YW5kYXJkIHNlcnZpY2UgbmFtZXMgKGFzIHBlciBSRkMtNjMzNSBhbmQgaHR0cDovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9zZXJ2aWNlLW5hbWVzKS4gTm9uLXN0YW5kYXJkIHByb3RvY29scyBzaG91bGQgdXNlIHByZWZpeGVkIG5hbWVzIHN1Y2ggYXMgbXljb21wYW55LmNvbS9teS1jdXN0b20tcHJvdG9jb2wuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkVuZHBvaW50UG9ydCNhcHBQcm90b2NvbFxuICAgKi9cbiAgcmVhZG9ubHkgYXBwUHJvdG9jb2w/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoaXMgcG9ydC4gIFRoaXMgbXVzdCBtYXRjaCB0aGUgJ25hbWUnIGZpZWxkIGluIHRoZSBjb3JyZXNwb25kaW5nIFNlcnZpY2VQb3J0LiBNdXN0IGJlIGEgRE5TX0xBQkVMLiBPcHRpb25hbCBvbmx5IGlmIG9uZSBwb3J0IGlzIGRlZmluZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkVuZHBvaW50UG9ydCNuYW1lXG4gICAqL1xuICByZWFkb25seSBuYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcG9ydCBudW1iZXIgb2YgdGhlIGVuZHBvaW50LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FbmRwb2ludFBvcnQjcG9ydFxuICAgKi9cbiAgcmVhZG9ubHkgcG9ydDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSVAgcHJvdG9jb2wgZm9yIHRoaXMgcG9ydC4gTXVzdCBiZSBVRFAsIFRDUCwgb3IgU0NUUC4gRGVmYXVsdCBpcyBUQ1AuXG4gICAqXG4gICAqIEBkZWZhdWx0IFRDUC5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRW5kcG9pbnRQb3J0I3Byb3RvY29sXG4gICAqL1xuICByZWFkb25seSBwcm90b2NvbD86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdFbmRwb2ludFBvcnQnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0VuZHBvaW50UG9ydChvYmo6IEVuZHBvaW50UG9ydCB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2FwcFByb3RvY29sJzogb2JqLmFwcFByb3RvY29sLFxuICAgICduYW1lJzogb2JqLm5hbWUsXG4gICAgJ3BvcnQnOiBvYmoucG9ydCxcbiAgICAncHJvdG9jb2wnOiBvYmoucHJvdG9jb2wsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogRW5kcG9pbnQgcmVwcmVzZW50cyBhIHNpbmdsZSBsb2dpY2FsIFwiYmFja2VuZFwiIGltcGxlbWVudGluZyBhIHNlcnZpY2UuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmRpc2NvdmVyeS52MWJldGExLkVuZHBvaW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRW5kcG9pbnRWMUJldGExIHtcbiAgLyoqXG4gICAqIGFkZHJlc3NlcyBvZiB0aGlzIGVuZHBvaW50LiBUaGUgY29udGVudHMgb2YgdGhpcyBmaWVsZCBhcmUgaW50ZXJwcmV0ZWQgYWNjb3JkaW5nIHRvIHRoZSBjb3JyZXNwb25kaW5nIEVuZHBvaW50U2xpY2UgYWRkcmVzc1R5cGUgZmllbGQuIENvbnN1bWVycyBtdXN0IGhhbmRsZSBkaWZmZXJlbnQgdHlwZXMgb2YgYWRkcmVzc2VzIGluIHRoZSBjb250ZXh0IG9mIHRoZWlyIG93biBjYXBhYmlsaXRpZXMuIFRoaXMgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBhZGRyZXNzIGJ1dCBubyBtb3JlIHRoYW4gMTAwLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZGlzY292ZXJ5LnYxYmV0YTEuRW5kcG9pbnQjYWRkcmVzc2VzXG4gICAqL1xuICByZWFkb25seSBhZGRyZXNzZXM6IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBjb25kaXRpb25zIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgZW5kcG9pbnQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjFiZXRhMS5FbmRwb2ludCNjb25kaXRpb25zXG4gICAqL1xuICByZWFkb25seSBjb25kaXRpb25zPzogRW5kcG9pbnRDb25kaXRpb25zVjFCZXRhMTtcblxuICAvKipcbiAgICogaGludHMgY29udGFpbnMgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIGhvdyBhbiBlbmRwb2ludCBzaG91bGQgYmUgY29uc3VtZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjFiZXRhMS5FbmRwb2ludCNoaW50c1xuICAgKi9cbiAgcmVhZG9ubHkgaGludHM/OiBFbmRwb2ludEhpbnRzVjFCZXRhMTtcblxuICAvKipcbiAgICogaG9zdG5hbWUgb2YgdGhpcyBlbmRwb2ludC4gVGhpcyBmaWVsZCBtYXkgYmUgdXNlZCBieSBjb25zdW1lcnMgb2YgZW5kcG9pbnRzIHRvIGRpc3Rpbmd1aXNoIGVuZHBvaW50cyBmcm9tIGVhY2ggb3RoZXIgKGUuZy4gaW4gRE5TIG5hbWVzKS4gTXVsdGlwbGUgZW5kcG9pbnRzIHdoaWNoIHVzZSB0aGUgc2FtZSBob3N0bmFtZSBzaG91bGQgYmUgY29uc2lkZXJlZCBmdW5naWJsZSAoZS5nLiBtdWx0aXBsZSBBIHZhbHVlcyBpbiBETlMpLiBNdXN0IGJlIGxvd2VyY2FzZSBhbmQgcGFzcyBETlMgTGFiZWwgKFJGQyAxMTIzKSB2YWxpZGF0aW9uLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZGlzY292ZXJ5LnYxYmV0YTEuRW5kcG9pbnQjaG9zdG5hbWVcbiAgICovXG4gIHJlYWRvbmx5IGhvc3RuYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBub2RlTmFtZSByZXByZXNlbnRzIHRoZSBuYW1lIG9mIHRoZSBOb2RlIGhvc3RpbmcgdGhpcyBlbmRwb2ludC4gVGhpcyBjYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgZW5kcG9pbnRzIGxvY2FsIHRvIGEgTm9kZS4gVGhpcyBmaWVsZCBjYW4gYmUgZW5hYmxlZCB3aXRoIHRoZSBFbmRwb2ludFNsaWNlTm9kZU5hbWUgZmVhdHVyZSBnYXRlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZGlzY292ZXJ5LnYxYmV0YTEuRW5kcG9pbnQjbm9kZU5hbWVcbiAgICovXG4gIHJlYWRvbmx5IG5vZGVOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiB0YXJnZXRSZWYgaXMgYSByZWZlcmVuY2UgdG8gYSBLdWJlcm5ldGVzIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhpcyBlbmRwb2ludC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmRpc2NvdmVyeS52MWJldGExLkVuZHBvaW50I3RhcmdldFJlZlxuICAgKi9cbiAgcmVhZG9ubHkgdGFyZ2V0UmVmPzogT2JqZWN0UmVmZXJlbmNlO1xuXG4gIC8qKlxuICAgKiB0b3BvbG9neSBjb250YWlucyBhcmJpdHJhcnkgdG9wb2xvZ3kgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBlbmRwb2ludC4gVGhlc2Uga2V5L3ZhbHVlIHBhaXJzIG11c3QgY29uZm9ybSB3aXRoIHRoZSBsYWJlbCBmb3JtYXQuIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL292ZXJ2aWV3L3dvcmtpbmctd2l0aC1vYmplY3RzL2xhYmVscyBUb3BvbG9neSBtYXkgaW5jbHVkZSBhIG1heGltdW0gb2YgMTYga2V5L3ZhbHVlIHBhaXJzLiBUaGlzIGluY2x1ZGVzLCBidXQgaXMgbm90IGxpbWl0ZWQgdG8gdGhlIGZvbGxvd2luZyB3ZWxsIGtub3duIGtleXM6ICoga3ViZXJuZXRlcy5pby9ob3N0bmFtZTogdGhlIHZhbHVlIGluZGljYXRlcyB0aGUgaG9zdG5hbWUgb2YgdGhlIG5vZGVcbiAgICogd2hlcmUgdGhlIGVuZHBvaW50IGlzIGxvY2F0ZWQuIFRoaXMgc2hvdWxkIG1hdGNoIHRoZSBjb3JyZXNwb25kaW5nXG4gICAqIG5vZGUgbGFiZWwuXG4gICAqICogdG9wb2xvZ3kua3ViZXJuZXRlcy5pby96b25lOiB0aGUgdmFsdWUgaW5kaWNhdGVzIHRoZSB6b25lIHdoZXJlIHRoZVxuICAgKiBlbmRwb2ludCBpcyBsb2NhdGVkLiBUaGlzIHNob3VsZCBtYXRjaCB0aGUgY29ycmVzcG9uZGluZyBub2RlIGxhYmVsLlxuICAgKiAqIHRvcG9sb2d5Lmt1YmVybmV0ZXMuaW8vcmVnaW9uOiB0aGUgdmFsdWUgaW5kaWNhdGVzIHRoZSByZWdpb24gd2hlcmUgdGhlXG4gICAqIGVuZHBvaW50IGlzIGxvY2F0ZWQuIFRoaXMgc2hvdWxkIG1hdGNoIHRoZSBjb3JyZXNwb25kaW5nIG5vZGUgbGFiZWwuXG4gICAqIFRoaXMgZmllbGQgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSBhcGkgdmVyc2lvbnMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjFiZXRhMS5FbmRwb2ludCN0b3BvbG9neVxuICAgKi9cbiAgcmVhZG9ubHkgdG9wb2xvZ3k/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0VuZHBvaW50VjFCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fRW5kcG9pbnRWMUJldGExKG9iajogRW5kcG9pbnRWMUJldGExIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnYWRkcmVzc2VzJzogb2JqLmFkZHJlc3Nlcz8ubWFwKHkgPT4geSksXG4gICAgJ2NvbmRpdGlvbnMnOiB0b0pzb25fRW5kcG9pbnRDb25kaXRpb25zVjFCZXRhMShvYmouY29uZGl0aW9ucyksXG4gICAgJ2hpbnRzJzogdG9Kc29uX0VuZHBvaW50SGludHNWMUJldGExKG9iai5oaW50cyksXG4gICAgJ2hvc3RuYW1lJzogb2JqLmhvc3RuYW1lLFxuICAgICdub2RlTmFtZSc6IG9iai5ub2RlTmFtZSxcbiAgICAndGFyZ2V0UmVmJzogdG9Kc29uX09iamVjdFJlZmVyZW5jZShvYmoudGFyZ2V0UmVmKSxcbiAgICAndG9wb2xvZ3knOiAoKG9iai50b3BvbG9neSkgPT09IHVuZGVmaW5lZCkgPyB1bmRlZmluZWQgOiAoT2JqZWN0LmVudHJpZXMob2JqLnRvcG9sb2d5KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBFbmRwb2ludFBvcnQgcmVwcmVzZW50cyBhIFBvcnQgdXNlZCBieSBhbiBFbmRwb2ludFNsaWNlXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmRpc2NvdmVyeS52MWJldGExLkVuZHBvaW50UG9ydFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVuZHBvaW50UG9ydFYxQmV0YTEge1xuICAvKipcbiAgICogVGhlIGFwcGxpY2F0aW9uIHByb3RvY29sIGZvciB0aGlzIHBvcnQuIFRoaXMgZmllbGQgZm9sbG93cyBzdGFuZGFyZCBLdWJlcm5ldGVzIGxhYmVsIHN5bnRheC4gVW4tcHJlZml4ZWQgbmFtZXMgYXJlIHJlc2VydmVkIGZvciBJQU5BIHN0YW5kYXJkIHNlcnZpY2UgbmFtZXMgKGFzIHBlciBSRkMtNjMzNSBhbmQgaHR0cDovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9zZXJ2aWNlLW5hbWVzKS4gTm9uLXN0YW5kYXJkIHByb3RvY29scyBzaG91bGQgdXNlIHByZWZpeGVkIG5hbWVzIHN1Y2ggYXMgbXljb21wYW55LmNvbS9teS1jdXN0b20tcHJvdG9jb2wuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjFiZXRhMS5FbmRwb2ludFBvcnQjYXBwUHJvdG9jb2xcbiAgICovXG4gIHJlYWRvbmx5IGFwcFByb3RvY29sPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGlzIHBvcnQuIEFsbCBwb3J0cyBpbiBhbiBFbmRwb2ludFNsaWNlIG11c3QgaGF2ZSBhIHVuaXF1ZSBuYW1lLiBJZiB0aGUgRW5kcG9pbnRTbGljZSBpcyBkZXJ2aWVkIGZyb20gYSBLdWJlcm5ldGVzIHNlcnZpY2UsIHRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIFNlcnZpY2UucG9ydHNbXS5uYW1lLiBOYW1lIG11c3QgZWl0aGVyIGJlIGFuIGVtcHR5IHN0cmluZyBvciBwYXNzIEROU19MQUJFTCB2YWxpZGF0aW9uOiAqIG11c3QgYmUgbm8gbW9yZSB0aGFuIDYzIGNoYXJhY3RlcnMgbG9uZy4gKiBtdXN0IGNvbnNpc3Qgb2YgbG93ZXIgY2FzZSBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBvciAnLScuICogbXVzdCBzdGFydCBhbmQgZW5kIHdpdGggYW4gYWxwaGFudW1lcmljIGNoYXJhY3Rlci4gRGVmYXVsdCBpcyBlbXB0eSBzdHJpbmcuXG4gICAqXG4gICAqIEBkZWZhdWx0IGVtcHR5IHN0cmluZy5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmRpc2NvdmVyeS52MWJldGExLkVuZHBvaW50UG9ydCNuYW1lXG4gICAqL1xuICByZWFkb25seSBuYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcG9ydCBudW1iZXIgb2YgdGhlIGVuZHBvaW50LiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIHBvcnRzIGFyZSBub3QgcmVzdHJpY3RlZCBhbmQgbXVzdCBiZSBpbnRlcnByZXRlZCBpbiB0aGUgY29udGV4dCBvZiB0aGUgc3BlY2lmaWMgY29uc3VtZXIuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjFiZXRhMS5FbmRwb2ludFBvcnQjcG9ydFxuICAgKi9cbiAgcmVhZG9ubHkgcG9ydD86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIElQIHByb3RvY29sIGZvciB0aGlzIHBvcnQuIE11c3QgYmUgVURQLCBUQ1AsIG9yIFNDVFAuIERlZmF1bHQgaXMgVENQLlxuICAgKlxuICAgKiBAZGVmYXVsdCBUQ1AuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjFiZXRhMS5FbmRwb2ludFBvcnQjcHJvdG9jb2xcbiAgICovXG4gIHJlYWRvbmx5IHByb3RvY29sPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0VuZHBvaW50UG9ydFYxQmV0YTEnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0VuZHBvaW50UG9ydFYxQmV0YTEob2JqOiBFbmRwb2ludFBvcnRWMUJldGExIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnYXBwUHJvdG9jb2wnOiBvYmouYXBwUHJvdG9jb2wsXG4gICAgJ25hbWUnOiBvYmoubmFtZSxcbiAgICAncG9ydCc6IG9iai5wb3J0LFxuICAgICdwcm90b2NvbCc6IG9iai5wcm90b2NvbCxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBFdmVudFNlcmllcyBjb250YWluIGluZm9ybWF0aW9uIG9uIHNlcmllcyBvZiBldmVudHMsIGkuZS4gdGhpbmcgdGhhdCB3YXMvaXMgaGFwcGVuaW5nIGNvbnRpbnVvdXNseSBmb3Igc29tZSB0aW1lLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5ldmVudHMudjFiZXRhMS5FdmVudFNlcmllc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50U2VyaWVzVjFCZXRhMSB7XG4gIC8qKlxuICAgKiBjb3VudCBpcyB0aGUgbnVtYmVyIG9mIG9jY3VycmVuY2VzIGluIHRoaXMgc2VyaWVzIHVwIHRvIHRoZSBsYXN0IGhlYXJ0YmVhdCB0aW1lLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZXZlbnRzLnYxYmV0YTEuRXZlbnRTZXJpZXMjY291bnRcbiAgICovXG4gIHJlYWRvbmx5IGNvdW50OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIGxhc3RPYnNlcnZlZFRpbWUgaXMgdGhlIHRpbWUgd2hlbiBsYXN0IEV2ZW50IGZyb20gdGhlIHNlcmllcyB3YXMgc2VlbiBiZWZvcmUgbGFzdCBoZWFydGJlYXQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5ldmVudHMudjFiZXRhMS5FdmVudFNlcmllcyNsYXN0T2JzZXJ2ZWRUaW1lXG4gICAqL1xuICByZWFkb25seSBsYXN0T2JzZXJ2ZWRUaW1lOiBEYXRlO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0V2ZW50U2VyaWVzVjFCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fRXZlbnRTZXJpZXNWMUJldGExKG9iajogRXZlbnRTZXJpZXNWMUJldGExIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnY291bnQnOiBvYmouY291bnQsXG4gICAgJ2xhc3RPYnNlcnZlZFRpbWUnOiBvYmoubGFzdE9ic2VydmVkVGltZT8udG9JU09TdHJpbmcoKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBGbG93U2NoZW1hU3BlYyBkZXNjcmliZXMgaG93IHRoZSBGbG93U2NoZW1hJ3Mgc3BlY2lmaWNhdGlvbiBsb29rcyBsaWtlLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLkZsb3dTY2hlbWFTcGVjXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmxvd1NjaGVtYVNwZWNWMUJldGExIHtcbiAgLyoqXG4gICAqIGBkaXN0aW5ndWlzaGVyTWV0aG9kYCBkZWZpbmVzIGhvdyB0byBjb21wdXRlIHRoZSBmbG93IGRpc3Rpbmd1aXNoZXIgZm9yIHJlcXVlc3RzIHRoYXQgbWF0Y2ggdGhpcyBzY2hlbWEuIGBuaWxgIHNwZWNpZmllcyB0aGF0IHRoZSBkaXN0aW5ndWlzaGVyIGlzIGRpc2FibGVkIGFuZCB0aHVzIHdpbGwgYWx3YXlzIGJlIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLkZsb3dTY2hlbWFTcGVjI2Rpc3Rpbmd1aXNoZXJNZXRob2RcbiAgICovXG4gIHJlYWRvbmx5IGRpc3Rpbmd1aXNoZXJNZXRob2Q/OiBGbG93RGlzdGluZ3Vpc2hlck1ldGhvZFYxQmV0YTE7XG5cbiAgLyoqXG4gICAqIGBtYXRjaGluZ1ByZWNlZGVuY2VgIGlzIHVzZWQgdG8gY2hvb3NlIGFtb25nIHRoZSBGbG93U2NoZW1hcyB0aGF0IG1hdGNoIGEgZ2l2ZW4gcmVxdWVzdC4gVGhlIGNob3NlbiBGbG93U2NoZW1hIGlzIGFtb25nIHRob3NlIHdpdGggdGhlIG51bWVyaWNhbGx5IGxvd2VzdCAod2hpY2ggd2UgdGFrZSB0byBiZSBsb2dpY2FsbHkgaGlnaGVzdCkgTWF0Y2hpbmdQcmVjZWRlbmNlLiAgRWFjaCBNYXRjaGluZ1ByZWNlZGVuY2UgdmFsdWUgbXVzdCBiZSByYW5nZWQgaW4gWzEsMTAwMDBdLiBOb3RlIHRoYXQgaWYgdGhlIHByZWNlZGVuY2UgaXMgbm90IHNwZWNpZmllZCwgaXQgd2lsbCBiZSBzZXQgdG8gMTAwMCBhcyBkZWZhdWx0LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZmxvd2NvbnRyb2wudjFiZXRhMS5GbG93U2NoZW1hU3BlYyNtYXRjaGluZ1ByZWNlZGVuY2VcbiAgICovXG4gIHJlYWRvbmx5IG1hdGNoaW5nUHJlY2VkZW5jZT86IG51bWJlcjtcblxuICAvKipcbiAgICogYHByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uYCBzaG91bGQgcmVmZXJlbmNlIGEgUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb24gaW4gdGhlIGNsdXN0ZXIuIElmIHRoZSByZWZlcmVuY2UgY2Fubm90IGJlIHJlc29sdmVkLCB0aGUgRmxvd1NjaGVtYSB3aWxsIGJlIGlnbm9yZWQgYW5kIG1hcmtlZCBhcyBpbnZhbGlkIGluIGl0cyBzdGF0dXMuIFJlcXVpcmVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZmxvd2NvbnRyb2wudjFiZXRhMS5GbG93U2NoZW1hU3BlYyNwcmlvcml0eUxldmVsQ29uZmlndXJhdGlvblxuICAgKi9cbiAgcmVhZG9ubHkgcHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb246IFByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uUmVmZXJlbmNlVjFCZXRhMTtcblxuICAvKipcbiAgICogYHJ1bGVzYCBkZXNjcmliZXMgd2hpY2ggcmVxdWVzdHMgd2lsbCBtYXRjaCB0aGlzIGZsb3cgc2NoZW1hLiBUaGlzIEZsb3dTY2hlbWEgbWF0Y2hlcyBhIHJlcXVlc3QgaWYgYW5kIG9ubHkgaWYgYXQgbGVhc3Qgb25lIG1lbWJlciBvZiBydWxlcyBtYXRjaGVzIHRoZSByZXF1ZXN0LiBpZiBpdCBpcyBhbiBlbXB0eSBzbGljZSwgdGhlcmUgd2lsbCBiZSBubyByZXF1ZXN0cyBtYXRjaGluZyB0aGUgRmxvd1NjaGVtYS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuRmxvd1NjaGVtYVNwZWMjcnVsZXNcbiAgICovXG4gIHJlYWRvbmx5IHJ1bGVzPzogUG9saWN5UnVsZXNXaXRoU3ViamVjdHNWMUJldGExW107XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnRmxvd1NjaGVtYVNwZWNWMUJldGExJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9GbG93U2NoZW1hU3BlY1YxQmV0YTEob2JqOiBGbG93U2NoZW1hU3BlY1YxQmV0YTEgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdkaXN0aW5ndWlzaGVyTWV0aG9kJzogdG9Kc29uX0Zsb3dEaXN0aW5ndWlzaGVyTWV0aG9kVjFCZXRhMShvYmouZGlzdGluZ3Vpc2hlck1ldGhvZCksXG4gICAgJ21hdGNoaW5nUHJlY2VkZW5jZSc6IG9iai5tYXRjaGluZ1ByZWNlZGVuY2UsXG4gICAgJ3ByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uJzogdG9Kc29uX1ByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uUmVmZXJlbmNlVjFCZXRhMShvYmoucHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb24pLFxuICAgICdydWxlcyc6IG9iai5ydWxlcz8ubWFwKHkgPT4gdG9Kc29uX1BvbGljeVJ1bGVzV2l0aFN1YmplY3RzVjFCZXRhMSh5KSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25TcGVjIHNwZWNpZmllcyB0aGUgY29uZmlndXJhdGlvbiBvZiBhIHByaW9yaXR5IGxldmVsLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLlByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uU3BlY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uU3BlY1YxQmV0YTEge1xuICAvKipcbiAgICogYGxpbWl0ZWRgIHNwZWNpZmllcyBob3cgcmVxdWVzdHMgYXJlIGhhbmRsZWQgZm9yIGEgTGltaXRlZCBwcmlvcml0eSBsZXZlbC4gVGhpcyBmaWVsZCBtdXN0IGJlIG5vbi1lbXB0eSBpZiBhbmQgb25seSBpZiBgdHlwZWAgaXMgYFwiTGltaXRlZFwiYC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25TcGVjI2xpbWl0ZWRcbiAgICovXG4gIHJlYWRvbmx5IGxpbWl0ZWQ/OiBMaW1pdGVkUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25WMUJldGExO1xuXG4gIC8qKlxuICAgKiBgdHlwZWAgaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBwcmlvcml0eSBsZXZlbCBpcyBzdWJqZWN0IHRvIGxpbWl0YXRpb24gb24gcmVxdWVzdCBleGVjdXRpb24uICBBIHZhbHVlIG9mIGBcIkV4ZW1wdFwiYCBtZWFucyB0aGF0IHJlcXVlc3RzIG9mIHRoaXMgcHJpb3JpdHkgbGV2ZWwgYXJlIG5vdCBzdWJqZWN0IHRvIGEgbGltaXQgKGFuZCB0aHVzIGFyZSBuZXZlciBxdWV1ZWQpIGFuZCBkbyBub3QgZGV0cmFjdCBmcm9tIHRoZSBjYXBhY2l0eSBtYWRlIGF2YWlsYWJsZSB0byBvdGhlciBwcmlvcml0eSBsZXZlbHMuICBBIHZhbHVlIG9mIGBcIkxpbWl0ZWRcImAgbWVhbnMgdGhhdCAoYSkgcmVxdWVzdHMgb2YgdGhpcyBwcmlvcml0eSBsZXZlbCBfYXJlXyBzdWJqZWN0IHRvIGxpbWl0cyBhbmQgKGIpIHNvbWUgb2YgdGhlIHNlcnZlcidzIGxpbWl0ZWQgY2FwYWNpdHkgaXMgbWFkZSBhdmFpbGFibGUgZXhjbHVzaXZlbHkgdG8gdGhpcyBwcmlvcml0eSBsZXZlbC4gUmVxdWlyZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLlByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uU3BlYyN0eXBlXG4gICAqL1xuICByZWFkb25seSB0eXBlOiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25TcGVjVjFCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25TcGVjVjFCZXRhMShvYmo6IFByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uU3BlY1YxQmV0YTEgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdsaW1pdGVkJzogdG9Kc29uX0xpbWl0ZWRQcmlvcml0eUxldmVsQ29uZmlndXJhdGlvblYxQmV0YTEob2JqLmxpbWl0ZWQpLFxuICAgICd0eXBlJzogb2JqLnR5cGUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogSW5ncmVzc1NwZWMgZGVzY3JpYmVzIHRoZSBJbmdyZXNzIHRoZSB1c2VyIHdpc2hlcyB0byBleGlzdC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5JbmdyZXNzU3BlY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEluZ3Jlc3NTcGVjIHtcbiAgLyoqXG4gICAqIERlZmF1bHRCYWNrZW5kIGlzIHRoZSBiYWNrZW5kIHRoYXQgc2hvdWxkIGhhbmRsZSByZXF1ZXN0cyB0aGF0IGRvbid0IG1hdGNoIGFueSBydWxlLiBJZiBSdWxlcyBhcmUgbm90IHNwZWNpZmllZCwgRGVmYXVsdEJhY2tlbmQgbXVzdCBiZSBzcGVjaWZpZWQuIElmIERlZmF1bHRCYWNrZW5kIGlzIG5vdCBzZXQsIHRoZSBoYW5kbGluZyBvZiByZXF1ZXN0cyB0aGF0IGRvIG5vdCBtYXRjaCBhbnkgb2YgdGhlIHJ1bGVzIHdpbGwgYmUgdXAgdG8gdGhlIEluZ3Jlc3MgY29udHJvbGxlci5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuSW5ncmVzc1NwZWMjZGVmYXVsdEJhY2tlbmRcbiAgICovXG4gIHJlYWRvbmx5IGRlZmF1bHRCYWNrZW5kPzogSW5ncmVzc0JhY2tlbmQ7XG5cbiAgLyoqXG4gICAqIEluZ3Jlc3NDbGFzc05hbWUgaXMgdGhlIG5hbWUgb2YgdGhlIEluZ3Jlc3NDbGFzcyBjbHVzdGVyIHJlc291cmNlLiBUaGUgYXNzb2NpYXRlZCBJbmdyZXNzQ2xhc3MgZGVmaW5lcyB3aGljaCBjb250cm9sbGVyIHdpbGwgaW1wbGVtZW50IHRoZSByZXNvdXJjZS4gVGhpcyByZXBsYWNlcyB0aGUgZGVwcmVjYXRlZCBga3ViZXJuZXRlcy5pby9pbmdyZXNzLmNsYXNzYCBhbm5vdGF0aW9uLiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHdoZW4gdGhhdCBhbm5vdGF0aW9uIGlzIHNldCwgaXQgbXVzdCBiZSBnaXZlbiBwcmVjZWRlbmNlIG92ZXIgdGhpcyBmaWVsZC4gVGhlIGNvbnRyb2xsZXIgbWF5IGVtaXQgYSB3YXJuaW5nIGlmIHRoZSBmaWVsZCBhbmQgYW5ub3RhdGlvbiBoYXZlIGRpZmZlcmVudCB2YWx1ZXMuIEltcGxlbWVudGF0aW9ucyBvZiB0aGlzIEFQSSBzaG91bGQgaWdub3JlIEluZ3Jlc3NlcyB3aXRob3V0IGEgY2xhc3Mgc3BlY2lmaWVkLiBBbiBJbmdyZXNzQ2xhc3MgcmVzb3VyY2UgbWF5IGJlIG1hcmtlZCBhcyBkZWZhdWx0LCB3aGljaCBjYW4gYmUgdXNlZCB0byBzZXQgYSBkZWZhdWx0IHZhbHVlIGZvciB0aGlzIGZpZWxkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIEluZ3Jlc3NDbGFzcyBkb2N1bWVudGF0aW9uLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5JbmdyZXNzU3BlYyNpbmdyZXNzQ2xhc3NOYW1lXG4gICAqL1xuICByZWFkb25seSBpbmdyZXNzQ2xhc3NOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgaG9zdCBydWxlcyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUgSW5ncmVzcy4gSWYgdW5zcGVjaWZpZWQsIG9yIG5vIHJ1bGUgbWF0Y2hlcywgYWxsIHRyYWZmaWMgaXMgc2VudCB0byB0aGUgZGVmYXVsdCBiYWNrZW5kLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5JbmdyZXNzU3BlYyNydWxlc1xuICAgKi9cbiAgcmVhZG9ubHkgcnVsZXM/OiBJbmdyZXNzUnVsZVtdO1xuXG4gIC8qKlxuICAgKiBUTFMgY29uZmlndXJhdGlvbi4gQ3VycmVudGx5IHRoZSBJbmdyZXNzIG9ubHkgc3VwcG9ydHMgYSBzaW5nbGUgVExTIHBvcnQsIDQ0My4gSWYgbXVsdGlwbGUgbWVtYmVycyBvZiB0aGlzIGxpc3Qgc3BlY2lmeSBkaWZmZXJlbnQgaG9zdHMsIHRoZXkgd2lsbCBiZSBtdWx0aXBsZXhlZCBvbiB0aGUgc2FtZSBwb3J0IGFjY29yZGluZyB0byB0aGUgaG9zdG5hbWUgc3BlY2lmaWVkIHRocm91Z2ggdGhlIFNOSSBUTFMgZXh0ZW5zaW9uLCBpZiB0aGUgaW5ncmVzcyBjb250cm9sbGVyIGZ1bGZpbGxpbmcgdGhlIGluZ3Jlc3Mgc3VwcG9ydHMgU05JLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5JbmdyZXNzU3BlYyN0bHNcbiAgICovXG4gIHJlYWRvbmx5IHRscz86IEluZ3Jlc3NUbHNbXTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdJbmdyZXNzU3BlYycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fSW5ncmVzc1NwZWMob2JqOiBJbmdyZXNzU3BlYyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2RlZmF1bHRCYWNrZW5kJzogdG9Kc29uX0luZ3Jlc3NCYWNrZW5kKG9iai5kZWZhdWx0QmFja2VuZCksXG4gICAgJ2luZ3Jlc3NDbGFzc05hbWUnOiBvYmouaW5ncmVzc0NsYXNzTmFtZSxcbiAgICAncnVsZXMnOiBvYmoucnVsZXM/Lm1hcCh5ID0+IHRvSnNvbl9JbmdyZXNzUnVsZSh5KSksXG4gICAgJ3Rscyc6IG9iai50bHM/Lm1hcCh5ID0+IHRvSnNvbl9JbmdyZXNzVGxzKHkpKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBJbmdyZXNzQ2xhc3NTcGVjIHByb3ZpZGVzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjbGFzcyBvZiBhbiBJbmdyZXNzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3NDbGFzc1NwZWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbmdyZXNzQ2xhc3NTcGVjIHtcbiAgLyoqXG4gICAqIENvbnRyb2xsZXIgcmVmZXJzIHRvIHRoZSBuYW1lIG9mIHRoZSBjb250cm9sbGVyIHRoYXQgc2hvdWxkIGhhbmRsZSB0aGlzIGNsYXNzLiBUaGlzIGFsbG93cyBmb3IgZGlmZmVyZW50IFwiZmxhdm9yc1wiIHRoYXQgYXJlIGNvbnRyb2xsZWQgYnkgdGhlIHNhbWUgY29udHJvbGxlci4gRm9yIGV4YW1wbGUsIHlvdSBtYXkgaGF2ZSBkaWZmZXJlbnQgUGFyYW1ldGVycyBmb3IgdGhlIHNhbWUgaW1wbGVtZW50aW5nIGNvbnRyb2xsZXIuIFRoaXMgc2hvdWxkIGJlIHNwZWNpZmllZCBhcyBhIGRvbWFpbi1wcmVmaXhlZCBwYXRoIG5vIG1vcmUgdGhhbiAyNTAgY2hhcmFjdGVycyBpbiBsZW5ndGgsIGUuZy4gXCJhY21lLmlvL2luZ3Jlc3MtY29udHJvbGxlclwiLiBUaGlzIGZpZWxkIGlzIGltbXV0YWJsZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuSW5ncmVzc0NsYXNzU3BlYyNjb250cm9sbGVyXG4gICAqL1xuICByZWFkb25seSBjb250cm9sbGVyPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBQYXJhbWV0ZXJzIGlzIGEgbGluayB0byBhIGN1c3RvbSByZXNvdXJjZSBjb250YWluaW5nIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiBmb3IgdGhlIGNvbnRyb2xsZXIuIFRoaXMgaXMgb3B0aW9uYWwgaWYgdGhlIGNvbnRyb2xsZXIgZG9lcyBub3QgcmVxdWlyZSBleHRyYSBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5JbmdyZXNzQ2xhc3NTcGVjI3BhcmFtZXRlcnNcbiAgICovXG4gIHJlYWRvbmx5IHBhcmFtZXRlcnM/OiBJbmdyZXNzQ2xhc3NQYXJhbWV0ZXJzUmVmZXJlbmNlO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0luZ3Jlc3NDbGFzc1NwZWMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0luZ3Jlc3NDbGFzc1NwZWMob2JqOiBJbmdyZXNzQ2xhc3NTcGVjIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnY29udHJvbGxlcic6IG9iai5jb250cm9sbGVyLFxuICAgICdwYXJhbWV0ZXJzJzogdG9Kc29uX0luZ3Jlc3NDbGFzc1BhcmFtZXRlcnNSZWZlcmVuY2Uob2JqLnBhcmFtZXRlcnMpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIE5ldHdvcmtQb2xpY3lTcGVjIHByb3ZpZGVzIHRoZSBzcGVjaWZpY2F0aW9uIG9mIGEgTmV0d29ya1BvbGljeVxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLk5ldHdvcmtQb2xpY3lTcGVjXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV0d29ya1BvbGljeVNwZWMge1xuICAvKipcbiAgICogTGlzdCBvZiBlZ3Jlc3MgcnVsZXMgdG8gYmUgYXBwbGllZCB0byB0aGUgc2VsZWN0ZWQgcG9kcy4gT3V0Z29pbmcgdHJhZmZpYyBpcyBhbGxvd2VkIGlmIHRoZXJlIGFyZSBubyBOZXR3b3JrUG9saWNpZXMgc2VsZWN0aW5nIHRoZSBwb2QgKGFuZCBjbHVzdGVyIHBvbGljeSBvdGhlcndpc2UgYWxsb3dzIHRoZSB0cmFmZmljKSwgT1IgaWYgdGhlIHRyYWZmaWMgbWF0Y2hlcyBhdCBsZWFzdCBvbmUgZWdyZXNzIHJ1bGUgYWNyb3NzIGFsbCBvZiB0aGUgTmV0d29ya1BvbGljeSBvYmplY3RzIHdob3NlIHBvZFNlbGVjdG9yIG1hdGNoZXMgdGhlIHBvZC4gSWYgdGhpcyBmaWVsZCBpcyBlbXB0eSB0aGVuIHRoaXMgTmV0d29ya1BvbGljeSBsaW1pdHMgYWxsIG91dGdvaW5nIHRyYWZmaWMgKGFuZCBzZXJ2ZXMgc29sZWx5IHRvIGVuc3VyZSB0aGF0IHRoZSBwb2RzIGl0IHNlbGVjdHMgYXJlIGlzb2xhdGVkIGJ5IGRlZmF1bHQpLiBUaGlzIGZpZWxkIGlzIGJldGEtbGV2ZWwgaW4gMS44XG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLk5ldHdvcmtQb2xpY3lTcGVjI2VncmVzc1xuICAgKi9cbiAgcmVhZG9ubHkgZWdyZXNzPzogTmV0d29ya1BvbGljeUVncmVzc1J1bGVbXTtcblxuICAvKipcbiAgICogTGlzdCBvZiBpbmdyZXNzIHJ1bGVzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHNlbGVjdGVkIHBvZHMuIFRyYWZmaWMgaXMgYWxsb3dlZCB0byBhIHBvZCBpZiB0aGVyZSBhcmUgbm8gTmV0d29ya1BvbGljaWVzIHNlbGVjdGluZyB0aGUgcG9kIChhbmQgY2x1c3RlciBwb2xpY3kgb3RoZXJ3aXNlIGFsbG93cyB0aGUgdHJhZmZpYyksIE9SIGlmIHRoZSB0cmFmZmljIHNvdXJjZSBpcyB0aGUgcG9kJ3MgbG9jYWwgbm9kZSwgT1IgaWYgdGhlIHRyYWZmaWMgbWF0Y2hlcyBhdCBsZWFzdCBvbmUgaW5ncmVzcyBydWxlIGFjcm9zcyBhbGwgb2YgdGhlIE5ldHdvcmtQb2xpY3kgb2JqZWN0cyB3aG9zZSBwb2RTZWxlY3RvciBtYXRjaGVzIHRoZSBwb2QuIElmIHRoaXMgZmllbGQgaXMgZW1wdHkgdGhlbiB0aGlzIE5ldHdvcmtQb2xpY3kgZG9lcyBub3QgYWxsb3cgYW55IHRyYWZmaWMgKGFuZCBzZXJ2ZXMgc29sZWx5IHRvIGVuc3VyZSB0aGF0IHRoZSBwb2RzIGl0IHNlbGVjdHMgYXJlIGlzb2xhdGVkIGJ5IGRlZmF1bHQpXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLk5ldHdvcmtQb2xpY3lTcGVjI2luZ3Jlc3NcbiAgICovXG4gIHJlYWRvbmx5IGluZ3Jlc3M/OiBOZXR3b3JrUG9saWN5SW5ncmVzc1J1bGVbXTtcblxuICAvKipcbiAgICogU2VsZWN0cyB0aGUgcG9kcyB0byB3aGljaCB0aGlzIE5ldHdvcmtQb2xpY3kgb2JqZWN0IGFwcGxpZXMuIFRoZSBhcnJheSBvZiBpbmdyZXNzIHJ1bGVzIGlzIGFwcGxpZWQgdG8gYW55IHBvZHMgc2VsZWN0ZWQgYnkgdGhpcyBmaWVsZC4gTXVsdGlwbGUgbmV0d29yayBwb2xpY2llcyBjYW4gc2VsZWN0IHRoZSBzYW1lIHNldCBvZiBwb2RzLiBJbiB0aGlzIGNhc2UsIHRoZSBpbmdyZXNzIHJ1bGVzIGZvciBlYWNoIGFyZSBjb21iaW5lZCBhZGRpdGl2ZWx5LiBUaGlzIGZpZWxkIGlzIE5PVCBvcHRpb25hbCBhbmQgZm9sbG93cyBzdGFuZGFyZCBsYWJlbCBzZWxlY3RvciBzZW1hbnRpY3MuIEFuIGVtcHR5IHBvZFNlbGVjdG9yIG1hdGNoZXMgYWxsIHBvZHMgaW4gdGhpcyBuYW1lc3BhY2UuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLk5ldHdvcmtQb2xpY3lTcGVjI3BvZFNlbGVjdG9yXG4gICAqL1xuICByZWFkb25seSBwb2RTZWxlY3RvcjogTGFiZWxTZWxlY3RvcjtcblxuICAvKipcbiAgICogTGlzdCBvZiBydWxlIHR5cGVzIHRoYXQgdGhlIE5ldHdvcmtQb2xpY3kgcmVsYXRlcyB0by4gVmFsaWQgb3B0aW9ucyBhcmUgW1wiSW5ncmVzc1wiXSwgW1wiRWdyZXNzXCJdLCBvciBbXCJJbmdyZXNzXCIsIFwiRWdyZXNzXCJdLiBJZiB0aGlzIGZpZWxkIGlzIG5vdCBzcGVjaWZpZWQsIGl0IHdpbGwgZGVmYXVsdCBiYXNlZCBvbiB0aGUgZXhpc3RlbmNlIG9mIEluZ3Jlc3Mgb3IgRWdyZXNzIHJ1bGVzOyBwb2xpY2llcyB0aGF0IGNvbnRhaW4gYW4gRWdyZXNzIHNlY3Rpb24gYXJlIGFzc3VtZWQgdG8gYWZmZWN0IEVncmVzcywgYW5kIGFsbCBwb2xpY2llcyAod2hldGhlciBvciBub3QgdGhleSBjb250YWluIGFuIEluZ3Jlc3Mgc2VjdGlvbikgYXJlIGFzc3VtZWQgdG8gYWZmZWN0IEluZ3Jlc3MuIElmIHlvdSB3YW50IHRvIHdyaXRlIGFuIGVncmVzcy1vbmx5IHBvbGljeSwgeW91IG11c3QgZXhwbGljaXRseSBzcGVjaWZ5IHBvbGljeVR5cGVzIFsgXCJFZ3Jlc3NcIiBdLiBMaWtld2lzZSwgaWYgeW91IHdhbnQgdG8gd3JpdGUgYSBwb2xpY3kgdGhhdCBzcGVjaWZpZXMgdGhhdCBubyBlZ3Jlc3MgaXMgYWxsb3dlZCwgeW91IG11c3Qgc3BlY2lmeSBhIHBvbGljeVR5cGVzIHZhbHVlIHRoYXQgaW5jbHVkZSBcIkVncmVzc1wiIChzaW5jZSBzdWNoIGEgcG9saWN5IHdvdWxkIG5vdCBpbmNsdWRlIGFuIEVncmVzcyBzZWN0aW9uIGFuZCB3b3VsZCBvdGhlcndpc2UgZGVmYXVsdCB0byBqdXN0IFsgXCJJbmdyZXNzXCIgXSkuIFRoaXMgZmllbGQgaXMgYmV0YS1sZXZlbCBpbiAxLjhcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuTmV0d29ya1BvbGljeVNwZWMjcG9saWN5VHlwZXNcbiAgICovXG4gIHJlYWRvbmx5IHBvbGljeVR5cGVzPzogc3RyaW5nW107XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnTmV0d29ya1BvbGljeVNwZWMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX05ldHdvcmtQb2xpY3lTcGVjKG9iajogTmV0d29ya1BvbGljeVNwZWMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdlZ3Jlc3MnOiBvYmouZWdyZXNzPy5tYXAoeSA9PiB0b0pzb25fTmV0d29ya1BvbGljeUVncmVzc1J1bGUoeSkpLFxuICAgICdpbmdyZXNzJzogb2JqLmluZ3Jlc3M/Lm1hcCh5ID0+IHRvSnNvbl9OZXR3b3JrUG9saWN5SW5ncmVzc1J1bGUoeSkpLFxuICAgICdwb2RTZWxlY3Rvcic6IHRvSnNvbl9MYWJlbFNlbGVjdG9yKG9iai5wb2RTZWxlY3RvciksXG4gICAgJ3BvbGljeVR5cGVzJzogb2JqLnBvbGljeVR5cGVzPy5tYXAoeSA9PiB5KSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBPdmVyaGVhZCBzdHJ1Y3R1cmUgcmVwcmVzZW50cyB0aGUgcmVzb3VyY2Ugb3ZlcmhlYWQgYXNzb2NpYXRlZCB3aXRoIHJ1bm5pbmcgYSBwb2QuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLm5vZGUudjEuT3ZlcmhlYWRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBPdmVyaGVhZCB7XG4gIC8qKlxuICAgKiBQb2RGaXhlZCByZXByZXNlbnRzIHRoZSBmaXhlZCByZXNvdXJjZSBvdmVyaGVhZCBhc3NvY2lhdGVkIHdpdGggcnVubmluZyBhIHBvZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5vZGUudjEuT3ZlcmhlYWQjcG9kRml4ZWRcbiAgICovXG4gIHJlYWRvbmx5IHBvZEZpeGVkPzogeyBba2V5OiBzdHJpbmddOiBRdWFudGl0eSB9O1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ092ZXJoZWFkJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9PdmVyaGVhZChvYmo6IE92ZXJoZWFkIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAncG9kRml4ZWQnOiAoKG9iai5wb2RGaXhlZCkgPT09IHVuZGVmaW5lZCkgPyB1bmRlZmluZWQgOiAoT2JqZWN0LmVudHJpZXMob2JqLnBvZEZpeGVkKS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXT8udmFsdWUgfSksIHt9KSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogU2NoZWR1bGluZyBzcGVjaWZpZXMgdGhlIHNjaGVkdWxpbmcgY29uc3RyYWludHMgZm9yIG5vZGVzIHN1cHBvcnRpbmcgYSBSdW50aW1lQ2xhc3MuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLm5vZGUudjEuU2NoZWR1bGluZ1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFNjaGVkdWxpbmcge1xuICAvKipcbiAgICogbm9kZVNlbGVjdG9yIGxpc3RzIGxhYmVscyB0aGF0IG11c3QgYmUgcHJlc2VudCBvbiBub2RlcyB0aGF0IHN1cHBvcnQgdGhpcyBSdW50aW1lQ2xhc3MuIFBvZHMgdXNpbmcgdGhpcyBSdW50aW1lQ2xhc3MgY2FuIG9ubHkgYmUgc2NoZWR1bGVkIHRvIGEgbm9kZSBtYXRjaGVkIGJ5IHRoaXMgc2VsZWN0b3IuIFRoZSBSdW50aW1lQ2xhc3Mgbm9kZVNlbGVjdG9yIGlzIG1lcmdlZCB3aXRoIGEgcG9kJ3MgZXhpc3Rpbmcgbm9kZVNlbGVjdG9yLiBBbnkgY29uZmxpY3RzIHdpbGwgY2F1c2UgdGhlIHBvZCB0byBiZSByZWplY3RlZCBpbiBhZG1pc3Npb24uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5ub2RlLnYxLlNjaGVkdWxpbmcjbm9kZVNlbGVjdG9yXG4gICAqL1xuICByZWFkb25seSBub2RlU2VsZWN0b3I/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXG4gIC8qKlxuICAgKiB0b2xlcmF0aW9ucyBhcmUgYXBwZW5kZWQgKGV4Y2x1ZGluZyBkdXBsaWNhdGVzKSB0byBwb2RzIHJ1bm5pbmcgd2l0aCB0aGlzIFJ1bnRpbWVDbGFzcyBkdXJpbmcgYWRtaXNzaW9uLCBlZmZlY3RpdmVseSB1bmlvbmluZyB0aGUgc2V0IG9mIG5vZGVzIHRvbGVyYXRlZCBieSB0aGUgcG9kIGFuZCB0aGUgUnVudGltZUNsYXNzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubm9kZS52MS5TY2hlZHVsaW5nI3RvbGVyYXRpb25zXG4gICAqL1xuICByZWFkb25seSB0b2xlcmF0aW9ucz86IFRvbGVyYXRpb25bXTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdTY2hlZHVsaW5nJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9TY2hlZHVsaW5nKG9iajogU2NoZWR1bGluZyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ25vZGVTZWxlY3Rvcic6ICgob2JqLm5vZGVTZWxlY3RvcikgPT09IHVuZGVmaW5lZCkgPyB1bmRlZmluZWQgOiAoT2JqZWN0LmVudHJpZXMob2JqLm5vZGVTZWxlY3RvcikucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KSksXG4gICAgJ3RvbGVyYXRpb25zJzogb2JqLnRvbGVyYXRpb25zPy5tYXAoeSA9PiB0b0pzb25fVG9sZXJhdGlvbih5KSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUnVudGltZUNsYXNzU3BlYyBpcyBhIHNwZWNpZmljYXRpb24gb2YgYSBSdW50aW1lQ2xhc3MuIEl0IGNvbnRhaW5zIHBhcmFtZXRlcnMgdGhhdCBhcmUgcmVxdWlyZWQgdG8gZGVzY3JpYmUgdGhlIFJ1bnRpbWVDbGFzcyB0byB0aGUgQ29udGFpbmVyIFJ1bnRpbWUgSW50ZXJmYWNlIChDUkkpIGltcGxlbWVudGF0aW9uLCBhcyB3ZWxsIGFzIGFueSBvdGhlciBjb21wb25lbnRzIHRoYXQgbmVlZCB0byB1bmRlcnN0YW5kIGhvdyB0aGUgcG9kIHdpbGwgYmUgcnVuLiBUaGUgUnVudGltZUNsYXNzU3BlYyBpcyBpbW11dGFibGUuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLm5vZGUudjFhbHBoYTEuUnVudGltZUNsYXNzU3BlY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFJ1bnRpbWVDbGFzc1NwZWNWMUFscGhhMSB7XG4gIC8qKlxuICAgKiBPdmVyaGVhZCByZXByZXNlbnRzIHRoZSByZXNvdXJjZSBvdmVyaGVhZCBhc3NvY2lhdGVkIHdpdGggcnVubmluZyBhIHBvZCBmb3IgYSBnaXZlbiBSdW50aW1lQ2xhc3MuIEZvciBtb3JlIGRldGFpbHMsIHNlZSBodHRwczovL2dpdC5rOHMuaW8vZW5oYW5jZW1lbnRzL2tlcHMvc2lnLW5vZGUvNjg4LXBvZC1vdmVyaGVhZC9SRUFETUUubWQgVGhpcyBmaWVsZCBpcyBiZXRhLWxldmVsIGFzIG9mIEt1YmVybmV0ZXMgdjEuMTgsIGFuZCBpcyBvbmx5IGhvbm9yZWQgYnkgc2VydmVycyB0aGF0IGVuYWJsZSB0aGUgUG9kT3ZlcmhlYWQgZmVhdHVyZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5vZGUudjFhbHBoYTEuUnVudGltZUNsYXNzU3BlYyNvdmVyaGVhZFxuICAgKi9cbiAgcmVhZG9ubHkgb3ZlcmhlYWQ/OiBPdmVyaGVhZFYxQWxwaGExO1xuXG4gIC8qKlxuICAgKiBSdW50aW1lSGFuZGxlciBzcGVjaWZpZXMgdGhlIHVuZGVybHlpbmcgcnVudGltZSBhbmQgY29uZmlndXJhdGlvbiB0aGF0IHRoZSBDUkkgaW1wbGVtZW50YXRpb24gd2lsbCB1c2UgdG8gaGFuZGxlIHBvZHMgb2YgdGhpcyBjbGFzcy4gVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmUgc3BlY2lmaWMgdG8gdGhlIG5vZGUgJiBDUkkgY29uZmlndXJhdGlvbi4gIEl0IGlzIGFzc3VtZWQgdGhhdCBhbGwgaGFuZGxlcnMgYXJlIGF2YWlsYWJsZSBvbiBldmVyeSBub2RlLCBhbmQgaGFuZGxlcnMgb2YgdGhlIHNhbWUgbmFtZSBhcmUgZXF1aXZhbGVudCBvbiBldmVyeSBub2RlLiBGb3IgZXhhbXBsZSwgYSBoYW5kbGVyIGNhbGxlZCBcInJ1bmNcIiBtaWdodCBzcGVjaWZ5IHRoYXQgdGhlIHJ1bmMgT0NJIHJ1bnRpbWUgKHVzaW5nIG5hdGl2ZSBMaW51eCBjb250YWluZXJzKSB3aWxsIGJlIHVzZWQgdG8gcnVuIHRoZSBjb250YWluZXJzIGluIGEgcG9kLiBUaGUgUnVudGltZUhhbmRsZXIgbXVzdCBiZSBsb3dlcmNhc2UsIGNvbmZvcm0gdG8gdGhlIEROUyBMYWJlbCAoUkZDIDExMjMpIHJlcXVpcmVtZW50cywgYW5kIGlzIGltbXV0YWJsZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5vZGUudjFhbHBoYTEuUnVudGltZUNsYXNzU3BlYyNydW50aW1lSGFuZGxlclxuICAgKi9cbiAgcmVhZG9ubHkgcnVudGltZUhhbmRsZXI6IHN0cmluZztcblxuICAvKipcbiAgICogU2NoZWR1bGluZyBob2xkcyB0aGUgc2NoZWR1bGluZyBjb25zdHJhaW50cyB0byBlbnN1cmUgdGhhdCBwb2RzIHJ1bm5pbmcgd2l0aCB0aGlzIFJ1bnRpbWVDbGFzcyBhcmUgc2NoZWR1bGVkIHRvIG5vZGVzIHRoYXQgc3VwcG9ydCBpdC4gSWYgc2NoZWR1bGluZyBpcyBuaWwsIHRoaXMgUnVudGltZUNsYXNzIGlzIGFzc3VtZWQgdG8gYmUgc3VwcG9ydGVkIGJ5IGFsbCBub2Rlcy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5vZGUudjFhbHBoYTEuUnVudGltZUNsYXNzU3BlYyNzY2hlZHVsaW5nXG4gICAqL1xuICByZWFkb25seSBzY2hlZHVsaW5nPzogU2NoZWR1bGluZ1YxQWxwaGExO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1J1bnRpbWVDbGFzc1NwZWNWMUFscGhhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fUnVudGltZUNsYXNzU3BlY1YxQWxwaGExKG9iajogUnVudGltZUNsYXNzU3BlY1YxQWxwaGExIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnb3ZlcmhlYWQnOiB0b0pzb25fT3ZlcmhlYWRWMUFscGhhMShvYmoub3ZlcmhlYWQpLFxuICAgICdydW50aW1lSGFuZGxlcic6IG9iai5ydW50aW1lSGFuZGxlcixcbiAgICAnc2NoZWR1bGluZyc6IHRvSnNvbl9TY2hlZHVsaW5nVjFBbHBoYTEob2JqLnNjaGVkdWxpbmcpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIE92ZXJoZWFkIHN0cnVjdHVyZSByZXByZXNlbnRzIHRoZSByZXNvdXJjZSBvdmVyaGVhZCBhc3NvY2lhdGVkIHdpdGggcnVubmluZyBhIHBvZC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkubm9kZS52MWJldGExLk92ZXJoZWFkXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT3ZlcmhlYWRWMUJldGExIHtcbiAgLyoqXG4gICAqIFBvZEZpeGVkIHJlcHJlc2VudHMgdGhlIGZpeGVkIHJlc291cmNlIG92ZXJoZWFkIGFzc29jaWF0ZWQgd2l0aCBydW5uaW5nIGEgcG9kLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubm9kZS52MWJldGExLk92ZXJoZWFkI3BvZEZpeGVkXG4gICAqL1xuICByZWFkb25seSBwb2RGaXhlZD86IHsgW2tleTogc3RyaW5nXTogUXVhbnRpdHkgfTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdPdmVyaGVhZFYxQmV0YTEnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX092ZXJoZWFkVjFCZXRhMShvYmo6IE92ZXJoZWFkVjFCZXRhMSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ3BvZEZpeGVkJzogKChvYmoucG9kRml4ZWQpID09PSB1bmRlZmluZWQpID8gdW5kZWZpbmVkIDogKE9iamVjdC5lbnRyaWVzKG9iai5wb2RGaXhlZCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0/LnZhbHVlIH0pLCB7fSkpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFNjaGVkdWxpbmcgc3BlY2lmaWVzIHRoZSBzY2hlZHVsaW5nIGNvbnN0cmFpbnRzIGZvciBub2RlcyBzdXBwb3J0aW5nIGEgUnVudGltZUNsYXNzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5ub2RlLnYxYmV0YTEuU2NoZWR1bGluZ1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFNjaGVkdWxpbmdWMUJldGExIHtcbiAgLyoqXG4gICAqIG5vZGVTZWxlY3RvciBsaXN0cyBsYWJlbHMgdGhhdCBtdXN0IGJlIHByZXNlbnQgb24gbm9kZXMgdGhhdCBzdXBwb3J0IHRoaXMgUnVudGltZUNsYXNzLiBQb2RzIHVzaW5nIHRoaXMgUnVudGltZUNsYXNzIGNhbiBvbmx5IGJlIHNjaGVkdWxlZCB0byBhIG5vZGUgbWF0Y2hlZCBieSB0aGlzIHNlbGVjdG9yLiBUaGUgUnVudGltZUNsYXNzIG5vZGVTZWxlY3RvciBpcyBtZXJnZWQgd2l0aCBhIHBvZCdzIGV4aXN0aW5nIG5vZGVTZWxlY3Rvci4gQW55IGNvbmZsaWN0cyB3aWxsIGNhdXNlIHRoZSBwb2QgdG8gYmUgcmVqZWN0ZWQgaW4gYWRtaXNzaW9uLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubm9kZS52MWJldGExLlNjaGVkdWxpbmcjbm9kZVNlbGVjdG9yXG4gICAqL1xuICByZWFkb25seSBub2RlU2VsZWN0b3I/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXG4gIC8qKlxuICAgKiB0b2xlcmF0aW9ucyBhcmUgYXBwZW5kZWQgKGV4Y2x1ZGluZyBkdXBsaWNhdGVzKSB0byBwb2RzIHJ1bm5pbmcgd2l0aCB0aGlzIFJ1bnRpbWVDbGFzcyBkdXJpbmcgYWRtaXNzaW9uLCBlZmZlY3RpdmVseSB1bmlvbmluZyB0aGUgc2V0IG9mIG5vZGVzIHRvbGVyYXRlZCBieSB0aGUgcG9kIGFuZCB0aGUgUnVudGltZUNsYXNzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubm9kZS52MWJldGExLlNjaGVkdWxpbmcjdG9sZXJhdGlvbnNcbiAgICovXG4gIHJlYWRvbmx5IHRvbGVyYXRpb25zPzogVG9sZXJhdGlvbltdO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1NjaGVkdWxpbmdWMUJldGExJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9TY2hlZHVsaW5nVjFCZXRhMShvYmo6IFNjaGVkdWxpbmdWMUJldGExIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbm9kZVNlbGVjdG9yJzogKChvYmoubm9kZVNlbGVjdG9yKSA9PT0gdW5kZWZpbmVkKSA/IHVuZGVmaW5lZCA6IChPYmplY3QuZW50cmllcyhvYmoubm9kZVNlbGVjdG9yKS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pKSxcbiAgICAndG9sZXJhdGlvbnMnOiBvYmoudG9sZXJhdGlvbnM/Lm1hcCh5ID0+IHRvSnNvbl9Ub2xlcmF0aW9uKHkpKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBEZWxldGVPcHRpb25zIG1heSBiZSBwcm92aWRlZCB3aGVuIGRlbGV0aW5nIGFuIEFQSSBvYmplY3QuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuRGVsZXRlT3B0aW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIERlbGV0ZU9wdGlvbnMge1xuICAvKipcbiAgICogQVBJVmVyc2lvbiBkZWZpbmVzIHRoZSB2ZXJzaW9uZWQgc2NoZW1hIG9mIHRoaXMgcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0LiBTZXJ2ZXJzIHNob3VsZCBjb252ZXJ0IHJlY29nbml6ZWQgc2NoZW1hcyB0byB0aGUgbGF0ZXN0IGludGVybmFsIHZhbHVlLCBhbmQgbWF5IHJlamVjdCB1bnJlY29nbml6ZWQgdmFsdWVzLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3Jlc291cmNlc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5EZWxldGVPcHRpb25zI2FwaVZlcnNpb25cbiAgICovXG4gIHJlYWRvbmx5IGFwaVZlcnNpb24/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdoZW4gcHJlc2VudCwgaW5kaWNhdGVzIHRoYXQgbW9kaWZpY2F0aW9ucyBzaG91bGQgbm90IGJlIHBlcnNpc3RlZC4gQW4gaW52YWxpZCBvciB1bnJlY29nbml6ZWQgZHJ5UnVuIGRpcmVjdGl2ZSB3aWxsIHJlc3VsdCBpbiBhbiBlcnJvciByZXNwb25zZSBhbmQgbm8gZnVydGhlciBwcm9jZXNzaW5nIG9mIHRoZSByZXF1ZXN0LiBWYWxpZCB2YWx1ZXMgYXJlOiAtIEFsbDogYWxsIGRyeSBydW4gc3RhZ2VzIHdpbGwgYmUgcHJvY2Vzc2VkXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLkRlbGV0ZU9wdGlvbnMjZHJ5UnVuXG4gICAqL1xuICByZWFkb25seSBkcnlSdW4/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogVGhlIGR1cmF0aW9uIGluIHNlY29uZHMgYmVmb3JlIHRoZSBvYmplY3Qgc2hvdWxkIGJlIGRlbGV0ZWQuIFZhbHVlIG11c3QgYmUgbm9uLW5lZ2F0aXZlIGludGVnZXIuIFRoZSB2YWx1ZSB6ZXJvIGluZGljYXRlcyBkZWxldGUgaW1tZWRpYXRlbHkuIElmIHRoaXMgdmFsdWUgaXMgbmlsLCB0aGUgZGVmYXVsdCBncmFjZSBwZXJpb2QgZm9yIHRoZSBzcGVjaWZpZWQgdHlwZSB3aWxsIGJlIHVzZWQuIERlZmF1bHRzIHRvIGEgcGVyIG9iamVjdCB2YWx1ZSBpZiBub3Qgc3BlY2lmaWVkLiB6ZXJvIG1lYW5zIGRlbGV0ZSBpbW1lZGlhdGVseS5cbiAgICpcbiAgICogQGRlZmF1bHQgYSBwZXIgb2JqZWN0IHZhbHVlIGlmIG5vdCBzcGVjaWZpZWQuIHplcm8gbWVhbnMgZGVsZXRlIGltbWVkaWF0ZWx5LlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5EZWxldGVPcHRpb25zI2dyYWNlUGVyaW9kU2Vjb25kc1xuICAgKi9cbiAgcmVhZG9ubHkgZ3JhY2VQZXJpb2RTZWNvbmRzPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBLaW5kIGlzIGEgc3RyaW5nIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgUkVTVCByZXNvdXJjZSB0aGlzIG9iamVjdCByZXByZXNlbnRzLiBTZXJ2ZXJzIG1heSBpbmZlciB0aGlzIGZyb20gdGhlIGVuZHBvaW50IHRoZSBjbGllbnQgc3VibWl0cyByZXF1ZXN0cyB0by4gQ2Fubm90IGJlIHVwZGF0ZWQuIEluIENhbWVsQ2FzZS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCN0eXBlcy1raW5kc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5EZWxldGVPcHRpb25zI2tpbmRcbiAgICovXG4gIHJlYWRvbmx5IGtpbmQ/OiBJb0s4U0FwaW1hY2hpbmVyeVBrZ0FwaXNNZXRhVjFEZWxldGVPcHRpb25zS2luZDtcblxuICAvKipcbiAgICogRGVwcmVjYXRlZDogcGxlYXNlIHVzZSB0aGUgUHJvcGFnYXRpb25Qb2xpY3ksIHRoaXMgZmllbGQgd2lsbCBiZSBkZXByZWNhdGVkIGluIDEuNy4gU2hvdWxkIHRoZSBkZXBlbmRlbnQgb2JqZWN0cyBiZSBvcnBoYW5lZC4gSWYgdHJ1ZS9mYWxzZSwgdGhlIFwib3JwaGFuXCIgZmluYWxpemVyIHdpbGwgYmUgYWRkZWQgdG8vcmVtb3ZlZCBmcm9tIHRoZSBvYmplY3QncyBmaW5hbGl6ZXJzIGxpc3QuIEVpdGhlciB0aGlzIGZpZWxkIG9yIFByb3BhZ2F0aW9uUG9saWN5IG1heSBiZSBzZXQsIGJ1dCBub3QgYm90aC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuRGVsZXRlT3B0aW9ucyNvcnBoYW5EZXBlbmRlbnRzXG4gICAqL1xuICByZWFkb25seSBvcnBoYW5EZXBlbmRlbnRzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogTXVzdCBiZSBmdWxmaWxsZWQgYmVmb3JlIGEgZGVsZXRpb24gaXMgY2FycmllZCBvdXQuIElmIG5vdCBwb3NzaWJsZSwgYSA0MDkgQ29uZmxpY3Qgc3RhdHVzIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLkRlbGV0ZU9wdGlvbnMjcHJlY29uZGl0aW9uc1xuICAgKi9cbiAgcmVhZG9ubHkgcHJlY29uZGl0aW9ucz86IFByZWNvbmRpdGlvbnM7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgYW5kIGhvdyBnYXJiYWdlIGNvbGxlY3Rpb24gd2lsbCBiZSBwZXJmb3JtZWQuIEVpdGhlciB0aGlzIGZpZWxkIG9yIE9ycGhhbkRlcGVuZGVudHMgbWF5IGJlIHNldCwgYnV0IG5vdCBib3RoLiBUaGUgZGVmYXVsdCBwb2xpY3kgaXMgZGVjaWRlZCBieSB0aGUgZXhpc3RpbmcgZmluYWxpemVyIHNldCBpbiB0aGUgbWV0YWRhdGEuZmluYWxpemVycyBhbmQgdGhlIHJlc291cmNlLXNwZWNpZmljIGRlZmF1bHQgcG9saWN5LiBBY2NlcHRhYmxlIHZhbHVlcyBhcmU6ICdPcnBoYW4nIC0gb3JwaGFuIHRoZSBkZXBlbmRlbnRzOyAnQmFja2dyb3VuZCcgLSBhbGxvdyB0aGUgZ2FyYmFnZSBjb2xsZWN0b3IgdG8gZGVsZXRlIHRoZSBkZXBlbmRlbnRzIGluIHRoZSBiYWNrZ3JvdW5kOyAnRm9yZWdyb3VuZCcgLSBhIGNhc2NhZGluZyBwb2xpY3kgdGhhdCBkZWxldGVzIGFsbCBkZXBlbmRlbnRzIGluIHRoZSBmb3JlZ3JvdW5kLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5EZWxldGVPcHRpb25zI3Byb3BhZ2F0aW9uUG9saWN5XG4gICAqL1xuICByZWFkb25seSBwcm9wYWdhdGlvblBvbGljeT86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdEZWxldGVPcHRpb25zJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9EZWxldGVPcHRpb25zKG9iajogRGVsZXRlT3B0aW9ucyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2FwaVZlcnNpb24nOiBvYmouYXBpVmVyc2lvbixcbiAgICAnZHJ5UnVuJzogb2JqLmRyeVJ1bj8ubWFwKHkgPT4geSksXG4gICAgJ2dyYWNlUGVyaW9kU2Vjb25kcyc6IG9iai5ncmFjZVBlcmlvZFNlY29uZHMsXG4gICAgJ2tpbmQnOiBvYmoua2luZCxcbiAgICAnb3JwaGFuRGVwZW5kZW50cyc6IG9iai5vcnBoYW5EZXBlbmRlbnRzLFxuICAgICdwcmVjb25kaXRpb25zJzogdG9Kc29uX1ByZWNvbmRpdGlvbnMob2JqLnByZWNvbmRpdGlvbnMpLFxuICAgICdwcm9wYWdhdGlvblBvbGljeSc6IG9iai5wcm9wYWdhdGlvblBvbGljeSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBQb2REaXNydXB0aW9uQnVkZ2V0U3BlYyBpcyBhIGRlc2NyaXB0aW9uIG9mIGEgUG9kRGlzcnVwdGlvbkJ1ZGdldC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkucG9saWN5LnYxLlBvZERpc3J1cHRpb25CdWRnZXRTcGVjXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUG9kRGlzcnVwdGlvbkJ1ZGdldFNwZWMge1xuICAvKipcbiAgICogQW4gZXZpY3Rpb24gaXMgYWxsb3dlZCBpZiBhdCBtb3N0IFwibWF4VW5hdmFpbGFibGVcIiBwb2RzIHNlbGVjdGVkIGJ5IFwic2VsZWN0b3JcIiBhcmUgdW5hdmFpbGFibGUgYWZ0ZXIgdGhlIGV2aWN0aW9uLCBpLmUuIGV2ZW4gaW4gYWJzZW5jZSBvZiB0aGUgZXZpY3RlZCBwb2QuIEZvciBleGFtcGxlLCBvbmUgY2FuIHByZXZlbnQgYWxsIHZvbHVudGFyeSBldmljdGlvbnMgYnkgc3BlY2lmeWluZyAwLiBUaGlzIGlzIGEgbXV0dWFsbHkgZXhjbHVzaXZlIHNldHRpbmcgd2l0aCBcIm1pbkF2YWlsYWJsZVwiLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucG9saWN5LnYxLlBvZERpc3J1cHRpb25CdWRnZXRTcGVjI21heFVuYXZhaWxhYmxlXG4gICAqL1xuICByZWFkb25seSBtYXhVbmF2YWlsYWJsZT86IEludE9yU3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBbiBldmljdGlvbiBpcyBhbGxvd2VkIGlmIGF0IGxlYXN0IFwibWluQXZhaWxhYmxlXCIgcG9kcyBzZWxlY3RlZCBieSBcInNlbGVjdG9yXCIgd2lsbCBzdGlsbCBiZSBhdmFpbGFibGUgYWZ0ZXIgdGhlIGV2aWN0aW9uLCBpLmUuIGV2ZW4gaW4gdGhlIGFic2VuY2Ugb2YgdGhlIGV2aWN0ZWQgcG9kLiAgU28gZm9yIGV4YW1wbGUgeW91IGNhbiBwcmV2ZW50IGFsbCB2b2x1bnRhcnkgZXZpY3Rpb25zIGJ5IHNwZWNpZnlpbmcgXCIxMDAlXCIuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjEuUG9kRGlzcnVwdGlvbkJ1ZGdldFNwZWMjbWluQXZhaWxhYmxlXG4gICAqL1xuICByZWFkb25seSBtaW5BdmFpbGFibGU/OiBJbnRPclN0cmluZztcblxuICAvKipcbiAgICogTGFiZWwgcXVlcnkgb3ZlciBwb2RzIHdob3NlIGV2aWN0aW9ucyBhcmUgbWFuYWdlZCBieSB0aGUgZGlzcnVwdGlvbiBidWRnZXQuIEEgbnVsbCBzZWxlY3RvciB3aWxsIG1hdGNoIG5vIHBvZHMsIHdoaWxlIGFuIGVtcHR5ICh7fSkgc2VsZWN0b3Igd2lsbCBzZWxlY3QgYWxsIHBvZHMgd2l0aGluIHRoZSBuYW1lc3BhY2UuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjEuUG9kRGlzcnVwdGlvbkJ1ZGdldFNwZWMjc2VsZWN0b3JcbiAgICovXG4gIHJlYWRvbmx5IHNlbGVjdG9yPzogTGFiZWxTZWxlY3RvcjtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdQb2REaXNydXB0aW9uQnVkZ2V0U3BlYycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fUG9kRGlzcnVwdGlvbkJ1ZGdldFNwZWMob2JqOiBQb2REaXNydXB0aW9uQnVkZ2V0U3BlYyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21heFVuYXZhaWxhYmxlJzogb2JqLm1heFVuYXZhaWxhYmxlPy52YWx1ZSxcbiAgICAnbWluQXZhaWxhYmxlJzogb2JqLm1pbkF2YWlsYWJsZT8udmFsdWUsXG4gICAgJ3NlbGVjdG9yJzogdG9Kc29uX0xhYmVsU2VsZWN0b3Iob2JqLnNlbGVjdG9yKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBQb2REaXNydXB0aW9uQnVkZ2V0U3BlYyBpcyBhIGRlc2NyaXB0aW9uIG9mIGEgUG9kRGlzcnVwdGlvbkJ1ZGdldC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkucG9saWN5LnYxYmV0YTEuUG9kRGlzcnVwdGlvbkJ1ZGdldFNwZWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQb2REaXNydXB0aW9uQnVkZ2V0U3BlY1YxQmV0YTEge1xuICAvKipcbiAgICogQW4gZXZpY3Rpb24gaXMgYWxsb3dlZCBpZiBhdCBtb3N0IFwibWF4VW5hdmFpbGFibGVcIiBwb2RzIHNlbGVjdGVkIGJ5IFwic2VsZWN0b3JcIiBhcmUgdW5hdmFpbGFibGUgYWZ0ZXIgdGhlIGV2aWN0aW9uLCBpLmUuIGV2ZW4gaW4gYWJzZW5jZSBvZiB0aGUgZXZpY3RlZCBwb2QuIEZvciBleGFtcGxlLCBvbmUgY2FuIHByZXZlbnQgYWxsIHZvbHVudGFyeSBldmljdGlvbnMgYnkgc3BlY2lmeWluZyAwLiBUaGlzIGlzIGEgbXV0dWFsbHkgZXhjbHVzaXZlIHNldHRpbmcgd2l0aCBcIm1pbkF2YWlsYWJsZVwiLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucG9saWN5LnYxYmV0YTEuUG9kRGlzcnVwdGlvbkJ1ZGdldFNwZWMjbWF4VW5hdmFpbGFibGVcbiAgICovXG4gIHJlYWRvbmx5IG1heFVuYXZhaWxhYmxlPzogSW50T3JTdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFuIGV2aWN0aW9uIGlzIGFsbG93ZWQgaWYgYXQgbGVhc3QgXCJtaW5BdmFpbGFibGVcIiBwb2RzIHNlbGVjdGVkIGJ5IFwic2VsZWN0b3JcIiB3aWxsIHN0aWxsIGJlIGF2YWlsYWJsZSBhZnRlciB0aGUgZXZpY3Rpb24sIGkuZS4gZXZlbiBpbiB0aGUgYWJzZW5jZSBvZiB0aGUgZXZpY3RlZCBwb2QuICBTbyBmb3IgZXhhbXBsZSB5b3UgY2FuIHByZXZlbnQgYWxsIHZvbHVudGFyeSBldmljdGlvbnMgYnkgc3BlY2lmeWluZyBcIjEwMCVcIi5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlBvZERpc3J1cHRpb25CdWRnZXRTcGVjI21pbkF2YWlsYWJsZVxuICAgKi9cbiAgcmVhZG9ubHkgbWluQXZhaWxhYmxlPzogSW50T3JTdHJpbmc7XG5cbiAgLyoqXG4gICAqIExhYmVsIHF1ZXJ5IG92ZXIgcG9kcyB3aG9zZSBldmljdGlvbnMgYXJlIG1hbmFnZWQgYnkgdGhlIGRpc3J1cHRpb24gYnVkZ2V0LiBBIG51bGwgc2VsZWN0b3Igc2VsZWN0cyBubyBwb2RzLiBBbiBlbXB0eSBzZWxlY3RvciAoe30pIGFsc28gc2VsZWN0cyBubyBwb2RzLCB3aGljaCBkaWZmZXJzIGZyb20gc3RhbmRhcmQgYmVoYXZpb3Igb2Ygc2VsZWN0aW5nIGFsbCBwb2RzLiBJbiBwb2xpY3kvdjEsIGFuIGVtcHR5IHNlbGVjdG9yIHdpbGwgc2VsZWN0IGFsbCBwb2RzIGluIHRoZSBuYW1lc3BhY2UuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5Qb2REaXNydXB0aW9uQnVkZ2V0U3BlYyNzZWxlY3RvclxuICAgKi9cbiAgcmVhZG9ubHkgc2VsZWN0b3I/OiBMYWJlbFNlbGVjdG9yO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1BvZERpc3J1cHRpb25CdWRnZXRTcGVjVjFCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fUG9kRGlzcnVwdGlvbkJ1ZGdldFNwZWNWMUJldGExKG9iajogUG9kRGlzcnVwdGlvbkJ1ZGdldFNwZWNWMUJldGExIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWF4VW5hdmFpbGFibGUnOiBvYmoubWF4VW5hdmFpbGFibGU/LnZhbHVlLFxuICAgICdtaW5BdmFpbGFibGUnOiBvYmoubWluQXZhaWxhYmxlPy52YWx1ZSxcbiAgICAnc2VsZWN0b3InOiB0b0pzb25fTGFiZWxTZWxlY3RvcihvYmouc2VsZWN0b3IpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFBvZFNlY3VyaXR5UG9saWN5U3BlYyBkZWZpbmVzIHRoZSBwb2xpY3kgZW5mb3JjZWQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlBvZFNlY3VyaXR5UG9saWN5U3BlY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFBvZFNlY3VyaXR5UG9saWN5U3BlY1YxQmV0YTEge1xuICAvKipcbiAgICogYWxsb3dQcml2aWxlZ2VFc2NhbGF0aW9uIGRldGVybWluZXMgaWYgYSBwb2QgY2FuIHJlcXVlc3QgdG8gYWxsb3cgcHJpdmlsZWdlIGVzY2FsYXRpb24uIElmIHVuc3BlY2lmaWVkLCBkZWZhdWx0cyB0byB0cnVlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucG9saWN5LnYxYmV0YTEuUG9kU2VjdXJpdHlQb2xpY3lTcGVjI2FsbG93UHJpdmlsZWdlRXNjYWxhdGlvblxuICAgKi9cbiAgcmVhZG9ubHkgYWxsb3dQcml2aWxlZ2VFc2NhbGF0aW9uPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQWxsb3dlZENTSURyaXZlcnMgaXMgYW4gYWxsb3dsaXN0IG9mIGlubGluZSBDU0kgZHJpdmVycyB0aGF0IG11c3QgYmUgZXhwbGljaXRseSBzZXQgdG8gYmUgZW1iZWRkZWQgd2l0aGluIGEgcG9kIHNwZWMuIEFuIGVtcHR5IHZhbHVlIGluZGljYXRlcyB0aGF0IGFueSBDU0kgZHJpdmVyIGNhbiBiZSB1c2VkIGZvciBpbmxpbmUgZXBoZW1lcmFsIHZvbHVtZXMuIFRoaXMgaXMgYSBiZXRhIGZpZWxkLCBhbmQgaXMgb25seSBob25vcmVkIGlmIHRoZSBBUEkgc2VydmVyIGVuYWJsZXMgdGhlIENTSUlubGluZVZvbHVtZSBmZWF0dXJlIGdhdGUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5Qb2RTZWN1cml0eVBvbGljeVNwZWMjYWxsb3dlZENTSURyaXZlcnNcbiAgICovXG4gIHJlYWRvbmx5IGFsbG93ZWRDc2lEcml2ZXJzPzogQWxsb3dlZENzaURyaXZlclYxQmV0YTFbXTtcblxuICAvKipcbiAgICogYWxsb3dlZENhcGFiaWxpdGllcyBpcyBhIGxpc3Qgb2YgY2FwYWJpbGl0aWVzIHRoYXQgY2FuIGJlIHJlcXVlc3RlZCB0byBhZGQgdG8gdGhlIGNvbnRhaW5lci4gQ2FwYWJpbGl0aWVzIGluIHRoaXMgZmllbGQgbWF5IGJlIGFkZGVkIGF0IHRoZSBwb2QgYXV0aG9yJ3MgZGlzY3JldGlvbi4gWW91IG11c3Qgbm90IGxpc3QgYSBjYXBhYmlsaXR5IGluIGJvdGggYWxsb3dlZENhcGFiaWxpdGllcyBhbmQgcmVxdWlyZWREcm9wQ2FwYWJpbGl0aWVzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucG9saWN5LnYxYmV0YTEuUG9kU2VjdXJpdHlQb2xpY3lTcGVjI2FsbG93ZWRDYXBhYmlsaXRpZXNcbiAgICovXG4gIHJlYWRvbmx5IGFsbG93ZWRDYXBhYmlsaXRpZXM/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogYWxsb3dlZEZsZXhWb2x1bWVzIGlzIGFuIGFsbG93bGlzdCBvZiBGbGV4dm9sdW1lcy4gIEVtcHR5IG9yIG5pbCBpbmRpY2F0ZXMgdGhhdCBhbGwgRmxleHZvbHVtZXMgbWF5IGJlIHVzZWQuICBUaGlzIHBhcmFtZXRlciBpcyBlZmZlY3RpdmUgb25seSB3aGVuIHRoZSB1c2FnZSBvZiB0aGUgRmxleHZvbHVtZXMgaXMgYWxsb3dlZCBpbiB0aGUgXCJ2b2x1bWVzXCIgZmllbGQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5Qb2RTZWN1cml0eVBvbGljeVNwZWMjYWxsb3dlZEZsZXhWb2x1bWVzXG4gICAqL1xuICByZWFkb25seSBhbGxvd2VkRmxleFZvbHVtZXM/OiBBbGxvd2VkRmxleFZvbHVtZVYxQmV0YTFbXTtcblxuICAvKipcbiAgICogYWxsb3dlZEhvc3RQYXRocyBpcyBhbiBhbGxvd2xpc3Qgb2YgaG9zdCBwYXRocy4gRW1wdHkgaW5kaWNhdGVzIHRoYXQgYWxsIGhvc3QgcGF0aHMgbWF5IGJlIHVzZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5Qb2RTZWN1cml0eVBvbGljeVNwZWMjYWxsb3dlZEhvc3RQYXRoc1xuICAgKi9cbiAgcmVhZG9ubHkgYWxsb3dlZEhvc3RQYXRocz86IEFsbG93ZWRIb3N0UGF0aFYxQmV0YTFbXTtcblxuICAvKipcbiAgICogQWxsb3dlZFByb2NNb3VudFR5cGVzIGlzIGFuIGFsbG93bGlzdCBvZiBhbGxvd2VkIFByb2NNb3VudFR5cGVzLiBFbXB0eSBvciBuaWwgaW5kaWNhdGVzIHRoYXQgb25seSB0aGUgRGVmYXVsdFByb2NNb3VudFR5cGUgbWF5IGJlIHVzZWQuIFRoaXMgcmVxdWlyZXMgdGhlIFByb2NNb3VudFR5cGUgZmVhdHVyZSBmbGFnIHRvIGJlIGVuYWJsZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5Qb2RTZWN1cml0eVBvbGljeVNwZWMjYWxsb3dlZFByb2NNb3VudFR5cGVzXG4gICAqL1xuICByZWFkb25seSBhbGxvd2VkUHJvY01vdW50VHlwZXM/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogYWxsb3dlZFVuc2FmZVN5c2N0bHMgaXMgYSBsaXN0IG9mIGV4cGxpY2l0bHkgYWxsb3dlZCB1bnNhZmUgc3lzY3RscywgZGVmYXVsdHMgdG8gbm9uZS4gRWFjaCBlbnRyeSBpcyBlaXRoZXIgYSBwbGFpbiBzeXNjdGwgbmFtZSBvciBlbmRzIGluIFwiKlwiIGluIHdoaWNoIGNhc2UgaXQgaXMgY29uc2lkZXJlZCBhcyBhIHByZWZpeCBvZiBhbGxvd2VkIHN5c2N0bHMuIFNpbmdsZSAqIG1lYW5zIGFsbCB1bnNhZmUgc3lzY3RscyBhcmUgYWxsb3dlZC4gS3ViZWxldCBoYXMgdG8gYWxsb3dsaXN0IGFsbCBhbGxvd2VkIHVuc2FmZSBzeXNjdGxzIGV4cGxpY2l0bHkgdG8gYXZvaWQgcmVqZWN0aW9uLlxuICAgKlxuICAgKiBFeGFtcGxlczogZS5nLiBcImZvby8qXCIgYWxsb3dzIFwiZm9vL2JhclwiLCBcImZvby9iYXpcIiwgZXRjLiBlLmcuIFwiZm9vLipcIiBhbGxvd3MgXCJmb28uYmFyXCIsIFwiZm9vLmJhelwiLCBldGMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5Qb2RTZWN1cml0eVBvbGljeVNwZWMjYWxsb3dlZFVuc2FmZVN5c2N0bHNcbiAgICovXG4gIHJlYWRvbmx5IGFsbG93ZWRVbnNhZmVTeXNjdGxzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIGRlZmF1bHRBZGRDYXBhYmlsaXRpZXMgaXMgdGhlIGRlZmF1bHQgc2V0IG9mIGNhcGFiaWxpdGllcyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGNvbnRhaW5lciB1bmxlc3MgdGhlIHBvZCBzcGVjIHNwZWNpZmljYWxseSBkcm9wcyB0aGUgY2FwYWJpbGl0eS4gIFlvdSBtYXkgbm90IGxpc3QgYSBjYXBhYmlsaXR5IGluIGJvdGggZGVmYXVsdEFkZENhcGFiaWxpdGllcyBhbmQgcmVxdWlyZWREcm9wQ2FwYWJpbGl0aWVzLiBDYXBhYmlsaXRpZXMgYWRkZWQgaGVyZSBhcmUgaW1wbGljaXRseSBhbGxvd2VkLCBhbmQgbmVlZCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIGFsbG93ZWRDYXBhYmlsaXRpZXMgbGlzdC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlBvZFNlY3VyaXR5UG9saWN5U3BlYyNkZWZhdWx0QWRkQ2FwYWJpbGl0aWVzXG4gICAqL1xuICByZWFkb25seSBkZWZhdWx0QWRkQ2FwYWJpbGl0aWVzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIGRlZmF1bHRBbGxvd1ByaXZpbGVnZUVzY2FsYXRpb24gY29udHJvbHMgdGhlIGRlZmF1bHQgc2V0dGluZyBmb3Igd2hldGhlciBhIHByb2Nlc3MgY2FuIGdhaW4gbW9yZSBwcml2aWxlZ2VzIHRoYW4gaXRzIHBhcmVudCBwcm9jZXNzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucG9saWN5LnYxYmV0YTEuUG9kU2VjdXJpdHlQb2xpY3lTcGVjI2RlZmF1bHRBbGxvd1ByaXZpbGVnZUVzY2FsYXRpb25cbiAgICovXG4gIHJlYWRvbmx5IGRlZmF1bHRBbGxvd1ByaXZpbGVnZUVzY2FsYXRpb24/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBmb3JiaWRkZW5TeXNjdGxzIGlzIGEgbGlzdCBvZiBleHBsaWNpdGx5IGZvcmJpZGRlbiBzeXNjdGxzLCBkZWZhdWx0cyB0byBub25lLiBFYWNoIGVudHJ5IGlzIGVpdGhlciBhIHBsYWluIHN5c2N0bCBuYW1lIG9yIGVuZHMgaW4gXCIqXCIgaW4gd2hpY2ggY2FzZSBpdCBpcyBjb25zaWRlcmVkIGFzIGEgcHJlZml4IG9mIGZvcmJpZGRlbiBzeXNjdGxzLiBTaW5nbGUgKiBtZWFucyBhbGwgc3lzY3RscyBhcmUgZm9yYmlkZGVuLlxuICAgKlxuICAgKiBFeGFtcGxlczogZS5nLiBcImZvby8qXCIgZm9yYmlkcyBcImZvby9iYXJcIiwgXCJmb28vYmF6XCIsIGV0Yy4gZS5nLiBcImZvby4qXCIgZm9yYmlkcyBcImZvby5iYXJcIiwgXCJmb28uYmF6XCIsIGV0Yy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlBvZFNlY3VyaXR5UG9saWN5U3BlYyNmb3JiaWRkZW5TeXNjdGxzXG4gICAqL1xuICByZWFkb25seSBmb3JiaWRkZW5TeXNjdGxzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIGZzR3JvdXAgaXMgdGhlIHN0cmF0ZWd5IHRoYXQgd2lsbCBkaWN0YXRlIHdoYXQgZnMgZ3JvdXAgaXMgdXNlZCBieSB0aGUgU2VjdXJpdHlDb250ZXh0LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucG9saWN5LnYxYmV0YTEuUG9kU2VjdXJpdHlQb2xpY3lTcGVjI2ZzR3JvdXBcbiAgICovXG4gIHJlYWRvbmx5IGZzR3JvdXA6IEZzR3JvdXBTdHJhdGVneU9wdGlvbnNWMUJldGExO1xuXG4gIC8qKlxuICAgKiBob3N0SVBDIGRldGVybWluZXMgaWYgdGhlIHBvbGljeSBhbGxvd3MgdGhlIHVzZSBvZiBIb3N0SVBDIGluIHRoZSBwb2Qgc3BlYy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlBvZFNlY3VyaXR5UG9saWN5U3BlYyNob3N0SVBDXG4gICAqL1xuICByZWFkb25seSBob3N0SXBjPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogaG9zdE5ldHdvcmsgZGV0ZXJtaW5lcyBpZiB0aGUgcG9saWN5IGFsbG93cyB0aGUgdXNlIG9mIEhvc3ROZXR3b3JrIGluIHRoZSBwb2Qgc3BlYy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlBvZFNlY3VyaXR5UG9saWN5U3BlYyNob3N0TmV0d29ya1xuICAgKi9cbiAgcmVhZG9ubHkgaG9zdE5ldHdvcms/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBob3N0UElEIGRldGVybWluZXMgaWYgdGhlIHBvbGljeSBhbGxvd3MgdGhlIHVzZSBvZiBIb3N0UElEIGluIHRoZSBwb2Qgc3BlYy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlBvZFNlY3VyaXR5UG9saWN5U3BlYyNob3N0UElEXG4gICAqL1xuICByZWFkb25seSBob3N0UGlkPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogaG9zdFBvcnRzIGRldGVybWluZXMgd2hpY2ggaG9zdCBwb3J0IHJhbmdlcyBhcmUgYWxsb3dlZCB0byBiZSBleHBvc2VkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucG9saWN5LnYxYmV0YTEuUG9kU2VjdXJpdHlQb2xpY3lTcGVjI2hvc3RQb3J0c1xuICAgKi9cbiAgcmVhZG9ubHkgaG9zdFBvcnRzPzogSG9zdFBvcnRSYW5nZVYxQmV0YTFbXTtcblxuICAvKipcbiAgICogcHJpdmlsZWdlZCBkZXRlcm1pbmVzIGlmIGEgcG9kIGNhbiByZXF1ZXN0IHRvIGJlIHJ1biBhcyBwcml2aWxlZ2VkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucG9saWN5LnYxYmV0YTEuUG9kU2VjdXJpdHlQb2xpY3lTcGVjI3ByaXZpbGVnZWRcbiAgICovXG4gIHJlYWRvbmx5IHByaXZpbGVnZWQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiByZWFkT25seVJvb3RGaWxlc3lzdGVtIHdoZW4gc2V0IHRvIHRydWUgd2lsbCBmb3JjZSBjb250YWluZXJzIHRvIHJ1biB3aXRoIGEgcmVhZCBvbmx5IHJvb3QgZmlsZSBzeXN0ZW0uICBJZiB0aGUgY29udGFpbmVyIHNwZWNpZmljYWxseSByZXF1ZXN0cyB0byBydW4gd2l0aCBhIG5vbi1yZWFkIG9ubHkgcm9vdCBmaWxlIHN5c3RlbSB0aGUgUFNQIHNob3VsZCBkZW55IHRoZSBwb2QuIElmIHNldCB0byBmYWxzZSB0aGUgY29udGFpbmVyIG1heSBydW4gd2l0aCBhIHJlYWQgb25seSByb290IGZpbGUgc3lzdGVtIGlmIGl0IHdpc2hlcyBidXQgaXQgd2lsbCBub3QgYmUgZm9yY2VkIHRvLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucG9saWN5LnYxYmV0YTEuUG9kU2VjdXJpdHlQb2xpY3lTcGVjI3JlYWRPbmx5Um9vdEZpbGVzeXN0ZW1cbiAgICovXG4gIHJlYWRvbmx5IHJlYWRPbmx5Um9vdEZpbGVzeXN0ZW0/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiByZXF1aXJlZERyb3BDYXBhYmlsaXRpZXMgYXJlIHRoZSBjYXBhYmlsaXRpZXMgdGhhdCB3aWxsIGJlIGRyb3BwZWQgZnJvbSB0aGUgY29udGFpbmVyLiAgVGhlc2UgYXJlIHJlcXVpcmVkIHRvIGJlIGRyb3BwZWQgYW5kIGNhbm5vdCBiZSBhZGRlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlBvZFNlY3VyaXR5UG9saWN5U3BlYyNyZXF1aXJlZERyb3BDYXBhYmlsaXRpZXNcbiAgICovXG4gIHJlYWRvbmx5IHJlcXVpcmVkRHJvcENhcGFiaWxpdGllcz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBSdW5Bc0dyb3VwIGlzIHRoZSBzdHJhdGVneSB0aGF0IHdpbGwgZGljdGF0ZSB0aGUgYWxsb3dhYmxlIFJ1bkFzR3JvdXAgdmFsdWVzIHRoYXQgbWF5IGJlIHNldC4gSWYgdGhpcyBmaWVsZCBpcyBvbWl0dGVkLCB0aGUgcG9kJ3MgUnVuQXNHcm91cCBjYW4gdGFrZSBhbnkgdmFsdWUuIFRoaXMgZmllbGQgcmVxdWlyZXMgdGhlIFJ1bkFzR3JvdXAgZmVhdHVyZSBnYXRlIHRvIGJlIGVuYWJsZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5Qb2RTZWN1cml0eVBvbGljeVNwZWMjcnVuQXNHcm91cFxuICAgKi9cbiAgcmVhZG9ubHkgcnVuQXNHcm91cD86IFJ1bkFzR3JvdXBTdHJhdGVneU9wdGlvbnNWMUJldGExO1xuXG4gIC8qKlxuICAgKiBydW5Bc1VzZXIgaXMgdGhlIHN0cmF0ZWd5IHRoYXQgd2lsbCBkaWN0YXRlIHRoZSBhbGxvd2FibGUgUnVuQXNVc2VyIHZhbHVlcyB0aGF0IG1heSBiZSBzZXQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5Qb2RTZWN1cml0eVBvbGljeVNwZWMjcnVuQXNVc2VyXG4gICAqL1xuICByZWFkb25seSBydW5Bc1VzZXI6IFJ1bkFzVXNlclN0cmF0ZWd5T3B0aW9uc1YxQmV0YTE7XG5cbiAgLyoqXG4gICAqIHJ1bnRpbWVDbGFzcyBpcyB0aGUgc3RyYXRlZ3kgdGhhdCB3aWxsIGRpY3RhdGUgdGhlIGFsbG93YWJsZSBSdW50aW1lQ2xhc3NlcyBmb3IgYSBwb2QuIElmIHRoaXMgZmllbGQgaXMgb21pdHRlZCwgdGhlIHBvZCdzIHJ1bnRpbWVDbGFzc05hbWUgZmllbGQgaXMgdW5yZXN0cmljdGVkLiBFbmZvcmNlbWVudCBvZiB0aGlzIGZpZWxkIGRlcGVuZHMgb24gdGhlIFJ1bnRpbWVDbGFzcyBmZWF0dXJlIGdhdGUgYmVpbmcgZW5hYmxlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlBvZFNlY3VyaXR5UG9saWN5U3BlYyNydW50aW1lQ2xhc3NcbiAgICovXG4gIHJlYWRvbmx5IHJ1bnRpbWVDbGFzcz86IFJ1bnRpbWVDbGFzc1N0cmF0ZWd5T3B0aW9uc1YxQmV0YTE7XG5cbiAgLyoqXG4gICAqIHNlTGludXggaXMgdGhlIHN0cmF0ZWd5IHRoYXQgd2lsbCBkaWN0YXRlIHRoZSBhbGxvd2FibGUgbGFiZWxzIHRoYXQgbWF5IGJlIHNldC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlBvZFNlY3VyaXR5UG9saWN5U3BlYyNzZUxpbnV4XG4gICAqL1xuICByZWFkb25seSBzZUxpbnV4OiBTZUxpbnV4U3RyYXRlZ3lPcHRpb25zVjFCZXRhMTtcblxuICAvKipcbiAgICogc3VwcGxlbWVudGFsR3JvdXBzIGlzIHRoZSBzdHJhdGVneSB0aGF0IHdpbGwgZGljdGF0ZSB3aGF0IHN1cHBsZW1lbnRhbCBncm91cHMgYXJlIHVzZWQgYnkgdGhlIFNlY3VyaXR5Q29udGV4dC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlBvZFNlY3VyaXR5UG9saWN5U3BlYyNzdXBwbGVtZW50YWxHcm91cHNcbiAgICovXG4gIHJlYWRvbmx5IHN1cHBsZW1lbnRhbEdyb3VwczogU3VwcGxlbWVudGFsR3JvdXBzU3RyYXRlZ3lPcHRpb25zVjFCZXRhMTtcblxuICAvKipcbiAgICogdm9sdW1lcyBpcyBhbiBhbGxvd2xpc3Qgb2Ygdm9sdW1lIHBsdWdpbnMuIEVtcHR5IGluZGljYXRlcyB0aGF0IG5vIHZvbHVtZXMgbWF5IGJlIHVzZWQuIFRvIGFsbG93IGFsbCB2b2x1bWVzIHlvdSBtYXkgdXNlICcqJy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlBvZFNlY3VyaXR5UG9saWN5U3BlYyN2b2x1bWVzXG4gICAqL1xuICByZWFkb25seSB2b2x1bWVzPzogc3RyaW5nW107XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnUG9kU2VjdXJpdHlQb2xpY3lTcGVjVjFCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fUG9kU2VjdXJpdHlQb2xpY3lTcGVjVjFCZXRhMShvYmo6IFBvZFNlY3VyaXR5UG9saWN5U3BlY1YxQmV0YTEgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdhbGxvd1ByaXZpbGVnZUVzY2FsYXRpb24nOiBvYmouYWxsb3dQcml2aWxlZ2VFc2NhbGF0aW9uLFxuICAgICdhbGxvd2VkQ1NJRHJpdmVycyc6IG9iai5hbGxvd2VkQ3NpRHJpdmVycz8ubWFwKHkgPT4gdG9Kc29uX0FsbG93ZWRDc2lEcml2ZXJWMUJldGExKHkpKSxcbiAgICAnYWxsb3dlZENhcGFiaWxpdGllcyc6IG9iai5hbGxvd2VkQ2FwYWJpbGl0aWVzPy5tYXAoeSA9PiB5KSxcbiAgICAnYWxsb3dlZEZsZXhWb2x1bWVzJzogb2JqLmFsbG93ZWRGbGV4Vm9sdW1lcz8ubWFwKHkgPT4gdG9Kc29uX0FsbG93ZWRGbGV4Vm9sdW1lVjFCZXRhMSh5KSksXG4gICAgJ2FsbG93ZWRIb3N0UGF0aHMnOiBvYmouYWxsb3dlZEhvc3RQYXRocz8ubWFwKHkgPT4gdG9Kc29uX0FsbG93ZWRIb3N0UGF0aFYxQmV0YTEoeSkpLFxuICAgICdhbGxvd2VkUHJvY01vdW50VHlwZXMnOiBvYmouYWxsb3dlZFByb2NNb3VudFR5cGVzPy5tYXAoeSA9PiB5KSxcbiAgICAnYWxsb3dlZFVuc2FmZVN5c2N0bHMnOiBvYmouYWxsb3dlZFVuc2FmZVN5c2N0bHM/Lm1hcCh5ID0+IHkpLFxuICAgICdkZWZhdWx0QWRkQ2FwYWJpbGl0aWVzJzogb2JqLmRlZmF1bHRBZGRDYXBhYmlsaXRpZXM/Lm1hcCh5ID0+IHkpLFxuICAgICdkZWZhdWx0QWxsb3dQcml2aWxlZ2VFc2NhbGF0aW9uJzogb2JqLmRlZmF1bHRBbGxvd1ByaXZpbGVnZUVzY2FsYXRpb24sXG4gICAgJ2ZvcmJpZGRlblN5c2N0bHMnOiBvYmouZm9yYmlkZGVuU3lzY3Rscz8ubWFwKHkgPT4geSksXG4gICAgJ2ZzR3JvdXAnOiB0b0pzb25fRnNHcm91cFN0cmF0ZWd5T3B0aW9uc1YxQmV0YTEob2JqLmZzR3JvdXApLFxuICAgICdob3N0SVBDJzogb2JqLmhvc3RJcGMsXG4gICAgJ2hvc3ROZXR3b3JrJzogb2JqLmhvc3ROZXR3b3JrLFxuICAgICdob3N0UElEJzogb2JqLmhvc3RQaWQsXG4gICAgJ2hvc3RQb3J0cyc6IG9iai5ob3N0UG9ydHM/Lm1hcCh5ID0+IHRvSnNvbl9Ib3N0UG9ydFJhbmdlVjFCZXRhMSh5KSksXG4gICAgJ3ByaXZpbGVnZWQnOiBvYmoucHJpdmlsZWdlZCxcbiAgICAncmVhZE9ubHlSb290RmlsZXN5c3RlbSc6IG9iai5yZWFkT25seVJvb3RGaWxlc3lzdGVtLFxuICAgICdyZXF1aXJlZERyb3BDYXBhYmlsaXRpZXMnOiBvYmoucmVxdWlyZWREcm9wQ2FwYWJpbGl0aWVzPy5tYXAoeSA9PiB5KSxcbiAgICAncnVuQXNHcm91cCc6IHRvSnNvbl9SdW5Bc0dyb3VwU3RyYXRlZ3lPcHRpb25zVjFCZXRhMShvYmoucnVuQXNHcm91cCksXG4gICAgJ3J1bkFzVXNlcic6IHRvSnNvbl9SdW5Bc1VzZXJTdHJhdGVneU9wdGlvbnNWMUJldGExKG9iai5ydW5Bc1VzZXIpLFxuICAgICdydW50aW1lQ2xhc3MnOiB0b0pzb25fUnVudGltZUNsYXNzU3RyYXRlZ3lPcHRpb25zVjFCZXRhMShvYmoucnVudGltZUNsYXNzKSxcbiAgICAnc2VMaW51eCc6IHRvSnNvbl9TZUxpbnV4U3RyYXRlZ3lPcHRpb25zVjFCZXRhMShvYmouc2VMaW51eCksXG4gICAgJ3N1cHBsZW1lbnRhbEdyb3Vwcyc6IHRvSnNvbl9TdXBwbGVtZW50YWxHcm91cHNTdHJhdGVneU9wdGlvbnNWMUJldGExKG9iai5zdXBwbGVtZW50YWxHcm91cHMpLFxuICAgICd2b2x1bWVzJzogb2JqLnZvbHVtZXM/Lm1hcCh5ID0+IHkpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEFnZ3JlZ2F0aW9uUnVsZSBkZXNjcmliZXMgaG93IHRvIGxvY2F0ZSBDbHVzdGVyUm9sZXMgdG8gYWdncmVnYXRlIGludG8gdGhlIENsdXN0ZXJSb2xlXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjEuQWdncmVnYXRpb25SdWxlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWdncmVnYXRpb25SdWxlIHtcbiAgLyoqXG4gICAqIENsdXN0ZXJSb2xlU2VsZWN0b3JzIGhvbGRzIGEgbGlzdCBvZiBzZWxlY3RvcnMgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIGZpbmQgQ2x1c3RlclJvbGVzIGFuZCBjcmVhdGUgdGhlIHJ1bGVzLiBJZiBhbnkgb2YgdGhlIHNlbGVjdG9ycyBtYXRjaCwgdGhlbiB0aGUgQ2x1c3RlclJvbGUncyBwZXJtaXNzaW9ucyB3aWxsIGJlIGFkZGVkXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxLkFnZ3JlZ2F0aW9uUnVsZSNjbHVzdGVyUm9sZVNlbGVjdG9yc1xuICAgKi9cbiAgcmVhZG9ubHkgY2x1c3RlclJvbGVTZWxlY3RvcnM/OiBMYWJlbFNlbGVjdG9yW107XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnQWdncmVnYXRpb25SdWxlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9BZ2dyZWdhdGlvblJ1bGUob2JqOiBBZ2dyZWdhdGlvblJ1bGUgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdjbHVzdGVyUm9sZVNlbGVjdG9ycyc6IG9iai5jbHVzdGVyUm9sZVNlbGVjdG9ycz8ubWFwKHkgPT4gdG9Kc29uX0xhYmVsU2VsZWN0b3IoeSkpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFBvbGljeVJ1bGUgaG9sZHMgaW5mb3JtYXRpb24gdGhhdCBkZXNjcmliZXMgYSBwb2xpY3kgcnVsZSwgYnV0IGRvZXMgbm90IGNvbnRhaW4gaW5mb3JtYXRpb24gYWJvdXQgd2hvIHRoZSBydWxlIGFwcGxpZXMgdG8gb3Igd2hpY2ggbmFtZXNwYWNlIHRoZSBydWxlIGFwcGxpZXMgdG8uXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjEuUG9saWN5UnVsZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBvbGljeVJ1bGUge1xuICAvKipcbiAgICogQVBJR3JvdXBzIGlzIHRoZSBuYW1lIG9mIHRoZSBBUElHcm91cCB0aGF0IGNvbnRhaW5zIHRoZSByZXNvdXJjZXMuICBJZiBtdWx0aXBsZSBBUEkgZ3JvdXBzIGFyZSBzcGVjaWZpZWQsIGFueSBhY3Rpb24gcmVxdWVzdGVkIGFnYWluc3Qgb25lIG9mIHRoZSBlbnVtZXJhdGVkIHJlc291cmNlcyBpbiBhbnkgQVBJIGdyb3VwIHdpbGwgYmUgYWxsb3dlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjEuUG9saWN5UnVsZSNhcGlHcm91cHNcbiAgICovXG4gIHJlYWRvbmx5IGFwaUdyb3Vwcz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBOb25SZXNvdXJjZVVSTHMgaXMgYSBzZXQgb2YgcGFydGlhbCB1cmxzIHRoYXQgYSB1c2VyIHNob3VsZCBoYXZlIGFjY2VzcyB0by4gICpzIGFyZSBhbGxvd2VkLCBidXQgb25seSBhcyB0aGUgZnVsbCwgZmluYWwgc3RlcCBpbiB0aGUgcGF0aCBTaW5jZSBub24tcmVzb3VyY2UgVVJMcyBhcmUgbm90IG5hbWVzcGFjZWQsIHRoaXMgZmllbGQgaXMgb25seSBhcHBsaWNhYmxlIGZvciBDbHVzdGVyUm9sZXMgcmVmZXJlbmNlZCBmcm9tIGEgQ2x1c3RlclJvbGVCaW5kaW5nLiBSdWxlcyBjYW4gZWl0aGVyIGFwcGx5IHRvIEFQSSByZXNvdXJjZXMgKHN1Y2ggYXMgXCJwb2RzXCIgb3IgXCJzZWNyZXRzXCIpIG9yIG5vbi1yZXNvdXJjZSBVUkwgcGF0aHMgKHN1Y2ggYXMgXCIvYXBpXCIpLCAgYnV0IG5vdCBib3RoLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MS5Qb2xpY3lSdWxlI25vblJlc291cmNlVVJMc1xuICAgKi9cbiAgcmVhZG9ubHkgbm9uUmVzb3VyY2VVckxzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIFJlc291cmNlTmFtZXMgaXMgYW4gb3B0aW9uYWwgd2hpdGUgbGlzdCBvZiBuYW1lcyB0aGF0IHRoZSBydWxlIGFwcGxpZXMgdG8uICBBbiBlbXB0eSBzZXQgbWVhbnMgdGhhdCBldmVyeXRoaW5nIGlzIGFsbG93ZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxLlBvbGljeVJ1bGUjcmVzb3VyY2VOYW1lc1xuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VOYW1lcz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBSZXNvdXJjZXMgaXMgYSBsaXN0IG9mIHJlc291cmNlcyB0aGlzIHJ1bGUgYXBwbGllcyB0by4gJyonIHJlcHJlc2VudHMgYWxsIHJlc291cmNlcy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjEuUG9saWN5UnVsZSNyZXNvdXJjZXNcbiAgICovXG4gIHJlYWRvbmx5IHJlc291cmNlcz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBWZXJicyBpcyBhIGxpc3Qgb2YgVmVyYnMgdGhhdCBhcHBseSB0byBBTEwgdGhlIFJlc291cmNlS2luZHMgYW5kIEF0dHJpYnV0ZVJlc3RyaWN0aW9ucyBjb250YWluZWQgaW4gdGhpcyBydWxlLiAnKicgcmVwcmVzZW50cyBhbGwgdmVyYnMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxLlBvbGljeVJ1bGUjdmVyYnNcbiAgICovXG4gIHJlYWRvbmx5IHZlcmJzOiBzdHJpbmdbXTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdQb2xpY3lSdWxlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Qb2xpY3lSdWxlKG9iajogUG9saWN5UnVsZSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2FwaUdyb3Vwcyc6IG9iai5hcGlHcm91cHM/Lm1hcCh5ID0+IHkpLFxuICAgICdub25SZXNvdXJjZVVSTHMnOiBvYmoubm9uUmVzb3VyY2VVckxzPy5tYXAoeSA9PiB5KSxcbiAgICAncmVzb3VyY2VOYW1lcyc6IG9iai5yZXNvdXJjZU5hbWVzPy5tYXAoeSA9PiB5KSxcbiAgICAncmVzb3VyY2VzJzogb2JqLnJlc291cmNlcz8ubWFwKHkgPT4geSksXG4gICAgJ3ZlcmJzJzogb2JqLnZlcmJzPy5tYXAoeSA9PiB5KSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBSb2xlUmVmIGNvbnRhaW5zIGluZm9ybWF0aW9uIHRoYXQgcG9pbnRzIHRvIHRoZSByb2xlIGJlaW5nIHVzZWRcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MS5Sb2xlUmVmXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm9sZVJlZiB7XG4gIC8qKlxuICAgKiBBUElHcm91cCBpcyB0aGUgZ3JvdXAgZm9yIHRoZSByZXNvdXJjZSBiZWluZyByZWZlcmVuY2VkXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxLlJvbGVSZWYjYXBpR3JvdXBcbiAgICovXG4gIHJlYWRvbmx5IGFwaUdyb3VwOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEtpbmQgaXMgdGhlIHR5cGUgb2YgcmVzb3VyY2UgYmVpbmcgcmVmZXJlbmNlZFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MS5Sb2xlUmVmI2tpbmRcbiAgICovXG4gIHJlYWRvbmx5IGtpbmQ6IHN0cmluZztcblxuICAvKipcbiAgICogTmFtZSBpcyB0aGUgbmFtZSBvZiByZXNvdXJjZSBiZWluZyByZWZlcmVuY2VkXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxLlJvbGVSZWYjbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1JvbGVSZWYnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1JvbGVSZWYob2JqOiBSb2xlUmVmIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnYXBpR3JvdXAnOiBvYmouYXBpR3JvdXAsXG4gICAgJ2tpbmQnOiBvYmoua2luZCxcbiAgICAnbmFtZSc6IG9iai5uYW1lLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFN1YmplY3QgY29udGFpbnMgYSByZWZlcmVuY2UgdG8gdGhlIG9iamVjdCBvciB1c2VyIGlkZW50aXRpZXMgYSByb2xlIGJpbmRpbmcgYXBwbGllcyB0by4gIFRoaXMgY2FuIGVpdGhlciBob2xkIGEgZGlyZWN0IEFQSSBvYmplY3QgcmVmZXJlbmNlLCBvciBhIHZhbHVlIGZvciBub24tb2JqZWN0cyBzdWNoIGFzIHVzZXIgYW5kIGdyb3VwIG5hbWVzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxLlN1YmplY3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdWJqZWN0IHtcbiAgLyoqXG4gICAqIEFQSUdyb3VwIGhvbGRzIHRoZSBBUEkgZ3JvdXAgb2YgdGhlIHJlZmVyZW5jZWQgc3ViamVjdC4gRGVmYXVsdHMgdG8gXCJcIiBmb3IgU2VydmljZUFjY291bnQgc3ViamVjdHMuIERlZmF1bHRzIHRvIFwicmJhYy5hdXRob3JpemF0aW9uLms4cy5pb1wiIGZvciBVc2VyIGFuZCBHcm91cCBzdWJqZWN0cy5cbiAgICpcbiAgICogQGRlZmF1bHQgZm9yIFNlcnZpY2VBY2NvdW50IHN1YmplY3RzLiBEZWZhdWx0cyB0byBcInJiYWMuYXV0aG9yaXphdGlvbi5rOHMuaW9cIiBmb3IgVXNlciBhbmQgR3JvdXAgc3ViamVjdHMuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxLlN1YmplY3QjYXBpR3JvdXBcbiAgICovXG4gIHJlYWRvbmx5IGFwaUdyb3VwPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBLaW5kIG9mIG9iamVjdCBiZWluZyByZWZlcmVuY2VkLiBWYWx1ZXMgZGVmaW5lZCBieSB0aGlzIEFQSSBncm91cCBhcmUgXCJVc2VyXCIsIFwiR3JvdXBcIiwgYW5kIFwiU2VydmljZUFjY291bnRcIi4gSWYgdGhlIEF1dGhvcml6ZXIgZG9lcyBub3QgcmVjb2duaXplZCB0aGUga2luZCB2YWx1ZSwgdGhlIEF1dGhvcml6ZXIgc2hvdWxkIHJlcG9ydCBhbiBlcnJvci5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjEuU3ViamVjdCNraW5kXG4gICAqL1xuICByZWFkb25seSBraW5kOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIG9iamVjdCBiZWluZyByZWZlcmVuY2VkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MS5TdWJqZWN0I25hbWVcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogTmFtZXNwYWNlIG9mIHRoZSByZWZlcmVuY2VkIG9iamVjdC4gIElmIHRoZSBvYmplY3Qga2luZCBpcyBub24tbmFtZXNwYWNlLCBzdWNoIGFzIFwiVXNlclwiIG9yIFwiR3JvdXBcIiwgYW5kIHRoaXMgdmFsdWUgaXMgbm90IGVtcHR5IHRoZSBBdXRob3JpemVyIHNob3VsZCByZXBvcnQgYW4gZXJyb3IuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxLlN1YmplY3QjbmFtZXNwYWNlXG4gICAqL1xuICByZWFkb25seSBuYW1lc3BhY2U/OiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnU3ViamVjdCcgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fU3ViamVjdChvYmo6IFN1YmplY3QgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdhcGlHcm91cCc6IG9iai5hcGlHcm91cCxcbiAgICAna2luZCc6IG9iai5raW5kLFxuICAgICduYW1lJzogb2JqLm5hbWUsXG4gICAgJ25hbWVzcGFjZSc6IG9iai5uYW1lc3BhY2UsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQWdncmVnYXRpb25SdWxlIGRlc2NyaWJlcyBob3cgdG8gbG9jYXRlIENsdXN0ZXJSb2xlcyB0byBhZ2dyZWdhdGUgaW50byB0aGUgQ2x1c3RlclJvbGVcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MWFscGhhMS5BZ2dyZWdhdGlvblJ1bGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBZ2dyZWdhdGlvblJ1bGVWMUFscGhhMSB7XG4gIC8qKlxuICAgKiBDbHVzdGVyUm9sZVNlbGVjdG9ycyBob2xkcyBhIGxpc3Qgb2Ygc2VsZWN0b3JzIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBmaW5kIENsdXN0ZXJSb2xlcyBhbmQgY3JlYXRlIHRoZSBydWxlcy4gSWYgYW55IG9mIHRoZSBzZWxlY3RvcnMgbWF0Y2gsIHRoZW4gdGhlIENsdXN0ZXJSb2xlJ3MgcGVybWlzc2lvbnMgd2lsbCBiZSBhZGRlZFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MWFscGhhMS5BZ2dyZWdhdGlvblJ1bGUjY2x1c3RlclJvbGVTZWxlY3RvcnNcbiAgICovXG4gIHJlYWRvbmx5IGNsdXN0ZXJSb2xlU2VsZWN0b3JzPzogTGFiZWxTZWxlY3RvcltdO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0FnZ3JlZ2F0aW9uUnVsZVYxQWxwaGExJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9BZ2dyZWdhdGlvblJ1bGVWMUFscGhhMShvYmo6IEFnZ3JlZ2F0aW9uUnVsZVYxQWxwaGExIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnY2x1c3RlclJvbGVTZWxlY3RvcnMnOiBvYmouY2x1c3RlclJvbGVTZWxlY3RvcnM/Lm1hcCh5ID0+IHRvSnNvbl9MYWJlbFNlbGVjdG9yKHkpKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBQb2xpY3lSdWxlIGhvbGRzIGluZm9ybWF0aW9uIHRoYXQgZGVzY3JpYmVzIGEgcG9saWN5IHJ1bGUsIGJ1dCBkb2VzIG5vdCBjb250YWluIGluZm9ybWF0aW9uIGFib3V0IHdobyB0aGUgcnVsZSBhcHBsaWVzIHRvIG9yIHdoaWNoIG5hbWVzcGFjZSB0aGUgcnVsZSBhcHBsaWVzIHRvLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxYWxwaGExLlBvbGljeVJ1bGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQb2xpY3lSdWxlVjFBbHBoYTEge1xuICAvKipcbiAgICogQVBJR3JvdXBzIGlzIHRoZSBuYW1lIG9mIHRoZSBBUElHcm91cCB0aGF0IGNvbnRhaW5zIHRoZSByZXNvdXJjZXMuICBJZiBtdWx0aXBsZSBBUEkgZ3JvdXBzIGFyZSBzcGVjaWZpZWQsIGFueSBhY3Rpb24gcmVxdWVzdGVkIGFnYWluc3Qgb25lIG9mIHRoZSBlbnVtZXJhdGVkIHJlc291cmNlcyBpbiBhbnkgQVBJIGdyb3VwIHdpbGwgYmUgYWxsb3dlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuUG9saWN5UnVsZSNhcGlHcm91cHNcbiAgICovXG4gIHJlYWRvbmx5IGFwaUdyb3Vwcz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBOb25SZXNvdXJjZVVSTHMgaXMgYSBzZXQgb2YgcGFydGlhbCB1cmxzIHRoYXQgYSB1c2VyIHNob3VsZCBoYXZlIGFjY2VzcyB0by4gICpzIGFyZSBhbGxvd2VkLCBidXQgb25seSBhcyB0aGUgZnVsbCwgZmluYWwgc3RlcCBpbiB0aGUgcGF0aCBTaW5jZSBub24tcmVzb3VyY2UgVVJMcyBhcmUgbm90IG5hbWVzcGFjZWQsIHRoaXMgZmllbGQgaXMgb25seSBhcHBsaWNhYmxlIGZvciBDbHVzdGVyUm9sZXMgcmVmZXJlbmNlZCBmcm9tIGEgQ2x1c3RlclJvbGVCaW5kaW5nLiBSdWxlcyBjYW4gZWl0aGVyIGFwcGx5IHRvIEFQSSByZXNvdXJjZXMgKHN1Y2ggYXMgXCJwb2RzXCIgb3IgXCJzZWNyZXRzXCIpIG9yIG5vbi1yZXNvdXJjZSBVUkwgcGF0aHMgKHN1Y2ggYXMgXCIvYXBpXCIpLCAgYnV0IG5vdCBib3RoLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MWFscGhhMS5Qb2xpY3lSdWxlI25vblJlc291cmNlVVJMc1xuICAgKi9cbiAgcmVhZG9ubHkgbm9uUmVzb3VyY2VVckxzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIFJlc291cmNlTmFtZXMgaXMgYW4gb3B0aW9uYWwgd2hpdGUgbGlzdCBvZiBuYW1lcyB0aGF0IHRoZSBydWxlIGFwcGxpZXMgdG8uICBBbiBlbXB0eSBzZXQgbWVhbnMgdGhhdCBldmVyeXRoaW5nIGlzIGFsbG93ZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxYWxwaGExLlBvbGljeVJ1bGUjcmVzb3VyY2VOYW1lc1xuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VOYW1lcz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBSZXNvdXJjZXMgaXMgYSBsaXN0IG9mIHJlc291cmNlcyB0aGlzIHJ1bGUgYXBwbGllcyB0by4gJyonIHJlcHJlc2VudHMgYWxsIHJlc291cmNlcy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuUG9saWN5UnVsZSNyZXNvdXJjZXNcbiAgICovXG4gIHJlYWRvbmx5IHJlc291cmNlcz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBWZXJicyBpcyBhIGxpc3Qgb2YgVmVyYnMgdGhhdCBhcHBseSB0byBBTEwgdGhlIFJlc291cmNlS2luZHMgYW5kIEF0dHJpYnV0ZVJlc3RyaWN0aW9ucyBjb250YWluZWQgaW4gdGhpcyBydWxlLiAnKicgcmVwcmVzZW50cyBhbGwgdmVyYnMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxYWxwaGExLlBvbGljeVJ1bGUjdmVyYnNcbiAgICovXG4gIHJlYWRvbmx5IHZlcmJzOiBzdHJpbmdbXTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdQb2xpY3lSdWxlVjFBbHBoYTEnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1BvbGljeVJ1bGVWMUFscGhhMShvYmo6IFBvbGljeVJ1bGVWMUFscGhhMSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2FwaUdyb3Vwcyc6IG9iai5hcGlHcm91cHM/Lm1hcCh5ID0+IHkpLFxuICAgICdub25SZXNvdXJjZVVSTHMnOiBvYmoubm9uUmVzb3VyY2VVckxzPy5tYXAoeSA9PiB5KSxcbiAgICAncmVzb3VyY2VOYW1lcyc6IG9iai5yZXNvdXJjZU5hbWVzPy5tYXAoeSA9PiB5KSxcbiAgICAncmVzb3VyY2VzJzogb2JqLnJlc291cmNlcz8ubWFwKHkgPT4geSksXG4gICAgJ3ZlcmJzJzogb2JqLnZlcmJzPy5tYXAoeSA9PiB5KSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBSb2xlUmVmIGNvbnRhaW5zIGluZm9ybWF0aW9uIHRoYXQgcG9pbnRzIHRvIHRoZSByb2xlIGJlaW5nIHVzZWRcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MWFscGhhMS5Sb2xlUmVmXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm9sZVJlZlYxQWxwaGExIHtcbiAgLyoqXG4gICAqIEFQSUdyb3VwIGlzIHRoZSBncm91cCBmb3IgdGhlIHJlc291cmNlIGJlaW5nIHJlZmVyZW5jZWRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuUm9sZVJlZiNhcGlHcm91cFxuICAgKi9cbiAgcmVhZG9ubHkgYXBpR3JvdXA6IHN0cmluZztcblxuICAvKipcbiAgICogS2luZCBpcyB0aGUgdHlwZSBvZiByZXNvdXJjZSBiZWluZyByZWZlcmVuY2VkXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxYWxwaGExLlJvbGVSZWYja2luZFxuICAgKi9cbiAgcmVhZG9ubHkga2luZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBOYW1lIGlzIHRoZSBuYW1lIG9mIHJlc291cmNlIGJlaW5nIHJlZmVyZW5jZWRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuUm9sZVJlZiNuYW1lXG4gICAqL1xuICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnUm9sZVJlZlYxQWxwaGExJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Sb2xlUmVmVjFBbHBoYTEob2JqOiBSb2xlUmVmVjFBbHBoYTEgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdhcGlHcm91cCc6IG9iai5hcGlHcm91cCxcbiAgICAna2luZCc6IG9iai5raW5kLFxuICAgICduYW1lJzogb2JqLm5hbWUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogU3ViamVjdCBjb250YWlucyBhIHJlZmVyZW5jZSB0byB0aGUgb2JqZWN0IG9yIHVzZXIgaWRlbnRpdGllcyBhIHJvbGUgYmluZGluZyBhcHBsaWVzIHRvLiAgVGhpcyBjYW4gZWl0aGVyIGhvbGQgYSBkaXJlY3QgQVBJIG9iamVjdCByZWZlcmVuY2UsIG9yIGEgdmFsdWUgZm9yIG5vbi1vYmplY3RzIHN1Y2ggYXMgdXNlciBhbmQgZ3JvdXAgbmFtZXMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuU3ViamVjdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN1YmplY3RWMUFscGhhMSB7XG4gIC8qKlxuICAgKiBBUElWZXJzaW9uIGhvbGRzIHRoZSBBUEkgZ3JvdXAgYW5kIHZlcnNpb24gb2YgdGhlIHJlZmVyZW5jZWQgc3ViamVjdC4gRGVmYXVsdHMgdG8gXCJ2MVwiIGZvciBTZXJ2aWNlQWNjb3VudCBzdWJqZWN0cy4gRGVmYXVsdHMgdG8gXCJyYmFjLmF1dGhvcml6YXRpb24uazhzLmlvL3YxYWxwaGExXCIgZm9yIFVzZXIgYW5kIEdyb3VwIHN1YmplY3RzLlxuICAgKlxuICAgKiBAZGVmYXVsdCB2MVwiIGZvciBTZXJ2aWNlQWNjb3VudCBzdWJqZWN0cy4gRGVmYXVsdHMgdG8gXCJyYmFjLmF1dGhvcml6YXRpb24uazhzLmlvL3YxYWxwaGExXCIgZm9yIFVzZXIgYW5kIEdyb3VwIHN1YmplY3RzLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MWFscGhhMS5TdWJqZWN0I2FwaVZlcnNpb25cbiAgICovXG4gIHJlYWRvbmx5IGFwaVZlcnNpb24/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEtpbmQgb2Ygb2JqZWN0IGJlaW5nIHJlZmVyZW5jZWQuIFZhbHVlcyBkZWZpbmVkIGJ5IHRoaXMgQVBJIGdyb3VwIGFyZSBcIlVzZXJcIiwgXCJHcm91cFwiLCBhbmQgXCJTZXJ2aWNlQWNjb3VudFwiLiBJZiB0aGUgQXV0aG9yaXplciBkb2VzIG5vdCByZWNvZ25pemVkIHRoZSBraW5kIHZhbHVlLCB0aGUgQXV0aG9yaXplciBzaG91bGQgcmVwb3J0IGFuIGVycm9yLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucmJhYy52MWFscGhhMS5TdWJqZWN0I2tpbmRcbiAgICovXG4gIHJlYWRvbmx5IGtpbmQ6IHN0cmluZztcblxuICAvKipcbiAgICogTmFtZSBvZiB0aGUgb2JqZWN0IGJlaW5nIHJlZmVyZW5jZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5yYmFjLnYxYWxwaGExLlN1YmplY3QjbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBOYW1lc3BhY2Ugb2YgdGhlIHJlZmVyZW5jZWQgb2JqZWN0LiAgSWYgdGhlIG9iamVjdCBraW5kIGlzIG5vbi1uYW1lc3BhY2UsIHN1Y2ggYXMgXCJVc2VyXCIgb3IgXCJHcm91cFwiLCBhbmQgdGhpcyB2YWx1ZSBpcyBub3QgZW1wdHkgdGhlIEF1dGhvcml6ZXIgc2hvdWxkIHJlcG9ydCBhbiBlcnJvci5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnJiYWMudjFhbHBoYTEuU3ViamVjdCNuYW1lc3BhY2VcbiAgICovXG4gIHJlYWRvbmx5IG5hbWVzcGFjZT86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdTdWJqZWN0VjFBbHBoYTEnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1N1YmplY3RWMUFscGhhMShvYmo6IFN1YmplY3RWMUFscGhhMSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2FwaVZlcnNpb24nOiBvYmouYXBpVmVyc2lvbixcbiAgICAna2luZCc6IG9iai5raW5kLFxuICAgICduYW1lJzogb2JqLm5hbWUsXG4gICAgJ25hbWVzcGFjZSc6IG9iai5uYW1lc3BhY2UsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQ1NJRHJpdmVyU3BlYyBpcyB0aGUgc3BlY2lmaWNhdGlvbiBvZiBhIENTSURyaXZlci5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5DU0lEcml2ZXJTcGVjXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3NpRHJpdmVyU3BlYyB7XG4gIC8qKlxuICAgKiBhdHRhY2hSZXF1aXJlZCBpbmRpY2F0ZXMgdGhpcyBDU0kgdm9sdW1lIGRyaXZlciByZXF1aXJlcyBhbiBhdHRhY2ggb3BlcmF0aW9uIChiZWNhdXNlIGl0IGltcGxlbWVudHMgdGhlIENTSSBDb250cm9sbGVyUHVibGlzaFZvbHVtZSgpIG1ldGhvZCksIGFuZCB0aGF0IHRoZSBLdWJlcm5ldGVzIGF0dGFjaCBkZXRhY2ggY29udHJvbGxlciBzaG91bGQgY2FsbCB0aGUgYXR0YWNoIHZvbHVtZSBpbnRlcmZhY2Ugd2hpY2ggY2hlY2tzIHRoZSB2b2x1bWVhdHRhY2htZW50IHN0YXR1cyBhbmQgd2FpdHMgdW50aWwgdGhlIHZvbHVtZSBpcyBhdHRhY2hlZCBiZWZvcmUgcHJvY2VlZGluZyB0byBtb3VudGluZy4gVGhlIENTSSBleHRlcm5hbC1hdHRhY2hlciBjb29yZGluYXRlcyB3aXRoIENTSSB2b2x1bWUgZHJpdmVyIGFuZCB1cGRhdGVzIHRoZSB2b2x1bWVhdHRhY2htZW50IHN0YXR1cyB3aGVuIHRoZSBhdHRhY2ggb3BlcmF0aW9uIGlzIGNvbXBsZXRlLiBJZiB0aGUgQ1NJRHJpdmVyUmVnaXN0cnkgZmVhdHVyZSBnYXRlIGlzIGVuYWJsZWQgYW5kIHRoZSB2YWx1ZSBpcyBzcGVjaWZpZWQgdG8gZmFsc2UsIHRoZSBhdHRhY2ggb3BlcmF0aW9uIHdpbGwgYmUgc2tpcHBlZC4gT3RoZXJ3aXNlIHRoZSBhdHRhY2ggb3BlcmF0aW9uIHdpbGwgYmUgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIGZpZWxkIGlzIGltbXV0YWJsZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjEuQ1NJRHJpdmVyU3BlYyNhdHRhY2hSZXF1aXJlZFxuICAgKi9cbiAgcmVhZG9ubHkgYXR0YWNoUmVxdWlyZWQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGlmIHRoZSB1bmRlcmx5aW5nIHZvbHVtZSBzdXBwb3J0cyBjaGFuZ2luZyBvd25lcnNoaXAgYW5kIHBlcm1pc3Npb24gb2YgdGhlIHZvbHVtZSBiZWZvcmUgYmVpbmcgbW91bnRlZC4gUmVmZXIgdG8gdGhlIHNwZWNpZmljIEZTR3JvdXBQb2xpY3kgdmFsdWVzIGZvciBhZGRpdGlvbmFsIGRldGFpbHMuIFRoaXMgZmllbGQgaXMgYmV0YSwgYW5kIGlzIG9ubHkgaG9ub3JlZCBieSBzZXJ2ZXJzIHRoYXQgZW5hYmxlIHRoZSBDU0lWb2x1bWVGU0dyb3VwUG9saWN5IGZlYXR1cmUgZ2F0ZS5cbiAgICpcbiAgICogVGhpcyBmaWVsZCBpcyBpbW11dGFibGUuXG4gICAqXG4gICAqIERlZmF1bHRzIHRvIFJlYWRXcml0ZU9uY2VXaXRoRlNUeXBlLCB3aGljaCB3aWxsIGV4YW1pbmUgZWFjaCB2b2x1bWUgdG8gZGV0ZXJtaW5lIGlmIEt1YmVybmV0ZXMgc2hvdWxkIG1vZGlmeSBvd25lcnNoaXAgYW5kIHBlcm1pc3Npb25zIG9mIHRoZSB2b2x1bWUuIFdpdGggdGhlIGRlZmF1bHQgcG9saWN5IHRoZSBkZWZpbmVkIGZzR3JvdXAgd2lsbCBvbmx5IGJlIGFwcGxpZWQgaWYgYSBmc3R5cGUgaXMgZGVmaW5lZCBhbmQgdGhlIHZvbHVtZSdzIGFjY2VzcyBtb2RlIGNvbnRhaW5zIFJlYWRXcml0ZU9uY2UuXG4gICAqXG4gICAqIEBkZWZhdWx0IFJlYWRXcml0ZU9uY2VXaXRoRlNUeXBlLCB3aGljaCB3aWxsIGV4YW1pbmUgZWFjaCB2b2x1bWUgdG8gZGV0ZXJtaW5lIGlmIEt1YmVybmV0ZXMgc2hvdWxkIG1vZGlmeSBvd25lcnNoaXAgYW5kIHBlcm1pc3Npb25zIG9mIHRoZSB2b2x1bWUuIFdpdGggdGhlIGRlZmF1bHQgcG9saWN5IHRoZSBkZWZpbmVkIGZzR3JvdXAgd2lsbCBvbmx5IGJlIGFwcGxpZWQgaWYgYSBmc3R5cGUgaXMgZGVmaW5lZCBhbmQgdGhlIHZvbHVtZSdzIGFjY2VzcyBtb2RlIGNvbnRhaW5zIFJlYWRXcml0ZU9uY2UuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxLkNTSURyaXZlclNwZWMjZnNHcm91cFBvbGljeVxuICAgKi9cbiAgcmVhZG9ubHkgZnNHcm91cFBvbGljeT86IHN0cmluZztcblxuICAvKipcbiAgICogSWYgc2V0IHRvIHRydWUsIHBvZEluZm9Pbk1vdW50IGluZGljYXRlcyB0aGlzIENTSSB2b2x1bWUgZHJpdmVyIHJlcXVpcmVzIGFkZGl0aW9uYWwgcG9kIGluZm9ybWF0aW9uIChsaWtlIHBvZE5hbWUsIHBvZFVJRCwgZXRjLikgZHVyaW5nIG1vdW50IG9wZXJhdGlvbnMuIElmIHNldCB0byBmYWxzZSwgcG9kIGluZm9ybWF0aW9uIHdpbGwgbm90IGJlIHBhc3NlZCBvbiBtb3VudC4gRGVmYXVsdCBpcyBmYWxzZS4gVGhlIENTSSBkcml2ZXIgc3BlY2lmaWVzIHBvZEluZm9Pbk1vdW50IGFzIHBhcnQgb2YgZHJpdmVyIGRlcGxveW1lbnQuIElmIHRydWUsIEt1YmVsZXQgd2lsbCBwYXNzIHBvZCBpbmZvcm1hdGlvbiBhcyBWb2x1bWVDb250ZXh0IGluIHRoZSBDU0kgTm9kZVB1Ymxpc2hWb2x1bWUoKSBjYWxscy4gVGhlIENTSSBkcml2ZXIgaXMgcmVzcG9uc2libGUgZm9yIHBhcnNpbmcgYW5kIHZhbGlkYXRpbmcgdGhlIGluZm9ybWF0aW9uIHBhc3NlZCBpbiBhcyBWb2x1bWVDb250ZXh0LiBUaGUgZm9sbG93aW5nIFZvbHVtZUNvbmV4dCB3aWxsIGJlIHBhc3NlZCBpZiBwb2RJbmZvT25Nb3VudCBpcyBzZXQgdG8gdHJ1ZS4gVGhpcyBsaXN0IG1pZ2h0IGdyb3csIGJ1dCB0aGUgcHJlZml4IHdpbGwgYmUgdXNlZC4gXCJjc2kuc3RvcmFnZS5rOHMuaW8vcG9kLm5hbWVcIjogcG9kLk5hbWUgXCJjc2kuc3RvcmFnZS5rOHMuaW8vcG9kLm5hbWVzcGFjZVwiOiBwb2QuTmFtZXNwYWNlIFwiY3NpLnN0b3JhZ2UuazhzLmlvL3BvZC51aWRcIjogc3RyaW5nKHBvZC5VSUQpIFwiY3NpLnN0b3JhZ2UuazhzLmlvL2VwaGVtZXJhbFwiOiBcInRydWVcIiBpZiB0aGUgdm9sdW1lIGlzIGFuIGVwaGVtZXJhbCBpbmxpbmUgdm9sdW1lXG4gICAqIGRlZmluZWQgYnkgYSBDU0lWb2x1bWVTb3VyY2UsIG90aGVyd2lzZSBcImZhbHNlXCJcbiAgICpcbiAgICogXCJjc2kuc3RvcmFnZS5rOHMuaW8vZXBoZW1lcmFsXCIgaXMgYSBuZXcgZmVhdHVyZSBpbiBLdWJlcm5ldGVzIDEuMTYuIEl0IGlzIG9ubHkgcmVxdWlyZWQgZm9yIGRyaXZlcnMgd2hpY2ggc3VwcG9ydCBib3RoIHRoZSBcIlBlcnNpc3RlbnRcIiBhbmQgXCJFcGhlbWVyYWxcIiBWb2x1bWVMaWZlY3ljbGVNb2RlLiBPdGhlciBkcml2ZXJzIGNhbiBsZWF2ZSBwb2QgaW5mbyBkaXNhYmxlZCBhbmQvb3IgaWdub3JlIHRoaXMgZmllbGQuIEFzIEt1YmVybmV0ZXMgMS4xNSBkb2Vzbid0IHN1cHBvcnQgdGhpcyBmaWVsZCwgZHJpdmVycyBjYW4gb25seSBzdXBwb3J0IG9uZSBtb2RlIHdoZW4gZGVwbG95ZWQgb24gc3VjaCBhIGNsdXN0ZXIgYW5kIHRoZSBkZXBsb3ltZW50IGRldGVybWluZXMgd2hpY2ggbW9kZSB0aGF0IGlzLCBmb3IgZXhhbXBsZSB2aWEgYSBjb21tYW5kIGxpbmUgcGFyYW1ldGVyIG9mIHRoZSBkcml2ZXIuXG4gICAqXG4gICAqIFRoaXMgZmllbGQgaXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZS4gVGhlIENTSSBkcml2ZXIgc3BlY2lmaWVzIHBvZEluZm9Pbk1vdW50IGFzIHBhcnQgb2YgZHJpdmVyIGRlcGxveW1lbnQuIElmIHRydWUsIEt1YmVsZXQgd2lsbCBwYXNzIHBvZCBpbmZvcm1hdGlvbiBhcyBWb2x1bWVDb250ZXh0IGluIHRoZSBDU0kgTm9kZVB1Ymxpc2hWb2x1bWUoKSBjYWxscy4gVGhlIENTSSBkcml2ZXIgaXMgcmVzcG9uc2libGUgZm9yIHBhcnNpbmcgYW5kIHZhbGlkYXRpbmcgdGhlIGluZm9ybWF0aW9uIHBhc3NlZCBpbiBhcyBWb2x1bWVDb250ZXh0LiBUaGUgZm9sbG93aW5nIFZvbHVtZUNvbmV4dCB3aWxsIGJlIHBhc3NlZCBpZiBwb2RJbmZvT25Nb3VudCBpcyBzZXQgdG8gdHJ1ZS4gVGhpcyBsaXN0IG1pZ2h0IGdyb3csIGJ1dCB0aGUgcHJlZml4IHdpbGwgYmUgdXNlZC4gXCJjc2kuc3RvcmFnZS5rOHMuaW8vcG9kLm5hbWVcIjogcG9kLk5hbWUgXCJjc2kuc3RvcmFnZS5rOHMuaW8vcG9kLm5hbWVzcGFjZVwiOiBwb2QuTmFtZXNwYWNlIFwiY3NpLnN0b3JhZ2UuazhzLmlvL3BvZC51aWRcIjogc3RyaW5nKHBvZC5VSUQpIFwiY3NpLnN0b3JhZ2UuazhzLmlvL2VwaGVtZXJhbFwiOiBcInRydWVcIiBpZiB0aGUgdm9sdW1lIGlzIGFuIGVwaGVtZXJhbCBpbmxpbmUgdm9sdW1lXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxLkNTSURyaXZlclNwZWMjcG9kSW5mb09uTW91bnRcbiAgICovXG4gIHJlYWRvbmx5IHBvZEluZm9Pbk1vdW50PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogUmVxdWlyZXNSZXB1Ymxpc2ggaW5kaWNhdGVzIHRoZSBDU0kgZHJpdmVyIHdhbnRzIGBOb2RlUHVibGlzaFZvbHVtZWAgYmVpbmcgcGVyaW9kaWNhbGx5IGNhbGxlZCB0byByZWZsZWN0IGFueSBwb3NzaWJsZSBjaGFuZ2UgaW4gdGhlIG1vdW50ZWQgdm9sdW1lLiBUaGlzIGZpZWxkIGRlZmF1bHRzIHRvIGZhbHNlLlxuICAgKlxuICAgKiBOb3RlOiBBZnRlciBhIHN1Y2Nlc3NmdWwgaW5pdGlhbCBOb2RlUHVibGlzaFZvbHVtZSBjYWxsLCBzdWJzZXF1ZW50IGNhbGxzIHRvIE5vZGVQdWJsaXNoVm9sdW1lIHNob3VsZCBvbmx5IHVwZGF0ZSB0aGUgY29udGVudHMgb2YgdGhlIHZvbHVtZS4gTmV3IG1vdW50IHBvaW50cyB3aWxsIG5vdCBiZSBzZWVuIGJ5IGEgcnVubmluZyBjb250YWluZXIuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxLkNTSURyaXZlclNwZWMjcmVxdWlyZXNSZXB1Ymxpc2hcbiAgICovXG4gIHJlYWRvbmx5IHJlcXVpcmVzUmVwdWJsaXNoPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSWYgc2V0IHRvIHRydWUsIHN0b3JhZ2VDYXBhY2l0eSBpbmRpY2F0ZXMgdGhhdCB0aGUgQ1NJIHZvbHVtZSBkcml2ZXIgd2FudHMgcG9kIHNjaGVkdWxpbmcgdG8gY29uc2lkZXIgdGhlIHN0b3JhZ2UgY2FwYWNpdHkgdGhhdCB0aGUgZHJpdmVyIGRlcGxveW1lbnQgd2lsbCByZXBvcnQgYnkgY3JlYXRpbmcgQ1NJU3RvcmFnZUNhcGFjaXR5IG9iamVjdHMgd2l0aCBjYXBhY2l0eSBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogVGhlIGNoZWNrIGNhbiBiZSBlbmFibGVkIGltbWVkaWF0ZWx5IHdoZW4gZGVwbG95aW5nIGEgZHJpdmVyLiBJbiB0aGF0IGNhc2UsIHByb3Zpc2lvbmluZyBuZXcgdm9sdW1lcyB3aXRoIGxhdGUgYmluZGluZyB3aWxsIHBhdXNlIHVudGlsIHRoZSBkcml2ZXIgZGVwbG95bWVudCBoYXMgcHVibGlzaGVkIHNvbWUgc3VpdGFibGUgQ1NJU3RvcmFnZUNhcGFjaXR5IG9iamVjdC5cbiAgICpcbiAgICogQWx0ZXJuYXRpdmVseSwgdGhlIGRyaXZlciBjYW4gYmUgZGVwbG95ZWQgd2l0aCB0aGUgZmllbGQgdW5zZXQgb3IgZmFsc2UgYW5kIGl0IGNhbiBiZSBmbGlwcGVkIGxhdGVyIHdoZW4gc3RvcmFnZSBjYXBhY2l0eSBpbmZvcm1hdGlvbiBoYXMgYmVlbiBwdWJsaXNoZWQuXG4gICAqXG4gICAqIFRoaXMgZmllbGQgaXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGlzIGlzIGEgYmV0YSBmaWVsZCBhbmQgb25seSBhdmFpbGFibGUgd2hlbiB0aGUgQ1NJU3RvcmFnZUNhcGFjaXR5IGZlYXR1cmUgaXMgZW5hYmxlZC4gVGhlIGRlZmF1bHQgaXMgZmFsc2UuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxLkNTSURyaXZlclNwZWMjc3RvcmFnZUNhcGFjaXR5XG4gICAqL1xuICByZWFkb25seSBzdG9yYWdlQ2FwYWNpdHk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUb2tlblJlcXVlc3RzIGluZGljYXRlcyB0aGUgQ1NJIGRyaXZlciBuZWVkcyBwb2RzJyBzZXJ2aWNlIGFjY291bnQgdG9rZW5zIGl0IGlzIG1vdW50aW5nIHZvbHVtZSBmb3IgdG8gZG8gbmVjZXNzYXJ5IGF1dGhlbnRpY2F0aW9uLiBLdWJlbGV0IHdpbGwgcGFzcyB0aGUgdG9rZW5zIGluIFZvbHVtZUNvbnRleHQgaW4gdGhlIENTSSBOb2RlUHVibGlzaFZvbHVtZSBjYWxscy4gVGhlIENTSSBkcml2ZXIgc2hvdWxkIHBhcnNlIGFuZCB2YWxpZGF0ZSB0aGUgZm9sbG93aW5nIFZvbHVtZUNvbnRleHQ6IFwiY3NpLnN0b3JhZ2UuazhzLmlvL3NlcnZpY2VBY2NvdW50LnRva2Vuc1wiOiB7XG4gICAqIFwiPGF1ZGllbmNlPlwiOiB7XG4gICAqIFwidG9rZW5cIjogPHRva2VuPixcbiAgICogXCJleHBpcmF0aW9uVGltZXN0YW1wXCI6IDxleHBpcmF0aW9uIHRpbWVzdGFtcCBpbiBSRkMzMzM5PixcbiAgICogfSxcbiAgICogLi4uXG4gICAqIH1cbiAgICpcbiAgICogTm90ZTogQXVkaWVuY2UgaW4gZWFjaCBUb2tlblJlcXVlc3Qgc2hvdWxkIGJlIGRpZmZlcmVudCBhbmQgYXQgbW9zdCBvbmUgdG9rZW4gaXMgZW1wdHkgc3RyaW5nLiBUbyByZWNlaXZlIGEgbmV3IHRva2VuIGFmdGVyIGV4cGlyeSwgUmVxdWlyZXNSZXB1Ymxpc2ggY2FuIGJlIHVzZWQgdG8gdHJpZ2dlciBOb2RlUHVibGlzaFZvbHVtZSBwZXJpb2RpY2FsbHkuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxLkNTSURyaXZlclNwZWMjdG9rZW5SZXF1ZXN0c1xuICAgKi9cbiAgcmVhZG9ubHkgdG9rZW5SZXF1ZXN0cz86IFRva2VuUmVxdWVzdFtdO1xuXG4gIC8qKlxuICAgKiB2b2x1bWVMaWZlY3ljbGVNb2RlcyBkZWZpbmVzIHdoYXQga2luZCBvZiB2b2x1bWVzIHRoaXMgQ1NJIHZvbHVtZSBkcml2ZXIgc3VwcG9ydHMuIFRoZSBkZWZhdWx0IGlmIHRoZSBsaXN0IGlzIGVtcHR5IGlzIFwiUGVyc2lzdGVudFwiLCB3aGljaCBpcyB0aGUgdXNhZ2UgZGVmaW5lZCBieSB0aGUgQ1NJIHNwZWNpZmljYXRpb24gYW5kIGltcGxlbWVudGVkIGluIEt1YmVybmV0ZXMgdmlhIHRoZSB1c3VhbCBQVi9QVkMgbWVjaGFuaXNtLiBUaGUgb3RoZXIgbW9kZSBpcyBcIkVwaGVtZXJhbFwiLiBJbiB0aGlzIG1vZGUsIHZvbHVtZXMgYXJlIGRlZmluZWQgaW5saW5lIGluc2lkZSB0aGUgcG9kIHNwZWMgd2l0aCBDU0lWb2x1bWVTb3VyY2UgYW5kIHRoZWlyIGxpZmVjeWNsZSBpcyB0aWVkIHRvIHRoZSBsaWZlY3ljbGUgb2YgdGhhdCBwb2QuIEEgZHJpdmVyIGhhcyB0byBiZSBhd2FyZSBvZiB0aGlzIGJlY2F1c2UgaXQgaXMgb25seSBnb2luZyB0byBnZXQgYSBOb2RlUHVibGlzaFZvbHVtZSBjYWxsIGZvciBzdWNoIGEgdm9sdW1lLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBpbXBsZW1lbnRpbmcgdGhpcyBtb2RlLCBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLWNzaS5naXRodWIuaW8vZG9jcy9lcGhlbWVyYWwtbG9jYWwtdm9sdW1lcy5odG1sIEEgZHJpdmVyIGNhbiBzdXBwb3J0IG9uZSBvciBtb3JlIG9mIHRoZXNlIG1vZGVzIGFuZCBtb3JlIG1vZGVzIG1heSBiZSBhZGRlZCBpbiB0aGUgZnV0dXJlLiBUaGlzIGZpZWxkIGlzIGJldGEuXG4gICAqXG4gICAqIFRoaXMgZmllbGQgaXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5DU0lEcml2ZXJTcGVjI3ZvbHVtZUxpZmVjeWNsZU1vZGVzXG4gICAqL1xuICByZWFkb25seSB2b2x1bWVMaWZlY3ljbGVNb2Rlcz86IHN0cmluZ1tdO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0NzaURyaXZlclNwZWMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0NzaURyaXZlclNwZWMob2JqOiBDc2lEcml2ZXJTcGVjIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnYXR0YWNoUmVxdWlyZWQnOiBvYmouYXR0YWNoUmVxdWlyZWQsXG4gICAgJ2ZzR3JvdXBQb2xpY3knOiBvYmouZnNHcm91cFBvbGljeSxcbiAgICAncG9kSW5mb09uTW91bnQnOiBvYmoucG9kSW5mb09uTW91bnQsXG4gICAgJ3JlcXVpcmVzUmVwdWJsaXNoJzogb2JqLnJlcXVpcmVzUmVwdWJsaXNoLFxuICAgICdzdG9yYWdlQ2FwYWNpdHknOiBvYmouc3RvcmFnZUNhcGFjaXR5LFxuICAgICd0b2tlblJlcXVlc3RzJzogb2JqLnRva2VuUmVxdWVzdHM/Lm1hcCh5ID0+IHRvSnNvbl9Ub2tlblJlcXVlc3QoeSkpLFxuICAgICd2b2x1bWVMaWZlY3ljbGVNb2Rlcyc6IG9iai52b2x1bWVMaWZlY3ljbGVNb2Rlcz8ubWFwKHkgPT4geSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQ1NJTm9kZVNwZWMgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHNwZWNpZmljYXRpb24gb2YgYWxsIENTSSBkcml2ZXJzIGluc3RhbGxlZCBvbiBhIG5vZGVcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5DU0lOb2RlU3BlY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIENzaU5vZGVTcGVjIHtcbiAgLyoqXG4gICAqIGRyaXZlcnMgaXMgYSBsaXN0IG9mIGluZm9ybWF0aW9uIG9mIGFsbCBDU0kgRHJpdmVycyBleGlzdGluZyBvbiBhIG5vZGUuIElmIGFsbCBkcml2ZXJzIGluIHRoZSBsaXN0IGFyZSB1bmluc3RhbGxlZCwgdGhpcyBjYW4gYmVjb21lIGVtcHR5LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5DU0lOb2RlU3BlYyNkcml2ZXJzXG4gICAqL1xuICByZWFkb25seSBkcml2ZXJzOiBDc2lOb2RlRHJpdmVyW107XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnQ3NpTm9kZVNwZWMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0NzaU5vZGVTcGVjKG9iajogQ3NpTm9kZVNwZWMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdkcml2ZXJzJzogb2JqLmRyaXZlcnM/Lm1hcCh5ID0+IHRvSnNvbl9Dc2lOb2RlRHJpdmVyKHkpKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBBIHRvcG9sb2d5IHNlbGVjdG9yIHRlcm0gcmVwcmVzZW50cyB0aGUgcmVzdWx0IG9mIGxhYmVsIHF1ZXJpZXMuIEEgbnVsbCBvciBlbXB0eSB0b3BvbG9neSBzZWxlY3RvciB0ZXJtIG1hdGNoZXMgbm8gb2JqZWN0cy4gVGhlIHJlcXVpcmVtZW50cyBvZiB0aGVtIGFyZSBBTkRlZC4gSXQgcHJvdmlkZXMgYSBzdWJzZXQgb2YgZnVuY3Rpb25hbGl0eSBhcyBOb2RlU2VsZWN0b3JUZXJtLiBUaGlzIGlzIGFuIGFscGhhIGZlYXR1cmUgYW5kIG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Ub3BvbG9neVNlbGVjdG9yVGVybVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRvcG9sb2d5U2VsZWN0b3JUZXJtIHtcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0b3BvbG9neSBzZWxlY3RvciByZXF1aXJlbWVudHMgYnkgbGFiZWxzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Ub3BvbG9neVNlbGVjdG9yVGVybSNtYXRjaExhYmVsRXhwcmVzc2lvbnNcbiAgICovXG4gIHJlYWRvbmx5IG1hdGNoTGFiZWxFeHByZXNzaW9ucz86IFRvcG9sb2d5U2VsZWN0b3JMYWJlbFJlcXVpcmVtZW50W107XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnVG9wb2xvZ3lTZWxlY3RvclRlcm0nIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1RvcG9sb2d5U2VsZWN0b3JUZXJtKG9iajogVG9wb2xvZ3lTZWxlY3RvclRlcm0gfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtYXRjaExhYmVsRXhwcmVzc2lvbnMnOiBvYmoubWF0Y2hMYWJlbEV4cHJlc3Npb25zPy5tYXAoeSA9PiB0b0pzb25fVG9wb2xvZ3lTZWxlY3RvckxhYmVsUmVxdWlyZW1lbnQoeSkpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFZvbHVtZUF0dGFjaG1lbnRTcGVjIGlzIHRoZSBzcGVjaWZpY2F0aW9uIG9mIGEgVm9sdW1lQXR0YWNobWVudCByZXF1ZXN0LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxLlZvbHVtZUF0dGFjaG1lbnRTcGVjXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVm9sdW1lQXR0YWNobWVudFNwZWMge1xuICAvKipcbiAgICogQXR0YWNoZXIgaW5kaWNhdGVzIHRoZSBuYW1lIG9mIHRoZSB2b2x1bWUgZHJpdmVyIHRoYXQgTVVTVCBoYW5kbGUgdGhpcyByZXF1ZXN0LiBUaGlzIGlzIHRoZSBuYW1lIHJldHVybmVkIGJ5IEdldFBsdWdpbk5hbWUoKS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjEuVm9sdW1lQXR0YWNobWVudFNwZWMjYXR0YWNoZXJcbiAgICovXG4gIHJlYWRvbmx5IGF0dGFjaGVyOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBub2RlIHRoYXQgdGhlIHZvbHVtZSBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxLlZvbHVtZUF0dGFjaG1lbnRTcGVjI25vZGVOYW1lXG4gICAqL1xuICByZWFkb25seSBub2RlTmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTb3VyY2UgcmVwcmVzZW50cyB0aGUgdm9sdW1lIHRoYXQgc2hvdWxkIGJlIGF0dGFjaGVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5Wb2x1bWVBdHRhY2htZW50U3BlYyNzb3VyY2VcbiAgICovXG4gIHJlYWRvbmx5IHNvdXJjZTogVm9sdW1lQXR0YWNobWVudFNvdXJjZTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdWb2x1bWVBdHRhY2htZW50U3BlYycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fVm9sdW1lQXR0YWNobWVudFNwZWMob2JqOiBWb2x1bWVBdHRhY2htZW50U3BlYyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2F0dGFjaGVyJzogb2JqLmF0dGFjaGVyLFxuICAgICdub2RlTmFtZSc6IG9iai5ub2RlTmFtZSxcbiAgICAnc291cmNlJzogdG9Kc29uX1ZvbHVtZUF0dGFjaG1lbnRTb3VyY2Uob2JqLnNvdXJjZSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQHNjaGVtYSBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGkucmVzb3VyY2UuUXVhbnRpdHlcbiAqL1xuZXhwb3J0IGNsYXNzIFF1YW50aXR5IHtcbiAgcHVibGljIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlOiBzdHJpbmcpOiBRdWFudGl0eSB7XG4gICAgcmV0dXJuIG5ldyBRdWFudGl0eSh2YWx1ZSk7XG4gIH1cbiAgcHVibGljIHN0YXRpYyBmcm9tTnVtYmVyKHZhbHVlOiBudW1iZXIpOiBRdWFudGl0eSB7XG4gICAgcmV0dXJuIG5ldyBRdWFudGl0eSh2YWx1ZSk7XG4gIH1cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgdmFsdWU6IGFueSkge1xuICB9XG59XG5cbi8qKlxuICogQSBsYWJlbCBzZWxlY3RvciBpcyBhIGxhYmVsIHF1ZXJ5IG92ZXIgYSBzZXQgb2YgcmVzb3VyY2VzLiBUaGUgcmVzdWx0IG9mIG1hdGNoTGFiZWxzIGFuZCBtYXRjaEV4cHJlc3Npb25zIGFyZSBBTkRlZC4gQW4gZW1wdHkgbGFiZWwgc2VsZWN0b3IgbWF0Y2hlcyBhbGwgb2JqZWN0cy4gQSBudWxsIGxhYmVsIHNlbGVjdG9yIG1hdGNoZXMgbm8gb2JqZWN0cy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5MYWJlbFNlbGVjdG9yXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGFiZWxTZWxlY3RvciB7XG4gIC8qKlxuICAgKiBtYXRjaEV4cHJlc3Npb25zIGlzIGEgbGlzdCBvZiBsYWJlbCBzZWxlY3RvciByZXF1aXJlbWVudHMuIFRoZSByZXF1aXJlbWVudHMgYXJlIEFORGVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5MYWJlbFNlbGVjdG9yI21hdGNoRXhwcmVzc2lvbnNcbiAgICovXG4gIHJlYWRvbmx5IG1hdGNoRXhwcmVzc2lvbnM/OiBMYWJlbFNlbGVjdG9yUmVxdWlyZW1lbnRbXTtcblxuICAvKipcbiAgICogbWF0Y2hMYWJlbHMgaXMgYSBtYXAgb2Yge2tleSx2YWx1ZX0gcGFpcnMuIEEgc2luZ2xlIHtrZXksdmFsdWV9IGluIHRoZSBtYXRjaExhYmVscyBtYXAgaXMgZXF1aXZhbGVudCB0byBhbiBlbGVtZW50IG9mIG1hdGNoRXhwcmVzc2lvbnMsIHdob3NlIGtleSBmaWVsZCBpcyBcImtleVwiLCB0aGUgb3BlcmF0b3IgaXMgXCJJblwiLCBhbmQgdGhlIHZhbHVlcyBhcnJheSBjb250YWlucyBvbmx5IFwidmFsdWVcIi4gVGhlIHJlcXVpcmVtZW50cyBhcmUgQU5EZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLkxhYmVsU2VsZWN0b3IjbWF0Y2hMYWJlbHNcbiAgICovXG4gIHJlYWRvbmx5IG1hdGNoTGFiZWxzPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdMYWJlbFNlbGVjdG9yJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9MYWJlbFNlbGVjdG9yKG9iajogTGFiZWxTZWxlY3RvciB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21hdGNoRXhwcmVzc2lvbnMnOiBvYmoubWF0Y2hFeHByZXNzaW9ucz8ubWFwKHkgPT4gdG9Kc29uX0xhYmVsU2VsZWN0b3JSZXF1aXJlbWVudCh5KSksXG4gICAgJ21hdGNoTGFiZWxzJzogKChvYmoubWF0Y2hMYWJlbHMpID09PSB1bmRlZmluZWQpID8gdW5kZWZpbmVkIDogKE9iamVjdC5lbnRyaWVzKG9iai5tYXRjaExhYmVscykucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogVm9sdW1lQXR0YWNobWVudFNwZWMgaXMgdGhlIHNwZWNpZmljYXRpb24gb2YgYSBWb2x1bWVBdHRhY2htZW50IHJlcXVlc3QuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjFhbHBoYTEuVm9sdW1lQXR0YWNobWVudFNwZWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWb2x1bWVBdHRhY2htZW50U3BlY1YxQWxwaGExIHtcbiAgLyoqXG4gICAqIEF0dGFjaGVyIGluZGljYXRlcyB0aGUgbmFtZSBvZiB0aGUgdm9sdW1lIGRyaXZlciB0aGF0IE1VU1QgaGFuZGxlIHRoaXMgcmVxdWVzdC4gVGhpcyBpcyB0aGUgbmFtZSByZXR1cm5lZCBieSBHZXRQbHVnaW5OYW1lKCkuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxYWxwaGExLlZvbHVtZUF0dGFjaG1lbnRTcGVjI2F0dGFjaGVyXG4gICAqL1xuICByZWFkb25seSBhdHRhY2hlcjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbm9kZSB0aGF0IHRoZSB2b2x1bWUgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MWFscGhhMS5Wb2x1bWVBdHRhY2htZW50U3BlYyNub2RlTmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbm9kZU5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogU291cmNlIHJlcHJlc2VudHMgdGhlIHZvbHVtZSB0aGF0IHNob3VsZCBiZSBhdHRhY2hlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjFhbHBoYTEuVm9sdW1lQXR0YWNobWVudFNwZWMjc291cmNlXG4gICAqL1xuICByZWFkb25seSBzb3VyY2U6IFZvbHVtZUF0dGFjaG1lbnRTb3VyY2VWMUFscGhhMTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdWb2x1bWVBdHRhY2htZW50U3BlY1YxQWxwaGExJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Wb2x1bWVBdHRhY2htZW50U3BlY1YxQWxwaGExKG9iajogVm9sdW1lQXR0YWNobWVudFNwZWNWMUFscGhhMSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2F0dGFjaGVyJzogb2JqLmF0dGFjaGVyLFxuICAgICdub2RlTmFtZSc6IG9iai5ub2RlTmFtZSxcbiAgICAnc291cmNlJzogdG9Kc29uX1ZvbHVtZUF0dGFjaG1lbnRTb3VyY2VWMUFscGhhMShvYmouc291cmNlKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBDdXN0b21SZXNvdXJjZURlZmluaXRpb25TcGVjIGRlc2NyaWJlcyBob3cgYSB1c2VyIHdhbnRzIHRoZWlyIHJlc291cmNlIHRvIGFwcGVhclxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uU3BlY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbVJlc291cmNlRGVmaW5pdGlvblNwZWMge1xuICAvKipcbiAgICogY29udmVyc2lvbiBkZWZpbmVzIGNvbnZlcnNpb24gc2V0dGluZ3MgZm9yIHRoZSBDUkQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uU3BlYyNjb252ZXJzaW9uXG4gICAqL1xuICByZWFkb25seSBjb252ZXJzaW9uPzogQ3VzdG9tUmVzb3VyY2VDb252ZXJzaW9uO1xuXG4gIC8qKlxuICAgKiBncm91cCBpcyB0aGUgQVBJIGdyb3VwIG9mIHRoZSBkZWZpbmVkIGN1c3RvbSByZXNvdXJjZS4gVGhlIGN1c3RvbSByZXNvdXJjZXMgYXJlIHNlcnZlZCB1bmRlciBgL2FwaXMvPGdyb3VwPi8uLi5gLiBNdXN0IG1hdGNoIHRoZSBuYW1lIG9mIHRoZSBDdXN0b21SZXNvdXJjZURlZmluaXRpb24gKGluIHRoZSBmb3JtIGA8bmFtZXMucGx1cmFsPi48Z3JvdXA+YCkuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uU3BlYyNncm91cFxuICAgKi9cbiAgcmVhZG9ubHkgZ3JvdXA6IHN0cmluZztcblxuICAvKipcbiAgICogbmFtZXMgc3BlY2lmeSB0aGUgcmVzb3VyY2UgYW5kIGtpbmQgbmFtZXMgZm9yIHRoZSBjdXN0b20gcmVzb3VyY2UuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uU3BlYyNuYW1lc1xuICAgKi9cbiAgcmVhZG9ubHkgbmFtZXM6IEN1c3RvbVJlc291cmNlRGVmaW5pdGlvbk5hbWVzO1xuXG4gIC8qKlxuICAgKiBwcmVzZXJ2ZVVua25vd25GaWVsZHMgaW5kaWNhdGVzIHRoYXQgb2JqZWN0IGZpZWxkcyB3aGljaCBhcmUgbm90IHNwZWNpZmllZCBpbiB0aGUgT3BlbkFQSSBzY2hlbWEgc2hvdWxkIGJlIHByZXNlcnZlZCB3aGVuIHBlcnNpc3RpbmcgdG8gc3RvcmFnZS4gYXBpVmVyc2lvbiwga2luZCwgbWV0YWRhdGEgYW5kIGtub3duIGZpZWxkcyBpbnNpZGUgbWV0YWRhdGEgYXJlIGFsd2F5cyBwcmVzZXJ2ZWQuIFRoaXMgZmllbGQgaXMgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBzZXR0aW5nIGB4LXByZXNlcnZlLXVua25vd24tZmllbGRzYCB0byB0cnVlIGluIGBzcGVjLnZlcnNpb25zWypdLnNjaGVtYS5vcGVuQVBJVjNTY2hlbWFgLiBTZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvdGFza3MvYWNjZXNzLWt1YmVybmV0ZXMtYXBpL2N1c3RvbS1yZXNvdXJjZXMvY3VzdG9tLXJlc291cmNlLWRlZmluaXRpb25zLyNwcnVuaW5nLXZlcnN1cy1wcmVzZXJ2aW5nLXVua25vd24tZmllbGRzIGZvciBkZXRhaWxzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkN1c3RvbVJlc291cmNlRGVmaW5pdGlvblNwZWMjcHJlc2VydmVVbmtub3duRmllbGRzXG4gICAqL1xuICByZWFkb25seSBwcmVzZXJ2ZVVua25vd25GaWVsZHM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBzY29wZSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgZGVmaW5lZCBjdXN0b20gcmVzb3VyY2UgaXMgY2x1c3Rlci0gb3IgbmFtZXNwYWNlLXNjb3BlZC4gQWxsb3dlZCB2YWx1ZXMgYXJlIGBDbHVzdGVyYCBhbmQgYE5hbWVzcGFjZWRgLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkN1c3RvbVJlc291cmNlRGVmaW5pdGlvblNwZWMjc2NvcGVcbiAgICovXG4gIHJlYWRvbmx5IHNjb3BlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIHZlcnNpb25zIGlzIHRoZSBsaXN0IG9mIGFsbCBBUEkgdmVyc2lvbnMgb2YgdGhlIGRlZmluZWQgY3VzdG9tIHJlc291cmNlLiBWZXJzaW9uIG5hbWVzIGFyZSB1c2VkIHRvIGNvbXB1dGUgdGhlIG9yZGVyIGluIHdoaWNoIHNlcnZlZCB2ZXJzaW9ucyBhcmUgbGlzdGVkIGluIEFQSSBkaXNjb3ZlcnkuIElmIHRoZSB2ZXJzaW9uIHN0cmluZyBpcyBcImt1YmUtbGlrZVwiLCBpdCB3aWxsIHNvcnQgYWJvdmUgbm9uIFwia3ViZS1saWtlXCIgdmVyc2lvbiBzdHJpbmdzLCB3aGljaCBhcmUgb3JkZXJlZCBsZXhpY29ncmFwaGljYWxseS4gXCJLdWJlLWxpa2VcIiB2ZXJzaW9ucyBzdGFydCB3aXRoIGEgXCJ2XCIsIHRoZW4gYXJlIGZvbGxvd2VkIGJ5IGEgbnVtYmVyICh0aGUgbWFqb3IgdmVyc2lvbiksIHRoZW4gb3B0aW9uYWxseSB0aGUgc3RyaW5nIFwiYWxwaGFcIiBvciBcImJldGFcIiBhbmQgYW5vdGhlciBudW1iZXIgKHRoZSBtaW5vciB2ZXJzaW9uKS4gVGhlc2UgYXJlIHNvcnRlZCBmaXJzdCBieSBHQSA+IGJldGEgPiBhbHBoYSAod2hlcmUgR0EgaXMgYSB2ZXJzaW9uIHdpdGggbm8gc3VmZml4IHN1Y2ggYXMgYmV0YSBvciBhbHBoYSksIGFuZCB0aGVuIGJ5IGNvbXBhcmluZyBtYWpvciB2ZXJzaW9uLCB0aGVuIG1pbm9yIHZlcnNpb24uIEFuIGV4YW1wbGUgc29ydGVkIGxpc3Qgb2YgdmVyc2lvbnM6IHYxMCwgdjIsIHYxLCB2MTFiZXRhMiwgdjEwYmV0YTMsIHYzYmV0YTEsIHYxMmFscGhhMSwgdjExYWxwaGEyLCBmb28xLCBmb28xMC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5DdXN0b21SZXNvdXJjZURlZmluaXRpb25TcGVjI3ZlcnNpb25zXG4gICAqL1xuICByZWFkb25seSB2ZXJzaW9uczogQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uVmVyc2lvbltdO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0N1c3RvbVJlc291cmNlRGVmaW5pdGlvblNwZWMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0N1c3RvbVJlc291cmNlRGVmaW5pdGlvblNwZWMob2JqOiBDdXN0b21SZXNvdXJjZURlZmluaXRpb25TcGVjIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnY29udmVyc2lvbic6IHRvSnNvbl9DdXN0b21SZXNvdXJjZUNvbnZlcnNpb24ob2JqLmNvbnZlcnNpb24pLFxuICAgICdncm91cCc6IG9iai5ncm91cCxcbiAgICAnbmFtZXMnOiB0b0pzb25fQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uTmFtZXMob2JqLm5hbWVzKSxcbiAgICAncHJlc2VydmVVbmtub3duRmllbGRzJzogb2JqLnByZXNlcnZlVW5rbm93bkZpZWxkcyxcbiAgICAnc2NvcGUnOiBvYmouc2NvcGUsXG4gICAgJ3ZlcnNpb25zJzogb2JqLnZlcnNpb25zPy5tYXAoeSA9PiB0b0pzb25fQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uVmVyc2lvbih5KSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogU3RhdHVzRGV0YWlscyBpcyBhIHNldCBvZiBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdGhhdCBNQVkgYmUgc2V0IGJ5IHRoZSBzZXJ2ZXIgdG8gcHJvdmlkZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IGEgcmVzcG9uc2UuIFRoZSBSZWFzb24gZmllbGQgb2YgYSBTdGF0dXMgb2JqZWN0IGRlZmluZXMgd2hhdCBhdHRyaWJ1dGVzIHdpbGwgYmUgc2V0LiBDbGllbnRzIG11c3QgaWdub3JlIGZpZWxkcyB0aGF0IGRvIG5vdCBtYXRjaCB0aGUgZGVmaW5lZCB0eXBlIG9mIGVhY2ggYXR0cmlidXRlLCBhbmQgc2hvdWxkIGFzc3VtZSB0aGF0IGFueSBhdHRyaWJ1dGUgbWF5IGJlIGVtcHR5LCBpbnZhbGlkLCBvciB1bmRlciBkZWZpbmVkLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLlN0YXR1c0RldGFpbHNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdGF0dXNEZXRhaWxzIHtcbiAgLyoqXG4gICAqIFRoZSBDYXVzZXMgYXJyYXkgaW5jbHVkZXMgbW9yZSBkZXRhaWxzIGFzc29jaWF0ZWQgd2l0aCB0aGUgU3RhdHVzUmVhc29uIGZhaWx1cmUuIE5vdCBhbGwgU3RhdHVzUmVhc29ucyBtYXkgcHJvdmlkZSBkZXRhaWxlZCBjYXVzZXMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLlN0YXR1c0RldGFpbHMjY2F1c2VzXG4gICAqL1xuICByZWFkb25seSBjYXVzZXM/OiBTdGF0dXNDYXVzZVtdO1xuXG4gIC8qKlxuICAgKiBUaGUgZ3JvdXAgYXR0cmlidXRlIG9mIHRoZSByZXNvdXJjZSBhc3NvY2lhdGVkIHdpdGggdGhlIHN0YXR1cyBTdGF0dXNSZWFzb24uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLlN0YXR1c0RldGFpbHMjZ3JvdXBcbiAgICovXG4gIHJlYWRvbmx5IGdyb3VwPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUga2luZCBhdHRyaWJ1dGUgb2YgdGhlIHJlc291cmNlIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3RhdHVzIFN0YXR1c1JlYXNvbi4gT24gc29tZSBvcGVyYXRpb25zIG1heSBkaWZmZXIgZnJvbSB0aGUgcmVxdWVzdGVkIHJlc291cmNlIEtpbmQuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjdHlwZXMta2luZHNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuU3RhdHVzRGV0YWlscyNraW5kXG4gICAqL1xuICByZWFkb25seSBraW5kPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBhdHRyaWJ1dGUgb2YgdGhlIHJlc291cmNlIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3RhdHVzIFN0YXR1c1JlYXNvbiAod2hlbiB0aGVyZSBpcyBhIHNpbmdsZSBuYW1lIHdoaWNoIGNhbiBiZSBkZXNjcmliZWQpLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5TdGF0dXNEZXRhaWxzI25hbWVcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIElmIHNwZWNpZmllZCwgdGhlIHRpbWUgaW4gc2Vjb25kcyBiZWZvcmUgdGhlIG9wZXJhdGlvbiBzaG91bGQgYmUgcmV0cmllZC4gU29tZSBlcnJvcnMgbWF5IGluZGljYXRlIHRoZSBjbGllbnQgbXVzdCB0YWtlIGFuIGFsdGVybmF0ZSBhY3Rpb24gLSBmb3IgdGhvc2UgZXJyb3JzIHRoaXMgZmllbGQgbWF5IGluZGljYXRlIGhvdyBsb25nIHRvIHdhaXQgYmVmb3JlIHRha2luZyB0aGUgYWx0ZXJuYXRlIGFjdGlvbi5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuU3RhdHVzRGV0YWlscyNyZXRyeUFmdGVyU2Vjb25kc1xuICAgKi9cbiAgcmVhZG9ubHkgcmV0cnlBZnRlclNlY29uZHM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFVJRCBvZiB0aGUgcmVzb3VyY2UuICh3aGVuIHRoZXJlIGlzIGEgc2luZ2xlIHJlc291cmNlIHdoaWNoIGNhbiBiZSBkZXNjcmliZWQpLiBNb3JlIGluZm86IGh0dHA6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvdXNlci1ndWlkZS9pZGVudGlmaWVycyN1aWRzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLlN0YXR1c0RldGFpbHMjdWlkXG4gICAqL1xuICByZWFkb25seSB1aWQ/OiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnU3RhdHVzRGV0YWlscycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fU3RhdHVzRGV0YWlscyhvYmo6IFN0YXR1c0RldGFpbHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdjYXVzZXMnOiBvYmouY2F1c2VzPy5tYXAoeSA9PiB0b0pzb25fU3RhdHVzQ2F1c2UoeSkpLFxuICAgICdncm91cCc6IG9iai5ncm91cCxcbiAgICAna2luZCc6IG9iai5raW5kLFxuICAgICduYW1lJzogb2JqLm5hbWUsXG4gICAgJ3JldHJ5QWZ0ZXJTZWNvbmRzJzogb2JqLnJldHJ5QWZ0ZXJTZWNvbmRzLFxuICAgICd1aWQnOiBvYmoudWlkLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEFQSVNlcnZpY2VTcGVjIGNvbnRhaW5zIGluZm9ybWF0aW9uIGZvciBsb2NhdGluZyBhbmQgY29tbXVuaWNhdGluZyB3aXRoIGEgc2VydmVyLiBPbmx5IGh0dHBzIGlzIHN1cHBvcnRlZCwgdGhvdWdoIHlvdSBhcmUgYWJsZSB0byBkaXNhYmxlIGNlcnRpZmljYXRlIHZlcmlmaWNhdGlvbi5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5rdWJlLWFnZ3JlZ2F0b3IucGtnLmFwaXMuYXBpcmVnaXN0cmF0aW9uLnYxLkFQSVNlcnZpY2VTcGVjXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXBpU2VydmljZVNwZWMge1xuICAvKipcbiAgICogQ0FCdW5kbGUgaXMgYSBQRU0gZW5jb2RlZCBDQSBidW5kbGUgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIGFuIEFQSSBzZXJ2ZXIncyBzZXJ2aW5nIGNlcnRpZmljYXRlLiBJZiB1bnNwZWNpZmllZCwgc3lzdGVtIHRydXN0IHJvb3RzIG9uIHRoZSBhcGlzZXJ2ZXIgYXJlIHVzZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmt1YmUtYWdncmVnYXRvci5wa2cuYXBpcy5hcGlyZWdpc3RyYXRpb24udjEuQVBJU2VydmljZVNwZWMjY2FCdW5kbGVcbiAgICovXG4gIHJlYWRvbmx5IGNhQnVuZGxlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBHcm91cCBpcyB0aGUgQVBJIGdyb3VwIG5hbWUgdGhpcyBzZXJ2ZXIgaG9zdHNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMua3ViZS1hZ2dyZWdhdG9yLnBrZy5hcGlzLmFwaXJlZ2lzdHJhdGlvbi52MS5BUElTZXJ2aWNlU3BlYyNncm91cFxuICAgKi9cbiAgcmVhZG9ubHkgZ3JvdXA/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEdyb3VwUHJpb3JpdHlNaW5pbnVtIGlzIHRoZSBwcmlvcml0eSB0aGlzIGdyb3VwIHNob3VsZCBoYXZlIGF0IGxlYXN0LiBIaWdoZXIgcHJpb3JpdHkgbWVhbnMgdGhhdCB0aGUgZ3JvdXAgaXMgcHJlZmVycmVkIGJ5IGNsaWVudHMgb3ZlciBsb3dlciBwcmlvcml0eSBvbmVzLiBOb3RlIHRoYXQgb3RoZXIgdmVyc2lvbnMgb2YgdGhpcyBncm91cCBtaWdodCBzcGVjaWZ5IGV2ZW4gaGlnaGVyIEdyb3VwUHJpb3JpdHlNaW5pbnVtIHZhbHVlcyBzdWNoIHRoYXQgdGhlIHdob2xlIGdyb3VwIGdldHMgYSBoaWdoZXIgcHJpb3JpdHkuIFRoZSBwcmltYXJ5IHNvcnQgaXMgYmFzZWQgb24gR3JvdXBQcmlvcml0eU1pbmltdW0sIG9yZGVyZWQgaGlnaGVzdCBudW1iZXIgdG8gbG93ZXN0ICgyMCBiZWZvcmUgMTApLiBUaGUgc2Vjb25kYXJ5IHNvcnQgaXMgYmFzZWQgb24gdGhlIGFscGhhYmV0aWNhbCBjb21wYXJpc29uIG9mIHRoZSBuYW1lIG9mIHRoZSBvYmplY3QuICAodjEuYmFyIGJlZm9yZSB2MS5mb28pIFdlJ2QgcmVjb21tZW5kIHNvbWV0aGluZyBsaWtlOiAqLms4cy5pbyAoZXhjZXB0IGV4dGVuc2lvbnMpIGF0IDE4MDAwIGFuZCBQYWFTZXMgKE9wZW5TaGlmdCwgRGVpcykgYXJlIHJlY29tbWVuZGVkIHRvIGJlIGluIHRoZSAyMDAwc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5rdWJlLWFnZ3JlZ2F0b3IucGtnLmFwaXMuYXBpcmVnaXN0cmF0aW9uLnYxLkFQSVNlcnZpY2VTcGVjI2dyb3VwUHJpb3JpdHlNaW5pbXVtXG4gICAqL1xuICByZWFkb25seSBncm91cFByaW9yaXR5TWluaW11bTogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBJbnNlY3VyZVNraXBUTFNWZXJpZnkgZGlzYWJsZXMgVExTIGNlcnRpZmljYXRlIHZlcmlmaWNhdGlvbiB3aGVuIGNvbW11bmljYXRpbmcgd2l0aCB0aGlzIHNlcnZlci4gVGhpcyBpcyBzdHJvbmdseSBkaXNjb3VyYWdlZC4gIFlvdSBzaG91bGQgdXNlIHRoZSBDQUJ1bmRsZSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5rdWJlLWFnZ3JlZ2F0b3IucGtnLmFwaXMuYXBpcmVnaXN0cmF0aW9uLnYxLkFQSVNlcnZpY2VTcGVjI2luc2VjdXJlU2tpcFRMU1ZlcmlmeVxuICAgKi9cbiAgcmVhZG9ubHkgaW5zZWN1cmVTa2lwVGxzVmVyaWZ5PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogU2VydmljZSBpcyBhIHJlZmVyZW5jZSB0byB0aGUgc2VydmljZSBmb3IgdGhpcyBBUEkgc2VydmVyLiAgSXQgbXVzdCBjb21tdW5pY2F0ZSBvbiBwb3J0IDQ0My4gSWYgdGhlIFNlcnZpY2UgaXMgbmlsLCB0aGF0IG1lYW5zIHRoZSBoYW5kbGluZyBmb3IgdGhlIEFQSSBncm91cHZlcnNpb24gaXMgaGFuZGxlZCBsb2NhbGx5IG9uIHRoaXMgc2VydmVyLiBUaGUgY2FsbCB3aWxsIHNpbXBseSBkZWxlZ2F0ZSB0byB0aGUgbm9ybWFsIGhhbmRsZXIgY2hhaW4gdG8gYmUgZnVsZmlsbGVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5rdWJlLWFnZ3JlZ2F0b3IucGtnLmFwaXMuYXBpcmVnaXN0cmF0aW9uLnYxLkFQSVNlcnZpY2VTcGVjI3NlcnZpY2VcbiAgICovXG4gIHJlYWRvbmx5IHNlcnZpY2U/OiBTZXJ2aWNlUmVmZXJlbmNlO1xuXG4gIC8qKlxuICAgKiBWZXJzaW9uIGlzIHRoZSBBUEkgdmVyc2lvbiB0aGlzIHNlcnZlciBob3N0cy4gIEZvciBleGFtcGxlLCBcInYxXCJcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMua3ViZS1hZ2dyZWdhdG9yLnBrZy5hcGlzLmFwaXJlZ2lzdHJhdGlvbi52MS5BUElTZXJ2aWNlU3BlYyN2ZXJzaW9uXG4gICAqL1xuICByZWFkb25seSB2ZXJzaW9uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBWZXJzaW9uUHJpb3JpdHkgY29udHJvbHMgdGhlIG9yZGVyaW5nIG9mIHRoaXMgQVBJIHZlcnNpb24gaW5zaWRlIG9mIGl0cyBncm91cC4gIE11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8uIFRoZSBwcmltYXJ5IHNvcnQgaXMgYmFzZWQgb24gVmVyc2lvblByaW9yaXR5LCBvcmRlcmVkIGhpZ2hlc3QgdG8gbG93ZXN0ICgyMCBiZWZvcmUgMTApLiBTaW5jZSBpdCdzIGluc2lkZSBvZiBhIGdyb3VwLCB0aGUgbnVtYmVyIGNhbiBiZSBzbWFsbCwgcHJvYmFibHkgaW4gdGhlIDEwcy4gSW4gY2FzZSBvZiBlcXVhbCB2ZXJzaW9uIHByaW9yaXRpZXMsIHRoZSB2ZXJzaW9uIHN0cmluZyB3aWxsIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgb3JkZXIgaW5zaWRlIGEgZ3JvdXAuIElmIHRoZSB2ZXJzaW9uIHN0cmluZyBpcyBcImt1YmUtbGlrZVwiLCBpdCB3aWxsIHNvcnQgYWJvdmUgbm9uIFwia3ViZS1saWtlXCIgdmVyc2lvbiBzdHJpbmdzLCB3aGljaCBhcmUgb3JkZXJlZCBsZXhpY29ncmFwaGljYWxseS4gXCJLdWJlLWxpa2VcIiB2ZXJzaW9ucyBzdGFydCB3aXRoIGEgXCJ2XCIsIHRoZW4gYXJlIGZvbGxvd2VkIGJ5IGEgbnVtYmVyICh0aGUgbWFqb3IgdmVyc2lvbiksIHRoZW4gb3B0aW9uYWxseSB0aGUgc3RyaW5nIFwiYWxwaGFcIiBvciBcImJldGFcIiBhbmQgYW5vdGhlciBudW1iZXIgKHRoZSBtaW5vciB2ZXJzaW9uKS4gVGhlc2UgYXJlIHNvcnRlZCBmaXJzdCBieSBHQSA+IGJldGEgPiBhbHBoYSAod2hlcmUgR0EgaXMgYSB2ZXJzaW9uIHdpdGggbm8gc3VmZml4IHN1Y2ggYXMgYmV0YSBvciBhbHBoYSksIGFuZCB0aGVuIGJ5IGNvbXBhcmluZyBtYWpvciB2ZXJzaW9uLCB0aGVuIG1pbm9yIHZlcnNpb24uIEFuIGV4YW1wbGUgc29ydGVkIGxpc3Qgb2YgdmVyc2lvbnM6IHYxMCwgdjIsIHYxLCB2MTFiZXRhMiwgdjEwYmV0YTMsIHYzYmV0YTEsIHYxMmFscGhhMSwgdjExYWxwaGEyLCBmb28xLCBmb28xMC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMua3ViZS1hZ2dyZWdhdG9yLnBrZy5hcGlzLmFwaXJlZ2lzdHJhdGlvbi52MS5BUElTZXJ2aWNlU3BlYyN2ZXJzaW9uUHJpb3JpdHlcbiAgICovXG4gIHJlYWRvbmx5IHZlcnNpb25Qcmlvcml0eTogbnVtYmVyO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0FwaVNlcnZpY2VTcGVjJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9BcGlTZXJ2aWNlU3BlYyhvYmo6IEFwaVNlcnZpY2VTcGVjIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnY2FCdW5kbGUnOiBvYmouY2FCdW5kbGUsXG4gICAgJ2dyb3VwJzogb2JqLmdyb3VwLFxuICAgICdncm91cFByaW9yaXR5TWluaW11bSc6IG9iai5ncm91cFByaW9yaXR5TWluaW11bSxcbiAgICAnaW5zZWN1cmVTa2lwVExTVmVyaWZ5Jzogb2JqLmluc2VjdXJlU2tpcFRsc1ZlcmlmeSxcbiAgICAnc2VydmljZSc6IHRvSnNvbl9TZXJ2aWNlUmVmZXJlbmNlKG9iai5zZXJ2aWNlKSxcbiAgICAndmVyc2lvbic6IG9iai52ZXJzaW9uLFxuICAgICd2ZXJzaW9uUHJpb3JpdHknOiBvYmoudmVyc2lvblByaW9yaXR5LFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIE1hbmFnZWRGaWVsZHNFbnRyeSBpcyBhIHdvcmtmbG93LWlkLCBhIEZpZWxkU2V0IGFuZCB0aGUgZ3JvdXAgdmVyc2lvbiBvZiB0aGUgcmVzb3VyY2UgdGhhdCB0aGUgZmllbGRzZXQgYXBwbGllcyB0by5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5NYW5hZ2VkRmllbGRzRW50cnlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNYW5hZ2VkRmllbGRzRW50cnkge1xuICAvKipcbiAgICogQVBJVmVyc2lvbiBkZWZpbmVzIHRoZSB2ZXJzaW9uIG9mIHRoaXMgcmVzb3VyY2UgdGhhdCB0aGlzIGZpZWxkIHNldCBhcHBsaWVzIHRvLiBUaGUgZm9ybWF0IGlzIFwiZ3JvdXAvdmVyc2lvblwiIGp1c3QgbGlrZSB0aGUgdG9wLWxldmVsIEFQSVZlcnNpb24gZmllbGQuIEl0IGlzIG5lY2Vzc2FyeSB0byB0cmFjayB0aGUgdmVyc2lvbiBvZiBhIGZpZWxkIHNldCBiZWNhdXNlIGl0IGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuTWFuYWdlZEZpZWxkc0VudHJ5I2FwaVZlcnNpb25cbiAgICovXG4gIHJlYWRvbmx5IGFwaVZlcnNpb24/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEZpZWxkc1R5cGUgaXMgdGhlIGRpc2NyaW1pbmF0b3IgZm9yIHRoZSBkaWZmZXJlbnQgZmllbGRzIGZvcm1hdCBhbmQgdmVyc2lvbi4gVGhlcmUgaXMgY3VycmVudGx5IG9ubHkgb25lIHBvc3NpYmxlIHZhbHVlOiBcIkZpZWxkc1YxXCJcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuTWFuYWdlZEZpZWxkc0VudHJ5I2ZpZWxkc1R5cGVcbiAgICovXG4gIHJlYWRvbmx5IGZpZWxkc1R5cGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEZpZWxkc1YxIGhvbGRzIHRoZSBmaXJzdCBKU09OIHZlcnNpb24gZm9ybWF0IGFzIGRlc2NyaWJlZCBpbiB0aGUgXCJGaWVsZHNWMVwiIHR5cGUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLk1hbmFnZWRGaWVsZHNFbnRyeSNmaWVsZHNWMVxuICAgKi9cbiAgcmVhZG9ubHkgZmllbGRzVjE/OiBhbnk7XG5cbiAgLyoqXG4gICAqIE1hbmFnZXIgaXMgYW4gaWRlbnRpZmllciBvZiB0aGUgd29ya2Zsb3cgbWFuYWdpbmcgdGhlc2UgZmllbGRzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5NYW5hZ2VkRmllbGRzRW50cnkjbWFuYWdlclxuICAgKi9cbiAgcmVhZG9ubHkgbWFuYWdlcj86IHN0cmluZztcblxuICAvKipcbiAgICogT3BlcmF0aW9uIGlzIHRoZSB0eXBlIG9mIG9wZXJhdGlvbiB3aGljaCBsZWFkIHRvIHRoaXMgTWFuYWdlZEZpZWxkc0VudHJ5IGJlaW5nIGNyZWF0ZWQuIFRoZSBvbmx5IHZhbGlkIHZhbHVlcyBmb3IgdGhpcyBmaWVsZCBhcmUgJ0FwcGx5JyBhbmQgJ1VwZGF0ZScuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLk1hbmFnZWRGaWVsZHNFbnRyeSNvcGVyYXRpb25cbiAgICovXG4gIHJlYWRvbmx5IG9wZXJhdGlvbj86IHN0cmluZztcblxuICAvKipcbiAgICogU3VicmVzb3VyY2UgaXMgdGhlIG5hbWUgb2YgdGhlIHN1YnJlc291cmNlIHVzZWQgdG8gdXBkYXRlIHRoYXQgb2JqZWN0LCBvciBlbXB0eSBzdHJpbmcgaWYgdGhlIG9iamVjdCB3YXMgdXBkYXRlZCB0aHJvdWdoIHRoZSBtYWluIHJlc291cmNlLiBUaGUgdmFsdWUgb2YgdGhpcyBmaWVsZCBpcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gbWFuYWdlcnMsIGV2ZW4gaWYgdGhleSBzaGFyZSB0aGUgc2FtZSBuYW1lLiBGb3IgZXhhbXBsZSwgYSBzdGF0dXMgdXBkYXRlIHdpbGwgYmUgZGlzdGluY3QgZnJvbSBhIHJlZ3VsYXIgdXBkYXRlIHVzaW5nIHRoZSBzYW1lIG1hbmFnZXIgbmFtZS4gTm90ZSB0aGF0IHRoZSBBUElWZXJzaW9uIGZpZWxkIGlzIG5vdCByZWxhdGVkIHRvIHRoZSBTdWJyZXNvdXJjZSBmaWVsZCBhbmQgaXQgYWx3YXlzIGNvcnJlc3BvbmRzIHRvIHRoZSB2ZXJzaW9uIG9mIHRoZSBtYWluIHJlc291cmNlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5NYW5hZ2VkRmllbGRzRW50cnkjc3VicmVzb3VyY2VcbiAgICovXG4gIHJlYWRvbmx5IHN1YnJlc291cmNlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaW1lIGlzIHRpbWVzdGFtcCBvZiB3aGVuIHRoZXNlIGZpZWxkcyB3ZXJlIHNldC4gSXQgc2hvdWxkIGFsd2F5cyBiZSBlbXB0eSBpZiBPcGVyYXRpb24gaXMgJ0FwcGx5J1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5NYW5hZ2VkRmllbGRzRW50cnkjdGltZVxuICAgKi9cbiAgcmVhZG9ubHkgdGltZT86IERhdGU7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnTWFuYWdlZEZpZWxkc0VudHJ5JyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9NYW5hZ2VkRmllbGRzRW50cnkob2JqOiBNYW5hZ2VkRmllbGRzRW50cnkgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdhcGlWZXJzaW9uJzogb2JqLmFwaVZlcnNpb24sXG4gICAgJ2ZpZWxkc1R5cGUnOiBvYmouZmllbGRzVHlwZSxcbiAgICAnZmllbGRzVjEnOiBvYmouZmllbGRzVjEsXG4gICAgJ21hbmFnZXInOiBvYmoubWFuYWdlcixcbiAgICAnb3BlcmF0aW9uJzogb2JqLm9wZXJhdGlvbixcbiAgICAnc3VicmVzb3VyY2UnOiBvYmouc3VicmVzb3VyY2UsXG4gICAgJ3RpbWUnOiBvYmoudGltZT8udG9JU09TdHJpbmcoKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBPd25lclJlZmVyZW5jZSBjb250YWlucyBlbm91Z2ggaW5mb3JtYXRpb24gdG8gbGV0IHlvdSBpZGVudGlmeSBhbiBvd25pbmcgb2JqZWN0LiBBbiBvd25pbmcgb2JqZWN0IG11c3QgYmUgaW4gdGhlIHNhbWUgbmFtZXNwYWNlIGFzIHRoZSBkZXBlbmRlbnQsIG9yIGJlIGNsdXN0ZXItc2NvcGVkLCBzbyB0aGVyZSBpcyBubyBuYW1lc3BhY2UgZmllbGQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuT3duZXJSZWZlcmVuY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBPd25lclJlZmVyZW5jZSB7XG4gIC8qKlxuICAgKiBBUEkgdmVyc2lvbiBvZiB0aGUgcmVmZXJlbnQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLk93bmVyUmVmZXJlbmNlI2FwaVZlcnNpb25cbiAgICovXG4gIHJlYWRvbmx5IGFwaVZlcnNpb246IHN0cmluZztcblxuICAvKipcbiAgICogSWYgdHJ1ZSwgQU5EIGlmIHRoZSBvd25lciBoYXMgdGhlIFwiZm9yZWdyb3VuZERlbGV0aW9uXCIgZmluYWxpemVyLCB0aGVuIHRoZSBvd25lciBjYW5ub3QgYmUgZGVsZXRlZCBmcm9tIHRoZSBrZXktdmFsdWUgc3RvcmUgdW50aWwgdGhpcyByZWZlcmVuY2UgaXMgcmVtb3ZlZC4gRGVmYXVsdHMgdG8gZmFsc2UuIFRvIHNldCB0aGlzIGZpZWxkLCBhIHVzZXIgbmVlZHMgXCJkZWxldGVcIiBwZXJtaXNzaW9uIG9mIHRoZSBvd25lciwgb3RoZXJ3aXNlIDQyMiAoVW5wcm9jZXNzYWJsZSBFbnRpdHkpIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlLiBUbyBzZXQgdGhpcyBmaWVsZCwgYSB1c2VyIG5lZWRzIFwiZGVsZXRlXCIgcGVybWlzc2lvbiBvZiB0aGUgb3duZXIsIG90aGVyd2lzZSA0MjIgKFVucHJvY2Vzc2FibGUgRW50aXR5KSB3aWxsIGJlIHJldHVybmVkLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5Pd25lclJlZmVyZW5jZSNibG9ja093bmVyRGVsZXRpb25cbiAgICovXG4gIHJlYWRvbmx5IGJsb2NrT3duZXJEZWxldGlvbj86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIElmIHRydWUsIHRoaXMgcmVmZXJlbmNlIHBvaW50cyB0byB0aGUgbWFuYWdpbmcgY29udHJvbGxlci5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuT3duZXJSZWZlcmVuY2UjY29udHJvbGxlclxuICAgKi9cbiAgcmVhZG9ubHkgY29udHJvbGxlcj86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEtpbmQgb2YgdGhlIHJlZmVyZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3R5cGVzLWtpbmRzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLk93bmVyUmVmZXJlbmNlI2tpbmRcbiAgICovXG4gIHJlYWRvbmx5IGtpbmQ6IHN0cmluZztcblxuICAvKipcbiAgICogTmFtZSBvZiB0aGUgcmVmZXJlbnQuIE1vcmUgaW5mbzogaHR0cDovL2t1YmVybmV0ZXMuaW8vZG9jcy91c2VyLWd1aWRlL2lkZW50aWZpZXJzI25hbWVzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLk93bmVyUmVmZXJlbmNlI25hbWVcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogVUlEIG9mIHRoZSByZWZlcmVudC4gTW9yZSBpbmZvOiBodHRwOi8va3ViZXJuZXRlcy5pby9kb2NzL3VzZXItZ3VpZGUvaWRlbnRpZmllcnMjdWlkc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5Pd25lclJlZmVyZW5jZSN1aWRcbiAgICovXG4gIHJlYWRvbmx5IHVpZDogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ093bmVyUmVmZXJlbmNlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Pd25lclJlZmVyZW5jZShvYmo6IE93bmVyUmVmZXJlbmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnYXBpVmVyc2lvbic6IG9iai5hcGlWZXJzaW9uLFxuICAgICdibG9ja093bmVyRGVsZXRpb24nOiBvYmouYmxvY2tPd25lckRlbGV0aW9uLFxuICAgICdjb250cm9sbGVyJzogb2JqLmNvbnRyb2xsZXIsXG4gICAgJ2tpbmQnOiBvYmoua2luZCxcbiAgICAnbmFtZSc6IG9iai5uYW1lLFxuICAgICd1aWQnOiBvYmoudWlkLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFdlYmhvb2tDbGllbnRDb25maWcgY29udGFpbnMgdGhlIGluZm9ybWF0aW9uIHRvIG1ha2UgYSBUTFMgY29ubmVjdGlvbiB3aXRoIHRoZSB3ZWJob29rXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmFkbWlzc2lvbnJlZ2lzdHJhdGlvbi52MS5XZWJob29rQ2xpZW50Q29uZmlnXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgV2ViaG9va0NsaWVudENvbmZpZyB7XG4gIC8qKlxuICAgKiBgY2FCdW5kbGVgIGlzIGEgUEVNIGVuY29kZWQgQ0EgYnVuZGxlIHdoaWNoIHdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZSB0aGUgd2ViaG9vaydzIHNlcnZlciBjZXJ0aWZpY2F0ZS4gSWYgdW5zcGVjaWZpZWQsIHN5c3RlbSB0cnVzdCByb290cyBvbiB0aGUgYXBpc2VydmVyIGFyZSB1c2VkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYWRtaXNzaW9ucmVnaXN0cmF0aW9uLnYxLldlYmhvb2tDbGllbnRDb25maWcjY2FCdW5kbGVcbiAgICovXG4gIHJlYWRvbmx5IGNhQnVuZGxlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBgc2VydmljZWAgaXMgYSByZWZlcmVuY2UgdG8gdGhlIHNlcnZpY2UgZm9yIHRoaXMgd2ViaG9vay4gRWl0aGVyIGBzZXJ2aWNlYCBvciBgdXJsYCBtdXN0IGJlIHNwZWNpZmllZC5cbiAgICpcbiAgICogSWYgdGhlIHdlYmhvb2sgaXMgcnVubmluZyB3aXRoaW4gdGhlIGNsdXN0ZXIsIHRoZW4geW91IHNob3VsZCB1c2UgYHNlcnZpY2VgLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYWRtaXNzaW9ucmVnaXN0cmF0aW9uLnYxLldlYmhvb2tDbGllbnRDb25maWcjc2VydmljZVxuICAgKi9cbiAgcmVhZG9ubHkgc2VydmljZT86IFNlcnZpY2VSZWZlcmVuY2U7XG5cbiAgLyoqXG4gICAqIGB1cmxgIGdpdmVzIHRoZSBsb2NhdGlvbiBvZiB0aGUgd2ViaG9vaywgaW4gc3RhbmRhcmQgVVJMIGZvcm0gKGBzY2hlbWU6Ly9ob3N0OnBvcnQvcGF0aGApLiBFeGFjdGx5IG9uZSBvZiBgdXJsYCBvciBgc2VydmljZWAgbXVzdCBiZSBzcGVjaWZpZWQuXG4gICAqXG4gICAqIFRoZSBgaG9zdGAgc2hvdWxkIG5vdCByZWZlciB0byBhIHNlcnZpY2UgcnVubmluZyBpbiB0aGUgY2x1c3RlcjsgdXNlIHRoZSBgc2VydmljZWAgZmllbGQgaW5zdGVhZC4gVGhlIGhvc3QgbWlnaHQgYmUgcmVzb2x2ZWQgdmlhIGV4dGVybmFsIEROUyBpbiBzb21lIGFwaXNlcnZlcnMgKGUuZy4sIGBrdWJlLWFwaXNlcnZlcmAgY2Fubm90IHJlc29sdmUgaW4tY2x1c3RlciBETlMgYXMgdGhhdCB3b3VsZCBiZSBhIGxheWVyaW5nIHZpb2xhdGlvbikuIGBob3N0YCBtYXkgYWxzbyBiZSBhbiBJUCBhZGRyZXNzLlxuICAgKlxuICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHVzaW5nIGBsb2NhbGhvc3RgIG9yIGAxMjcuMC4wLjFgIGFzIGEgYGhvc3RgIGlzIHJpc2t5IHVubGVzcyB5b3UgdGFrZSBncmVhdCBjYXJlIHRvIHJ1biB0aGlzIHdlYmhvb2sgb24gYWxsIGhvc3RzIHdoaWNoIHJ1biBhbiBhcGlzZXJ2ZXIgd2hpY2ggbWlnaHQgbmVlZCB0byBtYWtlIGNhbGxzIHRvIHRoaXMgd2ViaG9vay4gU3VjaCBpbnN0YWxscyBhcmUgbGlrZWx5IHRvIGJlIG5vbi1wb3J0YWJsZSwgaS5lLiwgbm90IGVhc3kgdG8gdHVybiB1cCBpbiBhIG5ldyBjbHVzdGVyLlxuICAgKlxuICAgKiBUaGUgc2NoZW1lIG11c3QgYmUgXCJodHRwc1wiOyB0aGUgVVJMIG11c3QgYmVnaW4gd2l0aCBcImh0dHBzOi8vXCIuXG4gICAqXG4gICAqIEEgcGF0aCBpcyBvcHRpb25hbCwgYW5kIGlmIHByZXNlbnQgbWF5IGJlIGFueSBzdHJpbmcgcGVybWlzc2libGUgaW4gYSBVUkwuIFlvdSBtYXkgdXNlIHRoZSBwYXRoIHRvIHBhc3MgYW4gYXJiaXRyYXJ5IHN0cmluZyB0byB0aGUgd2ViaG9vaywgZm9yIGV4YW1wbGUsIGEgY2x1c3RlciBpZGVudGlmaWVyLlxuICAgKlxuICAgKiBBdHRlbXB0aW5nIHRvIHVzZSBhIHVzZXIgb3IgYmFzaWMgYXV0aCBlLmcuIFwidXNlcjpwYXNzd29yZEBcIiBpcyBub3QgYWxsb3dlZC4gRnJhZ21lbnRzIChcIiMuLi5cIikgYW5kIHF1ZXJ5IHBhcmFtZXRlcnMgKFwiPy4uLlwiKSBhcmUgbm90IGFsbG93ZWQsIGVpdGhlci5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFkbWlzc2lvbnJlZ2lzdHJhdGlvbi52MS5XZWJob29rQ2xpZW50Q29uZmlnI3VybFxuICAgKi9cbiAgcmVhZG9ubHkgdXJsPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1dlYmhvb2tDbGllbnRDb25maWcnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1dlYmhvb2tDbGllbnRDb25maWcob2JqOiBXZWJob29rQ2xpZW50Q29uZmlnIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnY2FCdW5kbGUnOiBvYmouY2FCdW5kbGUsXG4gICAgJ3NlcnZpY2UnOiB0b0pzb25fU2VydmljZVJlZmVyZW5jZShvYmouc2VydmljZSksXG4gICAgJ3VybCc6IG9iai51cmwsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUnVsZVdpdGhPcGVyYXRpb25zIGlzIGEgdHVwbGUgb2YgT3BlcmF0aW9ucyBhbmQgUmVzb3VyY2VzLiBJdCBpcyByZWNvbW1lbmRlZCB0byBtYWtlIHN1cmUgdGhhdCBhbGwgdGhlIHR1cGxlIGV4cGFuc2lvbnMgYXJlIHZhbGlkLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuUnVsZVdpdGhPcGVyYXRpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUnVsZVdpdGhPcGVyYXRpb25zIHtcbiAgLyoqXG4gICAqIEFQSUdyb3VwcyBpcyB0aGUgQVBJIGdyb3VwcyB0aGUgcmVzb3VyY2VzIGJlbG9uZyB0by4gJyonIGlzIGFsbCBncm91cHMuIElmICcqJyBpcyBwcmVzZW50LCB0aGUgbGVuZ3RoIG9mIHRoZSBzbGljZSBtdXN0IGJlIG9uZS4gUmVxdWlyZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuUnVsZVdpdGhPcGVyYXRpb25zI2FwaUdyb3Vwc1xuICAgKi9cbiAgcmVhZG9ubHkgYXBpR3JvdXBzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIEFQSVZlcnNpb25zIGlzIHRoZSBBUEkgdmVyc2lvbnMgdGhlIHJlc291cmNlcyBiZWxvbmcgdG8uICcqJyBpcyBhbGwgdmVyc2lvbnMuIElmICcqJyBpcyBwcmVzZW50LCB0aGUgbGVuZ3RoIG9mIHRoZSBzbGljZSBtdXN0IGJlIG9uZS4gUmVxdWlyZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuUnVsZVdpdGhPcGVyYXRpb25zI2FwaVZlcnNpb25zXG4gICAqL1xuICByZWFkb25seSBhcGlWZXJzaW9ucz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBPcGVyYXRpb25zIGlzIHRoZSBvcGVyYXRpb25zIHRoZSBhZG1pc3Npb24gaG9vayBjYXJlcyBhYm91dCAtIENSRUFURSwgVVBEQVRFLCBERUxFVEUsIENPTk5FQ1Qgb3IgKiBmb3IgYWxsIG9mIHRob3NlIG9wZXJhdGlvbnMgYW5kIGFueSBmdXR1cmUgYWRtaXNzaW9uIG9wZXJhdGlvbnMgdGhhdCBhcmUgYWRkZWQuIElmICcqJyBpcyBwcmVzZW50LCB0aGUgbGVuZ3RoIG9mIHRoZSBzbGljZSBtdXN0IGJlIG9uZS4gUmVxdWlyZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuUnVsZVdpdGhPcGVyYXRpb25zI29wZXJhdGlvbnNcbiAgICovXG4gIHJlYWRvbmx5IG9wZXJhdGlvbnM/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogUmVzb3VyY2VzIGlzIGEgbGlzdCBvZiByZXNvdXJjZXMgdGhpcyBydWxlIGFwcGxpZXMgdG8uXG4gICAqXG4gICAqIEZvciBleGFtcGxlOiAncG9kcycgbWVhbnMgcG9kcy4gJ3BvZHMvbG9nJyBtZWFucyB0aGUgbG9nIHN1YnJlc291cmNlIG9mIHBvZHMuICcqJyBtZWFucyBhbGwgcmVzb3VyY2VzLCBidXQgbm90IHN1YnJlc291cmNlcy4gJ3BvZHMvKicgbWVhbnMgYWxsIHN1YnJlc291cmNlcyBvZiBwb2RzLiAnXy9zY2FsZScgbWVhbnMgYWxsIHNjYWxlIHN1YnJlc291cmNlcy4gJ18vKicgbWVhbnMgYWxsIHJlc291cmNlcyBhbmQgdGhlaXIgc3VicmVzb3VyY2VzLlxuICAgKlxuICAgKiBJZiB3aWxkY2FyZCBpcyBwcmVzZW50LCB0aGUgdmFsaWRhdGlvbiBydWxlIHdpbGwgZW5zdXJlIHJlc291cmNlcyBkbyBub3Qgb3ZlcmxhcCB3aXRoIGVhY2ggb3RoZXIuXG4gICAqXG4gICAqIERlcGVuZGluZyBvbiB0aGUgZW5jbG9zaW5nIG9iamVjdCwgc3VicmVzb3VyY2VzIG1pZ2h0IG5vdCBiZSBhbGxvd2VkLiBSZXF1aXJlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFkbWlzc2lvbnJlZ2lzdHJhdGlvbi52MS5SdWxlV2l0aE9wZXJhdGlvbnMjcmVzb3VyY2VzXG4gICAqL1xuICByZWFkb25seSByZXNvdXJjZXM/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogc2NvcGUgc3BlY2lmaWVzIHRoZSBzY29wZSBvZiB0aGlzIHJ1bGUuIFZhbGlkIHZhbHVlcyBhcmUgXCJDbHVzdGVyXCIsIFwiTmFtZXNwYWNlZFwiLCBhbmQgXCIqXCIgXCJDbHVzdGVyXCIgbWVhbnMgdGhhdCBvbmx5IGNsdXN0ZXItc2NvcGVkIHJlc291cmNlcyB3aWxsIG1hdGNoIHRoaXMgcnVsZS4gTmFtZXNwYWNlIEFQSSBvYmplY3RzIGFyZSBjbHVzdGVyLXNjb3BlZC4gXCJOYW1lc3BhY2VkXCIgbWVhbnMgdGhhdCBvbmx5IG5hbWVzcGFjZWQgcmVzb3VyY2VzIHdpbGwgbWF0Y2ggdGhpcyBydWxlLiBcIipcIiBtZWFucyB0aGF0IHRoZXJlIGFyZSBubyBzY29wZSByZXN0cmljdGlvbnMuIFN1YnJlc291cmNlcyBtYXRjaCB0aGUgc2NvcGUgb2YgdGhlaXIgcGFyZW50IHJlc291cmNlLiBEZWZhdWx0IGlzIFwiKlwiLlxuICAgKlxuICAgKiBAZGVmYXVsdCAuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuUnVsZVdpdGhPcGVyYXRpb25zI3Njb3BlXG4gICAqL1xuICByZWFkb25seSBzY29wZT86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdSdWxlV2l0aE9wZXJhdGlvbnMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1J1bGVXaXRoT3BlcmF0aW9ucyhvYmo6IFJ1bGVXaXRoT3BlcmF0aW9ucyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2FwaUdyb3Vwcyc6IG9iai5hcGlHcm91cHM/Lm1hcCh5ID0+IHkpLFxuICAgICdhcGlWZXJzaW9ucyc6IG9iai5hcGlWZXJzaW9ucz8ubWFwKHkgPT4geSksXG4gICAgJ29wZXJhdGlvbnMnOiBvYmoub3BlcmF0aW9ucz8ubWFwKHkgPT4geSksXG4gICAgJ3Jlc291cmNlcyc6IG9iai5yZXNvdXJjZXM/Lm1hcCh5ID0+IHkpLFxuICAgICdzY29wZSc6IG9iai5zY29wZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBEYWVtb25TZXRVcGRhdGVTdHJhdGVneSBpcyBhIHN0cnVjdCB1c2VkIHRvIGNvbnRyb2wgdGhlIHVwZGF0ZSBzdHJhdGVneSBmb3IgYSBEYWVtb25TZXQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuRGFlbW9uU2V0VXBkYXRlU3RyYXRlZ3lcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEYWVtb25TZXRVcGRhdGVTdHJhdGVneSB7XG4gIC8qKlxuICAgKiBSb2xsaW5nIHVwZGF0ZSBjb25maWcgcGFyYW1zLiBQcmVzZW50IG9ubHkgaWYgdHlwZSA9IFwiUm9sbGluZ1VwZGF0ZVwiLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5EYWVtb25TZXRVcGRhdGVTdHJhdGVneSNyb2xsaW5nVXBkYXRlXG4gICAqL1xuICByZWFkb25seSByb2xsaW5nVXBkYXRlPzogUm9sbGluZ1VwZGF0ZURhZW1vblNldDtcblxuICAvKipcbiAgICogVHlwZSBvZiBkYWVtb24gc2V0IHVwZGF0ZS4gQ2FuIGJlIFwiUm9sbGluZ1VwZGF0ZVwiIG9yIFwiT25EZWxldGVcIi4gRGVmYXVsdCBpcyBSb2xsaW5nVXBkYXRlLlxuICAgKlxuICAgKiBAZGVmYXVsdCBSb2xsaW5nVXBkYXRlLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5EYWVtb25TZXRVcGRhdGVTdHJhdGVneSN0eXBlXG4gICAqL1xuICByZWFkb25seSB0eXBlPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0RhZW1vblNldFVwZGF0ZVN0cmF0ZWd5JyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9EYWVtb25TZXRVcGRhdGVTdHJhdGVneShvYmo6IERhZW1vblNldFVwZGF0ZVN0cmF0ZWd5IHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAncm9sbGluZ1VwZGF0ZSc6IHRvSnNvbl9Sb2xsaW5nVXBkYXRlRGFlbW9uU2V0KG9iai5yb2xsaW5nVXBkYXRlKSxcbiAgICAndHlwZSc6IG9iai50eXBlLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIERlcGxveW1lbnRTdHJhdGVneSBkZXNjcmliZXMgaG93IHRvIHJlcGxhY2UgZXhpc3RpbmcgcG9kcyB3aXRoIG5ldyBvbmVzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLkRlcGxveW1lbnRTdHJhdGVneVxuICovXG5leHBvcnQgaW50ZXJmYWNlIERlcGxveW1lbnRTdHJhdGVneSB7XG4gIC8qKlxuICAgKiBSb2xsaW5nIHVwZGF0ZSBjb25maWcgcGFyYW1zLiBQcmVzZW50IG9ubHkgaWYgRGVwbG95bWVudFN0cmF0ZWd5VHlwZSA9IFJvbGxpbmdVcGRhdGUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLkRlcGxveW1lbnRTdHJhdGVneSNyb2xsaW5nVXBkYXRlXG4gICAqL1xuICByZWFkb25seSByb2xsaW5nVXBkYXRlPzogUm9sbGluZ1VwZGF0ZURlcGxveW1lbnQ7XG5cbiAgLyoqXG4gICAqIFR5cGUgb2YgZGVwbG95bWVudC4gQ2FuIGJlIFwiUmVjcmVhdGVcIiBvciBcIlJvbGxpbmdVcGRhdGVcIi4gRGVmYXVsdCBpcyBSb2xsaW5nVXBkYXRlLlxuICAgKlxuICAgKiBAZGVmYXVsdCBSb2xsaW5nVXBkYXRlLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5EZXBsb3ltZW50U3RyYXRlZ3kjdHlwZVxuICAgKi9cbiAgcmVhZG9ubHkgdHlwZT86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdEZXBsb3ltZW50U3RyYXRlZ3knIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0RlcGxveW1lbnRTdHJhdGVneShvYmo6IERlcGxveW1lbnRTdHJhdGVneSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ3JvbGxpbmdVcGRhdGUnOiB0b0pzb25fUm9sbGluZ1VwZGF0ZURlcGxveW1lbnQob2JqLnJvbGxpbmdVcGRhdGUpLFxuICAgICd0eXBlJzogb2JqLnR5cGUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogU3RhdGVmdWxTZXRVcGRhdGVTdHJhdGVneSBpbmRpY2F0ZXMgdGhlIHN0cmF0ZWd5IHRoYXQgdGhlIFN0YXRlZnVsU2V0IGNvbnRyb2xsZXIgd2lsbCB1c2UgdG8gcGVyZm9ybSB1cGRhdGVzLiBJdCBpbmNsdWRlcyBhbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIG5lY2Vzc2FyeSB0byBwZXJmb3JtIHRoZSB1cGRhdGUgZm9yIHRoZSBpbmRpY2F0ZWQgc3RyYXRlZ3kuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuU3RhdGVmdWxTZXRVcGRhdGVTdHJhdGVneVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlZnVsU2V0VXBkYXRlU3RyYXRlZ3kge1xuICAvKipcbiAgICogUm9sbGluZ1VwZGF0ZSBpcyB1c2VkIHRvIGNvbW11bmljYXRlIHBhcmFtZXRlcnMgd2hlbiBUeXBlIGlzIFJvbGxpbmdVcGRhdGVTdGF0ZWZ1bFNldFN0cmF0ZWd5VHlwZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuU3RhdGVmdWxTZXRVcGRhdGVTdHJhdGVneSNyb2xsaW5nVXBkYXRlXG4gICAqL1xuICByZWFkb25seSByb2xsaW5nVXBkYXRlPzogUm9sbGluZ1VwZGF0ZVN0YXRlZnVsU2V0U3RyYXRlZ3k7XG5cbiAgLyoqXG4gICAqIFR5cGUgaW5kaWNhdGVzIHRoZSB0eXBlIG9mIHRoZSBTdGF0ZWZ1bFNldFVwZGF0ZVN0cmF0ZWd5LiBEZWZhdWx0IGlzIFJvbGxpbmdVcGRhdGUuXG4gICAqXG4gICAqIEBkZWZhdWx0IFJvbGxpbmdVcGRhdGUuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLlN0YXRlZnVsU2V0VXBkYXRlU3RyYXRlZ3kjdHlwZVxuICAgKi9cbiAgcmVhZG9ubHkgdHlwZT86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdTdGF0ZWZ1bFNldFVwZGF0ZVN0cmF0ZWd5JyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9TdGF0ZWZ1bFNldFVwZGF0ZVN0cmF0ZWd5KG9iajogU3RhdGVmdWxTZXRVcGRhdGVTdHJhdGVneSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ3JvbGxpbmdVcGRhdGUnOiB0b0pzb25fUm9sbGluZ1VwZGF0ZVN0YXRlZnVsU2V0U3RyYXRlZ3kob2JqLnJvbGxpbmdVcGRhdGUpLFxuICAgICd0eXBlJzogb2JqLnR5cGUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQm91bmRPYmplY3RSZWZlcmVuY2UgaXMgYSByZWZlcmVuY2UgdG8gYW4gb2JqZWN0IHRoYXQgYSB0b2tlbiBpcyBib3VuZCB0by5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0aGVudGljYXRpb24udjEuQm91bmRPYmplY3RSZWZlcmVuY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCb3VuZE9iamVjdFJlZmVyZW5jZSB7XG4gIC8qKlxuICAgKiBBUEkgdmVyc2lvbiBvZiB0aGUgcmVmZXJlbnQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRoZW50aWNhdGlvbi52MS5Cb3VuZE9iamVjdFJlZmVyZW5jZSNhcGlWZXJzaW9uXG4gICAqL1xuICByZWFkb25seSBhcGlWZXJzaW9uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBLaW5kIG9mIHRoZSByZWZlcmVudC4gVmFsaWQga2luZHMgYXJlICdQb2QnIGFuZCAnU2VjcmV0Jy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dGhlbnRpY2F0aW9uLnYxLkJvdW5kT2JqZWN0UmVmZXJlbmNlI2tpbmRcbiAgICovXG4gIHJlYWRvbmx5IGtpbmQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIHJlZmVyZW50LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0aGVudGljYXRpb24udjEuQm91bmRPYmplY3RSZWZlcmVuY2UjbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogVUlEIG9mIHRoZSByZWZlcmVudC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dGhlbnRpY2F0aW9uLnYxLkJvdW5kT2JqZWN0UmVmZXJlbmNlI3VpZFxuICAgKi9cbiAgcmVhZG9ubHkgdWlkPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0JvdW5kT2JqZWN0UmVmZXJlbmNlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Cb3VuZE9iamVjdFJlZmVyZW5jZShvYmo6IEJvdW5kT2JqZWN0UmVmZXJlbmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnYXBpVmVyc2lvbic6IG9iai5hcGlWZXJzaW9uLFxuICAgICdraW5kJzogb2JqLmtpbmQsXG4gICAgJ25hbWUnOiBvYmoubmFtZSxcbiAgICAndWlkJzogb2JqLnVpZCxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBOb25SZXNvdXJjZUF0dHJpYnV0ZXMgaW5jbHVkZXMgdGhlIGF1dGhvcml6YXRpb24gYXR0cmlidXRlcyBhdmFpbGFibGUgZm9yIG5vbi1yZXNvdXJjZSByZXF1ZXN0cyB0byB0aGUgQXV0aG9yaXplciBpbnRlcmZhY2VcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0aG9yaXphdGlvbi52MS5Ob25SZXNvdXJjZUF0dHJpYnV0ZXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOb25SZXNvdXJjZUF0dHJpYnV0ZXMge1xuICAvKipcbiAgICogUGF0aCBpcyB0aGUgVVJMIHBhdGggb2YgdGhlIHJlcXVlc3RcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dGhvcml6YXRpb24udjEuTm9uUmVzb3VyY2VBdHRyaWJ1dGVzI3BhdGhcbiAgICovXG4gIHJlYWRvbmx5IHBhdGg/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFZlcmIgaXMgdGhlIHN0YW5kYXJkIEhUVFAgdmVyYlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0aG9yaXphdGlvbi52MS5Ob25SZXNvdXJjZUF0dHJpYnV0ZXMjdmVyYlxuICAgKi9cbiAgcmVhZG9ubHkgdmVyYj86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdOb25SZXNvdXJjZUF0dHJpYnV0ZXMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX05vblJlc291cmNlQXR0cmlidXRlcyhvYmo6IE5vblJlc291cmNlQXR0cmlidXRlcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ3BhdGgnOiBvYmoucGF0aCxcbiAgICAndmVyYic6IG9iai52ZXJiLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFJlc291cmNlQXR0cmlidXRlcyBpbmNsdWRlcyB0aGUgYXV0aG9yaXphdGlvbiBhdHRyaWJ1dGVzIGF2YWlsYWJsZSBmb3IgcmVzb3VyY2UgcmVxdWVzdHMgdG8gdGhlIEF1dGhvcml6ZXIgaW50ZXJmYWNlXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dGhvcml6YXRpb24udjEuUmVzb3VyY2VBdHRyaWJ1dGVzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb3VyY2VBdHRyaWJ1dGVzIHtcbiAgLyoqXG4gICAqIEdyb3VwIGlzIHRoZSBBUEkgR3JvdXAgb2YgdGhlIFJlc291cmNlLiAgXCIqXCIgbWVhbnMgYWxsLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0aG9yaXphdGlvbi52MS5SZXNvdXJjZUF0dHJpYnV0ZXMjZ3JvdXBcbiAgICovXG4gIHJlYWRvbmx5IGdyb3VwPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBOYW1lIGlzIHRoZSBuYW1lIG9mIHRoZSByZXNvdXJjZSBiZWluZyByZXF1ZXN0ZWQgZm9yIGEgXCJnZXRcIiBvciBkZWxldGVkIGZvciBhIFwiZGVsZXRlXCIuIFwiXCIgKGVtcHR5KSBtZWFucyBhbGwuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRob3JpemF0aW9uLnYxLlJlc291cmNlQXR0cmlidXRlcyNuYW1lXG4gICAqL1xuICByZWFkb25seSBuYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBOYW1lc3BhY2UgaXMgdGhlIG5hbWVzcGFjZSBvZiB0aGUgYWN0aW9uIGJlaW5nIHJlcXVlc3RlZC4gIEN1cnJlbnRseSwgdGhlcmUgaXMgbm8gZGlzdGluY3Rpb24gYmV0d2VlbiBubyBuYW1lc3BhY2UgYW5kIGFsbCBuYW1lc3BhY2VzIFwiXCIgKGVtcHR5KSBpcyBkZWZhdWx0ZWQgZm9yIExvY2FsU3ViamVjdEFjY2Vzc1Jldmlld3MgXCJcIiAoZW1wdHkpIGlzIGVtcHR5IGZvciBjbHVzdGVyLXNjb3BlZCByZXNvdXJjZXMgXCJcIiAoZW1wdHkpIG1lYW5zIFwiYWxsXCIgZm9yIG5hbWVzcGFjZSBzY29wZWQgcmVzb3VyY2VzIGZyb20gYSBTdWJqZWN0QWNjZXNzUmV2aWV3IG9yIFNlbGZTdWJqZWN0QWNjZXNzUmV2aWV3XG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRob3JpemF0aW9uLnYxLlJlc291cmNlQXR0cmlidXRlcyNuYW1lc3BhY2VcbiAgICovXG4gIHJlYWRvbmx5IG5hbWVzcGFjZT86IHN0cmluZztcblxuICAvKipcbiAgICogUmVzb3VyY2UgaXMgb25lIG9mIHRoZSBleGlzdGluZyByZXNvdXJjZSB0eXBlcy4gIFwiKlwiIG1lYW5zIGFsbC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dGhvcml6YXRpb24udjEuUmVzb3VyY2VBdHRyaWJ1dGVzI3Jlc291cmNlXG4gICAqL1xuICByZWFkb25seSByZXNvdXJjZT86IHN0cmluZztcblxuICAvKipcbiAgICogU3VicmVzb3VyY2UgaXMgb25lIG9mIHRoZSBleGlzdGluZyByZXNvdXJjZSB0eXBlcy4gIFwiXCIgbWVhbnMgbm9uZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dGhvcml6YXRpb24udjEuUmVzb3VyY2VBdHRyaWJ1dGVzI3N1YnJlc291cmNlXG4gICAqL1xuICByZWFkb25seSBzdWJyZXNvdXJjZT86IHN0cmluZztcblxuICAvKipcbiAgICogVmVyYiBpcyBhIGt1YmVybmV0ZXMgcmVzb3VyY2UgQVBJIHZlcmIsIGxpa2U6IGdldCwgbGlzdCwgd2F0Y2gsIGNyZWF0ZSwgdXBkYXRlLCBkZWxldGUsIHByb3h5LiAgXCIqXCIgbWVhbnMgYWxsLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0aG9yaXphdGlvbi52MS5SZXNvdXJjZUF0dHJpYnV0ZXMjdmVyYlxuICAgKi9cbiAgcmVhZG9ubHkgdmVyYj86IHN0cmluZztcblxuICAvKipcbiAgICogVmVyc2lvbiBpcyB0aGUgQVBJIFZlcnNpb24gb2YgdGhlIFJlc291cmNlLiAgXCIqXCIgbWVhbnMgYWxsLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0aG9yaXphdGlvbi52MS5SZXNvdXJjZUF0dHJpYnV0ZXMjdmVyc2lvblxuICAgKi9cbiAgcmVhZG9ubHkgdmVyc2lvbj86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdSZXNvdXJjZUF0dHJpYnV0ZXMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1Jlc291cmNlQXR0cmlidXRlcyhvYmo6IFJlc291cmNlQXR0cmlidXRlcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2dyb3VwJzogb2JqLmdyb3VwLFxuICAgICduYW1lJzogb2JqLm5hbWUsXG4gICAgJ25hbWVzcGFjZSc6IG9iai5uYW1lc3BhY2UsXG4gICAgJ3Jlc291cmNlJzogb2JqLnJlc291cmNlLFxuICAgICdzdWJyZXNvdXJjZSc6IG9iai5zdWJyZXNvdXJjZSxcbiAgICAndmVyYic6IG9iai52ZXJiLFxuICAgICd2ZXJzaW9uJzogb2JqLnZlcnNpb24sXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQ3Jvc3NWZXJzaW9uT2JqZWN0UmVmZXJlbmNlIGNvbnRhaW5zIGVub3VnaCBpbmZvcm1hdGlvbiB0byBsZXQgeW91IGlkZW50aWZ5IHRoZSByZWZlcnJlZCByZXNvdXJjZS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjEuQ3Jvc3NWZXJzaW9uT2JqZWN0UmVmZXJlbmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3Jvc3NWZXJzaW9uT2JqZWN0UmVmZXJlbmNlIHtcbiAgLyoqXG4gICAqIEFQSSB2ZXJzaW9uIG9mIHRoZSByZWZlcmVudFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjEuQ3Jvc3NWZXJzaW9uT2JqZWN0UmVmZXJlbmNlI2FwaVZlcnNpb25cbiAgICovXG4gIHJlYWRvbmx5IGFwaVZlcnNpb24/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEtpbmQgb2YgdGhlIHJlZmVyZW50OyBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3R5cGVzLWtpbmRzXCJcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYxLkNyb3NzVmVyc2lvbk9iamVjdFJlZmVyZW5jZSNraW5kXG4gICAqL1xuICByZWFkb25seSBraW5kOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIHJlZmVyZW50OyBNb3JlIGluZm86IGh0dHA6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvdXNlci1ndWlkZS9pZGVudGlmaWVycyNuYW1lc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjEuQ3Jvc3NWZXJzaW9uT2JqZWN0UmVmZXJlbmNlI25hbWVcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdDcm9zc1ZlcnNpb25PYmplY3RSZWZlcmVuY2UnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0Nyb3NzVmVyc2lvbk9iamVjdFJlZmVyZW5jZShvYmo6IENyb3NzVmVyc2lvbk9iamVjdFJlZmVyZW5jZSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2FwaVZlcnNpb24nOiBvYmouYXBpVmVyc2lvbixcbiAgICAna2luZCc6IG9iai5raW5kLFxuICAgICduYW1lJzogb2JqLm5hbWUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogTWV0cmljU3BlYyBzcGVjaWZpZXMgaG93IHRvIHNjYWxlIGJhc2VkIG9uIGEgc2luZ2xlIG1ldHJpYyAob25seSBgdHlwZWAgYW5kIG9uZSBvdGhlciBtYXRjaGluZyBmaWVsZCBzaG91bGQgYmUgc2V0IGF0IG9uY2UpLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGExLk1ldHJpY1NwZWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNZXRyaWNTcGVjVjJCZXRhMSB7XG4gIC8qKlxuICAgKiBjb250YWluZXIgcmVzb3VyY2UgcmVmZXJzIHRvIGEgcmVzb3VyY2UgbWV0cmljIChzdWNoIGFzIHRob3NlIHNwZWNpZmllZCBpbiByZXF1ZXN0cyBhbmQgbGltaXRzKSBrbm93biB0byBLdWJlcm5ldGVzIGRlc2NyaWJpbmcgYSBzaW5nbGUgY29udGFpbmVyIGluIGVhY2ggcG9kIG9mIHRoZSBjdXJyZW50IHNjYWxlIHRhcmdldCAoZS5nLiBDUFUgb3IgbWVtb3J5KS4gU3VjaCBtZXRyaWNzIGFyZSBidWlsdCBpbiB0byBLdWJlcm5ldGVzLCBhbmQgaGF2ZSBzcGVjaWFsIHNjYWxpbmcgb3B0aW9ucyBvbiB0b3Agb2YgdGhvc2UgYXZhaWxhYmxlIHRvIG5vcm1hbCBwZXItcG9kIG1ldHJpY3MgdXNpbmcgdGhlIFwicG9kc1wiIHNvdXJjZS4gVGhpcyBpcyBhbiBhbHBoYSBmZWF0dXJlIGFuZCBjYW4gYmUgZW5hYmxlZCBieSB0aGUgSFBBQ29udGFpbmVyTWV0cmljcyBmZWF0dXJlIGZsYWcuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGExLk1ldHJpY1NwZWMjY29udGFpbmVyUmVzb3VyY2VcbiAgICovXG4gIHJlYWRvbmx5IGNvbnRhaW5lclJlc291cmNlPzogQ29udGFpbmVyUmVzb3VyY2VNZXRyaWNTb3VyY2VWMkJldGExO1xuXG4gIC8qKlxuICAgKiBleHRlcm5hbCByZWZlcnMgdG8gYSBnbG9iYWwgbWV0cmljIHRoYXQgaXMgbm90IGFzc29jaWF0ZWQgd2l0aCBhbnkgS3ViZXJuZXRlcyBvYmplY3QuIEl0IGFsbG93cyBhdXRvc2NhbGluZyBiYXNlZCBvbiBpbmZvcm1hdGlvbiBjb21pbmcgZnJvbSBjb21wb25lbnRzIHJ1bm5pbmcgb3V0c2lkZSBvZiBjbHVzdGVyIChmb3IgZXhhbXBsZSBsZW5ndGggb2YgcXVldWUgaW4gY2xvdWQgbWVzc2FnaW5nIHNlcnZpY2UsIG9yIFFQUyBmcm9tIGxvYWRiYWxhbmNlciBydW5uaW5nIG91dHNpZGUgb2YgY2x1c3RlcikuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGExLk1ldHJpY1NwZWMjZXh0ZXJuYWxcbiAgICovXG4gIHJlYWRvbmx5IGV4dGVybmFsPzogRXh0ZXJuYWxNZXRyaWNTb3VyY2VWMkJldGExO1xuXG4gIC8qKlxuICAgKiBvYmplY3QgcmVmZXJzIHRvIGEgbWV0cmljIGRlc2NyaWJpbmcgYSBzaW5nbGUga3ViZXJuZXRlcyBvYmplY3QgKGZvciBleGFtcGxlLCBoaXRzLXBlci1zZWNvbmQgb24gYW4gSW5ncmVzcyBvYmplY3QpLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMS5NZXRyaWNTcGVjI29iamVjdFxuICAgKi9cbiAgcmVhZG9ubHkgb2JqZWN0PzogT2JqZWN0TWV0cmljU291cmNlVjJCZXRhMTtcblxuICAvKipcbiAgICogcG9kcyByZWZlcnMgdG8gYSBtZXRyaWMgZGVzY3JpYmluZyBlYWNoIHBvZCBpbiB0aGUgY3VycmVudCBzY2FsZSB0YXJnZXQgKGZvciBleGFtcGxlLCB0cmFuc2FjdGlvbnMtcHJvY2Vzc2VkLXBlci1zZWNvbmQpLiAgVGhlIHZhbHVlcyB3aWxsIGJlIGF2ZXJhZ2VkIHRvZ2V0aGVyIGJlZm9yZSBiZWluZyBjb21wYXJlZCB0byB0aGUgdGFyZ2V0IHZhbHVlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMS5NZXRyaWNTcGVjI3BvZHNcbiAgICovXG4gIHJlYWRvbmx5IHBvZHM/OiBQb2RzTWV0cmljU291cmNlVjJCZXRhMTtcblxuICAvKipcbiAgICogcmVzb3VyY2UgcmVmZXJzIHRvIGEgcmVzb3VyY2UgbWV0cmljIChzdWNoIGFzIHRob3NlIHNwZWNpZmllZCBpbiByZXF1ZXN0cyBhbmQgbGltaXRzKSBrbm93biB0byBLdWJlcm5ldGVzIGRlc2NyaWJpbmcgZWFjaCBwb2QgaW4gdGhlIGN1cnJlbnQgc2NhbGUgdGFyZ2V0IChlLmcuIENQVSBvciBtZW1vcnkpLiBTdWNoIG1ldHJpY3MgYXJlIGJ1aWx0IGluIHRvIEt1YmVybmV0ZXMsIGFuZCBoYXZlIHNwZWNpYWwgc2NhbGluZyBvcHRpb25zIG9uIHRvcCBvZiB0aG9zZSBhdmFpbGFibGUgdG8gbm9ybWFsIHBlci1wb2QgbWV0cmljcyB1c2luZyB0aGUgXCJwb2RzXCIgc291cmNlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMS5NZXRyaWNTcGVjI3Jlc291cmNlXG4gICAqL1xuICByZWFkb25seSByZXNvdXJjZT86IFJlc291cmNlTWV0cmljU291cmNlVjJCZXRhMTtcblxuICAvKipcbiAgICogdHlwZSBpcyB0aGUgdHlwZSBvZiBtZXRyaWMgc291cmNlLiAgSXQgc2hvdWxkIGJlIG9uZSBvZiBcIkNvbnRhaW5lclJlc291cmNlXCIsIFwiRXh0ZXJuYWxcIiwgXCJPYmplY3RcIiwgXCJQb2RzXCIgb3IgXCJSZXNvdXJjZVwiLCBlYWNoIG1hcHBpbmcgdG8gYSBtYXRjaGluZyBmaWVsZCBpbiB0aGUgb2JqZWN0LiBOb3RlOiBcIkNvbnRhaW5lclJlc291cmNlXCIgdHlwZSBpcyBhdmFpbGFibGUgb24gd2hlbiB0aGUgZmVhdHVyZS1nYXRlIEhQQUNvbnRhaW5lck1ldHJpY3MgaXMgZW5hYmxlZFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMS5NZXRyaWNTcGVjI3R5cGVcbiAgICovXG4gIHJlYWRvbmx5IHR5cGU6IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdNZXRyaWNTcGVjVjJCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fTWV0cmljU3BlY1YyQmV0YTEob2JqOiBNZXRyaWNTcGVjVjJCZXRhMSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2NvbnRhaW5lclJlc291cmNlJzogdG9Kc29uX0NvbnRhaW5lclJlc291cmNlTWV0cmljU291cmNlVjJCZXRhMShvYmouY29udGFpbmVyUmVzb3VyY2UpLFxuICAgICdleHRlcm5hbCc6IHRvSnNvbl9FeHRlcm5hbE1ldHJpY1NvdXJjZVYyQmV0YTEob2JqLmV4dGVybmFsKSxcbiAgICAnb2JqZWN0JzogdG9Kc29uX09iamVjdE1ldHJpY1NvdXJjZVYyQmV0YTEob2JqLm9iamVjdCksXG4gICAgJ3BvZHMnOiB0b0pzb25fUG9kc01ldHJpY1NvdXJjZVYyQmV0YTEob2JqLnBvZHMpLFxuICAgICdyZXNvdXJjZSc6IHRvSnNvbl9SZXNvdXJjZU1ldHJpY1NvdXJjZVYyQmV0YTEob2JqLnJlc291cmNlKSxcbiAgICAndHlwZSc6IG9iai50eXBlLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIENyb3NzVmVyc2lvbk9iamVjdFJlZmVyZW5jZSBjb250YWlucyBlbm91Z2ggaW5mb3JtYXRpb24gdG8gbGV0IHlvdSBpZGVudGlmeSB0aGUgcmVmZXJyZWQgcmVzb3VyY2UuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTEuQ3Jvc3NWZXJzaW9uT2JqZWN0UmVmZXJlbmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3Jvc3NWZXJzaW9uT2JqZWN0UmVmZXJlbmNlVjJCZXRhMSB7XG4gIC8qKlxuICAgKiBBUEkgdmVyc2lvbiBvZiB0aGUgcmVmZXJlbnRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTEuQ3Jvc3NWZXJzaW9uT2JqZWN0UmVmZXJlbmNlI2FwaVZlcnNpb25cbiAgICovXG4gIHJlYWRvbmx5IGFwaVZlcnNpb24/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEtpbmQgb2YgdGhlIHJlZmVyZW50OyBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3R5cGVzLWtpbmRzXCJcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTEuQ3Jvc3NWZXJzaW9uT2JqZWN0UmVmZXJlbmNlI2tpbmRcbiAgICovXG4gIHJlYWRvbmx5IGtpbmQ6IHN0cmluZztcblxuICAvKipcbiAgICogTmFtZSBvZiB0aGUgcmVmZXJlbnQ7IE1vcmUgaW5mbzogaHR0cDovL2t1YmVybmV0ZXMuaW8vZG9jcy91c2VyLWd1aWRlL2lkZW50aWZpZXJzI25hbWVzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGExLkNyb3NzVmVyc2lvbk9iamVjdFJlZmVyZW5jZSNuYW1lXG4gICAqL1xuICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnQ3Jvc3NWZXJzaW9uT2JqZWN0UmVmZXJlbmNlVjJCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fQ3Jvc3NWZXJzaW9uT2JqZWN0UmVmZXJlbmNlVjJCZXRhMShvYmo6IENyb3NzVmVyc2lvbk9iamVjdFJlZmVyZW5jZVYyQmV0YTEgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdhcGlWZXJzaW9uJzogb2JqLmFwaVZlcnNpb24sXG4gICAgJ2tpbmQnOiBvYmoua2luZCxcbiAgICAnbmFtZSc6IG9iai5uYW1lLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEhvcml6b250YWxQb2RBdXRvc2NhbGVyQmVoYXZpb3IgY29uZmlndXJlcyB0aGUgc2NhbGluZyBiZWhhdmlvciBvZiB0aGUgdGFyZ2V0IGluIGJvdGggVXAgYW5kIERvd24gZGlyZWN0aW9ucyAoc2NhbGVVcCBhbmQgc2NhbGVEb3duIGZpZWxkcyByZXNwZWN0aXZlbHkpLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGEyLkhvcml6b250YWxQb2RBdXRvc2NhbGVyQmVoYXZpb3JcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIb3Jpem9udGFsUG9kQXV0b3NjYWxlckJlaGF2aW9yVjJCZXRhMiB7XG4gIC8qKlxuICAgKiBzY2FsZURvd24gaXMgc2NhbGluZyBwb2xpY3kgZm9yIHNjYWxpbmcgRG93bi4gSWYgbm90IHNldCwgdGhlIGRlZmF1bHQgdmFsdWUgaXMgdG8gYWxsb3cgdG8gc2NhbGUgZG93biB0byBtaW5SZXBsaWNhcyBwb2RzLCB3aXRoIGEgMzAwIHNlY29uZCBzdGFiaWxpemF0aW9uIHdpbmRvdyAoaS5lLiwgdGhlIGhpZ2hlc3QgcmVjb21tZW5kYXRpb24gZm9yIHRoZSBsYXN0IDMwMHNlYyBpcyB1c2VkKS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuSG9yaXpvbnRhbFBvZEF1dG9zY2FsZXJCZWhhdmlvciNzY2FsZURvd25cbiAgICovXG4gIHJlYWRvbmx5IHNjYWxlRG93bj86IEhwYVNjYWxpbmdSdWxlc1YyQmV0YTI7XG5cbiAgLyoqXG4gICAqIHNjYWxlVXAgaXMgc2NhbGluZyBwb2xpY3kgZm9yIHNjYWxpbmcgVXAuIElmIG5vdCBzZXQsIHRoZSBkZWZhdWx0IHZhbHVlIGlzIHRoZSBoaWdoZXIgb2Y6XG4gICAqICogaW5jcmVhc2Ugbm8gbW9yZSB0aGFuIDQgcG9kcyBwZXIgNjAgc2Vjb25kc1xuICAgKiAqIGRvdWJsZSB0aGUgbnVtYmVyIG9mIHBvZHMgcGVyIDYwIHNlY29uZHNcbiAgICogTm8gc3RhYmlsaXphdGlvbiBpcyB1c2VkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMi5Ib3Jpem9udGFsUG9kQXV0b3NjYWxlckJlaGF2aW9yI3NjYWxlVXBcbiAgICovXG4gIHJlYWRvbmx5IHNjYWxlVXA/OiBIcGFTY2FsaW5nUnVsZXNWMkJldGEyO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0hvcml6b250YWxQb2RBdXRvc2NhbGVyQmVoYXZpb3JWMkJldGEyJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Ib3Jpem9udGFsUG9kQXV0b3NjYWxlckJlaGF2aW9yVjJCZXRhMihvYmo6IEhvcml6b250YWxQb2RBdXRvc2NhbGVyQmVoYXZpb3JWMkJldGEyIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnc2NhbGVEb3duJzogdG9Kc29uX0hwYVNjYWxpbmdSdWxlc1YyQmV0YTIob2JqLnNjYWxlRG93biksXG4gICAgJ3NjYWxlVXAnOiB0b0pzb25fSHBhU2NhbGluZ1J1bGVzVjJCZXRhMihvYmouc2NhbGVVcCksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogTWV0cmljU3BlYyBzcGVjaWZpZXMgaG93IHRvIHNjYWxlIGJhc2VkIG9uIGEgc2luZ2xlIG1ldHJpYyAob25seSBgdHlwZWAgYW5kIG9uZSBvdGhlciBtYXRjaGluZyBmaWVsZCBzaG91bGQgYmUgc2V0IGF0IG9uY2UpLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGEyLk1ldHJpY1NwZWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNZXRyaWNTcGVjVjJCZXRhMiB7XG4gIC8qKlxuICAgKiBjb250YWluZXIgcmVzb3VyY2UgcmVmZXJzIHRvIGEgcmVzb3VyY2UgbWV0cmljIChzdWNoIGFzIHRob3NlIHNwZWNpZmllZCBpbiByZXF1ZXN0cyBhbmQgbGltaXRzKSBrbm93biB0byBLdWJlcm5ldGVzIGRlc2NyaWJpbmcgYSBzaW5nbGUgY29udGFpbmVyIGluIGVhY2ggcG9kIG9mIHRoZSBjdXJyZW50IHNjYWxlIHRhcmdldCAoZS5nLiBDUFUgb3IgbWVtb3J5KS4gU3VjaCBtZXRyaWNzIGFyZSBidWlsdCBpbiB0byBLdWJlcm5ldGVzLCBhbmQgaGF2ZSBzcGVjaWFsIHNjYWxpbmcgb3B0aW9ucyBvbiB0b3Agb2YgdGhvc2UgYXZhaWxhYmxlIHRvIG5vcm1hbCBwZXItcG9kIG1ldHJpY3MgdXNpbmcgdGhlIFwicG9kc1wiIHNvdXJjZS4gVGhpcyBpcyBhbiBhbHBoYSBmZWF0dXJlIGFuZCBjYW4gYmUgZW5hYmxlZCBieSB0aGUgSFBBQ29udGFpbmVyTWV0cmljcyBmZWF0dXJlIGZsYWcuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGEyLk1ldHJpY1NwZWMjY29udGFpbmVyUmVzb3VyY2VcbiAgICovXG4gIHJlYWRvbmx5IGNvbnRhaW5lclJlc291cmNlPzogQ29udGFpbmVyUmVzb3VyY2VNZXRyaWNTb3VyY2VWMkJldGEyO1xuXG4gIC8qKlxuICAgKiBleHRlcm5hbCByZWZlcnMgdG8gYSBnbG9iYWwgbWV0cmljIHRoYXQgaXMgbm90IGFzc29jaWF0ZWQgd2l0aCBhbnkgS3ViZXJuZXRlcyBvYmplY3QuIEl0IGFsbG93cyBhdXRvc2NhbGluZyBiYXNlZCBvbiBpbmZvcm1hdGlvbiBjb21pbmcgZnJvbSBjb21wb25lbnRzIHJ1bm5pbmcgb3V0c2lkZSBvZiBjbHVzdGVyIChmb3IgZXhhbXBsZSBsZW5ndGggb2YgcXVldWUgaW4gY2xvdWQgbWVzc2FnaW5nIHNlcnZpY2UsIG9yIFFQUyBmcm9tIGxvYWRiYWxhbmNlciBydW5uaW5nIG91dHNpZGUgb2YgY2x1c3RlcikuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGEyLk1ldHJpY1NwZWMjZXh0ZXJuYWxcbiAgICovXG4gIHJlYWRvbmx5IGV4dGVybmFsPzogRXh0ZXJuYWxNZXRyaWNTb3VyY2VWMkJldGEyO1xuXG4gIC8qKlxuICAgKiBvYmplY3QgcmVmZXJzIHRvIGEgbWV0cmljIGRlc2NyaWJpbmcgYSBzaW5nbGUga3ViZXJuZXRlcyBvYmplY3QgKGZvciBleGFtcGxlLCBoaXRzLXBlci1zZWNvbmQgb24gYW4gSW5ncmVzcyBvYmplY3QpLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMi5NZXRyaWNTcGVjI29iamVjdFxuICAgKi9cbiAgcmVhZG9ubHkgb2JqZWN0PzogT2JqZWN0TWV0cmljU291cmNlVjJCZXRhMjtcblxuICAvKipcbiAgICogcG9kcyByZWZlcnMgdG8gYSBtZXRyaWMgZGVzY3JpYmluZyBlYWNoIHBvZCBpbiB0aGUgY3VycmVudCBzY2FsZSB0YXJnZXQgKGZvciBleGFtcGxlLCB0cmFuc2FjdGlvbnMtcHJvY2Vzc2VkLXBlci1zZWNvbmQpLiAgVGhlIHZhbHVlcyB3aWxsIGJlIGF2ZXJhZ2VkIHRvZ2V0aGVyIGJlZm9yZSBiZWluZyBjb21wYXJlZCB0byB0aGUgdGFyZ2V0IHZhbHVlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMi5NZXRyaWNTcGVjI3BvZHNcbiAgICovXG4gIHJlYWRvbmx5IHBvZHM/OiBQb2RzTWV0cmljU291cmNlVjJCZXRhMjtcblxuICAvKipcbiAgICogcmVzb3VyY2UgcmVmZXJzIHRvIGEgcmVzb3VyY2UgbWV0cmljIChzdWNoIGFzIHRob3NlIHNwZWNpZmllZCBpbiByZXF1ZXN0cyBhbmQgbGltaXRzKSBrbm93biB0byBLdWJlcm5ldGVzIGRlc2NyaWJpbmcgZWFjaCBwb2QgaW4gdGhlIGN1cnJlbnQgc2NhbGUgdGFyZ2V0IChlLmcuIENQVSBvciBtZW1vcnkpLiBTdWNoIG1ldHJpY3MgYXJlIGJ1aWx0IGluIHRvIEt1YmVybmV0ZXMsIGFuZCBoYXZlIHNwZWNpYWwgc2NhbGluZyBvcHRpb25zIG9uIHRvcCBvZiB0aG9zZSBhdmFpbGFibGUgdG8gbm9ybWFsIHBlci1wb2QgbWV0cmljcyB1c2luZyB0aGUgXCJwb2RzXCIgc291cmNlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMi5NZXRyaWNTcGVjI3Jlc291cmNlXG4gICAqL1xuICByZWFkb25seSByZXNvdXJjZT86IFJlc291cmNlTWV0cmljU291cmNlVjJCZXRhMjtcblxuICAvKipcbiAgICogdHlwZSBpcyB0aGUgdHlwZSBvZiBtZXRyaWMgc291cmNlLiAgSXQgc2hvdWxkIGJlIG9uZSBvZiBcIkNvbnRhaW5lclJlc291cmNlXCIsIFwiRXh0ZXJuYWxcIiwgXCJPYmplY3RcIiwgXCJQb2RzXCIgb3IgXCJSZXNvdXJjZVwiLCBlYWNoIG1hcHBpbmcgdG8gYSBtYXRjaGluZyBmaWVsZCBpbiB0aGUgb2JqZWN0LiBOb3RlOiBcIkNvbnRhaW5lclJlc291cmNlXCIgdHlwZSBpcyBhdmFpbGFibGUgb24gd2hlbiB0aGUgZmVhdHVyZS1nYXRlIEhQQUNvbnRhaW5lck1ldHJpY3MgaXMgZW5hYmxlZFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMi5NZXRyaWNTcGVjI3R5cGVcbiAgICovXG4gIHJlYWRvbmx5IHR5cGU6IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdNZXRyaWNTcGVjVjJCZXRhMicgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fTWV0cmljU3BlY1YyQmV0YTIob2JqOiBNZXRyaWNTcGVjVjJCZXRhMiB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2NvbnRhaW5lclJlc291cmNlJzogdG9Kc29uX0NvbnRhaW5lclJlc291cmNlTWV0cmljU291cmNlVjJCZXRhMihvYmouY29udGFpbmVyUmVzb3VyY2UpLFxuICAgICdleHRlcm5hbCc6IHRvSnNvbl9FeHRlcm5hbE1ldHJpY1NvdXJjZVYyQmV0YTIob2JqLmV4dGVybmFsKSxcbiAgICAnb2JqZWN0JzogdG9Kc29uX09iamVjdE1ldHJpY1NvdXJjZVYyQmV0YTIob2JqLm9iamVjdCksXG4gICAgJ3BvZHMnOiB0b0pzb25fUG9kc01ldHJpY1NvdXJjZVYyQmV0YTIob2JqLnBvZHMpLFxuICAgICdyZXNvdXJjZSc6IHRvSnNvbl9SZXNvdXJjZU1ldHJpY1NvdXJjZVYyQmV0YTIob2JqLnJlc291cmNlKSxcbiAgICAndHlwZSc6IG9iai50eXBlLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIENyb3NzVmVyc2lvbk9iamVjdFJlZmVyZW5jZSBjb250YWlucyBlbm91Z2ggaW5mb3JtYXRpb24gdG8gbGV0IHlvdSBpZGVudGlmeSB0aGUgcmVmZXJyZWQgcmVzb3VyY2UuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuQ3Jvc3NWZXJzaW9uT2JqZWN0UmVmZXJlbmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3Jvc3NWZXJzaW9uT2JqZWN0UmVmZXJlbmNlVjJCZXRhMiB7XG4gIC8qKlxuICAgKiBBUEkgdmVyc2lvbiBvZiB0aGUgcmVmZXJlbnRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuQ3Jvc3NWZXJzaW9uT2JqZWN0UmVmZXJlbmNlI2FwaVZlcnNpb25cbiAgICovXG4gIHJlYWRvbmx5IGFwaVZlcnNpb24/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEtpbmQgb2YgdGhlIHJlZmVyZW50OyBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3R5cGVzLWtpbmRzXCJcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuQ3Jvc3NWZXJzaW9uT2JqZWN0UmVmZXJlbmNlI2tpbmRcbiAgICovXG4gIHJlYWRvbmx5IGtpbmQ6IHN0cmluZztcblxuICAvKipcbiAgICogTmFtZSBvZiB0aGUgcmVmZXJlbnQ7IE1vcmUgaW5mbzogaHR0cDovL2t1YmVybmV0ZXMuaW8vZG9jcy91c2VyLWd1aWRlL2lkZW50aWZpZXJzI25hbWVzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGEyLkNyb3NzVmVyc2lvbk9iamVjdFJlZmVyZW5jZSNuYW1lXG4gICAqL1xuICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnQ3Jvc3NWZXJzaW9uT2JqZWN0UmVmZXJlbmNlVjJCZXRhMicgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fQ3Jvc3NWZXJzaW9uT2JqZWN0UmVmZXJlbmNlVjJCZXRhMihvYmo6IENyb3NzVmVyc2lvbk9iamVjdFJlZmVyZW5jZVYyQmV0YTIgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdhcGlWZXJzaW9uJzogb2JqLmFwaVZlcnNpb24sXG4gICAgJ2tpbmQnOiBvYmoua2luZCxcbiAgICAnbmFtZSc6IG9iai5uYW1lLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEpvYlRlbXBsYXRlU3BlYyBkZXNjcmliZXMgdGhlIGRhdGEgYSBKb2Igc2hvdWxkIGhhdmUgd2hlbiBjcmVhdGVkIGZyb20gYSB0ZW1wbGF0ZVxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5iYXRjaC52MS5Kb2JUZW1wbGF0ZVNwZWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBKb2JUZW1wbGF0ZVNwZWMge1xuICAvKipcbiAgICogU3RhbmRhcmQgb2JqZWN0J3MgbWV0YWRhdGEgb2YgdGhlIGpvYnMgY3JlYXRlZCBmcm9tIHRoaXMgdGVtcGxhdGUuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjbWV0YWRhdGFcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmJhdGNoLnYxLkpvYlRlbXBsYXRlU3BlYyNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBPYmplY3RNZXRhO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uIG9mIHRoZSBkZXNpcmVkIGJlaGF2aW9yIG9mIHRoZSBqb2IuIE1vcmUgaW5mbzogaHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGV2ZWwvc2lnLWFyY2hpdGVjdHVyZS9hcGktY29udmVudGlvbnMubWQjc3BlYy1hbmQtc3RhdHVzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5iYXRjaC52MS5Kb2JUZW1wbGF0ZVNwZWMjc3BlY1xuICAgKi9cbiAgcmVhZG9ubHkgc3BlYz86IEpvYlNwZWM7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnSm9iVGVtcGxhdGVTcGVjJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Kb2JUZW1wbGF0ZVNwZWMob2JqOiBKb2JUZW1wbGF0ZVNwZWMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3NwZWMnOiB0b0pzb25fSm9iU3BlYyhvYmouc3BlYyksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogSm9iVGVtcGxhdGVTcGVjIGRlc2NyaWJlcyB0aGUgZGF0YSBhIEpvYiBzaG91bGQgaGF2ZSB3aGVuIGNyZWF0ZWQgZnJvbSBhIHRlbXBsYXRlXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmJhdGNoLnYxYmV0YTEuSm9iVGVtcGxhdGVTcGVjXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSm9iVGVtcGxhdGVTcGVjVjFCZXRhMSB7XG4gIC8qKlxuICAgKiBTdGFuZGFyZCBvYmplY3QncyBtZXRhZGF0YSBvZiB0aGUgam9icyBjcmVhdGVkIGZyb20gdGhpcyB0ZW1wbGF0ZS4gTW9yZSBpbmZvOiBodHRwczovL2dpdC5rOHMuaW8vY29tbXVuaXR5L2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctYXJjaGl0ZWN0dXJlL2FwaS1jb252ZW50aW9ucy5tZCNtZXRhZGF0YVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYmF0Y2gudjFiZXRhMS5Kb2JUZW1wbGF0ZVNwZWMjbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogT2JqZWN0TWV0YTtcblxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbiBvZiB0aGUgZGVzaXJlZCBiZWhhdmlvciBvZiB0aGUgam9iLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3NwZWMtYW5kLXN0YXR1c1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYmF0Y2gudjFiZXRhMS5Kb2JUZW1wbGF0ZVNwZWMjc3BlY1xuICAgKi9cbiAgcmVhZG9ubHkgc3BlYz86IEpvYlNwZWM7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnSm9iVGVtcGxhdGVTcGVjVjFCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fSm9iVGVtcGxhdGVTcGVjVjFCZXRhMShvYmo6IEpvYlRlbXBsYXRlU3BlY1YxQmV0YTEgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3NwZWMnOiB0b0pzb25fSm9iU3BlYyhvYmouc3BlYyksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogRW5kcG9pbnRBZGRyZXNzIGlzIGEgdHVwbGUgdGhhdCBkZXNjcmliZXMgc2luZ2xlIElQIGFkZHJlc3MuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRW5kcG9pbnRBZGRyZXNzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRW5kcG9pbnRBZGRyZXNzIHtcbiAgLyoqXG4gICAqIFRoZSBIb3N0bmFtZSBvZiB0aGlzIGVuZHBvaW50XG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkVuZHBvaW50QWRkcmVzcyNob3N0bmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgaG9zdG5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJUCBvZiB0aGlzIGVuZHBvaW50LiBNYXkgbm90IGJlIGxvb3BiYWNrICgxMjcuMC4wLjAvOCksIGxpbmstbG9jYWwgKDE2OS4yNTQuMC4wLzE2KSwgb3IgbGluay1sb2NhbCBtdWx0aWNhc3QgKCgyMjQuMC4wLjAvMjQpLiBJUHY2IGlzIGFsc28gYWNjZXB0ZWQgYnV0IG5vdCBmdWxseSBzdXBwb3J0ZWQgb24gYWxsIHBsYXRmb3Jtcy4gQWxzbywgY2VydGFpbiBrdWJlcm5ldGVzIGNvbXBvbmVudHMsIGxpa2Uga3ViZS1wcm94eSwgYXJlIG5vdCBJUHY2IHJlYWR5LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FbmRwb2ludEFkZHJlc3MjaXBcbiAgICovXG4gIHJlYWRvbmx5IGlwOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsOiBOb2RlIGhvc3RpbmcgdGhpcyBlbmRwb2ludC4gVGhpcyBjYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgZW5kcG9pbnRzIGxvY2FsIHRvIGEgbm9kZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRW5kcG9pbnRBZGRyZXNzI25vZGVOYW1lXG4gICAqL1xuICByZWFkb25seSBub2RlTmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIG9iamVjdCBwcm92aWRpbmcgdGhlIGVuZHBvaW50LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FbmRwb2ludEFkZHJlc3MjdGFyZ2V0UmVmXG4gICAqL1xuICByZWFkb25seSB0YXJnZXRSZWY/OiBPYmplY3RSZWZlcmVuY2U7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnRW5kcG9pbnRBZGRyZXNzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9FbmRwb2ludEFkZHJlc3Mob2JqOiBFbmRwb2ludEFkZHJlc3MgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdob3N0bmFtZSc6IG9iai5ob3N0bmFtZSxcbiAgICAnaXAnOiBvYmouaXAsXG4gICAgJ25vZGVOYW1lJzogb2JqLm5vZGVOYW1lLFxuICAgICd0YXJnZXRSZWYnOiB0b0pzb25fT2JqZWN0UmVmZXJlbmNlKG9iai50YXJnZXRSZWYpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIExpbWl0UmFuZ2VJdGVtIGRlZmluZXMgYSBtaW4vbWF4IHVzYWdlIGxpbWl0IGZvciBhbnkgcmVzb3VyY2UgdGhhdCBtYXRjaGVzIG9uIGtpbmQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTGltaXRSYW5nZUl0ZW1cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMaW1pdFJhbmdlSXRlbSB7XG4gIC8qKlxuICAgKiBEZWZhdWx0IHJlc291cmNlIHJlcXVpcmVtZW50IGxpbWl0IHZhbHVlIGJ5IHJlc291cmNlIG5hbWUgaWYgcmVzb3VyY2UgbGltaXQgaXMgb21pdHRlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTGltaXRSYW5nZUl0ZW0jZGVmYXVsdFxuICAgKi9cbiAgcmVhZG9ubHkgZGVmYXVsdD86IHsgW2tleTogc3RyaW5nXTogUXVhbnRpdHkgfTtcblxuICAvKipcbiAgICogRGVmYXVsdFJlcXVlc3QgaXMgdGhlIGRlZmF1bHQgcmVzb3VyY2UgcmVxdWlyZW1lbnQgcmVxdWVzdCB2YWx1ZSBieSByZXNvdXJjZSBuYW1lIGlmIHJlc291cmNlIHJlcXVlc3QgaXMgb21pdHRlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTGltaXRSYW5nZUl0ZW0jZGVmYXVsdFJlcXVlc3RcbiAgICovXG4gIHJlYWRvbmx5IGRlZmF1bHRSZXF1ZXN0PzogeyBba2V5OiBzdHJpbmddOiBRdWFudGl0eSB9O1xuXG4gIC8qKlxuICAgKiBNYXggdXNhZ2UgY29uc3RyYWludHMgb24gdGhpcyBraW5kIGJ5IHJlc291cmNlIG5hbWUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkxpbWl0UmFuZ2VJdGVtI21heFxuICAgKi9cbiAgcmVhZG9ubHkgbWF4PzogeyBba2V5OiBzdHJpbmddOiBRdWFudGl0eSB9O1xuXG4gIC8qKlxuICAgKiBNYXhMaW1pdFJlcXVlc3RSYXRpbyBpZiBzcGVjaWZpZWQsIHRoZSBuYW1lZCByZXNvdXJjZSBtdXN0IGhhdmUgYSByZXF1ZXN0IGFuZCBsaW1pdCB0aGF0IGFyZSBib3RoIG5vbi16ZXJvIHdoZXJlIGxpbWl0IGRpdmlkZWQgYnkgcmVxdWVzdCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGVudW1lcmF0ZWQgdmFsdWU7IHRoaXMgcmVwcmVzZW50cyB0aGUgbWF4IGJ1cnN0IGZvciB0aGUgbmFtZWQgcmVzb3VyY2UuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkxpbWl0UmFuZ2VJdGVtI21heExpbWl0UmVxdWVzdFJhdGlvXG4gICAqL1xuICByZWFkb25seSBtYXhMaW1pdFJlcXVlc3RSYXRpbz86IHsgW2tleTogc3RyaW5nXTogUXVhbnRpdHkgfTtcblxuICAvKipcbiAgICogTWluIHVzYWdlIGNvbnN0cmFpbnRzIG9uIHRoaXMga2luZCBieSByZXNvdXJjZSBuYW1lLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5MaW1pdFJhbmdlSXRlbSNtaW5cbiAgICovXG4gIHJlYWRvbmx5IG1pbj86IHsgW2tleTogc3RyaW5nXTogUXVhbnRpdHkgfTtcblxuICAvKipcbiAgICogVHlwZSBvZiByZXNvdXJjZSB0aGF0IHRoaXMgbGltaXQgYXBwbGllcyB0by5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTGltaXRSYW5nZUl0ZW0jdHlwZVxuICAgKi9cbiAgcmVhZG9ubHkgdHlwZTogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0xpbWl0UmFuZ2VJdGVtJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9MaW1pdFJhbmdlSXRlbShvYmo6IExpbWl0UmFuZ2VJdGVtIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZGVmYXVsdCc6ICgob2JqLmRlZmF1bHQpID09PSB1bmRlZmluZWQpID8gdW5kZWZpbmVkIDogKE9iamVjdC5lbnRyaWVzKG9iai5kZWZhdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXT8udmFsdWUgfSksIHt9KSksXG4gICAgJ2RlZmF1bHRSZXF1ZXN0JzogKChvYmouZGVmYXVsdFJlcXVlc3QpID09PSB1bmRlZmluZWQpID8gdW5kZWZpbmVkIDogKE9iamVjdC5lbnRyaWVzKG9iai5kZWZhdWx0UmVxdWVzdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0/LnZhbHVlIH0pLCB7fSkpLFxuICAgICdtYXgnOiAoKG9iai5tYXgpID09PSB1bmRlZmluZWQpID8gdW5kZWZpbmVkIDogKE9iamVjdC5lbnRyaWVzKG9iai5tYXgpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdPy52YWx1ZSB9KSwge30pKSxcbiAgICAnbWF4TGltaXRSZXF1ZXN0UmF0aW8nOiAoKG9iai5tYXhMaW1pdFJlcXVlc3RSYXRpbykgPT09IHVuZGVmaW5lZCkgPyB1bmRlZmluZWQgOiAoT2JqZWN0LmVudHJpZXMob2JqLm1heExpbWl0UmVxdWVzdFJhdGlvKS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXT8udmFsdWUgfSksIHt9KSksXG4gICAgJ21pbic6ICgob2JqLm1pbikgPT09IHVuZGVmaW5lZCkgPyB1bmRlZmluZWQgOiAoT2JqZWN0LmVudHJpZXMob2JqLm1pbikucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0/LnZhbHVlIH0pLCB7fSkpLFxuICAgICd0eXBlJzogb2JqLnR5cGUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogTm9kZUNvbmZpZ1NvdXJjZSBzcGVjaWZpZXMgYSBzb3VyY2Ugb2Ygbm9kZSBjb25maWd1cmF0aW9uLiBFeGFjdGx5IG9uZSBzdWJmaWVsZCAoZXhjbHVkaW5nIG1ldGFkYXRhKSBtdXN0IGJlIG5vbi1uaWwuIFRoaXMgQVBJIGlzIGRlcHJlY2F0ZWQgc2luY2UgMS4yMlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLk5vZGVDb25maWdTb3VyY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOb2RlQ29uZmlnU291cmNlIHtcbiAgLyoqXG4gICAqIENvbmZpZ01hcCBpcyBhIHJlZmVyZW5jZSB0byBhIE5vZGUncyBDb25maWdNYXBcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTm9kZUNvbmZpZ1NvdXJjZSNjb25maWdNYXBcbiAgICovXG4gIHJlYWRvbmx5IGNvbmZpZ01hcD86IENvbmZpZ01hcE5vZGVDb25maWdTb3VyY2U7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnTm9kZUNvbmZpZ1NvdXJjZScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fTm9kZUNvbmZpZ1NvdXJjZShvYmo6IE5vZGVDb25maWdTb3VyY2UgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdjb25maWdNYXAnOiB0b0pzb25fQ29uZmlnTWFwTm9kZUNvbmZpZ1NvdXJjZShvYmouY29uZmlnTWFwKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBUaGUgbm9kZSB0aGlzIFRhaW50IGlzIGF0dGFjaGVkIHRvIGhhcyB0aGUgXCJlZmZlY3RcIiBvbiBhbnkgcG9kIHRoYXQgZG9lcyBub3QgdG9sZXJhdGUgdGhlIFRhaW50LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlRhaW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGFpbnQge1xuICAvKipcbiAgICogUmVxdWlyZWQuIFRoZSBlZmZlY3Qgb2YgdGhlIHRhaW50IG9uIHBvZHMgdGhhdCBkbyBub3QgdG9sZXJhdGUgdGhlIHRhaW50LiBWYWxpZCBlZmZlY3RzIGFyZSBOb1NjaGVkdWxlLCBQcmVmZXJOb1NjaGVkdWxlIGFuZCBOb0V4ZWN1dGUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlRhaW50I2VmZmVjdFxuICAgKi9cbiAgcmVhZG9ubHkgZWZmZWN0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFJlcXVpcmVkLiBUaGUgdGFpbnQga2V5IHRvIGJlIGFwcGxpZWQgdG8gYSBub2RlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5UYWludCNrZXlcbiAgICovXG4gIHJlYWRvbmx5IGtleTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaW1lQWRkZWQgcmVwcmVzZW50cyB0aGUgdGltZSBhdCB3aGljaCB0aGUgdGFpbnQgd2FzIGFkZGVkLiBJdCBpcyBvbmx5IHdyaXR0ZW4gZm9yIE5vRXhlY3V0ZSB0YWludHMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlRhaW50I3RpbWVBZGRlZFxuICAgKi9cbiAgcmVhZG9ubHkgdGltZUFkZGVkPzogRGF0ZTtcblxuICAvKipcbiAgICogVGhlIHRhaW50IHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHRhaW50IGtleS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVGFpbnQjdmFsdWVcbiAgICovXG4gIHJlYWRvbmx5IHZhbHVlPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1RhaW50JyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9UYWludChvYmo6IFRhaW50IHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZWZmZWN0Jzogb2JqLmVmZmVjdCxcbiAgICAna2V5Jzogb2JqLmtleSxcbiAgICAndGltZUFkZGVkJzogb2JqLnRpbWVBZGRlZD8udG9JU09TdHJpbmcoKSxcbiAgICAndmFsdWUnOiBvYmoudmFsdWUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIFBlcnNpc3RlbnQgRGlzayByZXNvdXJjZSBpbiBBV1MuXG4gKlxuICogQW4gQVdTIEVCUyBkaXNrIG11c3QgZXhpc3QgYmVmb3JlIG1vdW50aW5nIHRvIGEgY29udGFpbmVyLiBUaGUgZGlzayBtdXN0IGFsc28gYmUgaW4gdGhlIHNhbWUgQVdTIHpvbmUgYXMgdGhlIGt1YmVsZXQuIEFuIEFXUyBFQlMgZGlzayBjYW4gb25seSBiZSBtb3VudGVkIGFzIHJlYWQvd3JpdGUgb25jZS4gQVdTIEVCUyB2b2x1bWVzIHN1cHBvcnQgb3duZXJzaGlwIG1hbmFnZW1lbnQgYW5kIFNFTGludXggcmVsYWJlbGluZy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5BV1NFbGFzdGljQmxvY2tTdG9yZVZvbHVtZVNvdXJjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEF3c0VsYXN0aWNCbG9ja1N0b3JlVm9sdW1lU291cmNlIHtcbiAgLyoqXG4gICAqIEZpbGVzeXN0ZW0gdHlwZSBvZiB0aGUgdm9sdW1lIHRoYXQgeW91IHdhbnQgdG8gbW91bnQuIFRpcDogRW5zdXJlIHRoYXQgdGhlIGZpbGVzeXN0ZW0gdHlwZSBpcyBzdXBwb3J0ZWQgYnkgdGhlIGhvc3Qgb3BlcmF0aW5nIHN5c3RlbS4gRXhhbXBsZXM6IFwiZXh0NFwiLCBcInhmc1wiLCBcIm50ZnNcIi4gSW1wbGljaXRseSBpbmZlcnJlZCB0byBiZSBcImV4dDRcIiBpZiB1bnNwZWNpZmllZC4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3ZvbHVtZXMjYXdzZWxhc3RpY2Jsb2Nrc3RvcmVcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQVdTRWxhc3RpY0Jsb2NrU3RvcmVWb2x1bWVTb3VyY2UjZnNUeXBlXG4gICAqL1xuICByZWFkb25seSBmc1R5cGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBwYXJ0aXRpb24gaW4gdGhlIHZvbHVtZSB0aGF0IHlvdSB3YW50IHRvIG1vdW50LiBJZiBvbWl0dGVkLCB0aGUgZGVmYXVsdCBpcyB0byBtb3VudCBieSB2b2x1bWUgbmFtZS4gRXhhbXBsZXM6IEZvciB2b2x1bWUgL2Rldi9zZGExLCB5b3Ugc3BlY2lmeSB0aGUgcGFydGl0aW9uIGFzIFwiMVwiLiBTaW1pbGFybHksIHRoZSB2b2x1bWUgcGFydGl0aW9uIGZvciAvZGV2L3NkYSBpcyBcIjBcIiAob3IgeW91IGNhbiBsZWF2ZSB0aGUgcHJvcGVydHkgZW1wdHkpLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5BV1NFbGFzdGljQmxvY2tTdG9yZVZvbHVtZVNvdXJjZSNwYXJ0aXRpb25cbiAgICovXG4gIHJlYWRvbmx5IHBhcnRpdGlvbj86IG51bWJlcjtcblxuICAvKipcbiAgICogU3BlY2lmeSBcInRydWVcIiB0byBmb3JjZSBhbmQgc2V0IHRoZSBSZWFkT25seSBwcm9wZXJ0eSBpbiBWb2x1bWVNb3VudHMgdG8gXCJ0cnVlXCIuIElmIG9taXR0ZWQsIHRoZSBkZWZhdWx0IGlzIFwiZmFsc2VcIi4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3ZvbHVtZXMjYXdzZWxhc3RpY2Jsb2Nrc3RvcmVcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQVdTRWxhc3RpY0Jsb2NrU3RvcmVWb2x1bWVTb3VyY2UjcmVhZE9ubHlcbiAgICovXG4gIHJlYWRvbmx5IHJlYWRPbmx5PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogVW5pcXVlIElEIG9mIHRoZSBwZXJzaXN0ZW50IGRpc2sgcmVzb3VyY2UgaW4gQVdTIChBbWF6b24gRUJTIHZvbHVtZSkuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvc3RvcmFnZS92b2x1bWVzI2F3c2VsYXN0aWNibG9ja3N0b3JlXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkFXU0VsYXN0aWNCbG9ja1N0b3JlVm9sdW1lU291cmNlI3ZvbHVtZUlEXG4gICAqL1xuICByZWFkb25seSB2b2x1bWVJZDogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0F3c0VsYXN0aWNCbG9ja1N0b3JlVm9sdW1lU291cmNlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Bd3NFbGFzdGljQmxvY2tTdG9yZVZvbHVtZVNvdXJjZShvYmo6IEF3c0VsYXN0aWNCbG9ja1N0b3JlVm9sdW1lU291cmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZnNUeXBlJzogb2JqLmZzVHlwZSxcbiAgICAncGFydGl0aW9uJzogb2JqLnBhcnRpdGlvbixcbiAgICAncmVhZE9ubHknOiBvYmoucmVhZE9ubHksXG4gICAgJ3ZvbHVtZUlEJzogb2JqLnZvbHVtZUlkLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEF6dXJlRGlzayByZXByZXNlbnRzIGFuIEF6dXJlIERhdGEgRGlzayBtb3VudCBvbiB0aGUgaG9zdCBhbmQgYmluZCBtb3VudCB0byB0aGUgcG9kLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkF6dXJlRGlza1ZvbHVtZVNvdXJjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEF6dXJlRGlza1ZvbHVtZVNvdXJjZSB7XG4gIC8qKlxuICAgKiBIb3N0IENhY2hpbmcgbW9kZTogTm9uZSwgUmVhZCBPbmx5LCBSZWFkIFdyaXRlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5BenVyZURpc2tWb2x1bWVTb3VyY2UjY2FjaGluZ01vZGVcbiAgICovXG4gIHJlYWRvbmx5IGNhY2hpbmdNb2RlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgTmFtZSBvZiB0aGUgZGF0YSBkaXNrIGluIHRoZSBibG9iIHN0b3JhZ2VcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQXp1cmVEaXNrVm9sdW1lU291cmNlI2Rpc2tOYW1lXG4gICAqL1xuICByZWFkb25seSBkaXNrTmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgVVJJIHRoZSBkYXRhIGRpc2sgaW4gdGhlIGJsb2Igc3RvcmFnZVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5BenVyZURpc2tWb2x1bWVTb3VyY2UjZGlza1VSSVxuICAgKi9cbiAgcmVhZG9ubHkgZGlza1VyaTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBGaWxlc3lzdGVtIHR5cGUgdG8gbW91bnQuIE11c3QgYmUgYSBmaWxlc3lzdGVtIHR5cGUgc3VwcG9ydGVkIGJ5IHRoZSBob3N0IG9wZXJhdGluZyBzeXN0ZW0uIEV4LiBcImV4dDRcIiwgXCJ4ZnNcIiwgXCJudGZzXCIuIEltcGxpY2l0bHkgaW5mZXJyZWQgdG8gYmUgXCJleHQ0XCIgaWYgdW5zcGVjaWZpZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkF6dXJlRGlza1ZvbHVtZVNvdXJjZSNmc1R5cGVcbiAgICovXG4gIHJlYWRvbmx5IGZzVHlwZT86IHN0cmluZztcblxuICAvKipcbiAgICogRXhwZWN0ZWQgdmFsdWVzIFNoYXJlZDogbXVsdGlwbGUgYmxvYiBkaXNrcyBwZXIgc3RvcmFnZSBhY2NvdW50ICBEZWRpY2F0ZWQ6IHNpbmdsZSBibG9iIGRpc2sgcGVyIHN0b3JhZ2UgYWNjb3VudCAgTWFuYWdlZDogYXp1cmUgbWFuYWdlZCBkYXRhIGRpc2sgKG9ubHkgaW4gbWFuYWdlZCBhdmFpbGFiaWxpdHkgc2V0KS4gZGVmYXVsdHMgdG8gc2hhcmVkXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkF6dXJlRGlza1ZvbHVtZVNvdXJjZSNraW5kXG4gICAqL1xuICByZWFkb25seSBraW5kPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0cyB0byBmYWxzZSAocmVhZC93cml0ZSkuIFJlYWRPbmx5IGhlcmUgd2lsbCBmb3JjZSB0aGUgUmVhZE9ubHkgc2V0dGluZyBpbiBWb2x1bWVNb3VudHMuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlIChyZWFkL3dyaXRlKS4gUmVhZE9ubHkgaGVyZSB3aWxsIGZvcmNlIHRoZSBSZWFkT25seSBzZXR0aW5nIGluIFZvbHVtZU1vdW50cy5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQXp1cmVEaXNrVm9sdW1lU291cmNlI3JlYWRPbmx5XG4gICAqL1xuICByZWFkb25seSByZWFkT25seT86IGJvb2xlYW47XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnQXp1cmVEaXNrVm9sdW1lU291cmNlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9BenVyZURpc2tWb2x1bWVTb3VyY2Uob2JqOiBBenVyZURpc2tWb2x1bWVTb3VyY2UgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdjYWNoaW5nTW9kZSc6IG9iai5jYWNoaW5nTW9kZSxcbiAgICAnZGlza05hbWUnOiBvYmouZGlza05hbWUsXG4gICAgJ2Rpc2tVUkknOiBvYmouZGlza1VyaSxcbiAgICAnZnNUeXBlJzogb2JqLmZzVHlwZSxcbiAgICAna2luZCc6IG9iai5raW5kLFxuICAgICdyZWFkT25seSc6IG9iai5yZWFkT25seSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBBenVyZUZpbGUgcmVwcmVzZW50cyBhbiBBenVyZSBGaWxlIFNlcnZpY2UgbW91bnQgb24gdGhlIGhvc3QgYW5kIGJpbmQgbW91bnQgdG8gdGhlIHBvZC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5BenVyZUZpbGVQZXJzaXN0ZW50Vm9sdW1lU291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXp1cmVGaWxlUGVyc2lzdGVudFZvbHVtZVNvdXJjZSB7XG4gIC8qKlxuICAgKiBEZWZhdWx0cyB0byBmYWxzZSAocmVhZC93cml0ZSkuIFJlYWRPbmx5IGhlcmUgd2lsbCBmb3JjZSB0aGUgUmVhZE9ubHkgc2V0dGluZyBpbiBWb2x1bWVNb3VudHMuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlIChyZWFkL3dyaXRlKS4gUmVhZE9ubHkgaGVyZSB3aWxsIGZvcmNlIHRoZSBSZWFkT25seSBzZXR0aW5nIGluIFZvbHVtZU1vdW50cy5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQXp1cmVGaWxlUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNyZWFkT25seVxuICAgKi9cbiAgcmVhZG9ubHkgcmVhZE9ubHk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiB0aGUgbmFtZSBvZiBzZWNyZXQgdGhhdCBjb250YWlucyBBenVyZSBTdG9yYWdlIEFjY291bnQgTmFtZSBhbmQgS2V5XG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkF6dXJlRmlsZVBlcnNpc3RlbnRWb2x1bWVTb3VyY2Ujc2VjcmV0TmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgc2VjcmV0TmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiB0aGUgbmFtZXNwYWNlIG9mIHRoZSBzZWNyZXQgdGhhdCBjb250YWlucyBBenVyZSBTdG9yYWdlIEFjY291bnQgTmFtZSBhbmQgS2V5IGRlZmF1bHQgaXMgdGhlIHNhbWUgYXMgdGhlIFBvZFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5BenVyZUZpbGVQZXJzaXN0ZW50Vm9sdW1lU291cmNlI3NlY3JldE5hbWVzcGFjZVxuICAgKi9cbiAgcmVhZG9ubHkgc2VjcmV0TmFtZXNwYWNlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTaGFyZSBOYW1lXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkF6dXJlRmlsZVBlcnNpc3RlbnRWb2x1bWVTb3VyY2Ujc2hhcmVOYW1lXG4gICAqL1xuICByZWFkb25seSBzaGFyZU5hbWU6IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdBenVyZUZpbGVQZXJzaXN0ZW50Vm9sdW1lU291cmNlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9BenVyZUZpbGVQZXJzaXN0ZW50Vm9sdW1lU291cmNlKG9iajogQXp1cmVGaWxlUGVyc2lzdGVudFZvbHVtZVNvdXJjZSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ3JlYWRPbmx5Jzogb2JqLnJlYWRPbmx5LFxuICAgICdzZWNyZXROYW1lJzogb2JqLnNlY3JldE5hbWUsXG4gICAgJ3NlY3JldE5hbWVzcGFjZSc6IG9iai5zZWNyZXROYW1lc3BhY2UsXG4gICAgJ3NoYXJlTmFtZSc6IG9iai5zaGFyZU5hbWUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIENlcGggRmlsZXN5c3RlbSBtb3VudCB0aGF0IGxhc3RzIHRoZSBsaWZldGltZSBvZiBhIHBvZCBDZXBoZnMgdm9sdW1lcyBkbyBub3Qgc3VwcG9ydCBvd25lcnNoaXAgbWFuYWdlbWVudCBvciBTRUxpbnV4IHJlbGFiZWxpbmcuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ2VwaEZTUGVyc2lzdGVudFZvbHVtZVNvdXJjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIENlcGhGc1BlcnNpc3RlbnRWb2x1bWVTb3VyY2Uge1xuICAvKipcbiAgICogUmVxdWlyZWQ6IE1vbml0b3JzIGlzIGEgY29sbGVjdGlvbiBvZiBDZXBoIG1vbml0b3JzIE1vcmUgaW5mbzogaHR0cHM6Ly9leGFtcGxlcy5rOHMuaW8vdm9sdW1lcy9jZXBoZnMvUkVBRE1FLm1kI2hvdy10by11c2UtaXRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ2VwaEZTUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNtb25pdG9yc1xuICAgKi9cbiAgcmVhZG9ubHkgbW9uaXRvcnM6IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbDogVXNlZCBhcyB0aGUgbW91bnRlZCByb290LCByYXRoZXIgdGhhbiB0aGUgZnVsbCBDZXBoIHRyZWUsIGRlZmF1bHQgaXMgL1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5DZXBoRlNQZXJzaXN0ZW50Vm9sdW1lU291cmNlI3BhdGhcbiAgICovXG4gIHJlYWRvbmx5IHBhdGg/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsOiBEZWZhdWx0cyB0byBmYWxzZSAocmVhZC93cml0ZSkuIFJlYWRPbmx5IGhlcmUgd2lsbCBmb3JjZSB0aGUgUmVhZE9ubHkgc2V0dGluZyBpbiBWb2x1bWVNb3VudHMuIE1vcmUgaW5mbzogaHR0cHM6Ly9leGFtcGxlcy5rOHMuaW8vdm9sdW1lcy9jZXBoZnMvUkVBRE1FLm1kI2hvdy10by11c2UtaXRcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2UgKHJlYWQvd3JpdGUpLiBSZWFkT25seSBoZXJlIHdpbGwgZm9yY2UgdGhlIFJlYWRPbmx5IHNldHRpbmcgaW4gVm9sdW1lTW91bnRzLiBNb3JlIGluZm86IGh0dHBzOi8vZXhhbXBsZXMuazhzLmlvL3ZvbHVtZXMvY2VwaGZzL1JFQURNRS5tZCNob3ctdG8tdXNlLWl0XG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNlcGhGU1BlcnNpc3RlbnRWb2x1bWVTb3VyY2UjcmVhZE9ubHlcbiAgICovXG4gIHJlYWRvbmx5IHJlYWRPbmx5PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogT3B0aW9uYWw6IFNlY3JldEZpbGUgaXMgdGhlIHBhdGggdG8ga2V5IHJpbmcgZm9yIFVzZXIsIGRlZmF1bHQgaXMgL2V0Yy9jZXBoL3VzZXIuc2VjcmV0IE1vcmUgaW5mbzogaHR0cHM6Ly9leGFtcGxlcy5rOHMuaW8vdm9sdW1lcy9jZXBoZnMvUkVBRE1FLm1kI2hvdy10by11c2UtaXRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ2VwaEZTUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNzZWNyZXRGaWxlXG4gICAqL1xuICByZWFkb25seSBzZWNyZXRGaWxlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbDogU2VjcmV0UmVmIGlzIHJlZmVyZW5jZSB0byB0aGUgYXV0aGVudGljYXRpb24gc2VjcmV0IGZvciBVc2VyLCBkZWZhdWx0IGlzIGVtcHR5LiBNb3JlIGluZm86IGh0dHBzOi8vZXhhbXBsZXMuazhzLmlvL3ZvbHVtZXMvY2VwaGZzL1JFQURNRS5tZCNob3ctdG8tdXNlLWl0XG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNlcGhGU1BlcnNpc3RlbnRWb2x1bWVTb3VyY2Ujc2VjcmV0UmVmXG4gICAqL1xuICByZWFkb25seSBzZWNyZXRSZWY/OiBTZWNyZXRSZWZlcmVuY2U7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsOiBVc2VyIGlzIHRoZSByYWRvcyB1c2VyIG5hbWUsIGRlZmF1bHQgaXMgYWRtaW4gTW9yZSBpbmZvOiBodHRwczovL2V4YW1wbGVzLms4cy5pby92b2x1bWVzL2NlcGhmcy9SRUFETUUubWQjaG93LXRvLXVzZS1pdFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5DZXBoRlNQZXJzaXN0ZW50Vm9sdW1lU291cmNlI3VzZXJcbiAgICovXG4gIHJlYWRvbmx5IHVzZXI/OiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnQ2VwaEZzUGVyc2lzdGVudFZvbHVtZVNvdXJjZScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fQ2VwaEZzUGVyc2lzdGVudFZvbHVtZVNvdXJjZShvYmo6IENlcGhGc1BlcnNpc3RlbnRWb2x1bWVTb3VyY2UgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtb25pdG9ycyc6IG9iai5tb25pdG9ycz8ubWFwKHkgPT4geSksXG4gICAgJ3BhdGgnOiBvYmoucGF0aCxcbiAgICAncmVhZE9ubHknOiBvYmoucmVhZE9ubHksXG4gICAgJ3NlY3JldEZpbGUnOiBvYmouc2VjcmV0RmlsZSxcbiAgICAnc2VjcmV0UmVmJzogdG9Kc29uX1NlY3JldFJlZmVyZW5jZShvYmouc2VjcmV0UmVmKSxcbiAgICAndXNlcic6IG9iai51c2VyLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaW5kZXIgdm9sdW1lIHJlc291cmNlIGluIE9wZW5zdGFjay4gQSBDaW5kZXIgdm9sdW1lIG11c3QgZXhpc3QgYmVmb3JlIG1vdW50aW5nIHRvIGEgY29udGFpbmVyLiBUaGUgdm9sdW1lIG11c3QgYWxzbyBiZSBpbiB0aGUgc2FtZSByZWdpb24gYXMgdGhlIGt1YmVsZXQuIENpbmRlciB2b2x1bWVzIHN1cHBvcnQgb3duZXJzaGlwIG1hbmFnZW1lbnQgYW5kIFNFTGludXggcmVsYWJlbGluZy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5DaW5kZXJQZXJzaXN0ZW50Vm9sdW1lU291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2luZGVyUGVyc2lzdGVudFZvbHVtZVNvdXJjZSB7XG4gIC8qKlxuICAgKiBGaWxlc3lzdGVtIHR5cGUgdG8gbW91bnQuIE11c3QgYmUgYSBmaWxlc3lzdGVtIHR5cGUgc3VwcG9ydGVkIGJ5IHRoZSBob3N0IG9wZXJhdGluZyBzeXN0ZW0uIEV4YW1wbGVzOiBcImV4dDRcIiwgXCJ4ZnNcIiwgXCJudGZzXCIuIEltcGxpY2l0bHkgaW5mZXJyZWQgdG8gYmUgXCJleHQ0XCIgaWYgdW5zcGVjaWZpZWQuIE1vcmUgaW5mbzogaHR0cHM6Ly9leGFtcGxlcy5rOHMuaW8vbXlzcWwtY2luZGVyLXBkL1JFQURNRS5tZFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5DaW5kZXJQZXJzaXN0ZW50Vm9sdW1lU291cmNlI2ZzVHlwZVxuICAgKi9cbiAgcmVhZG9ubHkgZnNUeXBlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbDogRGVmYXVsdHMgdG8gZmFsc2UgKHJlYWQvd3JpdGUpLiBSZWFkT25seSBoZXJlIHdpbGwgZm9yY2UgdGhlIFJlYWRPbmx5IHNldHRpbmcgaW4gVm9sdW1lTW91bnRzLiBNb3JlIGluZm86IGh0dHBzOi8vZXhhbXBsZXMuazhzLmlvL215c3FsLWNpbmRlci1wZC9SRUFETUUubWRcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2UgKHJlYWQvd3JpdGUpLiBSZWFkT25seSBoZXJlIHdpbGwgZm9yY2UgdGhlIFJlYWRPbmx5IHNldHRpbmcgaW4gVm9sdW1lTW91bnRzLiBNb3JlIGluZm86IGh0dHBzOi8vZXhhbXBsZXMuazhzLmlvL215c3FsLWNpbmRlci1wZC9SRUFETUUubWRcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ2luZGVyUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNyZWFkT25seVxuICAgKi9cbiAgcmVhZG9ubHkgcmVhZE9ubHk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbDogcG9pbnRzIHRvIGEgc2VjcmV0IG9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnMgdXNlZCB0byBjb25uZWN0IHRvIE9wZW5TdGFjay5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ2luZGVyUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNzZWNyZXRSZWZcbiAgICovXG4gIHJlYWRvbmx5IHNlY3JldFJlZj86IFNlY3JldFJlZmVyZW5jZTtcblxuICAvKipcbiAgICogdm9sdW1lIGlkIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHZvbHVtZSBpbiBjaW5kZXIuIE1vcmUgaW5mbzogaHR0cHM6Ly9leGFtcGxlcy5rOHMuaW8vbXlzcWwtY2luZGVyLXBkL1JFQURNRS5tZFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5DaW5kZXJQZXJzaXN0ZW50Vm9sdW1lU291cmNlI3ZvbHVtZUlEXG4gICAqL1xuICByZWFkb25seSB2b2x1bWVJZDogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0NpbmRlclBlcnNpc3RlbnRWb2x1bWVTb3VyY2UnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0NpbmRlclBlcnNpc3RlbnRWb2x1bWVTb3VyY2Uob2JqOiBDaW5kZXJQZXJzaXN0ZW50Vm9sdW1lU291cmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZnNUeXBlJzogb2JqLmZzVHlwZSxcbiAgICAncmVhZE9ubHknOiBvYmoucmVhZE9ubHksXG4gICAgJ3NlY3JldFJlZic6IHRvSnNvbl9TZWNyZXRSZWZlcmVuY2Uob2JqLnNlY3JldFJlZiksXG4gICAgJ3ZvbHVtZUlEJzogb2JqLnZvbHVtZUlkLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgc3RvcmFnZSB0aGF0IGlzIG1hbmFnZWQgYnkgYW4gZXh0ZXJuYWwgQ1NJIHZvbHVtZSBkcml2ZXIgKEJldGEgZmVhdHVyZSlcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5DU0lQZXJzaXN0ZW50Vm9sdW1lU291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3NpUGVyc2lzdGVudFZvbHVtZVNvdXJjZSB7XG4gIC8qKlxuICAgKiBDb250cm9sbGVyRXhwYW5kU2VjcmV0UmVmIGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBzZWNyZXQgb2JqZWN0IGNvbnRhaW5pbmcgc2Vuc2l0aXZlIGluZm9ybWF0aW9uIHRvIHBhc3MgdG8gdGhlIENTSSBkcml2ZXIgdG8gY29tcGxldGUgdGhlIENTSSBDb250cm9sbGVyRXhwYW5kVm9sdW1lIGNhbGwuIFRoaXMgaXMgYW4gYWxwaGEgZmllbGQgYW5kIHJlcXVpcmVzIGVuYWJsaW5nIEV4cGFuZENTSVZvbHVtZXMgZmVhdHVyZSBnYXRlLiBUaGlzIGZpZWxkIGlzIG9wdGlvbmFsLCBhbmQgbWF5IGJlIGVtcHR5IGlmIG5vIHNlY3JldCBpcyByZXF1aXJlZC4gSWYgdGhlIHNlY3JldCBvYmplY3QgY29udGFpbnMgbW9yZSB0aGFuIG9uZSBzZWNyZXQsIGFsbCBzZWNyZXRzIGFyZSBwYXNzZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNTSVBlcnNpc3RlbnRWb2x1bWVTb3VyY2UjY29udHJvbGxlckV4cGFuZFNlY3JldFJlZlxuICAgKi9cbiAgcmVhZG9ubHkgY29udHJvbGxlckV4cGFuZFNlY3JldFJlZj86IFNlY3JldFJlZmVyZW5jZTtcblxuICAvKipcbiAgICogQ29udHJvbGxlclB1Ymxpc2hTZWNyZXRSZWYgaXMgYSByZWZlcmVuY2UgdG8gdGhlIHNlY3JldCBvYmplY3QgY29udGFpbmluZyBzZW5zaXRpdmUgaW5mb3JtYXRpb24gdG8gcGFzcyB0byB0aGUgQ1NJIGRyaXZlciB0byBjb21wbGV0ZSB0aGUgQ1NJIENvbnRyb2xsZXJQdWJsaXNoVm9sdW1lIGFuZCBDb250cm9sbGVyVW5wdWJsaXNoVm9sdW1lIGNhbGxzLiBUaGlzIGZpZWxkIGlzIG9wdGlvbmFsLCBhbmQgbWF5IGJlIGVtcHR5IGlmIG5vIHNlY3JldCBpcyByZXF1aXJlZC4gSWYgdGhlIHNlY3JldCBvYmplY3QgY29udGFpbnMgbW9yZSB0aGFuIG9uZSBzZWNyZXQsIGFsbCBzZWNyZXRzIGFyZSBwYXNzZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNTSVBlcnNpc3RlbnRWb2x1bWVTb3VyY2UjY29udHJvbGxlclB1Ymxpc2hTZWNyZXRSZWZcbiAgICovXG4gIHJlYWRvbmx5IGNvbnRyb2xsZXJQdWJsaXNoU2VjcmV0UmVmPzogU2VjcmV0UmVmZXJlbmNlO1xuXG4gIC8qKlxuICAgKiBEcml2ZXIgaXMgdGhlIG5hbWUgb2YgdGhlIGRyaXZlciB0byB1c2UgZm9yIHRoaXMgdm9sdW1lLiBSZXF1aXJlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ1NJUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNkcml2ZXJcbiAgICovXG4gIHJlYWRvbmx5IGRyaXZlcjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBGaWxlc3lzdGVtIHR5cGUgdG8gbW91bnQuIE11c3QgYmUgYSBmaWxlc3lzdGVtIHR5cGUgc3VwcG9ydGVkIGJ5IHRoZSBob3N0IG9wZXJhdGluZyBzeXN0ZW0uIEV4LiBcImV4dDRcIiwgXCJ4ZnNcIiwgXCJudGZzXCIuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNTSVBlcnNpc3RlbnRWb2x1bWVTb3VyY2UjZnNUeXBlXG4gICAqL1xuICByZWFkb25seSBmc1R5cGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE5vZGVQdWJsaXNoU2VjcmV0UmVmIGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBzZWNyZXQgb2JqZWN0IGNvbnRhaW5pbmcgc2Vuc2l0aXZlIGluZm9ybWF0aW9uIHRvIHBhc3MgdG8gdGhlIENTSSBkcml2ZXIgdG8gY29tcGxldGUgdGhlIENTSSBOb2RlUHVibGlzaFZvbHVtZSBhbmQgTm9kZVVucHVibGlzaFZvbHVtZSBjYWxscy4gVGhpcyBmaWVsZCBpcyBvcHRpb25hbCwgYW5kIG1heSBiZSBlbXB0eSBpZiBubyBzZWNyZXQgaXMgcmVxdWlyZWQuIElmIHRoZSBzZWNyZXQgb2JqZWN0IGNvbnRhaW5zIG1vcmUgdGhhbiBvbmUgc2VjcmV0LCBhbGwgc2VjcmV0cyBhcmUgcGFzc2VkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5DU0lQZXJzaXN0ZW50Vm9sdW1lU291cmNlI25vZGVQdWJsaXNoU2VjcmV0UmVmXG4gICAqL1xuICByZWFkb25seSBub2RlUHVibGlzaFNlY3JldFJlZj86IFNlY3JldFJlZmVyZW5jZTtcblxuICAvKipcbiAgICogTm9kZVN0YWdlU2VjcmV0UmVmIGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBzZWNyZXQgb2JqZWN0IGNvbnRhaW5pbmcgc2Vuc2l0aXZlIGluZm9ybWF0aW9uIHRvIHBhc3MgdG8gdGhlIENTSSBkcml2ZXIgdG8gY29tcGxldGUgdGhlIENTSSBOb2RlU3RhZ2VWb2x1bWUgYW5kIE5vZGVTdGFnZVZvbHVtZSBhbmQgTm9kZVVuc3RhZ2VWb2x1bWUgY2FsbHMuIFRoaXMgZmllbGQgaXMgb3B0aW9uYWwsIGFuZCBtYXkgYmUgZW1wdHkgaWYgbm8gc2VjcmV0IGlzIHJlcXVpcmVkLiBJZiB0aGUgc2VjcmV0IG9iamVjdCBjb250YWlucyBtb3JlIHRoYW4gb25lIHNlY3JldCwgYWxsIHNlY3JldHMgYXJlIHBhc3NlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ1NJUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNub2RlU3RhZ2VTZWNyZXRSZWZcbiAgICovXG4gIHJlYWRvbmx5IG5vZGVTdGFnZVNlY3JldFJlZj86IFNlY3JldFJlZmVyZW5jZTtcblxuICAvKipcbiAgICogT3B0aW9uYWw6IFRoZSB2YWx1ZSB0byBwYXNzIHRvIENvbnRyb2xsZXJQdWJsaXNoVm9sdW1lUmVxdWVzdC4gRGVmYXVsdHMgdG8gZmFsc2UgKHJlYWQvd3JpdGUpLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZSAocmVhZC93cml0ZSkuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNTSVBlcnNpc3RlbnRWb2x1bWVTb3VyY2UjcmVhZE9ubHlcbiAgICovXG4gIHJlYWRvbmx5IHJlYWRPbmx5PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQXR0cmlidXRlcyBvZiB0aGUgdm9sdW1lIHRvIHB1Ymxpc2guXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNTSVBlcnNpc3RlbnRWb2x1bWVTb3VyY2Ujdm9sdW1lQXR0cmlidXRlc1xuICAgKi9cbiAgcmVhZG9ubHkgdm9sdW1lQXR0cmlidXRlcz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG5cbiAgLyoqXG4gICAqIFZvbHVtZUhhbmRsZSBpcyB0aGUgdW5pcXVlIHZvbHVtZSBuYW1lIHJldHVybmVkIGJ5IHRoZSBDU0kgdm9sdW1lIHBsdWdpbuKAmXMgQ3JlYXRlVm9sdW1lIHRvIHJlZmVyIHRvIHRoZSB2b2x1bWUgb24gYWxsIHN1YnNlcXVlbnQgY2FsbHMuIFJlcXVpcmVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5DU0lQZXJzaXN0ZW50Vm9sdW1lU291cmNlI3ZvbHVtZUhhbmRsZVxuICAgKi9cbiAgcmVhZG9ubHkgdm9sdW1lSGFuZGxlOiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnQ3NpUGVyc2lzdGVudFZvbHVtZVNvdXJjZScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fQ3NpUGVyc2lzdGVudFZvbHVtZVNvdXJjZShvYmo6IENzaVBlcnNpc3RlbnRWb2x1bWVTb3VyY2UgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdjb250cm9sbGVyRXhwYW5kU2VjcmV0UmVmJzogdG9Kc29uX1NlY3JldFJlZmVyZW5jZShvYmouY29udHJvbGxlckV4cGFuZFNlY3JldFJlZiksXG4gICAgJ2NvbnRyb2xsZXJQdWJsaXNoU2VjcmV0UmVmJzogdG9Kc29uX1NlY3JldFJlZmVyZW5jZShvYmouY29udHJvbGxlclB1Ymxpc2hTZWNyZXRSZWYpLFxuICAgICdkcml2ZXInOiBvYmouZHJpdmVyLFxuICAgICdmc1R5cGUnOiBvYmouZnNUeXBlLFxuICAgICdub2RlUHVibGlzaFNlY3JldFJlZic6IHRvSnNvbl9TZWNyZXRSZWZlcmVuY2Uob2JqLm5vZGVQdWJsaXNoU2VjcmV0UmVmKSxcbiAgICAnbm9kZVN0YWdlU2VjcmV0UmVmJzogdG9Kc29uX1NlY3JldFJlZmVyZW5jZShvYmoubm9kZVN0YWdlU2VjcmV0UmVmKSxcbiAgICAncmVhZE9ubHknOiBvYmoucmVhZE9ubHksXG4gICAgJ3ZvbHVtZUF0dHJpYnV0ZXMnOiAoKG9iai52b2x1bWVBdHRyaWJ1dGVzKSA9PT0gdW5kZWZpbmVkKSA/IHVuZGVmaW5lZCA6IChPYmplY3QuZW50cmllcyhvYmoudm9sdW1lQXR0cmlidXRlcykucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KSksXG4gICAgJ3ZvbHVtZUhhbmRsZSc6IG9iai52b2x1bWVIYW5kbGUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIEZpYnJlIENoYW5uZWwgdm9sdW1lLiBGaWJyZSBDaGFubmVsIHZvbHVtZXMgY2FuIG9ubHkgYmUgbW91bnRlZCBhcyByZWFkL3dyaXRlIG9uY2UuIEZpYnJlIENoYW5uZWwgdm9sdW1lcyBzdXBwb3J0IG93bmVyc2hpcCBtYW5hZ2VtZW50IGFuZCBTRUxpbnV4IHJlbGFiZWxpbmcuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRkNWb2x1bWVTb3VyY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGY1ZvbHVtZVNvdXJjZSB7XG4gIC8qKlxuICAgKiBGaWxlc3lzdGVtIHR5cGUgdG8gbW91bnQuIE11c3QgYmUgYSBmaWxlc3lzdGVtIHR5cGUgc3VwcG9ydGVkIGJ5IHRoZSBob3N0IG9wZXJhdGluZyBzeXN0ZW0uIEV4LiBcImV4dDRcIiwgXCJ4ZnNcIiwgXCJudGZzXCIuIEltcGxpY2l0bHkgaW5mZXJyZWQgdG8gYmUgXCJleHQ0XCIgaWYgdW5zcGVjaWZpZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkZDVm9sdW1lU291cmNlI2ZzVHlwZVxuICAgKi9cbiAgcmVhZG9ubHkgZnNUeXBlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbDogRkMgdGFyZ2V0IGx1biBudW1iZXJcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRkNWb2x1bWVTb3VyY2UjbHVuXG4gICAqL1xuICByZWFkb25seSBsdW4/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsOiBEZWZhdWx0cyB0byBmYWxzZSAocmVhZC93cml0ZSkuIFJlYWRPbmx5IGhlcmUgd2lsbCBmb3JjZSB0aGUgUmVhZE9ubHkgc2V0dGluZyBpbiBWb2x1bWVNb3VudHMuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlIChyZWFkL3dyaXRlKS4gUmVhZE9ubHkgaGVyZSB3aWxsIGZvcmNlIHRoZSBSZWFkT25seSBzZXR0aW5nIGluIFZvbHVtZU1vdW50cy5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRkNWb2x1bWVTb3VyY2UjcmVhZE9ubHlcbiAgICovXG4gIHJlYWRvbmx5IHJlYWRPbmx5PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogT3B0aW9uYWw6IEZDIHRhcmdldCB3b3JsZHdpZGUgbmFtZXMgKFdXTnMpXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkZDVm9sdW1lU291cmNlI3RhcmdldFdXTnNcbiAgICovXG4gIHJlYWRvbmx5IHRhcmdldFd3TnM/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogT3B0aW9uYWw6IEZDIHZvbHVtZSB3b3JsZCB3aWRlIGlkZW50aWZpZXJzICh3d2lkcykgRWl0aGVyIHd3aWRzIG9yIGNvbWJpbmF0aW9uIG9mIHRhcmdldFdXTnMgYW5kIGx1biBtdXN0IGJlIHNldCwgYnV0IG5vdCBib3RoIHNpbXVsdGFuZW91c2x5LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5GQ1ZvbHVtZVNvdXJjZSN3d2lkc1xuICAgKi9cbiAgcmVhZG9ubHkgd3dpZHM/OiBzdHJpbmdbXTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdGY1ZvbHVtZVNvdXJjZScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fRmNWb2x1bWVTb3VyY2Uob2JqOiBGY1ZvbHVtZVNvdXJjZSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2ZzVHlwZSc6IG9iai5mc1R5cGUsXG4gICAgJ2x1bic6IG9iai5sdW4sXG4gICAgJ3JlYWRPbmx5Jzogb2JqLnJlYWRPbmx5LFxuICAgICd0YXJnZXRXV05zJzogb2JqLnRhcmdldFd3TnM/Lm1hcCh5ID0+IHkpLFxuICAgICd3d2lkcyc6IG9iai53d2lkcz8ubWFwKHkgPT4geSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogRmxleFBlcnNpc3RlbnRWb2x1bWVTb3VyY2UgcmVwcmVzZW50cyBhIGdlbmVyaWMgcGVyc2lzdGVudCB2b2x1bWUgcmVzb3VyY2UgdGhhdCBpcyBwcm92aXNpb25lZC9hdHRhY2hlZCB1c2luZyBhbiBleGVjIGJhc2VkIHBsdWdpbi5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5GbGV4UGVyc2lzdGVudFZvbHVtZVNvdXJjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZsZXhQZXJzaXN0ZW50Vm9sdW1lU291cmNlIHtcbiAgLyoqXG4gICAqIERyaXZlciBpcyB0aGUgbmFtZSBvZiB0aGUgZHJpdmVyIHRvIHVzZSBmb3IgdGhpcyB2b2x1bWUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkZsZXhQZXJzaXN0ZW50Vm9sdW1lU291cmNlI2RyaXZlclxuICAgKi9cbiAgcmVhZG9ubHkgZHJpdmVyOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEZpbGVzeXN0ZW0gdHlwZSB0byBtb3VudC4gTXVzdCBiZSBhIGZpbGVzeXN0ZW0gdHlwZSBzdXBwb3J0ZWQgYnkgdGhlIGhvc3Qgb3BlcmF0aW5nIHN5c3RlbS4gRXguIFwiZXh0NFwiLCBcInhmc1wiLCBcIm50ZnNcIi4gVGhlIGRlZmF1bHQgZmlsZXN5c3RlbSBkZXBlbmRzIG9uIEZsZXhWb2x1bWUgc2NyaXB0LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5GbGV4UGVyc2lzdGVudFZvbHVtZVNvdXJjZSNmc1R5cGVcbiAgICovXG4gIHJlYWRvbmx5IGZzVHlwZT86IHN0cmluZztcblxuICAvKipcbiAgICogT3B0aW9uYWw6IEV4dHJhIGNvbW1hbmQgb3B0aW9ucyBpZiBhbnkuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkZsZXhQZXJzaXN0ZW50Vm9sdW1lU291cmNlI29wdGlvbnNcbiAgICovXG4gIHJlYWRvbmx5IG9wdGlvbnM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbDogRGVmYXVsdHMgdG8gZmFsc2UgKHJlYWQvd3JpdGUpLiBSZWFkT25seSBoZXJlIHdpbGwgZm9yY2UgdGhlIFJlYWRPbmx5IHNldHRpbmcgaW4gVm9sdW1lTW91bnRzLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZSAocmVhZC93cml0ZSkuIFJlYWRPbmx5IGhlcmUgd2lsbCBmb3JjZSB0aGUgUmVhZE9ubHkgc2V0dGluZyBpbiBWb2x1bWVNb3VudHMuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkZsZXhQZXJzaXN0ZW50Vm9sdW1lU291cmNlI3JlYWRPbmx5XG4gICAqL1xuICByZWFkb25seSByZWFkT25seT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsOiBTZWNyZXRSZWYgaXMgcmVmZXJlbmNlIHRvIHRoZSBzZWNyZXQgb2JqZWN0IGNvbnRhaW5pbmcgc2Vuc2l0aXZlIGluZm9ybWF0aW9uIHRvIHBhc3MgdG8gdGhlIHBsdWdpbiBzY3JpcHRzLiBUaGlzIG1heSBiZSBlbXB0eSBpZiBubyBzZWNyZXQgb2JqZWN0IGlzIHNwZWNpZmllZC4gSWYgdGhlIHNlY3JldCBvYmplY3QgY29udGFpbnMgbW9yZSB0aGFuIG9uZSBzZWNyZXQsIGFsbCBzZWNyZXRzIGFyZSBwYXNzZWQgdG8gdGhlIHBsdWdpbiBzY3JpcHRzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5GbGV4UGVyc2lzdGVudFZvbHVtZVNvdXJjZSNzZWNyZXRSZWZcbiAgICovXG4gIHJlYWRvbmx5IHNlY3JldFJlZj86IFNlY3JldFJlZmVyZW5jZTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdGbGV4UGVyc2lzdGVudFZvbHVtZVNvdXJjZScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fRmxleFBlcnNpc3RlbnRWb2x1bWVTb3VyY2Uob2JqOiBGbGV4UGVyc2lzdGVudFZvbHVtZVNvdXJjZSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2RyaXZlcic6IG9iai5kcml2ZXIsXG4gICAgJ2ZzVHlwZSc6IG9iai5mc1R5cGUsXG4gICAgJ29wdGlvbnMnOiAoKG9iai5vcHRpb25zKSA9PT0gdW5kZWZpbmVkKSA/IHVuZGVmaW5lZCA6IChPYmplY3QuZW50cmllcyhvYmoub3B0aW9ucykucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KSksXG4gICAgJ3JlYWRPbmx5Jzogb2JqLnJlYWRPbmx5LFxuICAgICdzZWNyZXRSZWYnOiB0b0pzb25fU2VjcmV0UmVmZXJlbmNlKG9iai5zZWNyZXRSZWYpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBGbG9ja2VyIHZvbHVtZSBtb3VudGVkIGJ5IHRoZSBGbG9ja2VyIGFnZW50LiBPbmUgYW5kIG9ubHkgb25lIG9mIGRhdGFzZXROYW1lIGFuZCBkYXRhc2V0VVVJRCBzaG91bGQgYmUgc2V0LiBGbG9ja2VyIHZvbHVtZXMgZG8gbm90IHN1cHBvcnQgb3duZXJzaGlwIG1hbmFnZW1lbnQgb3IgU0VMaW51eCByZWxhYmVsaW5nLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkZsb2NrZXJWb2x1bWVTb3VyY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGbG9ja2VyVm9sdW1lU291cmNlIHtcbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIGRhdGFzZXQgc3RvcmVkIGFzIG1ldGFkYXRhIC0+IG5hbWUgb24gdGhlIGRhdGFzZXQgZm9yIEZsb2NrZXIgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgZGVwcmVjYXRlZFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5GbG9ja2VyVm9sdW1lU291cmNlI2RhdGFzZXROYW1lXG4gICAqL1xuICByZWFkb25seSBkYXRhc2V0TmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogVVVJRCBvZiB0aGUgZGF0YXNldC4gVGhpcyBpcyB1bmlxdWUgaWRlbnRpZmllciBvZiBhIEZsb2NrZXIgZGF0YXNldFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5GbG9ja2VyVm9sdW1lU291cmNlI2RhdGFzZXRVVUlEXG4gICAqL1xuICByZWFkb25seSBkYXRhc2V0VXVpZD86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdGbG9ja2VyVm9sdW1lU291cmNlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9GbG9ja2VyVm9sdW1lU291cmNlKG9iajogRmxvY2tlclZvbHVtZVNvdXJjZSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2RhdGFzZXROYW1lJzogb2JqLmRhdGFzZXROYW1lLFxuICAgICdkYXRhc2V0VVVJRCc6IG9iai5kYXRhc2V0VXVpZCxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgUGVyc2lzdGVudCBEaXNrIHJlc291cmNlIGluIEdvb2dsZSBDb21wdXRlIEVuZ2luZS5cbiAqXG4gKiBBIEdDRSBQRCBtdXN0IGV4aXN0IGJlZm9yZSBtb3VudGluZyB0byBhIGNvbnRhaW5lci4gVGhlIGRpc2sgbXVzdCBhbHNvIGJlIGluIHRoZSBzYW1lIEdDRSBwcm9qZWN0IGFuZCB6b25lIGFzIHRoZSBrdWJlbGV0LiBBIEdDRSBQRCBjYW4gb25seSBiZSBtb3VudGVkIGFzIHJlYWQvd3JpdGUgb25jZSBvciByZWFkLW9ubHkgbWFueSB0aW1lcy4gR0NFIFBEcyBzdXBwb3J0IG93bmVyc2hpcCBtYW5hZ2VtZW50IGFuZCBTRUxpbnV4IHJlbGFiZWxpbmcuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuR0NFUGVyc2lzdGVudERpc2tWb2x1bWVTb3VyY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHY2VQZXJzaXN0ZW50RGlza1ZvbHVtZVNvdXJjZSB7XG4gIC8qKlxuICAgKiBGaWxlc3lzdGVtIHR5cGUgb2YgdGhlIHZvbHVtZSB0aGF0IHlvdSB3YW50IHRvIG1vdW50LiBUaXA6IEVuc3VyZSB0aGF0IHRoZSBmaWxlc3lzdGVtIHR5cGUgaXMgc3VwcG9ydGVkIGJ5IHRoZSBob3N0IG9wZXJhdGluZyBzeXN0ZW0uIEV4YW1wbGVzOiBcImV4dDRcIiwgXCJ4ZnNcIiwgXCJudGZzXCIuIEltcGxpY2l0bHkgaW5mZXJyZWQgdG8gYmUgXCJleHQ0XCIgaWYgdW5zcGVjaWZpZWQuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvc3RvcmFnZS92b2x1bWVzI2djZXBlcnNpc3RlbnRkaXNrXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkdDRVBlcnNpc3RlbnREaXNrVm9sdW1lU291cmNlI2ZzVHlwZVxuICAgKi9cbiAgcmVhZG9ubHkgZnNUeXBlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcGFydGl0aW9uIGluIHRoZSB2b2x1bWUgdGhhdCB5b3Ugd2FudCB0byBtb3VudC4gSWYgb21pdHRlZCwgdGhlIGRlZmF1bHQgaXMgdG8gbW91bnQgYnkgdm9sdW1lIG5hbWUuIEV4YW1wbGVzOiBGb3Igdm9sdW1lIC9kZXYvc2RhMSwgeW91IHNwZWNpZnkgdGhlIHBhcnRpdGlvbiBhcyBcIjFcIi4gU2ltaWxhcmx5LCB0aGUgdm9sdW1lIHBhcnRpdGlvbiBmb3IgL2Rldi9zZGEgaXMgXCIwXCIgKG9yIHlvdSBjYW4gbGVhdmUgdGhlIHByb3BlcnR5IGVtcHR5KS4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3ZvbHVtZXMjZ2NlcGVyc2lzdGVudGRpc2tcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuR0NFUGVyc2lzdGVudERpc2tWb2x1bWVTb3VyY2UjcGFydGl0aW9uXG4gICAqL1xuICByZWFkb25seSBwYXJ0aXRpb24/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFVuaXF1ZSBuYW1lIG9mIHRoZSBQRCByZXNvdXJjZSBpbiBHQ0UuIFVzZWQgdG8gaWRlbnRpZnkgdGhlIGRpc2sgaW4gR0NFLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2Uvdm9sdW1lcyNnY2VwZXJzaXN0ZW50ZGlza1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5HQ0VQZXJzaXN0ZW50RGlza1ZvbHVtZVNvdXJjZSNwZE5hbWVcbiAgICovXG4gIHJlYWRvbmx5IHBkTmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZWFkT25seSBoZXJlIHdpbGwgZm9yY2UgdGhlIFJlYWRPbmx5IHNldHRpbmcgaW4gVm9sdW1lTW91bnRzLiBEZWZhdWx0cyB0byBmYWxzZS4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3ZvbHVtZXMjZ2NlcGVyc2lzdGVudGRpc2tcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2UuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvc3RvcmFnZS92b2x1bWVzI2djZXBlcnNpc3RlbnRkaXNrXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkdDRVBlcnNpc3RlbnREaXNrVm9sdW1lU291cmNlI3JlYWRPbmx5XG4gICAqL1xuICByZWFkb25seSByZWFkT25seT86IGJvb2xlYW47XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnR2NlUGVyc2lzdGVudERpc2tWb2x1bWVTb3VyY2UnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0djZVBlcnNpc3RlbnREaXNrVm9sdW1lU291cmNlKG9iajogR2NlUGVyc2lzdGVudERpc2tWb2x1bWVTb3VyY2UgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdmc1R5cGUnOiBvYmouZnNUeXBlLFxuICAgICdwYXJ0aXRpb24nOiBvYmoucGFydGl0aW9uLFxuICAgICdwZE5hbWUnOiBvYmoucGROYW1lLFxuICAgICdyZWFkT25seSc6IG9iai5yZWFkT25seSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgR2x1c3RlcmZzIG1vdW50IHRoYXQgbGFzdHMgdGhlIGxpZmV0aW1lIG9mIGEgcG9kLiBHbHVzdGVyZnMgdm9sdW1lcyBkbyBub3Qgc3VwcG9ydCBvd25lcnNoaXAgbWFuYWdlbWVudCBvciBTRUxpbnV4IHJlbGFiZWxpbmcuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuR2x1c3RlcmZzUGVyc2lzdGVudFZvbHVtZVNvdXJjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdsdXN0ZXJmc1BlcnNpc3RlbnRWb2x1bWVTb3VyY2Uge1xuICAvKipcbiAgICogRW5kcG9pbnRzTmFtZSBpcyB0aGUgZW5kcG9pbnQgbmFtZSB0aGF0IGRldGFpbHMgR2x1c3RlcmZzIHRvcG9sb2d5LiBNb3JlIGluZm86IGh0dHBzOi8vZXhhbXBsZXMuazhzLmlvL3ZvbHVtZXMvZ2x1c3RlcmZzL1JFQURNRS5tZCNjcmVhdGUtYS1wb2RcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuR2x1c3RlcmZzUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNlbmRwb2ludHNcbiAgICovXG4gIHJlYWRvbmx5IGVuZHBvaW50czogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBFbmRwb2ludHNOYW1lc3BhY2UgaXMgdGhlIG5hbWVzcGFjZSB0aGF0IGNvbnRhaW5zIEdsdXN0ZXJmcyBlbmRwb2ludC4gSWYgdGhpcyBmaWVsZCBpcyBlbXB0eSwgdGhlIEVuZHBvaW50TmFtZXNwYWNlIGRlZmF1bHRzIHRvIHRoZSBzYW1lIG5hbWVzcGFjZSBhcyB0aGUgYm91bmQgUFZDLiBNb3JlIGluZm86IGh0dHBzOi8vZXhhbXBsZXMuazhzLmlvL3ZvbHVtZXMvZ2x1c3RlcmZzL1JFQURNRS5tZCNjcmVhdGUtYS1wb2RcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuR2x1c3RlcmZzUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNlbmRwb2ludHNOYW1lc3BhY2VcbiAgICovXG4gIHJlYWRvbmx5IGVuZHBvaW50c05hbWVzcGFjZT86IHN0cmluZztcblxuICAvKipcbiAgICogUGF0aCBpcyB0aGUgR2x1c3RlcmZzIHZvbHVtZSBwYXRoLiBNb3JlIGluZm86IGh0dHBzOi8vZXhhbXBsZXMuazhzLmlvL3ZvbHVtZXMvZ2x1c3RlcmZzL1JFQURNRS5tZCNjcmVhdGUtYS1wb2RcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuR2x1c3RlcmZzUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNwYXRoXG4gICAqL1xuICByZWFkb25seSBwYXRoOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFJlYWRPbmx5IGhlcmUgd2lsbCBmb3JjZSB0aGUgR2x1c3RlcmZzIHZvbHVtZSB0byBiZSBtb3VudGVkIHdpdGggcmVhZC1vbmx5IHBlcm1pc3Npb25zLiBEZWZhdWx0cyB0byBmYWxzZS4gTW9yZSBpbmZvOiBodHRwczovL2V4YW1wbGVzLms4cy5pby92b2x1bWVzL2dsdXN0ZXJmcy9SRUFETUUubWQjY3JlYXRlLWEtcG9kXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlLiBNb3JlIGluZm86IGh0dHBzOi8vZXhhbXBsZXMuazhzLmlvL3ZvbHVtZXMvZ2x1c3RlcmZzL1JFQURNRS5tZCNjcmVhdGUtYS1wb2RcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuR2x1c3RlcmZzUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNyZWFkT25seVxuICAgKi9cbiAgcmVhZG9ubHkgcmVhZE9ubHk/OiBib29sZWFuO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0dsdXN0ZXJmc1BlcnNpc3RlbnRWb2x1bWVTb3VyY2UnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0dsdXN0ZXJmc1BlcnNpc3RlbnRWb2x1bWVTb3VyY2Uob2JqOiBHbHVzdGVyZnNQZXJzaXN0ZW50Vm9sdW1lU291cmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZW5kcG9pbnRzJzogb2JqLmVuZHBvaW50cyxcbiAgICAnZW5kcG9pbnRzTmFtZXNwYWNlJzogb2JqLmVuZHBvaW50c05hbWVzcGFjZSxcbiAgICAncGF0aCc6IG9iai5wYXRoLFxuICAgICdyZWFkT25seSc6IG9iai5yZWFkT25seSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgaG9zdCBwYXRoIG1hcHBlZCBpbnRvIGEgcG9kLiBIb3N0IHBhdGggdm9sdW1lcyBkbyBub3Qgc3VwcG9ydCBvd25lcnNoaXAgbWFuYWdlbWVudCBvciBTRUxpbnV4IHJlbGFiZWxpbmcuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuSG9zdFBhdGhWb2x1bWVTb3VyY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIb3N0UGF0aFZvbHVtZVNvdXJjZSB7XG4gIC8qKlxuICAgKiBQYXRoIG9mIHRoZSBkaXJlY3Rvcnkgb24gdGhlIGhvc3QuIElmIHRoZSBwYXRoIGlzIGEgc3ltbGluaywgaXQgd2lsbCBmb2xsb3cgdGhlIGxpbmsgdG8gdGhlIHJlYWwgcGF0aC4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3ZvbHVtZXMjaG9zdHBhdGhcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuSG9zdFBhdGhWb2x1bWVTb3VyY2UjcGF0aFxuICAgKi9cbiAgcmVhZG9ubHkgcGF0aDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUeXBlIGZvciBIb3N0UGF0aCBWb2x1bWUgRGVmYXVsdHMgdG8gXCJcIiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2Uvdm9sdW1lcyNob3N0cGF0aFxuICAgKlxuICAgKiBAZGVmYXVsdCBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2Uvdm9sdW1lcyNob3N0cGF0aFxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Ib3N0UGF0aFZvbHVtZVNvdXJjZSN0eXBlXG4gICAqL1xuICByZWFkb25seSB0eXBlPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0hvc3RQYXRoVm9sdW1lU291cmNlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Ib3N0UGF0aFZvbHVtZVNvdXJjZShvYmo6IEhvc3RQYXRoVm9sdW1lU291cmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAncGF0aCc6IG9iai5wYXRoLFxuICAgICd0eXBlJzogb2JqLnR5cGUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogSVNDU0lQZXJzaXN0ZW50Vm9sdW1lU291cmNlIHJlcHJlc2VudHMgYW4gSVNDU0kgZGlzay4gSVNDU0kgdm9sdW1lcyBjYW4gb25seSBiZSBtb3VudGVkIGFzIHJlYWQvd3JpdGUgb25jZS4gSVNDU0kgdm9sdW1lcyBzdXBwb3J0IG93bmVyc2hpcCBtYW5hZ2VtZW50IGFuZCBTRUxpbnV4IHJlbGFiZWxpbmcuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuSVNDU0lQZXJzaXN0ZW50Vm9sdW1lU291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSXNjc2lQZXJzaXN0ZW50Vm9sdW1lU291cmNlIHtcbiAgLyoqXG4gICAqIHdoZXRoZXIgc3VwcG9ydCBpU0NTSSBEaXNjb3ZlcnkgQ0hBUCBhdXRoZW50aWNhdGlvblxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5JU0NTSVBlcnNpc3RlbnRWb2x1bWVTb3VyY2UjY2hhcEF1dGhEaXNjb3ZlcnlcbiAgICovXG4gIHJlYWRvbmx5IGNoYXBBdXRoRGlzY292ZXJ5PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogd2hldGhlciBzdXBwb3J0IGlTQ1NJIFNlc3Npb24gQ0hBUCBhdXRoZW50aWNhdGlvblxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5JU0NTSVBlcnNpc3RlbnRWb2x1bWVTb3VyY2UjY2hhcEF1dGhTZXNzaW9uXG4gICAqL1xuICByZWFkb25seSBjaGFwQXV0aFNlc3Npb24/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBGaWxlc3lzdGVtIHR5cGUgb2YgdGhlIHZvbHVtZSB0aGF0IHlvdSB3YW50IHRvIG1vdW50LiBUaXA6IEVuc3VyZSB0aGF0IHRoZSBmaWxlc3lzdGVtIHR5cGUgaXMgc3VwcG9ydGVkIGJ5IHRoZSBob3N0IG9wZXJhdGluZyBzeXN0ZW0uIEV4YW1wbGVzOiBcImV4dDRcIiwgXCJ4ZnNcIiwgXCJudGZzXCIuIEltcGxpY2l0bHkgaW5mZXJyZWQgdG8gYmUgXCJleHQ0XCIgaWYgdW5zcGVjaWZpZWQuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvc3RvcmFnZS92b2x1bWVzI2lzY3NpXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLklTQ1NJUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNmc1R5cGVcbiAgICovXG4gIHJlYWRvbmx5IGZzVHlwZT86IHN0cmluZztcblxuICAvKipcbiAgICogQ3VzdG9tIGlTQ1NJIEluaXRpYXRvciBOYW1lLiBJZiBpbml0aWF0b3JOYW1lIGlzIHNwZWNpZmllZCB3aXRoIGlzY3NpSW50ZXJmYWNlIHNpbXVsdGFuZW91c2x5LCBuZXcgaVNDU0kgaW50ZXJmYWNlIDx0YXJnZXQgcG9ydGFsPjo8dm9sdW1lIG5hbWU+IHdpbGwgYmUgY3JlYXRlZCBmb3IgdGhlIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLklTQ1NJUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNpbml0aWF0b3JOYW1lXG4gICAqL1xuICByZWFkb25seSBpbml0aWF0b3JOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUYXJnZXQgaVNDU0kgUXVhbGlmaWVkIE5hbWUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLklTQ1NJUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNpcW5cbiAgICovXG4gIHJlYWRvbmx5IGlxbjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBpU0NTSSBJbnRlcmZhY2UgTmFtZSB0aGF0IHVzZXMgYW4gaVNDU0kgdHJhbnNwb3J0LiBEZWZhdWx0cyB0byAnZGVmYXVsdCcgKHRjcCkuXG4gICAqXG4gICAqIEBkZWZhdWx0IGRlZmF1bHQnICh0Y3ApLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5JU0NTSVBlcnNpc3RlbnRWb2x1bWVTb3VyY2UjaXNjc2lJbnRlcmZhY2VcbiAgICovXG4gIHJlYWRvbmx5IGlzY3NpSW50ZXJmYWNlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBpU0NTSSBUYXJnZXQgTHVuIG51bWJlci5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuSVNDU0lQZXJzaXN0ZW50Vm9sdW1lU291cmNlI2x1blxuICAgKi9cbiAgcmVhZG9ubHkgbHVuOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIGlTQ1NJIFRhcmdldCBQb3J0YWwgTGlzdC4gVGhlIFBvcnRhbCBpcyBlaXRoZXIgYW4gSVAgb3IgaXBfYWRkcjpwb3J0IGlmIHRoZSBwb3J0IGlzIG90aGVyIHRoYW4gZGVmYXVsdCAodHlwaWNhbGx5IFRDUCBwb3J0cyA4NjAgYW5kIDMyNjApLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5JU0NTSVBlcnNpc3RlbnRWb2x1bWVTb3VyY2UjcG9ydGFsc1xuICAgKi9cbiAgcmVhZG9ubHkgcG9ydGFscz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBSZWFkT25seSBoZXJlIHdpbGwgZm9yY2UgdGhlIFJlYWRPbmx5IHNldHRpbmcgaW4gVm9sdW1lTW91bnRzLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2UuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLklTQ1NJUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNyZWFkT25seVxuICAgKi9cbiAgcmVhZG9ubHkgcmVhZE9ubHk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBDSEFQIFNlY3JldCBmb3IgaVNDU0kgdGFyZ2V0IGFuZCBpbml0aWF0b3IgYXV0aGVudGljYXRpb25cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuSVNDU0lQZXJzaXN0ZW50Vm9sdW1lU291cmNlI3NlY3JldFJlZlxuICAgKi9cbiAgcmVhZG9ubHkgc2VjcmV0UmVmPzogU2VjcmV0UmVmZXJlbmNlO1xuXG4gIC8qKlxuICAgKiBpU0NTSSBUYXJnZXQgUG9ydGFsLiBUaGUgUG9ydGFsIGlzIGVpdGhlciBhbiBJUCBvciBpcF9hZGRyOnBvcnQgaWYgdGhlIHBvcnQgaXMgb3RoZXIgdGhhbiBkZWZhdWx0ICh0eXBpY2FsbHkgVENQIHBvcnRzIDg2MCBhbmQgMzI2MCkuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLklTQ1NJUGVyc2lzdGVudFZvbHVtZVNvdXJjZSN0YXJnZXRQb3J0YWxcbiAgICovXG4gIHJlYWRvbmx5IHRhcmdldFBvcnRhbDogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0lzY3NpUGVyc2lzdGVudFZvbHVtZVNvdXJjZScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fSXNjc2lQZXJzaXN0ZW50Vm9sdW1lU291cmNlKG9iajogSXNjc2lQZXJzaXN0ZW50Vm9sdW1lU291cmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnY2hhcEF1dGhEaXNjb3ZlcnknOiBvYmouY2hhcEF1dGhEaXNjb3ZlcnksXG4gICAgJ2NoYXBBdXRoU2Vzc2lvbic6IG9iai5jaGFwQXV0aFNlc3Npb24sXG4gICAgJ2ZzVHlwZSc6IG9iai5mc1R5cGUsXG4gICAgJ2luaXRpYXRvck5hbWUnOiBvYmouaW5pdGlhdG9yTmFtZSxcbiAgICAnaXFuJzogb2JqLmlxbixcbiAgICAnaXNjc2lJbnRlcmZhY2UnOiBvYmouaXNjc2lJbnRlcmZhY2UsXG4gICAgJ2x1bic6IG9iai5sdW4sXG4gICAgJ3BvcnRhbHMnOiBvYmoucG9ydGFscz8ubWFwKHkgPT4geSksXG4gICAgJ3JlYWRPbmx5Jzogb2JqLnJlYWRPbmx5LFxuICAgICdzZWNyZXRSZWYnOiB0b0pzb25fU2VjcmV0UmVmZXJlbmNlKG9iai5zZWNyZXRSZWYpLFxuICAgICd0YXJnZXRQb3J0YWwnOiBvYmoudGFyZ2V0UG9ydGFsLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIExvY2FsIHJlcHJlc2VudHMgZGlyZWN0bHktYXR0YWNoZWQgc3RvcmFnZSB3aXRoIG5vZGUgYWZmaW5pdHkgKEJldGEgZmVhdHVyZSlcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Mb2NhbFZvbHVtZVNvdXJjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIExvY2FsVm9sdW1lU291cmNlIHtcbiAgLyoqXG4gICAqIEZpbGVzeXN0ZW0gdHlwZSB0byBtb3VudC4gSXQgYXBwbGllcyBvbmx5IHdoZW4gdGhlIFBhdGggaXMgYSBibG9jayBkZXZpY2UuIE11c3QgYmUgYSBmaWxlc3lzdGVtIHR5cGUgc3VwcG9ydGVkIGJ5IHRoZSBob3N0IG9wZXJhdGluZyBzeXN0ZW0uIEV4LiBcImV4dDRcIiwgXCJ4ZnNcIiwgXCJudGZzXCIuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRvIGF1dG8tc2VsZWN0IGEgZmlsZXlzdGVtIGlmIHVuc3BlY2lmaWVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Mb2NhbFZvbHVtZVNvdXJjZSNmc1R5cGVcbiAgICovXG4gIHJlYWRvbmx5IGZzVHlwZT86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGZ1bGwgcGF0aCB0byB0aGUgdm9sdW1lIG9uIHRoZSBub2RlLiBJdCBjYW4gYmUgZWl0aGVyIGEgZGlyZWN0b3J5IG9yIGJsb2NrIGRldmljZSAoZGlzaywgcGFydGl0aW9uLCAuLi4pLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Mb2NhbFZvbHVtZVNvdXJjZSNwYXRoXG4gICAqL1xuICByZWFkb25seSBwYXRoOiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnTG9jYWxWb2x1bWVTb3VyY2UnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0xvY2FsVm9sdW1lU291cmNlKG9iajogTG9jYWxWb2x1bWVTb3VyY2UgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdmc1R5cGUnOiBvYmouZnNUeXBlLFxuICAgICdwYXRoJzogb2JqLnBhdGgsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBORlMgbW91bnQgdGhhdCBsYXN0cyB0aGUgbGlmZXRpbWUgb2YgYSBwb2QuIE5GUyB2b2x1bWVzIGRvIG5vdCBzdXBwb3J0IG93bmVyc2hpcCBtYW5hZ2VtZW50IG9yIFNFTGludXggcmVsYWJlbGluZy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5ORlNWb2x1bWVTb3VyY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZnNWb2x1bWVTb3VyY2Uge1xuICAvKipcbiAgICogUGF0aCB0aGF0IGlzIGV4cG9ydGVkIGJ5IHRoZSBORlMgc2VydmVyLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2Uvdm9sdW1lcyNuZnNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTkZTVm9sdW1lU291cmNlI3BhdGhcbiAgICovXG4gIHJlYWRvbmx5IHBhdGg6IHN0cmluZztcblxuICAvKipcbiAgICogUmVhZE9ubHkgaGVyZSB3aWxsIGZvcmNlIHRoZSBORlMgZXhwb3J0IHRvIGJlIG1vdW50ZWQgd2l0aCByZWFkLW9ubHkgcGVybWlzc2lvbnMuIERlZmF1bHRzIHRvIGZhbHNlLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2Uvdm9sdW1lcyNuZnNcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2UuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvc3RvcmFnZS92b2x1bWVzI25mc1xuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5ORlNWb2x1bWVTb3VyY2UjcmVhZE9ubHlcbiAgICovXG4gIHJlYWRvbmx5IHJlYWRPbmx5PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogU2VydmVyIGlzIHRoZSBob3N0bmFtZSBvciBJUCBhZGRyZXNzIG9mIHRoZSBORlMgc2VydmVyLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2Uvdm9sdW1lcyNuZnNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTkZTVm9sdW1lU291cmNlI3NlcnZlclxuICAgKi9cbiAgcmVhZG9ubHkgc2VydmVyOiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnTmZzVm9sdW1lU291cmNlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9OZnNWb2x1bWVTb3VyY2Uob2JqOiBOZnNWb2x1bWVTb3VyY2UgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdwYXRoJzogb2JqLnBhdGgsXG4gICAgJ3JlYWRPbmx5Jzogb2JqLnJlYWRPbmx5LFxuICAgICdzZXJ2ZXInOiBvYmouc2VydmVyLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFZvbHVtZU5vZGVBZmZpbml0eSBkZWZpbmVzIGNvbnN0cmFpbnRzIHRoYXQgbGltaXQgd2hhdCBub2RlcyB0aGlzIHZvbHVtZSBjYW4gYmUgYWNjZXNzZWQgZnJvbS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Wb2x1bWVOb2RlQWZmaW5pdHlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWb2x1bWVOb2RlQWZmaW5pdHkge1xuICAvKipcbiAgICogUmVxdWlyZWQgc3BlY2lmaWVzIGhhcmQgbm9kZSBjb25zdHJhaW50cyB0aGF0IG11c3QgYmUgbWV0LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Wb2x1bWVOb2RlQWZmaW5pdHkjcmVxdWlyZWRcbiAgICovXG4gIHJlYWRvbmx5IHJlcXVpcmVkPzogTm9kZVNlbGVjdG9yO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1ZvbHVtZU5vZGVBZmZpbml0eScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fVm9sdW1lTm9kZUFmZmluaXR5KG9iajogVm9sdW1lTm9kZUFmZmluaXR5IHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAncmVxdWlyZWQnOiB0b0pzb25fTm9kZVNlbGVjdG9yKG9iai5yZXF1aXJlZCksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIFBob3RvbiBDb250cm9sbGVyIHBlcnNpc3RlbnQgZGlzayByZXNvdXJjZS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5QaG90b25QZXJzaXN0ZW50RGlza1ZvbHVtZVNvdXJjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBob3RvblBlcnNpc3RlbnREaXNrVm9sdW1lU291cmNlIHtcbiAgLyoqXG4gICAqIEZpbGVzeXN0ZW0gdHlwZSB0byBtb3VudC4gTXVzdCBiZSBhIGZpbGVzeXN0ZW0gdHlwZSBzdXBwb3J0ZWQgYnkgdGhlIGhvc3Qgb3BlcmF0aW5nIHN5c3RlbS4gRXguIFwiZXh0NFwiLCBcInhmc1wiLCBcIm50ZnNcIi4gSW1wbGljaXRseSBpbmZlcnJlZCB0byBiZSBcImV4dDRcIiBpZiB1bnNwZWNpZmllZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGhvdG9uUGVyc2lzdGVudERpc2tWb2x1bWVTb3VyY2UjZnNUeXBlXG4gICAqL1xuICByZWFkb25seSBmc1R5cGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIElEIHRoYXQgaWRlbnRpZmllcyBQaG90b24gQ29udHJvbGxlciBwZXJzaXN0ZW50IGRpc2tcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGhvdG9uUGVyc2lzdGVudERpc2tWb2x1bWVTb3VyY2UjcGRJRFxuICAgKi9cbiAgcmVhZG9ubHkgcGRJZDogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1Bob3RvblBlcnNpc3RlbnREaXNrVm9sdW1lU291cmNlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9QaG90b25QZXJzaXN0ZW50RGlza1ZvbHVtZVNvdXJjZShvYmo6IFBob3RvblBlcnNpc3RlbnREaXNrVm9sdW1lU291cmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZnNUeXBlJzogb2JqLmZzVHlwZSxcbiAgICAncGRJRCc6IG9iai5wZElkLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFBvcnR3b3J4Vm9sdW1lU291cmNlIHJlcHJlc2VudHMgYSBQb3J0d29yeCB2b2x1bWUgcmVzb3VyY2UuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9ydHdvcnhWb2x1bWVTb3VyY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQb3J0d29yeFZvbHVtZVNvdXJjZSB7XG4gIC8qKlxuICAgKiBGU1R5cGUgcmVwcmVzZW50cyB0aGUgZmlsZXN5c3RlbSB0eXBlIHRvIG1vdW50IE11c3QgYmUgYSBmaWxlc3lzdGVtIHR5cGUgc3VwcG9ydGVkIGJ5IHRoZSBob3N0IG9wZXJhdGluZyBzeXN0ZW0uIEV4LiBcImV4dDRcIiwgXCJ4ZnNcIi4gSW1wbGljaXRseSBpbmZlcnJlZCB0byBiZSBcImV4dDRcIiBpZiB1bnNwZWNpZmllZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9ydHdvcnhWb2x1bWVTb3VyY2UjZnNUeXBlXG4gICAqL1xuICByZWFkb25seSBmc1R5cGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIERlZmF1bHRzIHRvIGZhbHNlIChyZWFkL3dyaXRlKS4gUmVhZE9ubHkgaGVyZSB3aWxsIGZvcmNlIHRoZSBSZWFkT25seSBzZXR0aW5nIGluIFZvbHVtZU1vdW50cy5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2UgKHJlYWQvd3JpdGUpLiBSZWFkT25seSBoZXJlIHdpbGwgZm9yY2UgdGhlIFJlYWRPbmx5IHNldHRpbmcgaW4gVm9sdW1lTW91bnRzLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb3J0d29yeFZvbHVtZVNvdXJjZSNyZWFkT25seVxuICAgKi9cbiAgcmVhZG9ubHkgcmVhZE9ubHk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBWb2x1bWVJRCB1bmlxdWVseSBpZGVudGlmaWVzIGEgUG9ydHdvcnggdm9sdW1lXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvcnR3b3J4Vm9sdW1lU291cmNlI3ZvbHVtZUlEXG4gICAqL1xuICByZWFkb25seSB2b2x1bWVJZDogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1BvcnR3b3J4Vm9sdW1lU291cmNlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Qb3J0d29yeFZvbHVtZVNvdXJjZShvYmo6IFBvcnR3b3J4Vm9sdW1lU291cmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZnNUeXBlJzogb2JqLmZzVHlwZSxcbiAgICAncmVhZE9ubHknOiBvYmoucmVhZE9ubHksXG4gICAgJ3ZvbHVtZUlEJzogb2JqLnZvbHVtZUlkLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBRdW9ieXRlIG1vdW50IHRoYXQgbGFzdHMgdGhlIGxpZmV0aW1lIG9mIGEgcG9kLiBRdW9ieXRlIHZvbHVtZXMgZG8gbm90IHN1cHBvcnQgb3duZXJzaGlwIG1hbmFnZW1lbnQgb3IgU0VMaW51eCByZWxhYmVsaW5nLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlF1b2J5dGVWb2x1bWVTb3VyY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBRdW9ieXRlVm9sdW1lU291cmNlIHtcbiAgLyoqXG4gICAqIEdyb3VwIHRvIG1hcCB2b2x1bWUgYWNjZXNzIHRvIERlZmF1bHQgaXMgbm8gZ3JvdXBcbiAgICpcbiAgICogQGRlZmF1bHQgbm8gZ3JvdXBcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUXVvYnl0ZVZvbHVtZVNvdXJjZSNncm91cFxuICAgKi9cbiAgcmVhZG9ubHkgZ3JvdXA/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFJlYWRPbmx5IGhlcmUgd2lsbCBmb3JjZSB0aGUgUXVvYnl0ZSB2b2x1bWUgdG8gYmUgbW91bnRlZCB3aXRoIHJlYWQtb25seSBwZXJtaXNzaW9ucy4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5RdW9ieXRlVm9sdW1lU291cmNlI3JlYWRPbmx5XG4gICAqL1xuICByZWFkb25seSByZWFkT25seT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFJlZ2lzdHJ5IHJlcHJlc2VudHMgYSBzaW5nbGUgb3IgbXVsdGlwbGUgUXVvYnl0ZSBSZWdpc3RyeSBzZXJ2aWNlcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgYXMgaG9zdDpwb3J0IHBhaXIgKG11bHRpcGxlIGVudHJpZXMgYXJlIHNlcGFyYXRlZCB3aXRoIGNvbW1hcykgd2hpY2ggYWN0cyBhcyB0aGUgY2VudHJhbCByZWdpc3RyeSBmb3Igdm9sdW1lc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5RdW9ieXRlVm9sdW1lU291cmNlI3JlZ2lzdHJ5XG4gICAqL1xuICByZWFkb25seSByZWdpc3RyeTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUZW5hbnQgb3duaW5nIHRoZSBnaXZlbiBRdW9ieXRlIHZvbHVtZSBpbiB0aGUgQmFja2VuZCBVc2VkIHdpdGggZHluYW1pY2FsbHkgcHJvdmlzaW9uZWQgUXVvYnl0ZSB2b2x1bWVzLCB2YWx1ZSBpcyBzZXQgYnkgdGhlIHBsdWdpblxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5RdW9ieXRlVm9sdW1lU291cmNlI3RlbmFudFxuICAgKi9cbiAgcmVhZG9ubHkgdGVuYW50Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBVc2VyIHRvIG1hcCB2b2x1bWUgYWNjZXNzIHRvIERlZmF1bHRzIHRvIHNlcml2Y2VhY2NvdW50IHVzZXJcbiAgICpcbiAgICogQGRlZmF1bHQgc2VyaXZjZWFjY291bnQgdXNlclxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5RdW9ieXRlVm9sdW1lU291cmNlI3VzZXJcbiAgICovXG4gIHJlYWRvbmx5IHVzZXI/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFZvbHVtZSBpcyBhIHN0cmluZyB0aGF0IHJlZmVyZW5jZXMgYW4gYWxyZWFkeSBjcmVhdGVkIFF1b2J5dGUgdm9sdW1lIGJ5IG5hbWUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlF1b2J5dGVWb2x1bWVTb3VyY2Ujdm9sdW1lXG4gICAqL1xuICByZWFkb25seSB2b2x1bWU6IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdRdW9ieXRlVm9sdW1lU291cmNlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9RdW9ieXRlVm9sdW1lU291cmNlKG9iajogUXVvYnl0ZVZvbHVtZVNvdXJjZSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2dyb3VwJzogb2JqLmdyb3VwLFxuICAgICdyZWFkT25seSc6IG9iai5yZWFkT25seSxcbiAgICAncmVnaXN0cnknOiBvYmoucmVnaXN0cnksXG4gICAgJ3RlbmFudCc6IG9iai50ZW5hbnQsXG4gICAgJ3VzZXInOiBvYmoudXNlcixcbiAgICAndm9sdW1lJzogb2JqLnZvbHVtZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgUmFkb3MgQmxvY2sgRGV2aWNlIG1vdW50IHRoYXQgbGFzdHMgdGhlIGxpZmV0aW1lIG9mIGEgcG9kLiBSQkQgdm9sdW1lcyBzdXBwb3J0IG93bmVyc2hpcCBtYW5hZ2VtZW50IGFuZCBTRUxpbnV4IHJlbGFiZWxpbmcuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUkJEUGVyc2lzdGVudFZvbHVtZVNvdXJjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJiZFBlcnNpc3RlbnRWb2x1bWVTb3VyY2Uge1xuICAvKipcbiAgICogRmlsZXN5c3RlbSB0eXBlIG9mIHRoZSB2b2x1bWUgdGhhdCB5b3Ugd2FudCB0byBtb3VudC4gVGlwOiBFbnN1cmUgdGhhdCB0aGUgZmlsZXN5c3RlbSB0eXBlIGlzIHN1cHBvcnRlZCBieSB0aGUgaG9zdCBvcGVyYXRpbmcgc3lzdGVtLiBFeGFtcGxlczogXCJleHQ0XCIsIFwieGZzXCIsIFwibnRmc1wiLiBJbXBsaWNpdGx5IGluZmVycmVkIHRvIGJlIFwiZXh0NFwiIGlmIHVuc3BlY2lmaWVkLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2Uvdm9sdW1lcyNyYmRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUkJEUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNmc1R5cGVcbiAgICovXG4gIHJlYWRvbmx5IGZzVHlwZT86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHJhZG9zIGltYWdlIG5hbWUuIE1vcmUgaW5mbzogaHR0cHM6Ly9leGFtcGxlcy5rOHMuaW8vdm9sdW1lcy9yYmQvUkVBRE1FLm1kI2hvdy10by11c2UtaXRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUkJEUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNpbWFnZVxuICAgKi9cbiAgcmVhZG9ubHkgaW1hZ2U6IHN0cmluZztcblxuICAvKipcbiAgICogS2V5cmluZyBpcyB0aGUgcGF0aCB0byBrZXkgcmluZyBmb3IgUkJEVXNlci4gRGVmYXVsdCBpcyAvZXRjL2NlcGgva2V5cmluZy4gTW9yZSBpbmZvOiBodHRwczovL2V4YW1wbGVzLms4cy5pby92b2x1bWVzL3JiZC9SRUFETUUubWQjaG93LXRvLXVzZS1pdFxuICAgKlxuICAgKiBAZGVmYXVsdCBldGMvY2VwaC9rZXlyaW5nLiBNb3JlIGluZm86IGh0dHBzOi8vZXhhbXBsZXMuazhzLmlvL3ZvbHVtZXMvcmJkL1JFQURNRS5tZCNob3ctdG8tdXNlLWl0XG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlJCRFBlcnNpc3RlbnRWb2x1bWVTb3VyY2Uja2V5cmluZ1xuICAgKi9cbiAgcmVhZG9ubHkga2V5cmluZz86IHN0cmluZztcblxuICAvKipcbiAgICogQSBjb2xsZWN0aW9uIG9mIENlcGggbW9uaXRvcnMuIE1vcmUgaW5mbzogaHR0cHM6Ly9leGFtcGxlcy5rOHMuaW8vdm9sdW1lcy9yYmQvUkVBRE1FLm1kI2hvdy10by11c2UtaXRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUkJEUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNtb25pdG9yc1xuICAgKi9cbiAgcmVhZG9ubHkgbW9uaXRvcnM6IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBUaGUgcmFkb3MgcG9vbCBuYW1lLiBEZWZhdWx0IGlzIHJiZC4gTW9yZSBpbmZvOiBodHRwczovL2V4YW1wbGVzLms4cy5pby92b2x1bWVzL3JiZC9SRUFETUUubWQjaG93LXRvLXVzZS1pdFxuICAgKlxuICAgKiBAZGVmYXVsdCByYmQuIE1vcmUgaW5mbzogaHR0cHM6Ly9leGFtcGxlcy5rOHMuaW8vdm9sdW1lcy9yYmQvUkVBRE1FLm1kI2hvdy10by11c2UtaXRcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUkJEUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNwb29sXG4gICAqL1xuICByZWFkb25seSBwb29sPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZWFkT25seSBoZXJlIHdpbGwgZm9yY2UgdGhlIFJlYWRPbmx5IHNldHRpbmcgaW4gVm9sdW1lTW91bnRzLiBEZWZhdWx0cyB0byBmYWxzZS4gTW9yZSBpbmZvOiBodHRwczovL2V4YW1wbGVzLms4cy5pby92b2x1bWVzL3JiZC9SRUFETUUubWQjaG93LXRvLXVzZS1pdFxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZS4gTW9yZSBpbmZvOiBodHRwczovL2V4YW1wbGVzLms4cy5pby92b2x1bWVzL3JiZC9SRUFETUUubWQjaG93LXRvLXVzZS1pdFxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5SQkRQZXJzaXN0ZW50Vm9sdW1lU291cmNlI3JlYWRPbmx5XG4gICAqL1xuICByZWFkb25seSByZWFkT25seT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFNlY3JldFJlZiBpcyBuYW1lIG9mIHRoZSBhdXRoZW50aWNhdGlvbiBzZWNyZXQgZm9yIFJCRFVzZXIuIElmIHByb3ZpZGVkIG92ZXJyaWRlcyBrZXlyaW5nLiBEZWZhdWx0IGlzIG5pbC4gTW9yZSBpbmZvOiBodHRwczovL2V4YW1wbGVzLms4cy5pby92b2x1bWVzL3JiZC9SRUFETUUubWQjaG93LXRvLXVzZS1pdFxuICAgKlxuICAgKiBAZGVmYXVsdCBuaWwuIE1vcmUgaW5mbzogaHR0cHM6Ly9leGFtcGxlcy5rOHMuaW8vdm9sdW1lcy9yYmQvUkVBRE1FLm1kI2hvdy10by11c2UtaXRcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUkJEUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNzZWNyZXRSZWZcbiAgICovXG4gIHJlYWRvbmx5IHNlY3JldFJlZj86IFNlY3JldFJlZmVyZW5jZTtcblxuICAvKipcbiAgICogVGhlIHJhZG9zIHVzZXIgbmFtZS4gRGVmYXVsdCBpcyBhZG1pbi4gTW9yZSBpbmZvOiBodHRwczovL2V4YW1wbGVzLms4cy5pby92b2x1bWVzL3JiZC9SRUFETUUubWQjaG93LXRvLXVzZS1pdFxuICAgKlxuICAgKiBAZGVmYXVsdCBhZG1pbi4gTW9yZSBpbmZvOiBodHRwczovL2V4YW1wbGVzLms4cy5pby92b2x1bWVzL3JiZC9SRUFETUUubWQjaG93LXRvLXVzZS1pdFxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5SQkRQZXJzaXN0ZW50Vm9sdW1lU291cmNlI3VzZXJcbiAgICovXG4gIHJlYWRvbmx5IHVzZXI/OiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnUmJkUGVyc2lzdGVudFZvbHVtZVNvdXJjZScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fUmJkUGVyc2lzdGVudFZvbHVtZVNvdXJjZShvYmo6IFJiZFBlcnNpc3RlbnRWb2x1bWVTb3VyY2UgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdmc1R5cGUnOiBvYmouZnNUeXBlLFxuICAgICdpbWFnZSc6IG9iai5pbWFnZSxcbiAgICAna2V5cmluZyc6IG9iai5rZXlyaW5nLFxuICAgICdtb25pdG9ycyc6IG9iai5tb25pdG9ycz8ubWFwKHkgPT4geSksXG4gICAgJ3Bvb2wnOiBvYmoucG9vbCxcbiAgICAncmVhZE9ubHknOiBvYmoucmVhZE9ubHksXG4gICAgJ3NlY3JldFJlZic6IHRvSnNvbl9TZWNyZXRSZWZlcmVuY2Uob2JqLnNlY3JldFJlZiksXG4gICAgJ3VzZXInOiBvYmoudXNlcixcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBTY2FsZUlPUGVyc2lzdGVudFZvbHVtZVNvdXJjZSByZXByZXNlbnRzIGEgcGVyc2lzdGVudCBTY2FsZUlPIHZvbHVtZVxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNjYWxlSU9QZXJzaXN0ZW50Vm9sdW1lU291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2NhbGVJb1BlcnNpc3RlbnRWb2x1bWVTb3VyY2Uge1xuICAvKipcbiAgICogRmlsZXN5c3RlbSB0eXBlIHRvIG1vdW50LiBNdXN0IGJlIGEgZmlsZXN5c3RlbSB0eXBlIHN1cHBvcnRlZCBieSB0aGUgaG9zdCBvcGVyYXRpbmcgc3lzdGVtLiBFeC4gXCJleHQ0XCIsIFwieGZzXCIsIFwibnRmc1wiLiBEZWZhdWx0IGlzIFwieGZzXCJcbiAgICpcbiAgICogQGRlZmF1bHQgeGZzXCJcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2NhbGVJT1BlcnNpc3RlbnRWb2x1bWVTb3VyY2UjZnNUeXBlXG4gICAqL1xuICByZWFkb25seSBmc1R5cGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBob3N0IGFkZHJlc3Mgb2YgdGhlIFNjYWxlSU8gQVBJIEdhdGV3YXkuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNjYWxlSU9QZXJzaXN0ZW50Vm9sdW1lU291cmNlI2dhdGV3YXlcbiAgICovXG4gIHJlYWRvbmx5IGdhdGV3YXk6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIFNjYWxlSU8gUHJvdGVjdGlvbiBEb21haW4gZm9yIHRoZSBjb25maWd1cmVkIHN0b3JhZ2UuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNjYWxlSU9QZXJzaXN0ZW50Vm9sdW1lU291cmNlI3Byb3RlY3Rpb25Eb21haW5cbiAgICovXG4gIHJlYWRvbmx5IHByb3RlY3Rpb25Eb21haW4/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIERlZmF1bHRzIHRvIGZhbHNlIChyZWFkL3dyaXRlKS4gUmVhZE9ubHkgaGVyZSB3aWxsIGZvcmNlIHRoZSBSZWFkT25seSBzZXR0aW5nIGluIFZvbHVtZU1vdW50cy5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2UgKHJlYWQvd3JpdGUpLiBSZWFkT25seSBoZXJlIHdpbGwgZm9yY2UgdGhlIFJlYWRPbmx5IHNldHRpbmcgaW4gVm9sdW1lTW91bnRzLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TY2FsZUlPUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNyZWFkT25seVxuICAgKi9cbiAgcmVhZG9ubHkgcmVhZE9ubHk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBTZWNyZXRSZWYgcmVmZXJlbmNlcyB0byB0aGUgc2VjcmV0IGZvciBTY2FsZUlPIHVzZXIgYW5kIG90aGVyIHNlbnNpdGl2ZSBpbmZvcm1hdGlvbi4gSWYgdGhpcyBpcyBub3QgcHJvdmlkZWQsIExvZ2luIG9wZXJhdGlvbiB3aWxsIGZhaWwuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNjYWxlSU9QZXJzaXN0ZW50Vm9sdW1lU291cmNlI3NlY3JldFJlZlxuICAgKi9cbiAgcmVhZG9ubHkgc2VjcmV0UmVmOiBTZWNyZXRSZWZlcmVuY2U7XG5cbiAgLyoqXG4gICAqIEZsYWcgdG8gZW5hYmxlL2Rpc2FibGUgU1NMIGNvbW11bmljYXRpb24gd2l0aCBHYXRld2F5LCBkZWZhdWx0IGZhbHNlXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNjYWxlSU9QZXJzaXN0ZW50Vm9sdW1lU291cmNlI3NzbEVuYWJsZWRcbiAgICovXG4gIHJlYWRvbmx5IHNzbEVuYWJsZWQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3RvcmFnZSBmb3IgYSB2b2x1bWUgc2hvdWxkIGJlIFRoaWNrUHJvdmlzaW9uZWQgb3IgVGhpblByb3Zpc2lvbmVkLiBEZWZhdWx0IGlzIFRoaW5Qcm92aXNpb25lZC5cbiAgICpcbiAgICogQGRlZmF1bHQgVGhpblByb3Zpc2lvbmVkLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TY2FsZUlPUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNzdG9yYWdlTW9kZVxuICAgKi9cbiAgcmVhZG9ubHkgc3RvcmFnZU1vZGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBTY2FsZUlPIFN0b3JhZ2UgUG9vbCBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3RlY3Rpb24gZG9tYWluLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TY2FsZUlPUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNzdG9yYWdlUG9vbFxuICAgKi9cbiAgcmVhZG9ubHkgc3RvcmFnZVBvb2w/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBzdG9yYWdlIHN5c3RlbSBhcyBjb25maWd1cmVkIGluIFNjYWxlSU8uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNjYWxlSU9QZXJzaXN0ZW50Vm9sdW1lU291cmNlI3N5c3RlbVxuICAgKi9cbiAgcmVhZG9ubHkgc3lzdGVtOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIGEgdm9sdW1lIGFscmVhZHkgY3JlYXRlZCBpbiB0aGUgU2NhbGVJTyBzeXN0ZW0gdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggdGhpcyB2b2x1bWUgc291cmNlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TY2FsZUlPUGVyc2lzdGVudFZvbHVtZVNvdXJjZSN2b2x1bWVOYW1lXG4gICAqL1xuICByZWFkb25seSB2b2x1bWVOYW1lPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1NjYWxlSW9QZXJzaXN0ZW50Vm9sdW1lU291cmNlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9TY2FsZUlvUGVyc2lzdGVudFZvbHVtZVNvdXJjZShvYmo6IFNjYWxlSW9QZXJzaXN0ZW50Vm9sdW1lU291cmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZnNUeXBlJzogb2JqLmZzVHlwZSxcbiAgICAnZ2F0ZXdheSc6IG9iai5nYXRld2F5LFxuICAgICdwcm90ZWN0aW9uRG9tYWluJzogb2JqLnByb3RlY3Rpb25Eb21haW4sXG4gICAgJ3JlYWRPbmx5Jzogb2JqLnJlYWRPbmx5LFxuICAgICdzZWNyZXRSZWYnOiB0b0pzb25fU2VjcmV0UmVmZXJlbmNlKG9iai5zZWNyZXRSZWYpLFxuICAgICdzc2xFbmFibGVkJzogb2JqLnNzbEVuYWJsZWQsXG4gICAgJ3N0b3JhZ2VNb2RlJzogb2JqLnN0b3JhZ2VNb2RlLFxuICAgICdzdG9yYWdlUG9vbCc6IG9iai5zdG9yYWdlUG9vbCxcbiAgICAnc3lzdGVtJzogb2JqLnN5c3RlbSxcbiAgICAndm9sdW1lTmFtZSc6IG9iai52b2x1bWVOYW1lLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBTdG9yYWdlT1MgcGVyc2lzdGVudCB2b2x1bWUgcmVzb3VyY2UuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU3RvcmFnZU9TUGVyc2lzdGVudFZvbHVtZVNvdXJjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0b3JhZ2VPc1BlcnNpc3RlbnRWb2x1bWVTb3VyY2Uge1xuICAvKipcbiAgICogRmlsZXN5c3RlbSB0eXBlIHRvIG1vdW50LiBNdXN0IGJlIGEgZmlsZXN5c3RlbSB0eXBlIHN1cHBvcnRlZCBieSB0aGUgaG9zdCBvcGVyYXRpbmcgc3lzdGVtLiBFeC4gXCJleHQ0XCIsIFwieGZzXCIsIFwibnRmc1wiLiBJbXBsaWNpdGx5IGluZmVycmVkIHRvIGJlIFwiZXh0NFwiIGlmIHVuc3BlY2lmaWVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TdG9yYWdlT1NQZXJzaXN0ZW50Vm9sdW1lU291cmNlI2ZzVHlwZVxuICAgKi9cbiAgcmVhZG9ubHkgZnNUeXBlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0cyB0byBmYWxzZSAocmVhZC93cml0ZSkuIFJlYWRPbmx5IGhlcmUgd2lsbCBmb3JjZSB0aGUgUmVhZE9ubHkgc2V0dGluZyBpbiBWb2x1bWVNb3VudHMuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlIChyZWFkL3dyaXRlKS4gUmVhZE9ubHkgaGVyZSB3aWxsIGZvcmNlIHRoZSBSZWFkT25seSBzZXR0aW5nIGluIFZvbHVtZU1vdW50cy5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU3RvcmFnZU9TUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNyZWFkT25seVxuICAgKi9cbiAgcmVhZG9ubHkgcmVhZE9ubHk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBTZWNyZXRSZWYgc3BlY2lmaWVzIHRoZSBzZWNyZXQgdG8gdXNlIGZvciBvYnRhaW5pbmcgdGhlIFN0b3JhZ2VPUyBBUEkgY3JlZGVudGlhbHMuICBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0IHZhbHVlcyB3aWxsIGJlIGF0dGVtcHRlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU3RvcmFnZU9TUGVyc2lzdGVudFZvbHVtZVNvdXJjZSNzZWNyZXRSZWZcbiAgICovXG4gIHJlYWRvbmx5IHNlY3JldFJlZj86IE9iamVjdFJlZmVyZW5jZTtcblxuICAvKipcbiAgICogVm9sdW1lTmFtZSBpcyB0aGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgU3RvcmFnZU9TIHZvbHVtZS4gIFZvbHVtZSBuYW1lcyBhcmUgb25seSB1bmlxdWUgd2l0aGluIGEgbmFtZXNwYWNlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TdG9yYWdlT1NQZXJzaXN0ZW50Vm9sdW1lU291cmNlI3ZvbHVtZU5hbWVcbiAgICovXG4gIHJlYWRvbmx5IHZvbHVtZU5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFZvbHVtZU5hbWVzcGFjZSBzcGVjaWZpZXMgdGhlIHNjb3BlIG9mIHRoZSB2b2x1bWUgd2l0aGluIFN0b3JhZ2VPUy4gIElmIG5vIG5hbWVzcGFjZSBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgUG9kJ3MgbmFtZXNwYWNlIHdpbGwgYmUgdXNlZC4gIFRoaXMgYWxsb3dzIHRoZSBLdWJlcm5ldGVzIG5hbWUgc2NvcGluZyB0byBiZSBtaXJyb3JlZCB3aXRoaW4gU3RvcmFnZU9TIGZvciB0aWdodGVyIGludGVncmF0aW9uLiBTZXQgVm9sdW1lTmFtZSB0byBhbnkgbmFtZSB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvdXIuIFNldCB0byBcImRlZmF1bHRcIiBpZiB5b3UgYXJlIG5vdCB1c2luZyBuYW1lc3BhY2VzIHdpdGhpbiBTdG9yYWdlT1MuIE5hbWVzcGFjZXMgdGhhdCBkbyBub3QgcHJlLWV4aXN0IHdpdGhpbiBTdG9yYWdlT1Mgd2lsbCBiZSBjcmVhdGVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TdG9yYWdlT1NQZXJzaXN0ZW50Vm9sdW1lU291cmNlI3ZvbHVtZU5hbWVzcGFjZVxuICAgKi9cbiAgcmVhZG9ubHkgdm9sdW1lTmFtZXNwYWNlPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1N0b3JhZ2VPc1BlcnNpc3RlbnRWb2x1bWVTb3VyY2UnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1N0b3JhZ2VPc1BlcnNpc3RlbnRWb2x1bWVTb3VyY2Uob2JqOiBTdG9yYWdlT3NQZXJzaXN0ZW50Vm9sdW1lU291cmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZnNUeXBlJzogb2JqLmZzVHlwZSxcbiAgICAncmVhZE9ubHknOiBvYmoucmVhZE9ubHksXG4gICAgJ3NlY3JldFJlZic6IHRvSnNvbl9PYmplY3RSZWZlcmVuY2Uob2JqLnNlY3JldFJlZiksXG4gICAgJ3ZvbHVtZU5hbWUnOiBvYmoudm9sdW1lTmFtZSxcbiAgICAndm9sdW1lTmFtZXNwYWNlJzogb2JqLnZvbHVtZU5hbWVzcGFjZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdlNwaGVyZSB2b2x1bWUgcmVzb3VyY2UuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVnNwaGVyZVZpcnR1YWxEaXNrVm9sdW1lU291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVnNwaGVyZVZpcnR1YWxEaXNrVm9sdW1lU291cmNlIHtcbiAgLyoqXG4gICAqIEZpbGVzeXN0ZW0gdHlwZSB0byBtb3VudC4gTXVzdCBiZSBhIGZpbGVzeXN0ZW0gdHlwZSBzdXBwb3J0ZWQgYnkgdGhlIGhvc3Qgb3BlcmF0aW5nIHN5c3RlbS4gRXguIFwiZXh0NFwiLCBcInhmc1wiLCBcIm50ZnNcIi4gSW1wbGljaXRseSBpbmZlcnJlZCB0byBiZSBcImV4dDRcIiBpZiB1bnNwZWNpZmllZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVnNwaGVyZVZpcnR1YWxEaXNrVm9sdW1lU291cmNlI2ZzVHlwZVxuICAgKi9cbiAgcmVhZG9ubHkgZnNUeXBlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTdG9yYWdlIFBvbGljeSBCYXNlZCBNYW5hZ2VtZW50IChTUEJNKSBwcm9maWxlIElEIGFzc29jaWF0ZWQgd2l0aCB0aGUgU3RvcmFnZVBvbGljeU5hbWUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlZzcGhlcmVWaXJ0dWFsRGlza1ZvbHVtZVNvdXJjZSNzdG9yYWdlUG9saWN5SURcbiAgICovXG4gIHJlYWRvbmx5IHN0b3JhZ2VQb2xpY3lJZD86IHN0cmluZztcblxuICAvKipcbiAgICogU3RvcmFnZSBQb2xpY3kgQmFzZWQgTWFuYWdlbWVudCAoU1BCTSkgcHJvZmlsZSBuYW1lLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Wc3BoZXJlVmlydHVhbERpc2tWb2x1bWVTb3VyY2Ujc3RvcmFnZVBvbGljeU5hbWVcbiAgICovXG4gIHJlYWRvbmx5IHN0b3JhZ2VQb2xpY3lOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBQYXRoIHRoYXQgaWRlbnRpZmllcyB2U3BoZXJlIHZvbHVtZSB2bWRrXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlZzcGhlcmVWaXJ0dWFsRGlza1ZvbHVtZVNvdXJjZSN2b2x1bWVQYXRoXG4gICAqL1xuICByZWFkb25seSB2b2x1bWVQYXRoOiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnVnNwaGVyZVZpcnR1YWxEaXNrVm9sdW1lU291cmNlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Wc3BoZXJlVmlydHVhbERpc2tWb2x1bWVTb3VyY2Uob2JqOiBWc3BoZXJlVmlydHVhbERpc2tWb2x1bWVTb3VyY2UgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdmc1R5cGUnOiBvYmouZnNUeXBlLFxuICAgICdzdG9yYWdlUG9saWN5SUQnOiBvYmouc3RvcmFnZVBvbGljeUlkLFxuICAgICdzdG9yYWdlUG9saWN5TmFtZSc6IG9iai5zdG9yYWdlUG9saWN5TmFtZSxcbiAgICAndm9sdW1lUGF0aCc6IG9iai52b2x1bWVQYXRoLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFR5cGVkTG9jYWxPYmplY3RSZWZlcmVuY2UgY29udGFpbnMgZW5vdWdoIGluZm9ybWF0aW9uIHRvIGxldCB5b3UgbG9jYXRlIHRoZSB0eXBlZCByZWZlcmVuY2VkIG9iamVjdCBpbnNpZGUgdGhlIHNhbWUgbmFtZXNwYWNlLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlR5cGVkTG9jYWxPYmplY3RSZWZlcmVuY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUeXBlZExvY2FsT2JqZWN0UmVmZXJlbmNlIHtcbiAgLyoqXG4gICAqIEFQSUdyb3VwIGlzIHRoZSBncm91cCBmb3IgdGhlIHJlc291cmNlIGJlaW5nIHJlZmVyZW5jZWQuIElmIEFQSUdyb3VwIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBzcGVjaWZpZWQgS2luZCBtdXN0IGJlIGluIHRoZSBjb3JlIEFQSSBncm91cC4gRm9yIGFueSBvdGhlciB0aGlyZC1wYXJ0eSB0eXBlcywgQVBJR3JvdXAgaXMgcmVxdWlyZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlR5cGVkTG9jYWxPYmplY3RSZWZlcmVuY2UjYXBpR3JvdXBcbiAgICovXG4gIHJlYWRvbmx5IGFwaUdyb3VwPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBLaW5kIGlzIHRoZSB0eXBlIG9mIHJlc291cmNlIGJlaW5nIHJlZmVyZW5jZWRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVHlwZWRMb2NhbE9iamVjdFJlZmVyZW5jZSNraW5kXG4gICAqL1xuICByZWFkb25seSBraW5kOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE5hbWUgaXMgdGhlIG5hbWUgb2YgcmVzb3VyY2UgYmVpbmcgcmVmZXJlbmNlZFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5UeXBlZExvY2FsT2JqZWN0UmVmZXJlbmNlI25hbWVcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdUeXBlZExvY2FsT2JqZWN0UmVmZXJlbmNlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9UeXBlZExvY2FsT2JqZWN0UmVmZXJlbmNlKG9iajogVHlwZWRMb2NhbE9iamVjdFJlZmVyZW5jZSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2FwaUdyb3VwJzogb2JqLmFwaUdyb3VwLFxuICAgICdraW5kJzogb2JqLmtpbmQsXG4gICAgJ25hbWUnOiBvYmoubmFtZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBSZXNvdXJjZVJlcXVpcmVtZW50cyBkZXNjcmliZXMgdGhlIGNvbXB1dGUgcmVzb3VyY2UgcmVxdWlyZW1lbnRzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlJlc291cmNlUmVxdWlyZW1lbnRzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb3VyY2VSZXF1aXJlbWVudHMge1xuICAvKipcbiAgICogTGltaXRzIGRlc2NyaWJlcyB0aGUgbWF4aW11bSBhbW91bnQgb2YgY29tcHV0ZSByZXNvdXJjZXMgYWxsb3dlZC4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9jb25maWd1cmF0aW9uL21hbmFnZS1yZXNvdXJjZXMtY29udGFpbmVycy9cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUmVzb3VyY2VSZXF1aXJlbWVudHMjbGltaXRzXG4gICAqL1xuICByZWFkb25seSBsaW1pdHM/OiB7IFtrZXk6IHN0cmluZ106IFF1YW50aXR5IH07XG5cbiAgLyoqXG4gICAqIFJlcXVlc3RzIGRlc2NyaWJlcyB0aGUgbWluaW11bSBhbW91bnQgb2YgY29tcHV0ZSByZXNvdXJjZXMgcmVxdWlyZWQuIElmIFJlcXVlc3RzIGlzIG9taXR0ZWQgZm9yIGEgY29udGFpbmVyLCBpdCBkZWZhdWx0cyB0byBMaW1pdHMgaWYgdGhhdCBpcyBleHBsaWNpdGx5IHNwZWNpZmllZCwgb3RoZXJ3aXNlIHRvIGFuIGltcGxlbWVudGF0aW9uLWRlZmluZWQgdmFsdWUuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvY29uZmlndXJhdGlvbi9tYW5hZ2UtcmVzb3VyY2VzLWNvbnRhaW5lcnMvXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlJlc291cmNlUmVxdWlyZW1lbnRzI3JlcXVlc3RzXG4gICAqL1xuICByZWFkb25seSByZXF1ZXN0cz86IHsgW2tleTogc3RyaW5nXTogUXVhbnRpdHkgfTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdSZXNvdXJjZVJlcXVpcmVtZW50cycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fUmVzb3VyY2VSZXF1aXJlbWVudHMob2JqOiBSZXNvdXJjZVJlcXVpcmVtZW50cyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2xpbWl0cyc6ICgob2JqLmxpbWl0cykgPT09IHVuZGVmaW5lZCkgPyB1bmRlZmluZWQgOiAoT2JqZWN0LmVudHJpZXMob2JqLmxpbWl0cykucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0/LnZhbHVlIH0pLCB7fSkpLFxuICAgICdyZXF1ZXN0cyc6ICgob2JqLnJlcXVlc3RzKSA9PT0gdW5kZWZpbmVkKSA/IHVuZGVmaW5lZCA6IChPYmplY3QuZW50cmllcyhvYmoucmVxdWVzdHMpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdPy52YWx1ZSB9KSwge30pKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBBZmZpbml0eSBpcyBhIGdyb3VwIG9mIGFmZmluaXR5IHNjaGVkdWxpbmcgcnVsZXMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQWZmaW5pdHlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBZmZpbml0eSB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgbm9kZSBhZmZpbml0eSBzY2hlZHVsaW5nIHJ1bGVzIGZvciB0aGUgcG9kLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5BZmZpbml0eSNub2RlQWZmaW5pdHlcbiAgICovXG4gIHJlYWRvbmx5IG5vZGVBZmZpbml0eT86IE5vZGVBZmZpbml0eTtcblxuICAvKipcbiAgICogRGVzY3JpYmVzIHBvZCBhZmZpbml0eSBzY2hlZHVsaW5nIHJ1bGVzIChlLmcuIGNvLWxvY2F0ZSB0aGlzIHBvZCBpbiB0aGUgc2FtZSBub2RlLCB6b25lLCBldGMuIGFzIHNvbWUgb3RoZXIgcG9kKHMpKS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQWZmaW5pdHkjcG9kQWZmaW5pdHlcbiAgICovXG4gIHJlYWRvbmx5IHBvZEFmZmluaXR5PzogUG9kQWZmaW5pdHk7XG5cbiAgLyoqXG4gICAqIERlc2NyaWJlcyBwb2QgYW50aS1hZmZpbml0eSBzY2hlZHVsaW5nIHJ1bGVzIChlLmcuIGF2b2lkIHB1dHRpbmcgdGhpcyBwb2QgaW4gdGhlIHNhbWUgbm9kZSwgem9uZSwgZXRjLiBhcyBzb21lIG90aGVyIHBvZChzKSkuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkFmZmluaXR5I3BvZEFudGlBZmZpbml0eVxuICAgKi9cbiAgcmVhZG9ubHkgcG9kQW50aUFmZmluaXR5PzogUG9kQW50aUFmZmluaXR5O1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0FmZmluaXR5JyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9BZmZpbml0eShvYmo6IEFmZmluaXR5IHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbm9kZUFmZmluaXR5JzogdG9Kc29uX05vZGVBZmZpbml0eShvYmoubm9kZUFmZmluaXR5KSxcbiAgICAncG9kQWZmaW5pdHknOiB0b0pzb25fUG9kQWZmaW5pdHkob2JqLnBvZEFmZmluaXR5KSxcbiAgICAncG9kQW50aUFmZmluaXR5JzogdG9Kc29uX1BvZEFudGlBZmZpbml0eShvYmoucG9kQW50aUFmZmluaXR5KSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBBIHNpbmdsZSBhcHBsaWNhdGlvbiBjb250YWluZXIgdGhhdCB5b3Ugd2FudCB0byBydW4gd2l0aGluIGEgcG9kLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbnRhaW5lclxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbnRhaW5lciB7XG4gIC8qKlxuICAgKiBBcmd1bWVudHMgdG8gdGhlIGVudHJ5cG9pbnQuIFRoZSBkb2NrZXIgaW1hZ2UncyBDTUQgaXMgdXNlZCBpZiB0aGlzIGlzIG5vdCBwcm92aWRlZC4gVmFyaWFibGUgcmVmZXJlbmNlcyAkKFZBUl9OQU1FKSBhcmUgZXhwYW5kZWQgdXNpbmcgdGhlIGNvbnRhaW5lcidzIGVudmlyb25tZW50LiBJZiBhIHZhcmlhYmxlIGNhbm5vdCBiZSByZXNvbHZlZCwgdGhlIHJlZmVyZW5jZSBpbiB0aGUgaW5wdXQgc3RyaW5nIHdpbGwgYmUgdW5jaGFuZ2VkLiBEb3VibGUgJCQgYXJlIHJlZHVjZWQgdG8gYSBzaW5nbGUgJCwgd2hpY2ggYWxsb3dzIGZvciBlc2NhcGluZyB0aGUgJChWQVJfTkFNRSkgc3ludGF4OiBpLmUuIFwiJCQoVkFSX05BTUUpXCIgd2lsbCBwcm9kdWNlIHRoZSBzdHJpbmcgbGl0ZXJhbCBcIiQoVkFSX05BTUUpXCIuIEVzY2FwZWQgcmVmZXJlbmNlcyB3aWxsIG5ldmVyIGJlIGV4cGFuZGVkLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIHZhcmlhYmxlIGV4aXN0cyBvciBub3QuIENhbm5vdCBiZSB1cGRhdGVkLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL3Rhc2tzL2luamVjdC1kYXRhLWFwcGxpY2F0aW9uL2RlZmluZS1jb21tYW5kLWFyZ3VtZW50LWNvbnRhaW5lci8jcnVubmluZy1hLWNvbW1hbmQtaW4tYS1zaGVsbFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db250YWluZXIjYXJnc1xuICAgKi9cbiAgcmVhZG9ubHkgYXJncz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBFbnRyeXBvaW50IGFycmF5LiBOb3QgZXhlY3V0ZWQgd2l0aGluIGEgc2hlbGwuIFRoZSBkb2NrZXIgaW1hZ2UncyBFTlRSWVBPSU5UIGlzIHVzZWQgaWYgdGhpcyBpcyBub3QgcHJvdmlkZWQuIFZhcmlhYmxlIHJlZmVyZW5jZXMgJChWQVJfTkFNRSkgYXJlIGV4cGFuZGVkIHVzaW5nIHRoZSBjb250YWluZXIncyBlbnZpcm9ubWVudC4gSWYgYSB2YXJpYWJsZSBjYW5ub3QgYmUgcmVzb2x2ZWQsIHRoZSByZWZlcmVuY2UgaW4gdGhlIGlucHV0IHN0cmluZyB3aWxsIGJlIHVuY2hhbmdlZC4gRG91YmxlICQkIGFyZSByZWR1Y2VkIHRvIGEgc2luZ2xlICQsIHdoaWNoIGFsbG93cyBmb3IgZXNjYXBpbmcgdGhlICQoVkFSX05BTUUpIHN5bnRheDogaS5lLiBcIiQkKFZBUl9OQU1FKVwiIHdpbGwgcHJvZHVjZSB0aGUgc3RyaW5nIGxpdGVyYWwgXCIkKFZBUl9OQU1FKVwiLiBFc2NhcGVkIHJlZmVyZW5jZXMgd2lsbCBuZXZlciBiZSBleHBhbmRlZCwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSB2YXJpYWJsZSBleGlzdHMgb3Igbm90LiBDYW5ub3QgYmUgdXBkYXRlZC4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy90YXNrcy9pbmplY3QtZGF0YS1hcHBsaWNhdGlvbi9kZWZpbmUtY29tbWFuZC1hcmd1bWVudC1jb250YWluZXIvI3J1bm5pbmctYS1jb21tYW5kLWluLWEtc2hlbGxcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ29udGFpbmVyI2NvbW1hbmRcbiAgICovXG4gIHJlYWRvbmx5IGNvbW1hbmQ/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogTGlzdCBvZiBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdG8gc2V0IGluIHRoZSBjb250YWluZXIuIENhbm5vdCBiZSB1cGRhdGVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db250YWluZXIjZW52XG4gICAqL1xuICByZWFkb25seSBlbnY/OiBFbnZWYXJbXTtcblxuICAvKipcbiAgICogTGlzdCBvZiBzb3VyY2VzIHRvIHBvcHVsYXRlIGVudmlyb25tZW50IHZhcmlhYmxlcyBpbiB0aGUgY29udGFpbmVyLiBUaGUga2V5cyBkZWZpbmVkIHdpdGhpbiBhIHNvdXJjZSBtdXN0IGJlIGEgQ19JREVOVElGSUVSLiBBbGwgaW52YWxpZCBrZXlzIHdpbGwgYmUgcmVwb3J0ZWQgYXMgYW4gZXZlbnQgd2hlbiB0aGUgY29udGFpbmVyIGlzIHN0YXJ0aW5nLiBXaGVuIGEga2V5IGV4aXN0cyBpbiBtdWx0aXBsZSBzb3VyY2VzLCB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBsYXN0IHNvdXJjZSB3aWxsIHRha2UgcHJlY2VkZW5jZS4gVmFsdWVzIGRlZmluZWQgYnkgYW4gRW52IHdpdGggYSBkdXBsaWNhdGUga2V5IHdpbGwgdGFrZSBwcmVjZWRlbmNlLiBDYW5ub3QgYmUgdXBkYXRlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ29udGFpbmVyI2VudkZyb21cbiAgICovXG4gIHJlYWRvbmx5IGVudkZyb20/OiBFbnZGcm9tU291cmNlW107XG5cbiAgLyoqXG4gICAqIERvY2tlciBpbWFnZSBuYW1lLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL2NvbnRhaW5lcnMvaW1hZ2VzIFRoaXMgZmllbGQgaXMgb3B0aW9uYWwgdG8gYWxsb3cgaGlnaGVyIGxldmVsIGNvbmZpZyBtYW5hZ2VtZW50IHRvIGRlZmF1bHQgb3Igb3ZlcnJpZGUgY29udGFpbmVyIGltYWdlcyBpbiB3b3JrbG9hZCBjb250cm9sbGVycyBsaWtlIERlcGxveW1lbnRzIGFuZCBTdGF0ZWZ1bFNldHMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbnRhaW5lciNpbWFnZVxuICAgKi9cbiAgcmVhZG9ubHkgaW1hZ2U/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEltYWdlIHB1bGwgcG9saWN5LiBPbmUgb2YgQWx3YXlzLCBOZXZlciwgSWZOb3RQcmVzZW50LiBEZWZhdWx0cyB0byBBbHdheXMgaWYgOmxhdGVzdCB0YWcgaXMgc3BlY2lmaWVkLCBvciBJZk5vdFByZXNlbnQgb3RoZXJ3aXNlLiBDYW5ub3QgYmUgdXBkYXRlZC4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9jb250YWluZXJzL2ltYWdlcyN1cGRhdGluZy1pbWFnZXNcbiAgICpcbiAgICogQGRlZmF1bHQgQWx3YXlzIGlmIDpsYXRlc3QgdGFnIGlzIHNwZWNpZmllZCwgb3IgSWZOb3RQcmVzZW50IG90aGVyd2lzZS4gQ2Fubm90IGJlIHVwZGF0ZWQuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvY29udGFpbmVycy9pbWFnZXMjdXBkYXRpbmctaW1hZ2VzXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbnRhaW5lciNpbWFnZVB1bGxQb2xpY3lcbiAgICovXG4gIHJlYWRvbmx5IGltYWdlUHVsbFBvbGljeT86IHN0cmluZztcblxuICAvKipcbiAgICogQWN0aW9ucyB0aGF0IHRoZSBtYW5hZ2VtZW50IHN5c3RlbSBzaG91bGQgdGFrZSBpbiByZXNwb25zZSB0byBjb250YWluZXIgbGlmZWN5Y2xlIGV2ZW50cy4gQ2Fubm90IGJlIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbnRhaW5lciNsaWZlY3ljbGVcbiAgICovXG4gIHJlYWRvbmx5IGxpZmVjeWNsZT86IExpZmVjeWNsZTtcblxuICAvKipcbiAgICogUGVyaW9kaWMgcHJvYmUgb2YgY29udGFpbmVyIGxpdmVuZXNzLiBDb250YWluZXIgd2lsbCBiZSByZXN0YXJ0ZWQgaWYgdGhlIHByb2JlIGZhaWxzLiBDYW5ub3QgYmUgdXBkYXRlZC4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy93b3JrbG9hZHMvcG9kcy9wb2QtbGlmZWN5Y2xlI2NvbnRhaW5lci1wcm9iZXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ29udGFpbmVyI2xpdmVuZXNzUHJvYmVcbiAgICovXG4gIHJlYWRvbmx5IGxpdmVuZXNzUHJvYmU/OiBQcm9iZTtcblxuICAvKipcbiAgICogTmFtZSBvZiB0aGUgY29udGFpbmVyIHNwZWNpZmllZCBhcyBhIEROU19MQUJFTC4gRWFjaCBjb250YWluZXIgaW4gYSBwb2QgbXVzdCBoYXZlIGEgdW5pcXVlIG5hbWUgKEROU19MQUJFTCkuIENhbm5vdCBiZSB1cGRhdGVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db250YWluZXIjbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIHBvcnRzIHRvIGV4cG9zZSBmcm9tIHRoZSBjb250YWluZXIuIEV4cG9zaW5nIGEgcG9ydCBoZXJlIGdpdmVzIHRoZSBzeXN0ZW0gYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbmV0d29yayBjb25uZWN0aW9ucyBhIGNvbnRhaW5lciB1c2VzLCBidXQgaXMgcHJpbWFyaWx5IGluZm9ybWF0aW9uYWwuIE5vdCBzcGVjaWZ5aW5nIGEgcG9ydCBoZXJlIERPRVMgTk9UIHByZXZlbnQgdGhhdCBwb3J0IGZyb20gYmVpbmcgZXhwb3NlZC4gQW55IHBvcnQgd2hpY2ggaXMgbGlzdGVuaW5nIG9uIHRoZSBkZWZhdWx0IFwiMC4wLjAuMFwiIGFkZHJlc3MgaW5zaWRlIGEgY29udGFpbmVyIHdpbGwgYmUgYWNjZXNzaWJsZSBmcm9tIHRoZSBuZXR3b3JrLiBDYW5ub3QgYmUgdXBkYXRlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ29udGFpbmVyI3BvcnRzXG4gICAqL1xuICByZWFkb25seSBwb3J0cz86IENvbnRhaW5lclBvcnRbXTtcblxuICAvKipcbiAgICogUGVyaW9kaWMgcHJvYmUgb2YgY29udGFpbmVyIHNlcnZpY2UgcmVhZGluZXNzLiBDb250YWluZXIgd2lsbCBiZSByZW1vdmVkIGZyb20gc2VydmljZSBlbmRwb2ludHMgaWYgdGhlIHByb2JlIGZhaWxzLiBDYW5ub3QgYmUgdXBkYXRlZC4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy93b3JrbG9hZHMvcG9kcy9wb2QtbGlmZWN5Y2xlI2NvbnRhaW5lci1wcm9iZXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ29udGFpbmVyI3JlYWRpbmVzc1Byb2JlXG4gICAqL1xuICByZWFkb25seSByZWFkaW5lc3NQcm9iZT86IFByb2JlO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIFJlc291cmNlcyByZXF1aXJlZCBieSB0aGlzIGNvbnRhaW5lci4gQ2Fubm90IGJlIHVwZGF0ZWQuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvY29uZmlndXJhdGlvbi9tYW5hZ2UtcmVzb3VyY2VzLWNvbnRhaW5lcnMvXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbnRhaW5lciNyZXNvdXJjZXNcbiAgICovXG4gIHJlYWRvbmx5IHJlc291cmNlcz86IFJlc291cmNlUmVxdWlyZW1lbnRzO1xuXG4gIC8qKlxuICAgKiBTZWN1cml0eUNvbnRleHQgZGVmaW5lcyB0aGUgc2VjdXJpdHkgb3B0aW9ucyB0aGUgY29udGFpbmVyIHNob3VsZCBiZSBydW4gd2l0aC4gSWYgc2V0LCB0aGUgZmllbGRzIG9mIFNlY3VyaXR5Q29udGV4dCBvdmVycmlkZSB0aGUgZXF1aXZhbGVudCBmaWVsZHMgb2YgUG9kU2VjdXJpdHlDb250ZXh0LiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL3Rhc2tzL2NvbmZpZ3VyZS1wb2QtY29udGFpbmVyL3NlY3VyaXR5LWNvbnRleHQvXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbnRhaW5lciNzZWN1cml0eUNvbnRleHRcbiAgICovXG4gIHJlYWRvbmx5IHNlY3VyaXR5Q29udGV4dD86IFNlY3VyaXR5Q29udGV4dDtcblxuICAvKipcbiAgICogU3RhcnR1cFByb2JlIGluZGljYXRlcyB0aGF0IHRoZSBQb2QgaGFzIHN1Y2Nlc3NmdWxseSBpbml0aWFsaXplZC4gSWYgc3BlY2lmaWVkLCBubyBvdGhlciBwcm9iZXMgYXJlIGV4ZWN1dGVkIHVudGlsIHRoaXMgY29tcGxldGVzIHN1Y2Nlc3NmdWxseS4gSWYgdGhpcyBwcm9iZSBmYWlscywgdGhlIFBvZCB3aWxsIGJlIHJlc3RhcnRlZCwganVzdCBhcyBpZiB0aGUgbGl2ZW5lc3NQcm9iZSBmYWlsZWQuIFRoaXMgY2FuIGJlIHVzZWQgdG8gcHJvdmlkZSBkaWZmZXJlbnQgcHJvYmUgcGFyYW1ldGVycyBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgUG9kJ3MgbGlmZWN5Y2xlLCB3aGVuIGl0IG1pZ2h0IHRha2UgYSBsb25nIHRpbWUgdG8gbG9hZCBkYXRhIG9yIHdhcm0gYSBjYWNoZSwgdGhhbiBkdXJpbmcgc3RlYWR5LXN0YXRlIG9wZXJhdGlvbi4gVGhpcyBjYW5ub3QgYmUgdXBkYXRlZC4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy93b3JrbG9hZHMvcG9kcy9wb2QtbGlmZWN5Y2xlI2NvbnRhaW5lci1wcm9iZXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ29udGFpbmVyI3N0YXJ0dXBQcm9iZVxuICAgKi9cbiAgcmVhZG9ubHkgc3RhcnR1cFByb2JlPzogUHJvYmU7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBjb250YWluZXIgc2hvdWxkIGFsbG9jYXRlIGEgYnVmZmVyIGZvciBzdGRpbiBpbiB0aGUgY29udGFpbmVyIHJ1bnRpbWUuIElmIHRoaXMgaXMgbm90IHNldCwgcmVhZHMgZnJvbSBzdGRpbiBpbiB0aGUgY29udGFpbmVyIHdpbGwgYWx3YXlzIHJlc3VsdCBpbiBFT0YuIERlZmF1bHQgaXMgZmFsc2UuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db250YWluZXIjc3RkaW5cbiAgICovXG4gIHJlYWRvbmx5IHN0ZGluPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgY29udGFpbmVyIHJ1bnRpbWUgc2hvdWxkIGNsb3NlIHRoZSBzdGRpbiBjaGFubmVsIGFmdGVyIGl0IGhhcyBiZWVuIG9wZW5lZCBieSBhIHNpbmdsZSBhdHRhY2guIFdoZW4gc3RkaW4gaXMgdHJ1ZSB0aGUgc3RkaW4gc3RyZWFtIHdpbGwgcmVtYWluIG9wZW4gYWNyb3NzIG11bHRpcGxlIGF0dGFjaCBzZXNzaW9ucy4gSWYgc3RkaW5PbmNlIGlzIHNldCB0byB0cnVlLCBzdGRpbiBpcyBvcGVuZWQgb24gY29udGFpbmVyIHN0YXJ0LCBpcyBlbXB0eSB1bnRpbCB0aGUgZmlyc3QgY2xpZW50IGF0dGFjaGVzIHRvIHN0ZGluLCBhbmQgdGhlbiByZW1haW5zIG9wZW4gYW5kIGFjY2VwdHMgZGF0YSB1bnRpbCB0aGUgY2xpZW50IGRpc2Nvbm5lY3RzLCBhdCB3aGljaCB0aW1lIHN0ZGluIGlzIGNsb3NlZCBhbmQgcmVtYWlucyBjbG9zZWQgdW50aWwgdGhlIGNvbnRhaW5lciBpcyByZXN0YXJ0ZWQuIElmIHRoaXMgZmxhZyBpcyBmYWxzZSwgYSBjb250YWluZXIgcHJvY2Vzc2VzIHRoYXQgcmVhZHMgZnJvbSBzdGRpbiB3aWxsIG5ldmVyIHJlY2VpdmUgYW4gRU9GLiBEZWZhdWx0IGlzIGZhbHNlXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbnRhaW5lciNzdGRpbk9uY2VcbiAgICovXG4gIHJlYWRvbmx5IHN0ZGluT25jZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsOiBQYXRoIGF0IHdoaWNoIHRoZSBmaWxlIHRvIHdoaWNoIHRoZSBjb250YWluZXIncyB0ZXJtaW5hdGlvbiBtZXNzYWdlIHdpbGwgYmUgd3JpdHRlbiBpcyBtb3VudGVkIGludG8gdGhlIGNvbnRhaW5lcidzIGZpbGVzeXN0ZW0uIE1lc3NhZ2Ugd3JpdHRlbiBpcyBpbnRlbmRlZCB0byBiZSBicmllZiBmaW5hbCBzdGF0dXMsIHN1Y2ggYXMgYW4gYXNzZXJ0aW9uIGZhaWx1cmUgbWVzc2FnZS4gV2lsbCBiZSB0cnVuY2F0ZWQgYnkgdGhlIG5vZGUgaWYgZ3JlYXRlciB0aGFuIDQwOTYgYnl0ZXMuIFRoZSB0b3RhbCBtZXNzYWdlIGxlbmd0aCBhY3Jvc3MgYWxsIGNvbnRhaW5lcnMgd2lsbCBiZSBsaW1pdGVkIHRvIDEya2IuIERlZmF1bHRzIHRvIC9kZXYvdGVybWluYXRpb24tbG9nLiBDYW5ub3QgYmUgdXBkYXRlZC5cbiAgICpcbiAgICogQGRlZmF1bHQgZGV2L3Rlcm1pbmF0aW9uLWxvZy4gQ2Fubm90IGJlIHVwZGF0ZWQuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbnRhaW5lciN0ZXJtaW5hdGlvbk1lc3NhZ2VQYXRoXG4gICAqL1xuICByZWFkb25seSB0ZXJtaW5hdGlvbk1lc3NhZ2VQYXRoPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZSBob3cgdGhlIHRlcm1pbmF0aW9uIG1lc3NhZ2Ugc2hvdWxkIGJlIHBvcHVsYXRlZC4gRmlsZSB3aWxsIHVzZSB0aGUgY29udGVudHMgb2YgdGVybWluYXRpb25NZXNzYWdlUGF0aCB0byBwb3B1bGF0ZSB0aGUgY29udGFpbmVyIHN0YXR1cyBtZXNzYWdlIG9uIGJvdGggc3VjY2VzcyBhbmQgZmFpbHVyZS4gRmFsbGJhY2tUb0xvZ3NPbkVycm9yIHdpbGwgdXNlIHRoZSBsYXN0IGNodW5rIG9mIGNvbnRhaW5lciBsb2cgb3V0cHV0IGlmIHRoZSB0ZXJtaW5hdGlvbiBtZXNzYWdlIGZpbGUgaXMgZW1wdHkgYW5kIHRoZSBjb250YWluZXIgZXhpdGVkIHdpdGggYW4gZXJyb3IuIFRoZSBsb2cgb3V0cHV0IGlzIGxpbWl0ZWQgdG8gMjA0OCBieXRlcyBvciA4MCBsaW5lcywgd2hpY2hldmVyIGlzIHNtYWxsZXIuIERlZmF1bHRzIHRvIEZpbGUuIENhbm5vdCBiZSB1cGRhdGVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCBGaWxlLiBDYW5ub3QgYmUgdXBkYXRlZC5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ29udGFpbmVyI3Rlcm1pbmF0aW9uTWVzc2FnZVBvbGljeVxuICAgKi9cbiAgcmVhZG9ubHkgdGVybWluYXRpb25NZXNzYWdlUG9saWN5Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgY29udGFpbmVyIHNob3VsZCBhbGxvY2F0ZSBhIFRUWSBmb3IgaXRzZWxmLCBhbHNvIHJlcXVpcmVzICdzdGRpbicgdG8gYmUgdHJ1ZS4gRGVmYXVsdCBpcyBmYWxzZS5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2UuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbnRhaW5lciN0dHlcbiAgICovXG4gIHJlYWRvbmx5IHR0eT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHZvbHVtZURldmljZXMgaXMgdGhlIGxpc3Qgb2YgYmxvY2sgZGV2aWNlcyB0byBiZSB1c2VkIGJ5IHRoZSBjb250YWluZXIuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbnRhaW5lciN2b2x1bWVEZXZpY2VzXG4gICAqL1xuICByZWFkb25seSB2b2x1bWVEZXZpY2VzPzogVm9sdW1lRGV2aWNlW107XG5cbiAgLyoqXG4gICAqIFBvZCB2b2x1bWVzIHRvIG1vdW50IGludG8gdGhlIGNvbnRhaW5lcidzIGZpbGVzeXN0ZW0uIENhbm5vdCBiZSB1cGRhdGVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db250YWluZXIjdm9sdW1lTW91bnRzXG4gICAqL1xuICByZWFkb25seSB2b2x1bWVNb3VudHM/OiBWb2x1bWVNb3VudFtdO1xuXG4gIC8qKlxuICAgKiBDb250YWluZXIncyB3b3JraW5nIGRpcmVjdG9yeS4gSWYgbm90IHNwZWNpZmllZCwgdGhlIGNvbnRhaW5lciBydW50aW1lJ3MgZGVmYXVsdCB3aWxsIGJlIHVzZWQsIHdoaWNoIG1pZ2h0IGJlIGNvbmZpZ3VyZWQgaW4gdGhlIGNvbnRhaW5lciBpbWFnZS4gQ2Fubm90IGJlIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbnRhaW5lciN3b3JraW5nRGlyXG4gICAqL1xuICByZWFkb25seSB3b3JraW5nRGlyPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0NvbnRhaW5lcicgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fQ29udGFpbmVyKG9iajogQ29udGFpbmVyIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnYXJncyc6IG9iai5hcmdzPy5tYXAoeSA9PiB5KSxcbiAgICAnY29tbWFuZCc6IG9iai5jb21tYW5kPy5tYXAoeSA9PiB5KSxcbiAgICAnZW52Jzogb2JqLmVudj8ubWFwKHkgPT4gdG9Kc29uX0VudlZhcih5KSksXG4gICAgJ2VudkZyb20nOiBvYmouZW52RnJvbT8ubWFwKHkgPT4gdG9Kc29uX0VudkZyb21Tb3VyY2UoeSkpLFxuICAgICdpbWFnZSc6IG9iai5pbWFnZSxcbiAgICAnaW1hZ2VQdWxsUG9saWN5Jzogb2JqLmltYWdlUHVsbFBvbGljeSxcbiAgICAnbGlmZWN5Y2xlJzogdG9Kc29uX0xpZmVjeWNsZShvYmoubGlmZWN5Y2xlKSxcbiAgICAnbGl2ZW5lc3NQcm9iZSc6IHRvSnNvbl9Qcm9iZShvYmoubGl2ZW5lc3NQcm9iZSksXG4gICAgJ25hbWUnOiBvYmoubmFtZSxcbiAgICAncG9ydHMnOiBvYmoucG9ydHM/Lm1hcCh5ID0+IHRvSnNvbl9Db250YWluZXJQb3J0KHkpKSxcbiAgICAncmVhZGluZXNzUHJvYmUnOiB0b0pzb25fUHJvYmUob2JqLnJlYWRpbmVzc1Byb2JlKSxcbiAgICAncmVzb3VyY2VzJzogdG9Kc29uX1Jlc291cmNlUmVxdWlyZW1lbnRzKG9iai5yZXNvdXJjZXMpLFxuICAgICdzZWN1cml0eUNvbnRleHQnOiB0b0pzb25fU2VjdXJpdHlDb250ZXh0KG9iai5zZWN1cml0eUNvbnRleHQpLFxuICAgICdzdGFydHVwUHJvYmUnOiB0b0pzb25fUHJvYmUob2JqLnN0YXJ0dXBQcm9iZSksXG4gICAgJ3N0ZGluJzogb2JqLnN0ZGluLFxuICAgICdzdGRpbk9uY2UnOiBvYmouc3RkaW5PbmNlLFxuICAgICd0ZXJtaW5hdGlvbk1lc3NhZ2VQYXRoJzogb2JqLnRlcm1pbmF0aW9uTWVzc2FnZVBhdGgsXG4gICAgJ3Rlcm1pbmF0aW9uTWVzc2FnZVBvbGljeSc6IG9iai50ZXJtaW5hdGlvbk1lc3NhZ2VQb2xpY3ksXG4gICAgJ3R0eSc6IG9iai50dHksXG4gICAgJ3ZvbHVtZURldmljZXMnOiBvYmoudm9sdW1lRGV2aWNlcz8ubWFwKHkgPT4gdG9Kc29uX1ZvbHVtZURldmljZSh5KSksXG4gICAgJ3ZvbHVtZU1vdW50cyc6IG9iai52b2x1bWVNb3VudHM/Lm1hcCh5ID0+IHRvSnNvbl9Wb2x1bWVNb3VudCh5KSksXG4gICAgJ3dvcmtpbmdEaXInOiBvYmoud29ya2luZ0RpcixcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBQb2RETlNDb25maWcgZGVmaW5lcyB0aGUgRE5TIHBhcmFtZXRlcnMgb2YgYSBwb2QgaW4gYWRkaXRpb24gdG8gdGhvc2UgZ2VuZXJhdGVkIGZyb20gRE5TUG9saWN5LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZEROU0NvbmZpZ1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFBvZERuc0NvbmZpZyB7XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgRE5TIG5hbWUgc2VydmVyIElQIGFkZHJlc3Nlcy4gVGhpcyB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBiYXNlIG5hbWVzZXJ2ZXJzIGdlbmVyYXRlZCBmcm9tIEROU1BvbGljeS4gRHVwbGljYXRlZCBuYW1lc2VydmVycyB3aWxsIGJlIHJlbW92ZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZEROU0NvbmZpZyNuYW1lc2VydmVyc1xuICAgKi9cbiAgcmVhZG9ubHkgbmFtZXNlcnZlcnM/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIEROUyByZXNvbHZlciBvcHRpb25zLiBUaGlzIHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlIGJhc2Ugb3B0aW9ucyBnZW5lcmF0ZWQgZnJvbSBETlNQb2xpY3kuIER1cGxpY2F0ZWQgZW50cmllcyB3aWxsIGJlIHJlbW92ZWQuIFJlc29sdXRpb24gb3B0aW9ucyBnaXZlbiBpbiBPcHRpb25zIHdpbGwgb3ZlcnJpZGUgdGhvc2UgdGhhdCBhcHBlYXIgaW4gdGhlIGJhc2UgRE5TUG9saWN5LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RETlNDb25maWcjb3B0aW9uc1xuICAgKi9cbiAgcmVhZG9ubHkgb3B0aW9ucz86IFBvZERuc0NvbmZpZ09wdGlvbltdO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgRE5TIHNlYXJjaCBkb21haW5zIGZvciBob3N0LW5hbWUgbG9va3VwLiBUaGlzIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIGJhc2Ugc2VhcmNoIHBhdGhzIGdlbmVyYXRlZCBmcm9tIEROU1BvbGljeS4gRHVwbGljYXRlZCBzZWFyY2ggcGF0aHMgd2lsbCBiZSByZW1vdmVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RETlNDb25maWcjc2VhcmNoZXNcbiAgICovXG4gIHJlYWRvbmx5IHNlYXJjaGVzPzogc3RyaW5nW107XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnUG9kRG5zQ29uZmlnJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Qb2REbnNDb25maWcob2JqOiBQb2REbnNDb25maWcgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICduYW1lc2VydmVycyc6IG9iai5uYW1lc2VydmVycz8ubWFwKHkgPT4geSksXG4gICAgJ29wdGlvbnMnOiBvYmoub3B0aW9ucz8ubWFwKHkgPT4gdG9Kc29uX1BvZERuc0NvbmZpZ09wdGlvbih5KSksXG4gICAgJ3NlYXJjaGVzJzogb2JqLnNlYXJjaGVzPy5tYXAoeSA9PiB5KSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBBbiBFcGhlbWVyYWxDb250YWluZXIgaXMgYSBjb250YWluZXIgdGhhdCBtYXkgYmUgYWRkZWQgdGVtcG9yYXJpbHkgdG8gYW4gZXhpc3RpbmcgcG9kIGZvciB1c2VyLWluaXRpYXRlZCBhY3Rpdml0aWVzIHN1Y2ggYXMgZGVidWdnaW5nLiBFcGhlbWVyYWwgY29udGFpbmVycyBoYXZlIG5vIHJlc291cmNlIG9yIHNjaGVkdWxpbmcgZ3VhcmFudGVlcywgYW5kIHRoZXkgd2lsbCBub3QgYmUgcmVzdGFydGVkIHdoZW4gdGhleSBleGl0IG9yIHdoZW4gYSBwb2QgaXMgcmVtb3ZlZCBvciByZXN0YXJ0ZWQuIElmIGFuIGVwaGVtZXJhbCBjb250YWluZXIgY2F1c2VzIGEgcG9kIHRvIGV4Y2VlZCBpdHMgcmVzb3VyY2UgYWxsb2NhdGlvbiwgdGhlIHBvZCBtYXkgYmUgZXZpY3RlZC4gRXBoZW1lcmFsIGNvbnRhaW5lcnMgbWF5IG5vdCBiZSBhZGRlZCBieSBkaXJlY3RseSB1cGRhdGluZyB0aGUgcG9kIHNwZWMuIFRoZXkgbXVzdCBiZSBhZGRlZCB2aWEgdGhlIHBvZCdzIGVwaGVtZXJhbGNvbnRhaW5lcnMgc3VicmVzb3VyY2UsIGFuZCB0aGV5IHdpbGwgYXBwZWFyIGluIHRoZSBwb2Qgc3BlYyBvbmNlIGFkZGVkLiBUaGlzIGlzIGFuIGFscGhhIGZlYXR1cmUgZW5hYmxlZCBieSB0aGUgRXBoZW1lcmFsQ29udGFpbmVycyBmZWF0dXJlIGZsYWcuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRXBoZW1lcmFsQ29udGFpbmVyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXBoZW1lcmFsQ29udGFpbmVyIHtcbiAgLyoqXG4gICAqIEFyZ3VtZW50cyB0byB0aGUgZW50cnlwb2ludC4gVGhlIGRvY2tlciBpbWFnZSdzIENNRCBpcyB1c2VkIGlmIHRoaXMgaXMgbm90IHByb3ZpZGVkLiBWYXJpYWJsZSByZWZlcmVuY2VzICQoVkFSX05BTUUpIGFyZSBleHBhbmRlZCB1c2luZyB0aGUgY29udGFpbmVyJ3MgZW52aXJvbm1lbnQuIElmIGEgdmFyaWFibGUgY2Fubm90IGJlIHJlc29sdmVkLCB0aGUgcmVmZXJlbmNlIGluIHRoZSBpbnB1dCBzdHJpbmcgd2lsbCBiZSB1bmNoYW5nZWQuIERvdWJsZSAkJCBhcmUgcmVkdWNlZCB0byBhIHNpbmdsZSAkLCB3aGljaCBhbGxvd3MgZm9yIGVzY2FwaW5nIHRoZSAkKFZBUl9OQU1FKSBzeW50YXg6IGkuZS4gXCIkJChWQVJfTkFNRSlcIiB3aWxsIHByb2R1Y2UgdGhlIHN0cmluZyBsaXRlcmFsIFwiJChWQVJfTkFNRSlcIi4gRXNjYXBlZCByZWZlcmVuY2VzIHdpbGwgbmV2ZXIgYmUgZXhwYW5kZWQsIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdmFyaWFibGUgZXhpc3RzIG9yIG5vdC4gQ2Fubm90IGJlIHVwZGF0ZWQuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvdGFza3MvaW5qZWN0LWRhdGEtYXBwbGljYXRpb24vZGVmaW5lLWNvbW1hbmQtYXJndW1lbnQtY29udGFpbmVyLyNydW5uaW5nLWEtY29tbWFuZC1pbi1hLXNoZWxsXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkVwaGVtZXJhbENvbnRhaW5lciNhcmdzXG4gICAqL1xuICByZWFkb25seSBhcmdzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIEVudHJ5cG9pbnQgYXJyYXkuIE5vdCBleGVjdXRlZCB3aXRoaW4gYSBzaGVsbC4gVGhlIGRvY2tlciBpbWFnZSdzIEVOVFJZUE9JTlQgaXMgdXNlZCBpZiB0aGlzIGlzIG5vdCBwcm92aWRlZC4gVmFyaWFibGUgcmVmZXJlbmNlcyAkKFZBUl9OQU1FKSBhcmUgZXhwYW5kZWQgdXNpbmcgdGhlIGNvbnRhaW5lcidzIGVudmlyb25tZW50LiBJZiBhIHZhcmlhYmxlIGNhbm5vdCBiZSByZXNvbHZlZCwgdGhlIHJlZmVyZW5jZSBpbiB0aGUgaW5wdXQgc3RyaW5nIHdpbGwgYmUgdW5jaGFuZ2VkLiBEb3VibGUgJCQgYXJlIHJlZHVjZWQgdG8gYSBzaW5nbGUgJCwgd2hpY2ggYWxsb3dzIGZvciBlc2NhcGluZyB0aGUgJChWQVJfTkFNRSkgc3ludGF4OiBpLmUuIFwiJCQoVkFSX05BTUUpXCIgd2lsbCBwcm9kdWNlIHRoZSBzdHJpbmcgbGl0ZXJhbCBcIiQoVkFSX05BTUUpXCIuIEVzY2FwZWQgcmVmZXJlbmNlcyB3aWxsIG5ldmVyIGJlIGV4cGFuZGVkLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIHZhcmlhYmxlIGV4aXN0cyBvciBub3QuIENhbm5vdCBiZSB1cGRhdGVkLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL3Rhc2tzL2luamVjdC1kYXRhLWFwcGxpY2F0aW9uL2RlZmluZS1jb21tYW5kLWFyZ3VtZW50LWNvbnRhaW5lci8jcnVubmluZy1hLWNvbW1hbmQtaW4tYS1zaGVsbFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FcGhlbWVyYWxDb250YWluZXIjY29tbWFuZFxuICAgKi9cbiAgcmVhZG9ubHkgY29tbWFuZD86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGVudmlyb25tZW50IHZhcmlhYmxlcyB0byBzZXQgaW4gdGhlIGNvbnRhaW5lci4gQ2Fubm90IGJlIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkVwaGVtZXJhbENvbnRhaW5lciNlbnZcbiAgICovXG4gIHJlYWRvbmx5IGVudj86IEVudlZhcltdO1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIHNvdXJjZXMgdG8gcG9wdWxhdGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIGluIHRoZSBjb250YWluZXIuIFRoZSBrZXlzIGRlZmluZWQgd2l0aGluIGEgc291cmNlIG11c3QgYmUgYSBDX0lERU5USUZJRVIuIEFsbCBpbnZhbGlkIGtleXMgd2lsbCBiZSByZXBvcnRlZCBhcyBhbiBldmVudCB3aGVuIHRoZSBjb250YWluZXIgaXMgc3RhcnRpbmcuIFdoZW4gYSBrZXkgZXhpc3RzIGluIG11bHRpcGxlIHNvdXJjZXMsIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGxhc3Qgc291cmNlIHdpbGwgdGFrZSBwcmVjZWRlbmNlLiBWYWx1ZXMgZGVmaW5lZCBieSBhbiBFbnYgd2l0aCBhIGR1cGxpY2F0ZSBrZXkgd2lsbCB0YWtlIHByZWNlZGVuY2UuIENhbm5vdCBiZSB1cGRhdGVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FcGhlbWVyYWxDb250YWluZXIjZW52RnJvbVxuICAgKi9cbiAgcmVhZG9ubHkgZW52RnJvbT86IEVudkZyb21Tb3VyY2VbXTtcblxuICAvKipcbiAgICogRG9ja2VyIGltYWdlIG5hbWUuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvY29udGFpbmVycy9pbWFnZXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRXBoZW1lcmFsQ29udGFpbmVyI2ltYWdlXG4gICAqL1xuICByZWFkb25seSBpbWFnZT86IHN0cmluZztcblxuICAvKipcbiAgICogSW1hZ2UgcHVsbCBwb2xpY3kuIE9uZSBvZiBBbHdheXMsIE5ldmVyLCBJZk5vdFByZXNlbnQuIERlZmF1bHRzIHRvIEFsd2F5cyBpZiA6bGF0ZXN0IHRhZyBpcyBzcGVjaWZpZWQsIG9yIElmTm90UHJlc2VudCBvdGhlcndpc2UuIENhbm5vdCBiZSB1cGRhdGVkLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL2NvbnRhaW5lcnMvaW1hZ2VzI3VwZGF0aW5nLWltYWdlc1xuICAgKlxuICAgKiBAZGVmYXVsdCBBbHdheXMgaWYgOmxhdGVzdCB0YWcgaXMgc3BlY2lmaWVkLCBvciBJZk5vdFByZXNlbnQgb3RoZXJ3aXNlLiBDYW5ub3QgYmUgdXBkYXRlZC4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9jb250YWluZXJzL2ltYWdlcyN1cGRhdGluZy1pbWFnZXNcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRXBoZW1lcmFsQ29udGFpbmVyI2ltYWdlUHVsbFBvbGljeVxuICAgKi9cbiAgcmVhZG9ubHkgaW1hZ2VQdWxsUG9saWN5Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBMaWZlY3ljbGUgaXMgbm90IGFsbG93ZWQgZm9yIGVwaGVtZXJhbCBjb250YWluZXJzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FcGhlbWVyYWxDb250YWluZXIjbGlmZWN5Y2xlXG4gICAqL1xuICByZWFkb25seSBsaWZlY3ljbGU/OiBMaWZlY3ljbGU7XG5cbiAgLyoqXG4gICAqIFByb2JlcyBhcmUgbm90IGFsbG93ZWQgZm9yIGVwaGVtZXJhbCBjb250YWluZXJzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FcGhlbWVyYWxDb250YWluZXIjbGl2ZW5lc3NQcm9iZVxuICAgKi9cbiAgcmVhZG9ubHkgbGl2ZW5lc3NQcm9iZT86IFByb2JlO1xuXG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBlcGhlbWVyYWwgY29udGFpbmVyIHNwZWNpZmllZCBhcyBhIEROU19MQUJFTC4gVGhpcyBuYW1lIG11c3QgYmUgdW5pcXVlIGFtb25nIGFsbCBjb250YWluZXJzLCBpbml0IGNvbnRhaW5lcnMgYW5kIGVwaGVtZXJhbCBjb250YWluZXJzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FcGhlbWVyYWxDb250YWluZXIjbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBQb3J0cyBhcmUgbm90IGFsbG93ZWQgZm9yIGVwaGVtZXJhbCBjb250YWluZXJzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FcGhlbWVyYWxDb250YWluZXIjcG9ydHNcbiAgICovXG4gIHJlYWRvbmx5IHBvcnRzPzogQ29udGFpbmVyUG9ydFtdO1xuXG4gIC8qKlxuICAgKiBQcm9iZXMgYXJlIG5vdCBhbGxvd2VkIGZvciBlcGhlbWVyYWwgY29udGFpbmVycy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRXBoZW1lcmFsQ29udGFpbmVyI3JlYWRpbmVzc1Byb2JlXG4gICAqL1xuICByZWFkb25seSByZWFkaW5lc3NQcm9iZT86IFByb2JlO1xuXG4gIC8qKlxuICAgKiBSZXNvdXJjZXMgYXJlIG5vdCBhbGxvd2VkIGZvciBlcGhlbWVyYWwgY29udGFpbmVycy4gRXBoZW1lcmFsIGNvbnRhaW5lcnMgdXNlIHNwYXJlIHJlc291cmNlcyBhbHJlYWR5IGFsbG9jYXRlZCB0byB0aGUgcG9kLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FcGhlbWVyYWxDb250YWluZXIjcmVzb3VyY2VzXG4gICAqL1xuICByZWFkb25seSByZXNvdXJjZXM/OiBSZXNvdXJjZVJlcXVpcmVtZW50cztcblxuICAvKipcbiAgICogT3B0aW9uYWw6IFNlY3VyaXR5Q29udGV4dCBkZWZpbmVzIHRoZSBzZWN1cml0eSBvcHRpb25zIHRoZSBlcGhlbWVyYWwgY29udGFpbmVyIHNob3VsZCBiZSBydW4gd2l0aC4gSWYgc2V0LCB0aGUgZmllbGRzIG9mIFNlY3VyaXR5Q29udGV4dCBvdmVycmlkZSB0aGUgZXF1aXZhbGVudCBmaWVsZHMgb2YgUG9kU2VjdXJpdHlDb250ZXh0LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FcGhlbWVyYWxDb250YWluZXIjc2VjdXJpdHlDb250ZXh0XG4gICAqL1xuICByZWFkb25seSBzZWN1cml0eUNvbnRleHQ/OiBTZWN1cml0eUNvbnRleHQ7XG5cbiAgLyoqXG4gICAqIFByb2JlcyBhcmUgbm90IGFsbG93ZWQgZm9yIGVwaGVtZXJhbCBjb250YWluZXJzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FcGhlbWVyYWxDb250YWluZXIjc3RhcnR1cFByb2JlXG4gICAqL1xuICByZWFkb25seSBzdGFydHVwUHJvYmU/OiBQcm9iZTtcblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIGNvbnRhaW5lciBzaG91bGQgYWxsb2NhdGUgYSBidWZmZXIgZm9yIHN0ZGluIGluIHRoZSBjb250YWluZXIgcnVudGltZS4gSWYgdGhpcyBpcyBub3Qgc2V0LCByZWFkcyBmcm9tIHN0ZGluIGluIHRoZSBjb250YWluZXIgd2lsbCBhbHdheXMgcmVzdWx0IGluIEVPRi4gRGVmYXVsdCBpcyBmYWxzZS5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2UuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkVwaGVtZXJhbENvbnRhaW5lciNzdGRpblxuICAgKi9cbiAgcmVhZG9ubHkgc3RkaW4/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBjb250YWluZXIgcnVudGltZSBzaG91bGQgY2xvc2UgdGhlIHN0ZGluIGNoYW5uZWwgYWZ0ZXIgaXQgaGFzIGJlZW4gb3BlbmVkIGJ5IGEgc2luZ2xlIGF0dGFjaC4gV2hlbiBzdGRpbiBpcyB0cnVlIHRoZSBzdGRpbiBzdHJlYW0gd2lsbCByZW1haW4gb3BlbiBhY3Jvc3MgbXVsdGlwbGUgYXR0YWNoIHNlc3Npb25zLiBJZiBzdGRpbk9uY2UgaXMgc2V0IHRvIHRydWUsIHN0ZGluIGlzIG9wZW5lZCBvbiBjb250YWluZXIgc3RhcnQsIGlzIGVtcHR5IHVudGlsIHRoZSBmaXJzdCBjbGllbnQgYXR0YWNoZXMgdG8gc3RkaW4sIGFuZCB0aGVuIHJlbWFpbnMgb3BlbiBhbmQgYWNjZXB0cyBkYXRhIHVudGlsIHRoZSBjbGllbnQgZGlzY29ubmVjdHMsIGF0IHdoaWNoIHRpbWUgc3RkaW4gaXMgY2xvc2VkIGFuZCByZW1haW5zIGNsb3NlZCB1bnRpbCB0aGUgY29udGFpbmVyIGlzIHJlc3RhcnRlZC4gSWYgdGhpcyBmbGFnIGlzIGZhbHNlLCBhIGNvbnRhaW5lciBwcm9jZXNzZXMgdGhhdCByZWFkcyBmcm9tIHN0ZGluIHdpbGwgbmV2ZXIgcmVjZWl2ZSBhbiBFT0YuIERlZmF1bHQgaXMgZmFsc2VcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRXBoZW1lcmFsQ29udGFpbmVyI3N0ZGluT25jZVxuICAgKi9cbiAgcmVhZG9ubHkgc3RkaW5PbmNlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSWYgc2V0LCB0aGUgbmFtZSBvZiB0aGUgY29udGFpbmVyIGZyb20gUG9kU3BlYyB0aGF0IHRoaXMgZXBoZW1lcmFsIGNvbnRhaW5lciB0YXJnZXRzLiBUaGUgZXBoZW1lcmFsIGNvbnRhaW5lciB3aWxsIGJlIHJ1biBpbiB0aGUgbmFtZXNwYWNlcyAoSVBDLCBQSUQsIGV0Yykgb2YgdGhpcyBjb250YWluZXIuIElmIG5vdCBzZXQgdGhlbiB0aGUgZXBoZW1lcmFsIGNvbnRhaW5lciBpcyBydW4gaW4gd2hhdGV2ZXIgbmFtZXNwYWNlcyBhcmUgc2hhcmVkIGZvciB0aGUgcG9kLiBOb3RlIHRoYXQgdGhlIGNvbnRhaW5lciBydW50aW1lIG11c3Qgc3VwcG9ydCB0aGlzIGZlYXR1cmUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkVwaGVtZXJhbENvbnRhaW5lciN0YXJnZXRDb250YWluZXJOYW1lXG4gICAqL1xuICByZWFkb25seSB0YXJnZXRDb250YWluZXJOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbDogUGF0aCBhdCB3aGljaCB0aGUgZmlsZSB0byB3aGljaCB0aGUgY29udGFpbmVyJ3MgdGVybWluYXRpb24gbWVzc2FnZSB3aWxsIGJlIHdyaXR0ZW4gaXMgbW91bnRlZCBpbnRvIHRoZSBjb250YWluZXIncyBmaWxlc3lzdGVtLiBNZXNzYWdlIHdyaXR0ZW4gaXMgaW50ZW5kZWQgdG8gYmUgYnJpZWYgZmluYWwgc3RhdHVzLCBzdWNoIGFzIGFuIGFzc2VydGlvbiBmYWlsdXJlIG1lc3NhZ2UuIFdpbGwgYmUgdHJ1bmNhdGVkIGJ5IHRoZSBub2RlIGlmIGdyZWF0ZXIgdGhhbiA0MDk2IGJ5dGVzLiBUaGUgdG90YWwgbWVzc2FnZSBsZW5ndGggYWNyb3NzIGFsbCBjb250YWluZXJzIHdpbGwgYmUgbGltaXRlZCB0byAxMmtiLiBEZWZhdWx0cyB0byAvZGV2L3Rlcm1pbmF0aW9uLWxvZy4gQ2Fubm90IGJlIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IGRldi90ZXJtaW5hdGlvbi1sb2cuIENhbm5vdCBiZSB1cGRhdGVkLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FcGhlbWVyYWxDb250YWluZXIjdGVybWluYXRpb25NZXNzYWdlUGF0aFxuICAgKi9cbiAgcmVhZG9ubHkgdGVybWluYXRpb25NZXNzYWdlUGF0aD86IHN0cmluZztcblxuICAvKipcbiAgICogSW5kaWNhdGUgaG93IHRoZSB0ZXJtaW5hdGlvbiBtZXNzYWdlIHNob3VsZCBiZSBwb3B1bGF0ZWQuIEZpbGUgd2lsbCB1c2UgdGhlIGNvbnRlbnRzIG9mIHRlcm1pbmF0aW9uTWVzc2FnZVBhdGggdG8gcG9wdWxhdGUgdGhlIGNvbnRhaW5lciBzdGF0dXMgbWVzc2FnZSBvbiBib3RoIHN1Y2Nlc3MgYW5kIGZhaWx1cmUuIEZhbGxiYWNrVG9Mb2dzT25FcnJvciB3aWxsIHVzZSB0aGUgbGFzdCBjaHVuayBvZiBjb250YWluZXIgbG9nIG91dHB1dCBpZiB0aGUgdGVybWluYXRpb24gbWVzc2FnZSBmaWxlIGlzIGVtcHR5IGFuZCB0aGUgY29udGFpbmVyIGV4aXRlZCB3aXRoIGFuIGVycm9yLiBUaGUgbG9nIG91dHB1dCBpcyBsaW1pdGVkIHRvIDIwNDggYnl0ZXMgb3IgODAgbGluZXMsIHdoaWNoZXZlciBpcyBzbWFsbGVyLiBEZWZhdWx0cyB0byBGaWxlLiBDYW5ub3QgYmUgdXBkYXRlZC5cbiAgICpcbiAgICogQGRlZmF1bHQgRmlsZS4gQ2Fubm90IGJlIHVwZGF0ZWQuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkVwaGVtZXJhbENvbnRhaW5lciN0ZXJtaW5hdGlvbk1lc3NhZ2VQb2xpY3lcbiAgICovXG4gIHJlYWRvbmx5IHRlcm1pbmF0aW9uTWVzc2FnZVBvbGljeT86IHN0cmluZztcblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIGNvbnRhaW5lciBzaG91bGQgYWxsb2NhdGUgYSBUVFkgZm9yIGl0c2VsZiwgYWxzbyByZXF1aXJlcyAnc3RkaW4nIHRvIGJlIHRydWUuIERlZmF1bHQgaXMgZmFsc2UuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FcGhlbWVyYWxDb250YWluZXIjdHR5XG4gICAqL1xuICByZWFkb25seSB0dHk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiB2b2x1bWVEZXZpY2VzIGlzIHRoZSBsaXN0IG9mIGJsb2NrIGRldmljZXMgdG8gYmUgdXNlZCBieSB0aGUgY29udGFpbmVyLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FcGhlbWVyYWxDb250YWluZXIjdm9sdW1lRGV2aWNlc1xuICAgKi9cbiAgcmVhZG9ubHkgdm9sdW1lRGV2aWNlcz86IFZvbHVtZURldmljZVtdO1xuXG4gIC8qKlxuICAgKiBQb2Qgdm9sdW1lcyB0byBtb3VudCBpbnRvIHRoZSBjb250YWluZXIncyBmaWxlc3lzdGVtLiBDYW5ub3QgYmUgdXBkYXRlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRXBoZW1lcmFsQ29udGFpbmVyI3ZvbHVtZU1vdW50c1xuICAgKi9cbiAgcmVhZG9ubHkgdm9sdW1lTW91bnRzPzogVm9sdW1lTW91bnRbXTtcblxuICAvKipcbiAgICogQ29udGFpbmVyJ3Mgd29ya2luZyBkaXJlY3RvcnkuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBjb250YWluZXIgcnVudGltZSdzIGRlZmF1bHQgd2lsbCBiZSB1c2VkLCB3aGljaCBtaWdodCBiZSBjb25maWd1cmVkIGluIHRoZSBjb250YWluZXIgaW1hZ2UuIENhbm5vdCBiZSB1cGRhdGVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FcGhlbWVyYWxDb250YWluZXIjd29ya2luZ0RpclxuICAgKi9cbiAgcmVhZG9ubHkgd29ya2luZ0Rpcj86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdFcGhlbWVyYWxDb250YWluZXInIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0VwaGVtZXJhbENvbnRhaW5lcihvYmo6IEVwaGVtZXJhbENvbnRhaW5lciB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2FyZ3MnOiBvYmouYXJncz8ubWFwKHkgPT4geSksXG4gICAgJ2NvbW1hbmQnOiBvYmouY29tbWFuZD8ubWFwKHkgPT4geSksXG4gICAgJ2Vudic6IG9iai5lbnY/Lm1hcCh5ID0+IHRvSnNvbl9FbnZWYXIoeSkpLFxuICAgICdlbnZGcm9tJzogb2JqLmVudkZyb20/Lm1hcCh5ID0+IHRvSnNvbl9FbnZGcm9tU291cmNlKHkpKSxcbiAgICAnaW1hZ2UnOiBvYmouaW1hZ2UsXG4gICAgJ2ltYWdlUHVsbFBvbGljeSc6IG9iai5pbWFnZVB1bGxQb2xpY3ksXG4gICAgJ2xpZmVjeWNsZSc6IHRvSnNvbl9MaWZlY3ljbGUob2JqLmxpZmVjeWNsZSksXG4gICAgJ2xpdmVuZXNzUHJvYmUnOiB0b0pzb25fUHJvYmUob2JqLmxpdmVuZXNzUHJvYmUpLFxuICAgICduYW1lJzogb2JqLm5hbWUsXG4gICAgJ3BvcnRzJzogb2JqLnBvcnRzPy5tYXAoeSA9PiB0b0pzb25fQ29udGFpbmVyUG9ydCh5KSksXG4gICAgJ3JlYWRpbmVzc1Byb2JlJzogdG9Kc29uX1Byb2JlKG9iai5yZWFkaW5lc3NQcm9iZSksXG4gICAgJ3Jlc291cmNlcyc6IHRvSnNvbl9SZXNvdXJjZVJlcXVpcmVtZW50cyhvYmoucmVzb3VyY2VzKSxcbiAgICAnc2VjdXJpdHlDb250ZXh0JzogdG9Kc29uX1NlY3VyaXR5Q29udGV4dChvYmouc2VjdXJpdHlDb250ZXh0KSxcbiAgICAnc3RhcnR1cFByb2JlJzogdG9Kc29uX1Byb2JlKG9iai5zdGFydHVwUHJvYmUpLFxuICAgICdzdGRpbic6IG9iai5zdGRpbixcbiAgICAnc3RkaW5PbmNlJzogb2JqLnN0ZGluT25jZSxcbiAgICAndGFyZ2V0Q29udGFpbmVyTmFtZSc6IG9iai50YXJnZXRDb250YWluZXJOYW1lLFxuICAgICd0ZXJtaW5hdGlvbk1lc3NhZ2VQYXRoJzogb2JqLnRlcm1pbmF0aW9uTWVzc2FnZVBhdGgsXG4gICAgJ3Rlcm1pbmF0aW9uTWVzc2FnZVBvbGljeSc6IG9iai50ZXJtaW5hdGlvbk1lc3NhZ2VQb2xpY3ksXG4gICAgJ3R0eSc6IG9iai50dHksXG4gICAgJ3ZvbHVtZURldmljZXMnOiBvYmoudm9sdW1lRGV2aWNlcz8ubWFwKHkgPT4gdG9Kc29uX1ZvbHVtZURldmljZSh5KSksXG4gICAgJ3ZvbHVtZU1vdW50cyc6IG9iai52b2x1bWVNb3VudHM/Lm1hcCh5ID0+IHRvSnNvbl9Wb2x1bWVNb3VudCh5KSksXG4gICAgJ3dvcmtpbmdEaXInOiBvYmoud29ya2luZ0RpcixcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBIb3N0QWxpYXMgaG9sZHMgdGhlIG1hcHBpbmcgYmV0d2VlbiBJUCBhbmQgaG9zdG5hbWVzIHRoYXQgd2lsbCBiZSBpbmplY3RlZCBhcyBhbiBlbnRyeSBpbiB0aGUgcG9kJ3MgaG9zdHMgZmlsZS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Ib3N0QWxpYXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIb3N0QWxpYXMge1xuICAvKipcbiAgICogSG9zdG5hbWVzIGZvciB0aGUgYWJvdmUgSVAgYWRkcmVzcy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuSG9zdEFsaWFzI2hvc3RuYW1lc1xuICAgKi9cbiAgcmVhZG9ubHkgaG9zdG5hbWVzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIElQIGFkZHJlc3Mgb2YgdGhlIGhvc3QgZmlsZSBlbnRyeS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuSG9zdEFsaWFzI2lwXG4gICAqL1xuICByZWFkb25seSBpcD86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdIb3N0QWxpYXMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0hvc3RBbGlhcyhvYmo6IEhvc3RBbGlhcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2hvc3RuYW1lcyc6IG9iai5ob3N0bmFtZXM/Lm1hcCh5ID0+IHkpLFxuICAgICdpcCc6IG9iai5pcCxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBQb2RSZWFkaW5lc3NHYXRlIGNvbnRhaW5zIHRoZSByZWZlcmVuY2UgdG8gYSBwb2QgY29uZGl0aW9uXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kUmVhZGluZXNzR2F0ZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBvZFJlYWRpbmVzc0dhdGUge1xuICAvKipcbiAgICogQ29uZGl0aW9uVHlwZSByZWZlcnMgdG8gYSBjb25kaXRpb24gaW4gdGhlIHBvZCdzIGNvbmRpdGlvbiBsaXN0IHdpdGggbWF0Y2hpbmcgdHlwZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kUmVhZGluZXNzR2F0ZSNjb25kaXRpb25UeXBlXG4gICAqL1xuICByZWFkb25seSBjb25kaXRpb25UeXBlOiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnUG9kUmVhZGluZXNzR2F0ZScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fUG9kUmVhZGluZXNzR2F0ZShvYmo6IFBvZFJlYWRpbmVzc0dhdGUgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdjb25kaXRpb25UeXBlJzogb2JqLmNvbmRpdGlvblR5cGUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUG9kU2VjdXJpdHlDb250ZXh0IGhvbGRzIHBvZC1sZXZlbCBzZWN1cml0eSBhdHRyaWJ1dGVzIGFuZCBjb21tb24gY29udGFpbmVyIHNldHRpbmdzLiBTb21lIGZpZWxkcyBhcmUgYWxzbyBwcmVzZW50IGluIGNvbnRhaW5lci5zZWN1cml0eUNvbnRleHQuICBGaWVsZCB2YWx1ZXMgb2YgY29udGFpbmVyLnNlY3VyaXR5Q29udGV4dCB0YWtlIHByZWNlZGVuY2Ugb3ZlciBmaWVsZCB2YWx1ZXMgb2YgUG9kU2VjdXJpdHlDb250ZXh0LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZFNlY3VyaXR5Q29udGV4dFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBvZFNlY3VyaXR5Q29udGV4dCB7XG4gIC8qKlxuICAgKiBBIHNwZWNpYWwgc3VwcGxlbWVudGFsIGdyb3VwIHRoYXQgYXBwbGllcyB0byBhbGwgY29udGFpbmVycyBpbiBhIHBvZC4gU29tZSB2b2x1bWUgdHlwZXMgYWxsb3cgdGhlIEt1YmVsZXQgdG8gY2hhbmdlIHRoZSBvd25lcnNoaXAgb2YgdGhhdCB2b2x1bWUgdG8gYmUgb3duZWQgYnkgdGhlIHBvZDpcbiAgICpcbiAgICogMS4gVGhlIG93bmluZyBHSUQgd2lsbCBiZSB0aGUgRlNHcm91cCAyLiBUaGUgc2V0Z2lkIGJpdCBpcyBzZXQgKG5ldyBmaWxlcyBjcmVhdGVkIGluIHRoZSB2b2x1bWUgd2lsbCBiZSBvd25lZCBieSBGU0dyb3VwKSAzLiBUaGUgcGVybWlzc2lvbiBiaXRzIGFyZSBPUidkIHdpdGggcnctcnctLS0tXG4gICAqXG4gICAqIElmIHVuc2V0LCB0aGUgS3ViZWxldCB3aWxsIG5vdCBtb2RpZnkgdGhlIG93bmVyc2hpcCBhbmQgcGVybWlzc2lvbnMgb2YgYW55IHZvbHVtZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kU2VjdXJpdHlDb250ZXh0I2ZzR3JvdXBcbiAgICovXG4gIHJlYWRvbmx5IGZzR3JvdXA/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIGZzR3JvdXBDaGFuZ2VQb2xpY3kgZGVmaW5lcyBiZWhhdmlvciBvZiBjaGFuZ2luZyBvd25lcnNoaXAgYW5kIHBlcm1pc3Npb24gb2YgdGhlIHZvbHVtZSBiZWZvcmUgYmVpbmcgZXhwb3NlZCBpbnNpZGUgUG9kLiBUaGlzIGZpZWxkIHdpbGwgb25seSBhcHBseSB0byB2b2x1bWUgdHlwZXMgd2hpY2ggc3VwcG9ydCBmc0dyb3VwIGJhc2VkIG93bmVyc2hpcChhbmQgcGVybWlzc2lvbnMpLiBJdCB3aWxsIGhhdmUgbm8gZWZmZWN0IG9uIGVwaGVtZXJhbCB2b2x1bWUgdHlwZXMgc3VjaCBhczogc2VjcmV0LCBjb25maWdtYXBzIGFuZCBlbXB0eWRpci4gVmFsaWQgdmFsdWVzIGFyZSBcIk9uUm9vdE1pc21hdGNoXCIgYW5kIFwiQWx3YXlzXCIuIElmIG5vdCBzcGVjaWZpZWQsIFwiQWx3YXlzXCIgaXMgdXNlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kU2VjdXJpdHlDb250ZXh0I2ZzR3JvdXBDaGFuZ2VQb2xpY3lcbiAgICovXG4gIHJlYWRvbmx5IGZzR3JvdXBDaGFuZ2VQb2xpY3k/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBHSUQgdG8gcnVuIHRoZSBlbnRyeXBvaW50IG9mIHRoZSBjb250YWluZXIgcHJvY2Vzcy4gVXNlcyBydW50aW1lIGRlZmF1bHQgaWYgdW5zZXQuIE1heSBhbHNvIGJlIHNldCBpbiBTZWN1cml0eUNvbnRleHQuICBJZiBzZXQgaW4gYm90aCBTZWN1cml0eUNvbnRleHQgYW5kIFBvZFNlY3VyaXR5Q29udGV4dCwgdGhlIHZhbHVlIHNwZWNpZmllZCBpbiBTZWN1cml0eUNvbnRleHQgdGFrZXMgcHJlY2VkZW5jZSBmb3IgdGhhdCBjb250YWluZXIuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZFNlY3VyaXR5Q29udGV4dCNydW5Bc0dyb3VwXG4gICAqL1xuICByZWFkb25seSBydW5Bc0dyb3VwPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgY29udGFpbmVyIG11c3QgcnVuIGFzIGEgbm9uLXJvb3QgdXNlci4gSWYgdHJ1ZSwgdGhlIEt1YmVsZXQgd2lsbCB2YWxpZGF0ZSB0aGUgaW1hZ2UgYXQgcnVudGltZSB0byBlbnN1cmUgdGhhdCBpdCBkb2VzIG5vdCBydW4gYXMgVUlEIDAgKHJvb3QpIGFuZCBmYWlsIHRvIHN0YXJ0IHRoZSBjb250YWluZXIgaWYgaXQgZG9lcy4gSWYgdW5zZXQgb3IgZmFsc2UsIG5vIHN1Y2ggdmFsaWRhdGlvbiB3aWxsIGJlIHBlcmZvcm1lZC4gTWF5IGFsc28gYmUgc2V0IGluIFNlY3VyaXR5Q29udGV4dC4gIElmIHNldCBpbiBib3RoIFNlY3VyaXR5Q29udGV4dCBhbmQgUG9kU2VjdXJpdHlDb250ZXh0LCB0aGUgdmFsdWUgc3BlY2lmaWVkIGluIFNlY3VyaXR5Q29udGV4dCB0YWtlcyBwcmVjZWRlbmNlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RTZWN1cml0eUNvbnRleHQjcnVuQXNOb25Sb290XG4gICAqL1xuICByZWFkb25seSBydW5Bc05vblJvb3Q/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUaGUgVUlEIHRvIHJ1biB0aGUgZW50cnlwb2ludCBvZiB0aGUgY29udGFpbmVyIHByb2Nlc3MuIERlZmF1bHRzIHRvIHVzZXIgc3BlY2lmaWVkIGluIGltYWdlIG1ldGFkYXRhIGlmIHVuc3BlY2lmaWVkLiBNYXkgYWxzbyBiZSBzZXQgaW4gU2VjdXJpdHlDb250ZXh0LiAgSWYgc2V0IGluIGJvdGggU2VjdXJpdHlDb250ZXh0IGFuZCBQb2RTZWN1cml0eUNvbnRleHQsIHRoZSB2YWx1ZSBzcGVjaWZpZWQgaW4gU2VjdXJpdHlDb250ZXh0IHRha2VzIHByZWNlZGVuY2UgZm9yIHRoYXQgY29udGFpbmVyLlxuICAgKlxuICAgKiBAZGVmYXVsdCB1c2VyIHNwZWNpZmllZCBpbiBpbWFnZSBtZXRhZGF0YSBpZiB1bnNwZWNpZmllZC4gTWF5IGFsc28gYmUgc2V0IGluIFNlY3VyaXR5Q29udGV4dC4gIElmIHNldCBpbiBib3RoIFNlY3VyaXR5Q29udGV4dCBhbmQgUG9kU2VjdXJpdHlDb250ZXh0LCB0aGUgdmFsdWUgc3BlY2lmaWVkIGluIFNlY3VyaXR5Q29udGV4dCB0YWtlcyBwcmVjZWRlbmNlIGZvciB0aGF0IGNvbnRhaW5lci5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kU2VjdXJpdHlDb250ZXh0I3J1bkFzVXNlclxuICAgKi9cbiAgcmVhZG9ubHkgcnVuQXNVc2VyPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgU0VMaW51eCBjb250ZXh0IHRvIGJlIGFwcGxpZWQgdG8gYWxsIGNvbnRhaW5lcnMuIElmIHVuc3BlY2lmaWVkLCB0aGUgY29udGFpbmVyIHJ1bnRpbWUgd2lsbCBhbGxvY2F0ZSBhIHJhbmRvbSBTRUxpbnV4IGNvbnRleHQgZm9yIGVhY2ggY29udGFpbmVyLiAgTWF5IGFsc28gYmUgc2V0IGluIFNlY3VyaXR5Q29udGV4dC4gIElmIHNldCBpbiBib3RoIFNlY3VyaXR5Q29udGV4dCBhbmQgUG9kU2VjdXJpdHlDb250ZXh0LCB0aGUgdmFsdWUgc3BlY2lmaWVkIGluIFNlY3VyaXR5Q29udGV4dCB0YWtlcyBwcmVjZWRlbmNlIGZvciB0aGF0IGNvbnRhaW5lci5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kU2VjdXJpdHlDb250ZXh0I3NlTGludXhPcHRpb25zXG4gICAqL1xuICByZWFkb25seSBzZUxpbnV4T3B0aW9ucz86IFNlTGludXhPcHRpb25zO1xuXG4gIC8qKlxuICAgKiBUaGUgc2VjY29tcCBvcHRpb25zIHRvIHVzZSBieSB0aGUgY29udGFpbmVycyBpbiB0aGlzIHBvZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kU2VjdXJpdHlDb250ZXh0I3NlY2NvbXBQcm9maWxlXG4gICAqL1xuICByZWFkb25seSBzZWNjb21wUHJvZmlsZT86IFNlY2NvbXBQcm9maWxlO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgZ3JvdXBzIGFwcGxpZWQgdG8gdGhlIGZpcnN0IHByb2Nlc3MgcnVuIGluIGVhY2ggY29udGFpbmVyLCBpbiBhZGRpdGlvbiB0byB0aGUgY29udGFpbmVyJ3MgcHJpbWFyeSBHSUQuICBJZiB1bnNwZWNpZmllZCwgbm8gZ3JvdXBzIHdpbGwgYmUgYWRkZWQgdG8gYW55IGNvbnRhaW5lci5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kU2VjdXJpdHlDb250ZXh0I3N1cHBsZW1lbnRhbEdyb3Vwc1xuICAgKi9cbiAgcmVhZG9ubHkgc3VwcGxlbWVudGFsR3JvdXBzPzogbnVtYmVyW107XG5cbiAgLyoqXG4gICAqIFN5c2N0bHMgaG9sZCBhIGxpc3Qgb2YgbmFtZXNwYWNlZCBzeXNjdGxzIHVzZWQgZm9yIHRoZSBwb2QuIFBvZHMgd2l0aCB1bnN1cHBvcnRlZCBzeXNjdGxzIChieSB0aGUgY29udGFpbmVyIHJ1bnRpbWUpIG1pZ2h0IGZhaWwgdG8gbGF1bmNoLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RTZWN1cml0eUNvbnRleHQjc3lzY3Rsc1xuICAgKi9cbiAgcmVhZG9ubHkgc3lzY3Rscz86IFN5c2N0bFtdO1xuXG4gIC8qKlxuICAgKiBUaGUgV2luZG93cyBzcGVjaWZpYyBzZXR0aW5ncyBhcHBsaWVkIHRvIGFsbCBjb250YWluZXJzLiBJZiB1bnNwZWNpZmllZCwgdGhlIG9wdGlvbnMgd2l0aGluIGEgY29udGFpbmVyJ3MgU2VjdXJpdHlDb250ZXh0IHdpbGwgYmUgdXNlZC4gSWYgc2V0IGluIGJvdGggU2VjdXJpdHlDb250ZXh0IGFuZCBQb2RTZWN1cml0eUNvbnRleHQsIHRoZSB2YWx1ZSBzcGVjaWZpZWQgaW4gU2VjdXJpdHlDb250ZXh0IHRha2VzIHByZWNlZGVuY2UuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZFNlY3VyaXR5Q29udGV4dCN3aW5kb3dzT3B0aW9uc1xuICAgKi9cbiAgcmVhZG9ubHkgd2luZG93c09wdGlvbnM/OiBXaW5kb3dzU2VjdXJpdHlDb250ZXh0T3B0aW9ucztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdQb2RTZWN1cml0eUNvbnRleHQnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1BvZFNlY3VyaXR5Q29udGV4dChvYmo6IFBvZFNlY3VyaXR5Q29udGV4dCB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2ZzR3JvdXAnOiBvYmouZnNHcm91cCxcbiAgICAnZnNHcm91cENoYW5nZVBvbGljeSc6IG9iai5mc0dyb3VwQ2hhbmdlUG9saWN5LFxuICAgICdydW5Bc0dyb3VwJzogb2JqLnJ1bkFzR3JvdXAsXG4gICAgJ3J1bkFzTm9uUm9vdCc6IG9iai5ydW5Bc05vblJvb3QsXG4gICAgJ3J1bkFzVXNlcic6IG9iai5ydW5Bc1VzZXIsXG4gICAgJ3NlTGludXhPcHRpb25zJzogdG9Kc29uX1NlTGludXhPcHRpb25zKG9iai5zZUxpbnV4T3B0aW9ucyksXG4gICAgJ3NlY2NvbXBQcm9maWxlJzogdG9Kc29uX1NlY2NvbXBQcm9maWxlKG9iai5zZWNjb21wUHJvZmlsZSksXG4gICAgJ3N1cHBsZW1lbnRhbEdyb3Vwcyc6IG9iai5zdXBwbGVtZW50YWxHcm91cHM/Lm1hcCh5ID0+IHkpLFxuICAgICdzeXNjdGxzJzogb2JqLnN5c2N0bHM/Lm1hcCh5ID0+IHRvSnNvbl9TeXNjdGwoeSkpLFxuICAgICd3aW5kb3dzT3B0aW9ucyc6IHRvSnNvbl9XaW5kb3dzU2VjdXJpdHlDb250ZXh0T3B0aW9ucyhvYmoud2luZG93c09wdGlvbnMpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFRoZSBwb2QgdGhpcyBUb2xlcmF0aW9uIGlzIGF0dGFjaGVkIHRvIHRvbGVyYXRlcyBhbnkgdGFpbnQgdGhhdCBtYXRjaGVzIHRoZSB0cmlwbGUgPGtleSx2YWx1ZSxlZmZlY3Q+IHVzaW5nIHRoZSBtYXRjaGluZyBvcGVyYXRvciA8b3BlcmF0b3I+LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlRvbGVyYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUb2xlcmF0aW9uIHtcbiAgLyoqXG4gICAqIEVmZmVjdCBpbmRpY2F0ZXMgdGhlIHRhaW50IGVmZmVjdCB0byBtYXRjaC4gRW1wdHkgbWVhbnMgbWF0Y2ggYWxsIHRhaW50IGVmZmVjdHMuIFdoZW4gc3BlY2lmaWVkLCBhbGxvd2VkIHZhbHVlcyBhcmUgTm9TY2hlZHVsZSwgUHJlZmVyTm9TY2hlZHVsZSBhbmQgTm9FeGVjdXRlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Ub2xlcmF0aW9uI2VmZmVjdFxuICAgKi9cbiAgcmVhZG9ubHkgZWZmZWN0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBLZXkgaXMgdGhlIHRhaW50IGtleSB0aGF0IHRoZSB0b2xlcmF0aW9uIGFwcGxpZXMgdG8uIEVtcHR5IG1lYW5zIG1hdGNoIGFsbCB0YWludCBrZXlzLiBJZiB0aGUga2V5IGlzIGVtcHR5LCBvcGVyYXRvciBtdXN0IGJlIEV4aXN0czsgdGhpcyBjb21iaW5hdGlvbiBtZWFucyB0byBtYXRjaCBhbGwgdmFsdWVzIGFuZCBhbGwga2V5cy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVG9sZXJhdGlvbiNrZXlcbiAgICovXG4gIHJlYWRvbmx5IGtleT86IHN0cmluZztcblxuICAvKipcbiAgICogT3BlcmF0b3IgcmVwcmVzZW50cyBhIGtleSdzIHJlbGF0aW9uc2hpcCB0byB0aGUgdmFsdWUuIFZhbGlkIG9wZXJhdG9ycyBhcmUgRXhpc3RzIGFuZCBFcXVhbC4gRGVmYXVsdHMgdG8gRXF1YWwuIEV4aXN0cyBpcyBlcXVpdmFsZW50IHRvIHdpbGRjYXJkIGZvciB2YWx1ZSwgc28gdGhhdCBhIHBvZCBjYW4gdG9sZXJhdGUgYWxsIHRhaW50cyBvZiBhIHBhcnRpY3VsYXIgY2F0ZWdvcnkuXG4gICAqXG4gICAqIEBkZWZhdWx0IEVxdWFsLiBFeGlzdHMgaXMgZXF1aXZhbGVudCB0byB3aWxkY2FyZCBmb3IgdmFsdWUsIHNvIHRoYXQgYSBwb2QgY2FuIHRvbGVyYXRlIGFsbCB0YWludHMgb2YgYSBwYXJ0aWN1bGFyIGNhdGVnb3J5LlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Ub2xlcmF0aW9uI29wZXJhdG9yXG4gICAqL1xuICByZWFkb25seSBvcGVyYXRvcj86IHN0cmluZztcblxuICAvKipcbiAgICogVG9sZXJhdGlvblNlY29uZHMgcmVwcmVzZW50cyB0aGUgcGVyaW9kIG9mIHRpbWUgdGhlIHRvbGVyYXRpb24gKHdoaWNoIG11c3QgYmUgb2YgZWZmZWN0IE5vRXhlY3V0ZSwgb3RoZXJ3aXNlIHRoaXMgZmllbGQgaXMgaWdub3JlZCkgdG9sZXJhdGVzIHRoZSB0YWludC4gQnkgZGVmYXVsdCwgaXQgaXMgbm90IHNldCwgd2hpY2ggbWVhbnMgdG9sZXJhdGUgdGhlIHRhaW50IGZvcmV2ZXIgKGRvIG5vdCBldmljdCkuIFplcm8gYW5kIG5lZ2F0aXZlIHZhbHVlcyB3aWxsIGJlIHRyZWF0ZWQgYXMgMCAoZXZpY3QgaW1tZWRpYXRlbHkpIGJ5IHRoZSBzeXN0ZW0uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlRvbGVyYXRpb24jdG9sZXJhdGlvblNlY29uZHNcbiAgICovXG4gIHJlYWRvbmx5IHRvbGVyYXRpb25TZWNvbmRzPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBWYWx1ZSBpcyB0aGUgdGFpbnQgdmFsdWUgdGhlIHRvbGVyYXRpb24gbWF0Y2hlcyB0by4gSWYgdGhlIG9wZXJhdG9yIGlzIEV4aXN0cywgdGhlIHZhbHVlIHNob3VsZCBiZSBlbXB0eSwgb3RoZXJ3aXNlIGp1c3QgYSByZWd1bGFyIHN0cmluZy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVG9sZXJhdGlvbiN2YWx1ZVxuICAgKi9cbiAgcmVhZG9ubHkgdmFsdWU/OiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnVG9sZXJhdGlvbicgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fVG9sZXJhdGlvbihvYmo6IFRvbGVyYXRpb24gfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdlZmZlY3QnOiBvYmouZWZmZWN0LFxuICAgICdrZXknOiBvYmoua2V5LFxuICAgICdvcGVyYXRvcic6IG9iai5vcGVyYXRvcixcbiAgICAndG9sZXJhdGlvblNlY29uZHMnOiBvYmoudG9sZXJhdGlvblNlY29uZHMsXG4gICAgJ3ZhbHVlJzogb2JqLnZhbHVlLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFRvcG9sb2d5U3ByZWFkQ29uc3RyYWludCBzcGVjaWZpZXMgaG93IHRvIHNwcmVhZCBtYXRjaGluZyBwb2RzIGFtb25nIHRoZSBnaXZlbiB0b3BvbG9neS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Ub3BvbG9neVNwcmVhZENvbnN0cmFpbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUb3BvbG9neVNwcmVhZENvbnN0cmFpbnQge1xuICAvKipcbiAgICogTGFiZWxTZWxlY3RvciBpcyB1c2VkIHRvIGZpbmQgbWF0Y2hpbmcgcG9kcy4gUG9kcyB0aGF0IG1hdGNoIHRoaXMgbGFiZWwgc2VsZWN0b3IgYXJlIGNvdW50ZWQgdG8gZGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgcG9kcyBpbiB0aGVpciBjb3JyZXNwb25kaW5nIHRvcG9sb2d5IGRvbWFpbi5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVG9wb2xvZ3lTcHJlYWRDb25zdHJhaW50I2xhYmVsU2VsZWN0b3JcbiAgICovXG4gIHJlYWRvbmx5IGxhYmVsU2VsZWN0b3I/OiBMYWJlbFNlbGVjdG9yO1xuXG4gIC8qKlxuICAgKiBNYXhTa2V3IGRlc2NyaWJlcyB0aGUgZGVncmVlIHRvIHdoaWNoIHBvZHMgbWF5IGJlIHVuZXZlbmx5IGRpc3RyaWJ1dGVkLiBXaGVuIGB3aGVuVW5zYXRpc2ZpYWJsZT1Eb05vdFNjaGVkdWxlYCwgaXQgaXMgdGhlIG1heGltdW0gcGVybWl0dGVkIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbnVtYmVyIG9mIG1hdGNoaW5nIHBvZHMgaW4gdGhlIHRhcmdldCB0b3BvbG9neSBhbmQgdGhlIGdsb2JhbCBtaW5pbXVtLiBGb3IgZXhhbXBsZSwgaW4gYSAzLXpvbmUgY2x1c3RlciwgTWF4U2tldyBpcyBzZXQgdG8gMSwgYW5kIHBvZHMgd2l0aCB0aGUgc2FtZSBsYWJlbFNlbGVjdG9yIHNwcmVhZCBhcyAxLzEvMDogfCB6b25lMSB8IHpvbmUyIHwgem9uZTMgfCB8ICAgUCAgIHwgICBQICAgfCAgICAgICB8IC0gaWYgTWF4U2tldyBpcyAxLCBpbmNvbWluZyBwb2QgY2FuIG9ubHkgYmUgc2NoZWR1bGVkIHRvIHpvbmUzIHRvIGJlY29tZSAxLzEvMTsgc2NoZWR1bGluZyBpdCBvbnRvIHpvbmUxKHpvbmUyKSB3b3VsZCBtYWtlIHRoZSBBY3R1YWxTa2V3KDItMCkgb24gem9uZTEoem9uZTIpIHZpb2xhdGUgTWF4U2tldygxKS4gLSBpZiBNYXhTa2V3IGlzIDIsIGluY29taW5nIHBvZCBjYW4gYmUgc2NoZWR1bGVkIG9udG8gYW55IHpvbmUuIFdoZW4gYHdoZW5VbnNhdGlzZmlhYmxlPVNjaGVkdWxlQW55d2F5YCwgaXQgaXMgdXNlZCB0byBnaXZlIGhpZ2hlciBwcmVjZWRlbmNlIHRvIHRvcG9sb2dpZXMgdGhhdCBzYXRpc2Z5IGl0LiBJdCdzIGEgcmVxdWlyZWQgZmllbGQuIERlZmF1bHQgdmFsdWUgaXMgMSBhbmQgMCBpcyBub3QgYWxsb3dlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVG9wb2xvZ3lTcHJlYWRDb25zdHJhaW50I21heFNrZXdcbiAgICovXG4gIHJlYWRvbmx5IG1heFNrZXc6IG51bWJlcjtcblxuICAvKipcbiAgICogVG9wb2xvZ3lLZXkgaXMgdGhlIGtleSBvZiBub2RlIGxhYmVscy4gTm9kZXMgdGhhdCBoYXZlIGEgbGFiZWwgd2l0aCB0aGlzIGtleSBhbmQgaWRlbnRpY2FsIHZhbHVlcyBhcmUgY29uc2lkZXJlZCB0byBiZSBpbiB0aGUgc2FtZSB0b3BvbG9neS4gV2UgY29uc2lkZXIgZWFjaCA8a2V5LCB2YWx1ZT4gYXMgYSBcImJ1Y2tldFwiLCBhbmQgdHJ5IHRvIHB1dCBiYWxhbmNlZCBudW1iZXIgb2YgcG9kcyBpbnRvIGVhY2ggYnVja2V0LiBJdCdzIGEgcmVxdWlyZWQgZmllbGQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlRvcG9sb2d5U3ByZWFkQ29uc3RyYWludCN0b3BvbG9neUtleVxuICAgKi9cbiAgcmVhZG9ubHkgdG9wb2xvZ3lLZXk6IHN0cmluZztcblxuICAvKipcbiAgICogV2hlblVuc2F0aXNmaWFibGUgaW5kaWNhdGVzIGhvdyB0byBkZWFsIHdpdGggYSBwb2QgaWYgaXQgZG9lc24ndCBzYXRpc2Z5IHRoZSBzcHJlYWQgY29uc3RyYWludC4gLSBEb05vdFNjaGVkdWxlIChkZWZhdWx0KSB0ZWxscyB0aGUgc2NoZWR1bGVyIG5vdCB0byBzY2hlZHVsZSBpdC4gLSBTY2hlZHVsZUFueXdheSB0ZWxscyB0aGUgc2NoZWR1bGVyIHRvIHNjaGVkdWxlIHRoZSBwb2QgaW4gYW55IGxvY2F0aW9uLFxuICAgKiBidXQgZ2l2aW5nIGhpZ2hlciBwcmVjZWRlbmNlIHRvIHRvcG9sb2dpZXMgdGhhdCB3b3VsZCBoZWxwIHJlZHVjZSB0aGVcbiAgICogc2tldy5cbiAgICogQSBjb25zdHJhaW50IGlzIGNvbnNpZGVyZWQgXCJVbnNhdGlzZmlhYmxlXCIgZm9yIGFuIGluY29taW5nIHBvZCBpZiBhbmQgb25seSBpZiBldmVyeSBwb3NzaWJsZSBub2RlIGFzc2lnbWVudCBmb3IgdGhhdCBwb2Qgd291bGQgdmlvbGF0ZSBcIk1heFNrZXdcIiBvbiBzb21lIHRvcG9sb2d5LiBGb3IgZXhhbXBsZSwgaW4gYSAzLXpvbmUgY2x1c3RlciwgTWF4U2tldyBpcyBzZXQgdG8gMSwgYW5kIHBvZHMgd2l0aCB0aGUgc2FtZSBsYWJlbFNlbGVjdG9yIHNwcmVhZCBhcyAzLzEvMTogfCB6b25lMSB8IHpvbmUyIHwgem9uZTMgfCB8IFAgUCBQIHwgICBQICAgfCAgIFAgICB8IElmIFdoZW5VbnNhdGlzZmlhYmxlIGlzIHNldCB0byBEb05vdFNjaGVkdWxlLCBpbmNvbWluZyBwb2QgY2FuIG9ubHkgYmUgc2NoZWR1bGVkIHRvIHpvbmUyKHpvbmUzKSB0byBiZWNvbWUgMy8yLzEoMy8xLzIpIGFzIEFjdHVhbFNrZXcoMi0xKSBvbiB6b25lMih6b25lMykgc2F0aXNmaWVzIE1heFNrZXcoMSkuIEluIG90aGVyIHdvcmRzLCB0aGUgY2x1c3RlciBjYW4gc3RpbGwgYmUgaW1iYWxhbmNlZCwgYnV0IHNjaGVkdWxlciB3b24ndCBtYWtlIGl0ICptb3JlKiBpbWJhbGFuY2VkLiBJdCdzIGEgcmVxdWlyZWQgZmllbGQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlRvcG9sb2d5U3ByZWFkQ29uc3RyYWludCN3aGVuVW5zYXRpc2ZpYWJsZVxuICAgKi9cbiAgcmVhZG9ubHkgd2hlblVuc2F0aXNmaWFibGU6IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdUb3BvbG9neVNwcmVhZENvbnN0cmFpbnQnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1RvcG9sb2d5U3ByZWFkQ29uc3RyYWludChvYmo6IFRvcG9sb2d5U3ByZWFkQ29uc3RyYWludCB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2xhYmVsU2VsZWN0b3InOiB0b0pzb25fTGFiZWxTZWxlY3RvcihvYmoubGFiZWxTZWxlY3RvciksXG4gICAgJ21heFNrZXcnOiBvYmoubWF4U2tldyxcbiAgICAndG9wb2xvZ3lLZXknOiBvYmoudG9wb2xvZ3lLZXksXG4gICAgJ3doZW5VbnNhdGlzZmlhYmxlJzogb2JqLndoZW5VbnNhdGlzZmlhYmxlLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFZvbHVtZSByZXByZXNlbnRzIGEgbmFtZWQgdm9sdW1lIGluIGEgcG9kIHRoYXQgbWF5IGJlIGFjY2Vzc2VkIGJ5IGFueSBjb250YWluZXIgaW4gdGhlIHBvZC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Wb2x1bWVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWb2x1bWUge1xuICAvKipcbiAgICogQVdTRWxhc3RpY0Jsb2NrU3RvcmUgcmVwcmVzZW50cyBhbiBBV1MgRGlzayByZXNvdXJjZSB0aGF0IGlzIGF0dGFjaGVkIHRvIGEga3ViZWxldCdzIGhvc3QgbWFjaGluZSBhbmQgdGhlbiBleHBvc2VkIHRvIHRoZSBwb2QuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvc3RvcmFnZS92b2x1bWVzI2F3c2VsYXN0aWNibG9ja3N0b3JlXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlZvbHVtZSNhd3NFbGFzdGljQmxvY2tTdG9yZVxuICAgKi9cbiAgcmVhZG9ubHkgYXdzRWxhc3RpY0Jsb2NrU3RvcmU/OiBBd3NFbGFzdGljQmxvY2tTdG9yZVZvbHVtZVNvdXJjZTtcblxuICAvKipcbiAgICogQXp1cmVEaXNrIHJlcHJlc2VudHMgYW4gQXp1cmUgRGF0YSBEaXNrIG1vdW50IG9uIHRoZSBob3N0IGFuZCBiaW5kIG1vdW50IHRvIHRoZSBwb2QuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlZvbHVtZSNhenVyZURpc2tcbiAgICovXG4gIHJlYWRvbmx5IGF6dXJlRGlzaz86IEF6dXJlRGlza1ZvbHVtZVNvdXJjZTtcblxuICAvKipcbiAgICogQXp1cmVGaWxlIHJlcHJlc2VudHMgYW4gQXp1cmUgRmlsZSBTZXJ2aWNlIG1vdW50IG9uIHRoZSBob3N0IGFuZCBiaW5kIG1vdW50IHRvIHRoZSBwb2QuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlZvbHVtZSNhenVyZUZpbGVcbiAgICovXG4gIHJlYWRvbmx5IGF6dXJlRmlsZT86IEF6dXJlRmlsZVZvbHVtZVNvdXJjZTtcblxuICAvKipcbiAgICogQ2VwaEZTIHJlcHJlc2VudHMgYSBDZXBoIEZTIG1vdW50IG9uIHRoZSBob3N0IHRoYXQgc2hhcmVzIGEgcG9kJ3MgbGlmZXRpbWVcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVm9sdW1lI2NlcGhmc1xuICAgKi9cbiAgcmVhZG9ubHkgY2VwaGZzPzogQ2VwaEZzVm9sdW1lU291cmNlO1xuXG4gIC8qKlxuICAgKiBDaW5kZXIgcmVwcmVzZW50cyBhIGNpbmRlciB2b2x1bWUgYXR0YWNoZWQgYW5kIG1vdW50ZWQgb24ga3ViZWxldHMgaG9zdCBtYWNoaW5lLiBNb3JlIGluZm86IGh0dHBzOi8vZXhhbXBsZXMuazhzLmlvL215c3FsLWNpbmRlci1wZC9SRUFETUUubWRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVm9sdW1lI2NpbmRlclxuICAgKi9cbiAgcmVhZG9ubHkgY2luZGVyPzogQ2luZGVyVm9sdW1lU291cmNlO1xuXG4gIC8qKlxuICAgKiBDb25maWdNYXAgcmVwcmVzZW50cyBhIGNvbmZpZ01hcCB0aGF0IHNob3VsZCBwb3B1bGF0ZSB0aGlzIHZvbHVtZVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Wb2x1bWUjY29uZmlnTWFwXG4gICAqL1xuICByZWFkb25seSBjb25maWdNYXA/OiBDb25maWdNYXBWb2x1bWVTb3VyY2U7XG5cbiAgLyoqXG4gICAqIENTSSAoQ29udGFpbmVyIFN0b3JhZ2UgSW50ZXJmYWNlKSByZXByZXNlbnRzIGVwaGVtZXJhbCBzdG9yYWdlIHRoYXQgaXMgaGFuZGxlZCBieSBjZXJ0YWluIGV4dGVybmFsIENTSSBkcml2ZXJzIChCZXRhIGZlYXR1cmUpLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Wb2x1bWUjY3NpXG4gICAqL1xuICByZWFkb25seSBjc2k/OiBDc2lWb2x1bWVTb3VyY2U7XG5cbiAgLyoqXG4gICAqIERvd253YXJkQVBJIHJlcHJlc2VudHMgZG93bndhcmQgQVBJIGFib3V0IHRoZSBwb2QgdGhhdCBzaG91bGQgcG9wdWxhdGUgdGhpcyB2b2x1bWVcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVm9sdW1lI2Rvd253YXJkQVBJXG4gICAqL1xuICByZWFkb25seSBkb3dud2FyZEFwaT86IERvd253YXJkQXBpVm9sdW1lU291cmNlO1xuXG4gIC8qKlxuICAgKiBFbXB0eURpciByZXByZXNlbnRzIGEgdGVtcG9yYXJ5IGRpcmVjdG9yeSB0aGF0IHNoYXJlcyBhIHBvZCdzIGxpZmV0aW1lLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2Uvdm9sdW1lcyNlbXB0eWRpclxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Wb2x1bWUjZW1wdHlEaXJcbiAgICovXG4gIHJlYWRvbmx5IGVtcHR5RGlyPzogRW1wdHlEaXJWb2x1bWVTb3VyY2U7XG5cbiAgLyoqXG4gICAqIEVwaGVtZXJhbCByZXByZXNlbnRzIGEgdm9sdW1lIHRoYXQgaXMgaGFuZGxlZCBieSBhIGNsdXN0ZXIgc3RvcmFnZSBkcml2ZXIuIFRoZSB2b2x1bWUncyBsaWZlY3ljbGUgaXMgdGllZCB0byB0aGUgcG9kIHRoYXQgZGVmaW5lcyBpdCAtIGl0IHdpbGwgYmUgY3JlYXRlZCBiZWZvcmUgdGhlIHBvZCBzdGFydHMsIGFuZCBkZWxldGVkIHdoZW4gdGhlIHBvZCBpcyByZW1vdmVkLlxuICAgKlxuICAgKiBVc2UgdGhpcyBpZjogYSkgdGhlIHZvbHVtZSBpcyBvbmx5IG5lZWRlZCB3aGlsZSB0aGUgcG9kIHJ1bnMsIGIpIGZlYXR1cmVzIG9mIG5vcm1hbCB2b2x1bWVzIGxpa2UgcmVzdG9yaW5nIGZyb20gc25hcHNob3Qgb3IgY2FwYWNpdHlcbiAgICogdHJhY2tpbmcgYXJlIG5lZWRlZCxcbiAgICogYykgdGhlIHN0b3JhZ2UgZHJpdmVyIGlzIHNwZWNpZmllZCB0aHJvdWdoIGEgc3RvcmFnZSBjbGFzcywgYW5kIGQpIHRoZSBzdG9yYWdlIGRyaXZlciBzdXBwb3J0cyBkeW5hbWljIHZvbHVtZSBwcm92aXNpb25pbmcgdGhyb3VnaFxuICAgKiBhIFBlcnNpc3RlbnRWb2x1bWVDbGFpbSAoc2VlIEVwaGVtZXJhbFZvbHVtZVNvdXJjZSBmb3IgbW9yZVxuICAgKiBpbmZvcm1hdGlvbiBvbiB0aGUgY29ubmVjdGlvbiBiZXR3ZWVuIHRoaXMgdm9sdW1lIHR5cGVcbiAgICogYW5kIFBlcnNpc3RlbnRWb2x1bWVDbGFpbSkuXG4gICAqXG4gICAqIFVzZSBQZXJzaXN0ZW50Vm9sdW1lQ2xhaW0gb3Igb25lIG9mIHRoZSB2ZW5kb3Itc3BlY2lmaWMgQVBJcyBmb3Igdm9sdW1lcyB0aGF0IHBlcnNpc3QgZm9yIGxvbmdlciB0aGFuIHRoZSBsaWZlY3ljbGUgb2YgYW4gaW5kaXZpZHVhbCBwb2QuXG4gICAqXG4gICAqIFVzZSBDU0kgZm9yIGxpZ2h0LXdlaWdodCBsb2NhbCBlcGhlbWVyYWwgdm9sdW1lcyBpZiB0aGUgQ1NJIGRyaXZlciBpcyBtZWFudCB0byBiZSB1c2VkIHRoYXQgd2F5IC0gc2VlIHRoZSBkb2N1bWVudGF0aW9uIG9mIHRoZSBkcml2ZXIgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEEgcG9kIGNhbiB1c2UgYm90aCB0eXBlcyBvZiBlcGhlbWVyYWwgdm9sdW1lcyBhbmQgcGVyc2lzdGVudCB2b2x1bWVzIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAqXG4gICAqIFRoaXMgaXMgYSBiZXRhIGZlYXR1cmUgYW5kIG9ubHkgYXZhaWxhYmxlIHdoZW4gdGhlIEdlbmVyaWNFcGhlbWVyYWxWb2x1bWUgZmVhdHVyZSBnYXRlIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlZvbHVtZSNlcGhlbWVyYWxcbiAgICovXG4gIHJlYWRvbmx5IGVwaGVtZXJhbD86IEVwaGVtZXJhbFZvbHVtZVNvdXJjZTtcblxuICAvKipcbiAgICogRkMgcmVwcmVzZW50cyBhIEZpYnJlIENoYW5uZWwgcmVzb3VyY2UgdGhhdCBpcyBhdHRhY2hlZCB0byBhIGt1YmVsZXQncyBob3N0IG1hY2hpbmUgYW5kIHRoZW4gZXhwb3NlZCB0byB0aGUgcG9kLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Wb2x1bWUjZmNcbiAgICovXG4gIHJlYWRvbmx5IGZjPzogRmNWb2x1bWVTb3VyY2U7XG5cbiAgLyoqXG4gICAqIEZsZXhWb2x1bWUgcmVwcmVzZW50cyBhIGdlbmVyaWMgdm9sdW1lIHJlc291cmNlIHRoYXQgaXMgcHJvdmlzaW9uZWQvYXR0YWNoZWQgdXNpbmcgYW4gZXhlYyBiYXNlZCBwbHVnaW4uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlZvbHVtZSNmbGV4Vm9sdW1lXG4gICAqL1xuICByZWFkb25seSBmbGV4Vm9sdW1lPzogRmxleFZvbHVtZVNvdXJjZTtcblxuICAvKipcbiAgICogRmxvY2tlciByZXByZXNlbnRzIGEgRmxvY2tlciB2b2x1bWUgYXR0YWNoZWQgdG8gYSBrdWJlbGV0J3MgaG9zdCBtYWNoaW5lLiBUaGlzIGRlcGVuZHMgb24gdGhlIEZsb2NrZXIgY29udHJvbCBzZXJ2aWNlIGJlaW5nIHJ1bm5pbmdcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVm9sdW1lI2Zsb2NrZXJcbiAgICovXG4gIHJlYWRvbmx5IGZsb2NrZXI/OiBGbG9ja2VyVm9sdW1lU291cmNlO1xuXG4gIC8qKlxuICAgKiBHQ0VQZXJzaXN0ZW50RGlzayByZXByZXNlbnRzIGEgR0NFIERpc2sgcmVzb3VyY2UgdGhhdCBpcyBhdHRhY2hlZCB0byBhIGt1YmVsZXQncyBob3N0IG1hY2hpbmUgYW5kIHRoZW4gZXhwb3NlZCB0byB0aGUgcG9kLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2Uvdm9sdW1lcyNnY2VwZXJzaXN0ZW50ZGlza1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Wb2x1bWUjZ2NlUGVyc2lzdGVudERpc2tcbiAgICovXG4gIHJlYWRvbmx5IGdjZVBlcnNpc3RlbnREaXNrPzogR2NlUGVyc2lzdGVudERpc2tWb2x1bWVTb3VyY2U7XG5cbiAgLyoqXG4gICAqIEdpdFJlcG8gcmVwcmVzZW50cyBhIGdpdCByZXBvc2l0b3J5IGF0IGEgcGFydGljdWxhciByZXZpc2lvbi4gREVQUkVDQVRFRDogR2l0UmVwbyBpcyBkZXByZWNhdGVkLiBUbyBwcm92aXNpb24gYSBjb250YWluZXIgd2l0aCBhIGdpdCByZXBvLCBtb3VudCBhbiBFbXB0eURpciBpbnRvIGFuIEluaXRDb250YWluZXIgdGhhdCBjbG9uZXMgdGhlIHJlcG8gdXNpbmcgZ2l0LCB0aGVuIG1vdW50IHRoZSBFbXB0eURpciBpbnRvIHRoZSBQb2QncyBjb250YWluZXIuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlZvbHVtZSNnaXRSZXBvXG4gICAqL1xuICByZWFkb25seSBnaXRSZXBvPzogR2l0UmVwb1ZvbHVtZVNvdXJjZTtcblxuICAvKipcbiAgICogR2x1c3RlcmZzIHJlcHJlc2VudHMgYSBHbHVzdGVyZnMgbW91bnQgb24gdGhlIGhvc3QgdGhhdCBzaGFyZXMgYSBwb2QncyBsaWZldGltZS4gTW9yZSBpbmZvOiBodHRwczovL2V4YW1wbGVzLms4cy5pby92b2x1bWVzL2dsdXN0ZXJmcy9SRUFETUUubWRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVm9sdW1lI2dsdXN0ZXJmc1xuICAgKi9cbiAgcmVhZG9ubHkgZ2x1c3RlcmZzPzogR2x1c3RlcmZzVm9sdW1lU291cmNlO1xuXG4gIC8qKlxuICAgKiBIb3N0UGF0aCByZXByZXNlbnRzIGEgcHJlLWV4aXN0aW5nIGZpbGUgb3IgZGlyZWN0b3J5IG9uIHRoZSBob3N0IG1hY2hpbmUgdGhhdCBpcyBkaXJlY3RseSBleHBvc2VkIHRvIHRoZSBjb250YWluZXIuIFRoaXMgaXMgZ2VuZXJhbGx5IHVzZWQgZm9yIHN5c3RlbSBhZ2VudHMgb3Igb3RoZXIgcHJpdmlsZWdlZCB0aGluZ3MgdGhhdCBhcmUgYWxsb3dlZCB0byBzZWUgdGhlIGhvc3QgbWFjaGluZS4gTW9zdCBjb250YWluZXJzIHdpbGwgTk9UIG5lZWQgdGhpcy4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3ZvbHVtZXMjaG9zdHBhdGhcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVm9sdW1lI2hvc3RQYXRoXG4gICAqL1xuICByZWFkb25seSBob3N0UGF0aD86IEhvc3RQYXRoVm9sdW1lU291cmNlO1xuXG4gIC8qKlxuICAgKiBJU0NTSSByZXByZXNlbnRzIGFuIElTQ1NJIERpc2sgcmVzb3VyY2UgdGhhdCBpcyBhdHRhY2hlZCB0byBhIGt1YmVsZXQncyBob3N0IG1hY2hpbmUgYW5kIHRoZW4gZXhwb3NlZCB0byB0aGUgcG9kLiBNb3JlIGluZm86IGh0dHBzOi8vZXhhbXBsZXMuazhzLmlvL3ZvbHVtZXMvaXNjc2kvUkVBRE1FLm1kXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlZvbHVtZSNpc2NzaVxuICAgKi9cbiAgcmVhZG9ubHkgaXNjc2k/OiBJc2NzaVZvbHVtZVNvdXJjZTtcblxuICAvKipcbiAgICogVm9sdW1lJ3MgbmFtZS4gTXVzdCBiZSBhIEROU19MQUJFTCBhbmQgdW5pcXVlIHdpdGhpbiB0aGUgcG9kLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL292ZXJ2aWV3L3dvcmtpbmctd2l0aC1vYmplY3RzL25hbWVzLyNuYW1lc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Wb2x1bWUjbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBORlMgcmVwcmVzZW50cyBhbiBORlMgbW91bnQgb24gdGhlIGhvc3QgdGhhdCBzaGFyZXMgYSBwb2QncyBsaWZldGltZSBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2Uvdm9sdW1lcyNuZnNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVm9sdW1lI25mc1xuICAgKi9cbiAgcmVhZG9ubHkgbmZzPzogTmZzVm9sdW1lU291cmNlO1xuXG4gIC8qKlxuICAgKiBQZXJzaXN0ZW50Vm9sdW1lQ2xhaW1Wb2x1bWVTb3VyY2UgcmVwcmVzZW50cyBhIHJlZmVyZW5jZSB0byBhIFBlcnNpc3RlbnRWb2x1bWVDbGFpbSBpbiB0aGUgc2FtZSBuYW1lc3BhY2UuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvc3RvcmFnZS9wZXJzaXN0ZW50LXZvbHVtZXMjcGVyc2lzdGVudHZvbHVtZWNsYWltc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Wb2x1bWUjcGVyc2lzdGVudFZvbHVtZUNsYWltXG4gICAqL1xuICByZWFkb25seSBwZXJzaXN0ZW50Vm9sdW1lQ2xhaW0/OiBQZXJzaXN0ZW50Vm9sdW1lQ2xhaW1Wb2x1bWVTb3VyY2U7XG5cbiAgLyoqXG4gICAqIFBob3RvblBlcnNpc3RlbnREaXNrIHJlcHJlc2VudHMgYSBQaG90b25Db250cm9sbGVyIHBlcnNpc3RlbnQgZGlzayBhdHRhY2hlZCBhbmQgbW91bnRlZCBvbiBrdWJlbGV0cyBob3N0IG1hY2hpbmVcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVm9sdW1lI3Bob3RvblBlcnNpc3RlbnREaXNrXG4gICAqL1xuICByZWFkb25seSBwaG90b25QZXJzaXN0ZW50RGlzaz86IFBob3RvblBlcnNpc3RlbnREaXNrVm9sdW1lU291cmNlO1xuXG4gIC8qKlxuICAgKiBQb3J0d29yeFZvbHVtZSByZXByZXNlbnRzIGEgcG9ydHdvcnggdm9sdW1lIGF0dGFjaGVkIGFuZCBtb3VudGVkIG9uIGt1YmVsZXRzIGhvc3QgbWFjaGluZVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Wb2x1bWUjcG9ydHdvcnhWb2x1bWVcbiAgICovXG4gIHJlYWRvbmx5IHBvcnR3b3J4Vm9sdW1lPzogUG9ydHdvcnhWb2x1bWVTb3VyY2U7XG5cbiAgLyoqXG4gICAqIEl0ZW1zIGZvciBhbGwgaW4gb25lIHJlc291cmNlcyBzZWNyZXRzLCBjb25maWdtYXBzLCBhbmQgZG93bndhcmQgQVBJXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlZvbHVtZSNwcm9qZWN0ZWRcbiAgICovXG4gIHJlYWRvbmx5IHByb2plY3RlZD86IFByb2plY3RlZFZvbHVtZVNvdXJjZTtcblxuICAvKipcbiAgICogUXVvYnl0ZSByZXByZXNlbnRzIGEgUXVvYnl0ZSBtb3VudCBvbiB0aGUgaG9zdCB0aGF0IHNoYXJlcyBhIHBvZCdzIGxpZmV0aW1lXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlZvbHVtZSNxdW9ieXRlXG4gICAqL1xuICByZWFkb25seSBxdW9ieXRlPzogUXVvYnl0ZVZvbHVtZVNvdXJjZTtcblxuICAvKipcbiAgICogUkJEIHJlcHJlc2VudHMgYSBSYWRvcyBCbG9jayBEZXZpY2UgbW91bnQgb24gdGhlIGhvc3QgdGhhdCBzaGFyZXMgYSBwb2QncyBsaWZldGltZS4gTW9yZSBpbmZvOiBodHRwczovL2V4YW1wbGVzLms4cy5pby92b2x1bWVzL3JiZC9SRUFETUUubWRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVm9sdW1lI3JiZFxuICAgKi9cbiAgcmVhZG9ubHkgcmJkPzogUmJkVm9sdW1lU291cmNlO1xuXG4gIC8qKlxuICAgKiBTY2FsZUlPIHJlcHJlc2VudHMgYSBTY2FsZUlPIHBlcnNpc3RlbnQgdm9sdW1lIGF0dGFjaGVkIGFuZCBtb3VudGVkIG9uIEt1YmVybmV0ZXMgbm9kZXMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlZvbHVtZSNzY2FsZUlPXG4gICAqL1xuICByZWFkb25seSBzY2FsZUlvPzogU2NhbGVJb1ZvbHVtZVNvdXJjZTtcblxuICAvKipcbiAgICogU2VjcmV0IHJlcHJlc2VudHMgYSBzZWNyZXQgdGhhdCBzaG91bGQgcG9wdWxhdGUgdGhpcyB2b2x1bWUuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvc3RvcmFnZS92b2x1bWVzI3NlY3JldFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Wb2x1bWUjc2VjcmV0XG4gICAqL1xuICByZWFkb25seSBzZWNyZXQ/OiBTZWNyZXRWb2x1bWVTb3VyY2U7XG5cbiAgLyoqXG4gICAqIFN0b3JhZ2VPUyByZXByZXNlbnRzIGEgU3RvcmFnZU9TIHZvbHVtZSBhdHRhY2hlZCBhbmQgbW91bnRlZCBvbiBLdWJlcm5ldGVzIG5vZGVzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Wb2x1bWUjc3RvcmFnZW9zXG4gICAqL1xuICByZWFkb25seSBzdG9yYWdlb3M/OiBTdG9yYWdlT3NWb2x1bWVTb3VyY2U7XG5cbiAgLyoqXG4gICAqIFZzcGhlcmVWb2x1bWUgcmVwcmVzZW50cyBhIHZTcGhlcmUgdm9sdW1lIGF0dGFjaGVkIGFuZCBtb3VudGVkIG9uIGt1YmVsZXRzIGhvc3QgbWFjaGluZVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Wb2x1bWUjdnNwaGVyZVZvbHVtZVxuICAgKi9cbiAgcmVhZG9ubHkgdnNwaGVyZVZvbHVtZT86IFZzcGhlcmVWaXJ0dWFsRGlza1ZvbHVtZVNvdXJjZTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdWb2x1bWUnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1ZvbHVtZShvYmo6IFZvbHVtZSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2F3c0VsYXN0aWNCbG9ja1N0b3JlJzogdG9Kc29uX0F3c0VsYXN0aWNCbG9ja1N0b3JlVm9sdW1lU291cmNlKG9iai5hd3NFbGFzdGljQmxvY2tTdG9yZSksXG4gICAgJ2F6dXJlRGlzayc6IHRvSnNvbl9BenVyZURpc2tWb2x1bWVTb3VyY2Uob2JqLmF6dXJlRGlzayksXG4gICAgJ2F6dXJlRmlsZSc6IHRvSnNvbl9BenVyZUZpbGVWb2x1bWVTb3VyY2Uob2JqLmF6dXJlRmlsZSksXG4gICAgJ2NlcGhmcyc6IHRvSnNvbl9DZXBoRnNWb2x1bWVTb3VyY2Uob2JqLmNlcGhmcyksXG4gICAgJ2NpbmRlcic6IHRvSnNvbl9DaW5kZXJWb2x1bWVTb3VyY2Uob2JqLmNpbmRlciksXG4gICAgJ2NvbmZpZ01hcCc6IHRvSnNvbl9Db25maWdNYXBWb2x1bWVTb3VyY2Uob2JqLmNvbmZpZ01hcCksXG4gICAgJ2NzaSc6IHRvSnNvbl9Dc2lWb2x1bWVTb3VyY2Uob2JqLmNzaSksXG4gICAgJ2Rvd253YXJkQVBJJzogdG9Kc29uX0Rvd253YXJkQXBpVm9sdW1lU291cmNlKG9iai5kb3dud2FyZEFwaSksXG4gICAgJ2VtcHR5RGlyJzogdG9Kc29uX0VtcHR5RGlyVm9sdW1lU291cmNlKG9iai5lbXB0eURpciksXG4gICAgJ2VwaGVtZXJhbCc6IHRvSnNvbl9FcGhlbWVyYWxWb2x1bWVTb3VyY2Uob2JqLmVwaGVtZXJhbCksXG4gICAgJ2ZjJzogdG9Kc29uX0ZjVm9sdW1lU291cmNlKG9iai5mYyksXG4gICAgJ2ZsZXhWb2x1bWUnOiB0b0pzb25fRmxleFZvbHVtZVNvdXJjZShvYmouZmxleFZvbHVtZSksXG4gICAgJ2Zsb2NrZXInOiB0b0pzb25fRmxvY2tlclZvbHVtZVNvdXJjZShvYmouZmxvY2tlciksXG4gICAgJ2djZVBlcnNpc3RlbnREaXNrJzogdG9Kc29uX0djZVBlcnNpc3RlbnREaXNrVm9sdW1lU291cmNlKG9iai5nY2VQZXJzaXN0ZW50RGlzayksXG4gICAgJ2dpdFJlcG8nOiB0b0pzb25fR2l0UmVwb1ZvbHVtZVNvdXJjZShvYmouZ2l0UmVwbyksXG4gICAgJ2dsdXN0ZXJmcyc6IHRvSnNvbl9HbHVzdGVyZnNWb2x1bWVTb3VyY2Uob2JqLmdsdXN0ZXJmcyksXG4gICAgJ2hvc3RQYXRoJzogdG9Kc29uX0hvc3RQYXRoVm9sdW1lU291cmNlKG9iai5ob3N0UGF0aCksXG4gICAgJ2lzY3NpJzogdG9Kc29uX0lzY3NpVm9sdW1lU291cmNlKG9iai5pc2NzaSksXG4gICAgJ25hbWUnOiBvYmoubmFtZSxcbiAgICAnbmZzJzogdG9Kc29uX05mc1ZvbHVtZVNvdXJjZShvYmoubmZzKSxcbiAgICAncGVyc2lzdGVudFZvbHVtZUNsYWltJzogdG9Kc29uX1BlcnNpc3RlbnRWb2x1bWVDbGFpbVZvbHVtZVNvdXJjZShvYmoucGVyc2lzdGVudFZvbHVtZUNsYWltKSxcbiAgICAncGhvdG9uUGVyc2lzdGVudERpc2snOiB0b0pzb25fUGhvdG9uUGVyc2lzdGVudERpc2tWb2x1bWVTb3VyY2Uob2JqLnBob3RvblBlcnNpc3RlbnREaXNrKSxcbiAgICAncG9ydHdvcnhWb2x1bWUnOiB0b0pzb25fUG9ydHdvcnhWb2x1bWVTb3VyY2Uob2JqLnBvcnR3b3J4Vm9sdW1lKSxcbiAgICAncHJvamVjdGVkJzogdG9Kc29uX1Byb2plY3RlZFZvbHVtZVNvdXJjZShvYmoucHJvamVjdGVkKSxcbiAgICAncXVvYnl0ZSc6IHRvSnNvbl9RdW9ieXRlVm9sdW1lU291cmNlKG9iai5xdW9ieXRlKSxcbiAgICAncmJkJzogdG9Kc29uX1JiZFZvbHVtZVNvdXJjZShvYmoucmJkKSxcbiAgICAnc2NhbGVJTyc6IHRvSnNvbl9TY2FsZUlvVm9sdW1lU291cmNlKG9iai5zY2FsZUlvKSxcbiAgICAnc2VjcmV0JzogdG9Kc29uX1NlY3JldFZvbHVtZVNvdXJjZShvYmouc2VjcmV0KSxcbiAgICAnc3RvcmFnZW9zJzogdG9Kc29uX1N0b3JhZ2VPc1ZvbHVtZVNvdXJjZShvYmouc3RvcmFnZW9zKSxcbiAgICAndnNwaGVyZVZvbHVtZSc6IHRvSnNvbl9Wc3BoZXJlVmlydHVhbERpc2tWb2x1bWVTb3VyY2Uob2JqLnZzcGhlcmVWb2x1bWUpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEEgc2NvcGUgc2VsZWN0b3IgcmVwcmVzZW50cyB0aGUgQU5EIG9mIHRoZSBzZWxlY3RvcnMgcmVwcmVzZW50ZWQgYnkgdGhlIHNjb3BlZC1yZXNvdXJjZSBzZWxlY3RvciByZXF1aXJlbWVudHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2NvcGVTZWxlY3RvclxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNjb3BlU2VsZWN0b3Ige1xuICAvKipcbiAgICogQSBsaXN0IG9mIHNjb3BlIHNlbGVjdG9yIHJlcXVpcmVtZW50cyBieSBzY29wZSBvZiB0aGUgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TY29wZVNlbGVjdG9yI21hdGNoRXhwcmVzc2lvbnNcbiAgICovXG4gIHJlYWRvbmx5IG1hdGNoRXhwcmVzc2lvbnM/OiBTY29wZWRSZXNvdXJjZVNlbGVjdG9yUmVxdWlyZW1lbnRbXTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdTY29wZVNlbGVjdG9yJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9TY29wZVNlbGVjdG9yKG9iajogU2NvcGVTZWxlY3RvciB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21hdGNoRXhwcmVzc2lvbnMnOiBvYmoubWF0Y2hFeHByZXNzaW9ucz8ubWFwKHkgPT4gdG9Kc29uX1Njb3BlZFJlc291cmNlU2VsZWN0b3JSZXF1aXJlbWVudCh5KSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogU2VydmljZVBvcnQgY29udGFpbnMgaW5mb3JtYXRpb24gb24gc2VydmljZSdzIHBvcnQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZVBvcnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZXJ2aWNlUG9ydCB7XG4gIC8qKlxuICAgKiBUaGUgYXBwbGljYXRpb24gcHJvdG9jb2wgZm9yIHRoaXMgcG9ydC4gVGhpcyBmaWVsZCBmb2xsb3dzIHN0YW5kYXJkIEt1YmVybmV0ZXMgbGFiZWwgc3ludGF4LiBVbi1wcmVmaXhlZCBuYW1lcyBhcmUgcmVzZXJ2ZWQgZm9yIElBTkEgc3RhbmRhcmQgc2VydmljZSBuYW1lcyAoYXMgcGVyIFJGQy02MzM1IGFuZCBodHRwOi8vd3d3LmlhbmEub3JnL2Fzc2lnbm1lbnRzL3NlcnZpY2UtbmFtZXMpLiBOb24tc3RhbmRhcmQgcHJvdG9jb2xzIHNob3VsZCB1c2UgcHJlZml4ZWQgbmFtZXMgc3VjaCBhcyBteWNvbXBhbnkuY29tL215LWN1c3RvbS1wcm90b2NvbC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZVBvcnQjYXBwUHJvdG9jb2xcbiAgICovXG4gIHJlYWRvbmx5IGFwcFByb3RvY29sPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGlzIHBvcnQgd2l0aGluIHRoZSBzZXJ2aWNlLiBUaGlzIG11c3QgYmUgYSBETlNfTEFCRUwuIEFsbCBwb3J0cyB3aXRoaW4gYSBTZXJ2aWNlU3BlYyBtdXN0IGhhdmUgdW5pcXVlIG5hbWVzLiBXaGVuIGNvbnNpZGVyaW5nIHRoZSBlbmRwb2ludHMgZm9yIGEgU2VydmljZSwgdGhpcyBtdXN0IG1hdGNoIHRoZSAnbmFtZScgZmllbGQgaW4gdGhlIEVuZHBvaW50UG9ydC4gT3B0aW9uYWwgaWYgb25seSBvbmUgU2VydmljZVBvcnQgaXMgZGVmaW5lZCBvbiB0aGlzIHNlcnZpY2UuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlcnZpY2VQb3J0I25hbWVcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBwb3J0IG9uIGVhY2ggbm9kZSBvbiB3aGljaCB0aGlzIHNlcnZpY2UgaXMgZXhwb3NlZCB3aGVuIHR5cGUgaXMgTm9kZVBvcnQgb3IgTG9hZEJhbGFuY2VyLiAgVXN1YWxseSBhc3NpZ25lZCBieSB0aGUgc3lzdGVtLiBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCwgaW4tcmFuZ2UsIGFuZCBub3QgaW4gdXNlIGl0IHdpbGwgYmUgdXNlZCwgb3RoZXJ3aXNlIHRoZSBvcGVyYXRpb24gd2lsbCBmYWlsLiAgSWYgbm90IHNwZWNpZmllZCwgYSBwb3J0IHdpbGwgYmUgYWxsb2NhdGVkIGlmIHRoaXMgU2VydmljZSByZXF1aXJlcyBvbmUuICBJZiB0aGlzIGZpZWxkIGlzIHNwZWNpZmllZCB3aGVuIGNyZWF0aW5nIGEgU2VydmljZSB3aGljaCBkb2VzIG5vdCBuZWVkIGl0LCBjcmVhdGlvbiB3aWxsIGZhaWwuIFRoaXMgZmllbGQgd2lsbCBiZSB3aXBlZCB3aGVuIHVwZGF0aW5nIGEgU2VydmljZSB0byBubyBsb25nZXIgbmVlZCBpdCAoZS5nLiBjaGFuZ2luZyB0eXBlIGZyb20gTm9kZVBvcnQgdG8gQ2x1c3RlcklQKS4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zZXJ2aWNlcy1uZXR3b3JraW5nL3NlcnZpY2UvI3R5cGUtbm9kZXBvcnRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZVBvcnQjbm9kZVBvcnRcbiAgICovXG4gIHJlYWRvbmx5IG5vZGVQb3J0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgcG9ydCB0aGF0IHdpbGwgYmUgZXhwb3NlZCBieSB0aGlzIHNlcnZpY2UuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlcnZpY2VQb3J0I3BvcnRcbiAgICovXG4gIHJlYWRvbmx5IHBvcnQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIElQIHByb3RvY29sIGZvciB0aGlzIHBvcnQuIFN1cHBvcnRzIFwiVENQXCIsIFwiVURQXCIsIGFuZCBcIlNDVFBcIi4gRGVmYXVsdCBpcyBUQ1AuXG4gICAqXG4gICAqIEBkZWZhdWx0IFRDUC5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZVBvcnQjcHJvdG9jb2xcbiAgICovXG4gIHJlYWRvbmx5IHByb3RvY29sPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb3IgbmFtZSBvZiB0aGUgcG9ydCB0byBhY2Nlc3Mgb24gdGhlIHBvZHMgdGFyZ2V0ZWQgYnkgdGhlIHNlcnZpY2UuIE51bWJlciBtdXN0IGJlIGluIHRoZSByYW5nZSAxIHRvIDY1NTM1LiBOYW1lIG11c3QgYmUgYW4gSUFOQV9TVkNfTkFNRS4gSWYgdGhpcyBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSBsb29rZWQgdXAgYXMgYSBuYW1lZCBwb3J0IGluIHRoZSB0YXJnZXQgUG9kJ3MgY29udGFpbmVyIHBvcnRzLiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSB2YWx1ZSBvZiB0aGUgJ3BvcnQnIGZpZWxkIGlzIHVzZWQgKGFuIGlkZW50aXR5IG1hcCkuIFRoaXMgZmllbGQgaXMgaWdub3JlZCBmb3Igc2VydmljZXMgd2l0aCBjbHVzdGVySVA9Tm9uZSwgYW5kIHNob3VsZCBiZSBvbWl0dGVkIG9yIHNldCBlcXVhbCB0byB0aGUgJ3BvcnQnIGZpZWxkLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3NlcnZpY2VzLW5ldHdvcmtpbmcvc2VydmljZS8jZGVmaW5pbmctYS1zZXJ2aWNlXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlcnZpY2VQb3J0I3RhcmdldFBvcnRcbiAgICovXG4gIHJlYWRvbmx5IHRhcmdldFBvcnQ/OiBJbnRPclN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdTZXJ2aWNlUG9ydCcgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fU2VydmljZVBvcnQob2JqOiBTZXJ2aWNlUG9ydCB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2FwcFByb3RvY29sJzogb2JqLmFwcFByb3RvY29sLFxuICAgICduYW1lJzogb2JqLm5hbWUsXG4gICAgJ25vZGVQb3J0Jzogb2JqLm5vZGVQb3J0LFxuICAgICdwb3J0Jzogb2JqLnBvcnQsXG4gICAgJ3Byb3RvY29sJzogb2JqLnByb3RvY29sLFxuICAgICd0YXJnZXRQb3J0Jzogb2JqLnRhcmdldFBvcnQ/LnZhbHVlLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFNlc3Npb25BZmZpbml0eUNvbmZpZyByZXByZXNlbnRzIHRoZSBjb25maWd1cmF0aW9ucyBvZiBzZXNzaW9uIGFmZmluaXR5LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlc3Npb25BZmZpbml0eUNvbmZpZ1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlc3Npb25BZmZpbml0eUNvbmZpZyB7XG4gIC8qKlxuICAgKiBjbGllbnRJUCBjb250YWlucyB0aGUgY29uZmlndXJhdGlvbnMgb2YgQ2xpZW50IElQIGJhc2VkIHNlc3Npb24gYWZmaW5pdHkuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlc3Npb25BZmZpbml0eUNvbmZpZyNjbGllbnRJUFxuICAgKi9cbiAgcmVhZG9ubHkgY2xpZW50SXA/OiBDbGllbnRJcENvbmZpZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdTZXNzaW9uQWZmaW5pdHlDb25maWcnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1Nlc3Npb25BZmZpbml0eUNvbmZpZyhvYmo6IFNlc3Npb25BZmZpbml0eUNvbmZpZyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2NsaWVudElQJzogdG9Kc29uX0NsaWVudElwQ29uZmlnKG9iai5jbGllbnRJcCksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogRW5kcG9pbnRDb25kaXRpb25zIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgY29uZGl0aW9uIG9mIGFuIGVuZHBvaW50LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjEuRW5kcG9pbnRDb25kaXRpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRW5kcG9pbnRDb25kaXRpb25zIHtcbiAgLyoqXG4gICAqIHJlYWR5IGluZGljYXRlcyB0aGF0IHRoaXMgZW5kcG9pbnQgaXMgcHJlcGFyZWQgdG8gcmVjZWl2ZSB0cmFmZmljLCBhY2NvcmRpbmcgdG8gd2hhdGV2ZXIgc3lzdGVtIGlzIG1hbmFnaW5nIHRoZSBlbmRwb2ludC4gQSBuaWwgdmFsdWUgaW5kaWNhdGVzIGFuIHVua25vd24gc3RhdGUuIEluIG1vc3QgY2FzZXMgY29uc3VtZXJzIHNob3VsZCBpbnRlcnByZXQgdGhpcyB1bmtub3duIHN0YXRlIGFzIHJlYWR5LiBGb3IgY29tcGF0aWJpbGl0eSByZWFzb25zLCByZWFkeSBzaG91bGQgbmV2ZXIgYmUgXCJ0cnVlXCIgZm9yIHRlcm1pbmF0aW5nIGVuZHBvaW50cy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmRpc2NvdmVyeS52MS5FbmRwb2ludENvbmRpdGlvbnMjcmVhZHlcbiAgICovXG4gIHJlYWRvbmx5IHJlYWR5PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogc2VydmluZyBpcyBpZGVudGljYWwgdG8gcmVhZHkgZXhjZXB0IHRoYXQgaXQgaXMgc2V0IHJlZ2FyZGxlc3Mgb2YgdGhlIHRlcm1pbmF0aW5nIHN0YXRlIG9mIGVuZHBvaW50cy4gVGhpcyBjb25kaXRpb24gc2hvdWxkIGJlIHNldCB0byB0cnVlIGZvciBhIHJlYWR5IGVuZHBvaW50IHRoYXQgaXMgdGVybWluYXRpbmcuIElmIG5pbCwgY29uc3VtZXJzIHNob3VsZCBkZWZlciB0byB0aGUgcmVhZHkgY29uZGl0aW9uLiBUaGlzIGZpZWxkIGNhbiBiZSBlbmFibGVkIHdpdGggdGhlIEVuZHBvaW50U2xpY2VUZXJtaW5hdGluZ0NvbmRpdGlvbiBmZWF0dXJlIGdhdGUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjEuRW5kcG9pbnRDb25kaXRpb25zI3NlcnZpbmdcbiAgICovXG4gIHJlYWRvbmx5IHNlcnZpbmc/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiB0ZXJtaW5hdGluZyBpbmRpY2F0ZXMgdGhhdCB0aGlzIGVuZHBvaW50IGlzIHRlcm1pbmF0aW5nLiBBIG5pbCB2YWx1ZSBpbmRpY2F0ZXMgYW4gdW5rbm93biBzdGF0ZS4gQ29uc3VtZXJzIHNob3VsZCBpbnRlcnByZXQgdGhpcyB1bmtub3duIHN0YXRlIHRvIG1lYW4gdGhhdCB0aGUgZW5kcG9pbnQgaXMgbm90IHRlcm1pbmF0aW5nLiBUaGlzIGZpZWxkIGNhbiBiZSBlbmFibGVkIHdpdGggdGhlIEVuZHBvaW50U2xpY2VUZXJtaW5hdGluZ0NvbmRpdGlvbiBmZWF0dXJlIGdhdGUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjEuRW5kcG9pbnRDb25kaXRpb25zI3Rlcm1pbmF0aW5nXG4gICAqL1xuICByZWFkb25seSB0ZXJtaW5hdGluZz86IGJvb2xlYW47XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnRW5kcG9pbnRDb25kaXRpb25zJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9FbmRwb2ludENvbmRpdGlvbnMob2JqOiBFbmRwb2ludENvbmRpdGlvbnMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdyZWFkeSc6IG9iai5yZWFkeSxcbiAgICAnc2VydmluZyc6IG9iai5zZXJ2aW5nLFxuICAgICd0ZXJtaW5hdGluZyc6IG9iai50ZXJtaW5hdGluZyxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBFbmRwb2ludEhpbnRzIHByb3ZpZGVzIGhpbnRzIGRlc2NyaWJpbmcgaG93IGFuIGVuZHBvaW50IHNob3VsZCBiZSBjb25zdW1lZC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuZGlzY292ZXJ5LnYxLkVuZHBvaW50SGludHNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFbmRwb2ludEhpbnRzIHtcbiAgLyoqXG4gICAqIGZvclpvbmVzIGluZGljYXRlcyB0aGUgem9uZShzKSB0aGlzIGVuZHBvaW50IHNob3VsZCBiZSBjb25zdW1lZCBieSB0byBlbmFibGUgdG9wb2xvZ3kgYXdhcmUgcm91dGluZy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmRpc2NvdmVyeS52MS5FbmRwb2ludEhpbnRzI2ZvclpvbmVzXG4gICAqL1xuICByZWFkb25seSBmb3Jab25lcz86IEZvclpvbmVbXTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdFbmRwb2ludEhpbnRzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9FbmRwb2ludEhpbnRzKG9iajogRW5kcG9pbnRIaW50cyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2ZvclpvbmVzJzogb2JqLmZvclpvbmVzPy5tYXAoeSA9PiB0b0pzb25fRm9yWm9uZSh5KSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogRW5kcG9pbnRDb25kaXRpb25zIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgY29uZGl0aW9uIG9mIGFuIGVuZHBvaW50LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjFiZXRhMS5FbmRwb2ludENvbmRpdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFbmRwb2ludENvbmRpdGlvbnNWMUJldGExIHtcbiAgLyoqXG4gICAqIHJlYWR5IGluZGljYXRlcyB0aGF0IHRoaXMgZW5kcG9pbnQgaXMgcHJlcGFyZWQgdG8gcmVjZWl2ZSB0cmFmZmljLCBhY2NvcmRpbmcgdG8gd2hhdGV2ZXIgc3lzdGVtIGlzIG1hbmFnaW5nIHRoZSBlbmRwb2ludC4gQSBuaWwgdmFsdWUgaW5kaWNhdGVzIGFuIHVua25vd24gc3RhdGUuIEluIG1vc3QgY2FzZXMgY29uc3VtZXJzIHNob3VsZCBpbnRlcnByZXQgdGhpcyB1bmtub3duIHN0YXRlIGFzIHJlYWR5LiBGb3IgY29tcGF0aWJpbGl0eSByZWFzb25zLCByZWFkeSBzaG91bGQgbmV2ZXIgYmUgXCJ0cnVlXCIgZm9yIHRlcm1pbmF0aW5nIGVuZHBvaW50cy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmRpc2NvdmVyeS52MWJldGExLkVuZHBvaW50Q29uZGl0aW9ucyNyZWFkeVxuICAgKi9cbiAgcmVhZG9ubHkgcmVhZHk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBzZXJ2aW5nIGlzIGlkZW50aWNhbCB0byByZWFkeSBleGNlcHQgdGhhdCBpdCBpcyBzZXQgcmVnYXJkbGVzcyBvZiB0aGUgdGVybWluYXRpbmcgc3RhdGUgb2YgZW5kcG9pbnRzLiBUaGlzIGNvbmRpdGlvbiBzaG91bGQgYmUgc2V0IHRvIHRydWUgZm9yIGEgcmVhZHkgZW5kcG9pbnQgdGhhdCBpcyB0ZXJtaW5hdGluZy4gSWYgbmlsLCBjb25zdW1lcnMgc2hvdWxkIGRlZmVyIHRvIHRoZSByZWFkeSBjb25kaXRpb24uIFRoaXMgZmllbGQgY2FuIGJlIGVuYWJsZWQgd2l0aCB0aGUgRW5kcG9pbnRTbGljZVRlcm1pbmF0aW5nQ29uZGl0aW9uIGZlYXR1cmUgZ2F0ZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmRpc2NvdmVyeS52MWJldGExLkVuZHBvaW50Q29uZGl0aW9ucyNzZXJ2aW5nXG4gICAqL1xuICByZWFkb25seSBzZXJ2aW5nPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogdGVybWluYXRpbmcgaW5kaWNhdGVzIHRoYXQgdGhpcyBlbmRwb2ludCBpcyB0ZXJtaW5hdGluZy4gQSBuaWwgdmFsdWUgaW5kaWNhdGVzIGFuIHVua25vd24gc3RhdGUuIENvbnN1bWVycyBzaG91bGQgaW50ZXJwcmV0IHRoaXMgdW5rbm93biBzdGF0ZSB0byBtZWFuIHRoYXQgdGhlIGVuZHBvaW50IGlzIG5vdCB0ZXJtaW5hdGluZy4gVGhpcyBmaWVsZCBjYW4gYmUgZW5hYmxlZCB3aXRoIHRoZSBFbmRwb2ludFNsaWNlVGVybWluYXRpbmdDb25kaXRpb24gZmVhdHVyZSBnYXRlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZGlzY292ZXJ5LnYxYmV0YTEuRW5kcG9pbnRDb25kaXRpb25zI3Rlcm1pbmF0aW5nXG4gICAqL1xuICByZWFkb25seSB0ZXJtaW5hdGluZz86IGJvb2xlYW47XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnRW5kcG9pbnRDb25kaXRpb25zVjFCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fRW5kcG9pbnRDb25kaXRpb25zVjFCZXRhMShvYmo6IEVuZHBvaW50Q29uZGl0aW9uc1YxQmV0YTEgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdyZWFkeSc6IG9iai5yZWFkeSxcbiAgICAnc2VydmluZyc6IG9iai5zZXJ2aW5nLFxuICAgICd0ZXJtaW5hdGluZyc6IG9iai50ZXJtaW5hdGluZyxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBFbmRwb2ludEhpbnRzIHByb3ZpZGVzIGhpbnRzIGRlc2NyaWJpbmcgaG93IGFuIGVuZHBvaW50IHNob3VsZCBiZSBjb25zdW1lZC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuZGlzY292ZXJ5LnYxYmV0YTEuRW5kcG9pbnRIaW50c1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEVuZHBvaW50SGludHNWMUJldGExIHtcbiAgLyoqXG4gICAqIGZvclpvbmVzIGluZGljYXRlcyB0aGUgem9uZShzKSB0aGlzIGVuZHBvaW50IHNob3VsZCBiZSBjb25zdW1lZCBieSB0byBlbmFibGUgdG9wb2xvZ3kgYXdhcmUgcm91dGluZy4gTWF5IGNvbnRhaW4gYSBtYXhpbXVtIG9mIDggZW50cmllcy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmRpc2NvdmVyeS52MWJldGExLkVuZHBvaW50SGludHMjZm9yWm9uZXNcbiAgICovXG4gIHJlYWRvbmx5IGZvclpvbmVzPzogRm9yWm9uZVYxQmV0YTFbXTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdFbmRwb2ludEhpbnRzVjFCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fRW5kcG9pbnRIaW50c1YxQmV0YTEob2JqOiBFbmRwb2ludEhpbnRzVjFCZXRhMSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2ZvclpvbmVzJzogb2JqLmZvclpvbmVzPy5tYXAoeSA9PiB0b0pzb25fRm9yWm9uZVYxQmV0YTEoeSkpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEZsb3dEaXN0aW5ndWlzaGVyTWV0aG9kIHNwZWNpZmllcyB0aGUgbWV0aG9kIG9mIGEgZmxvdyBkaXN0aW5ndWlzaGVyLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLkZsb3dEaXN0aW5ndWlzaGVyTWV0aG9kXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmxvd0Rpc3Rpbmd1aXNoZXJNZXRob2RWMUJldGExIHtcbiAgLyoqXG4gICAqIGB0eXBlYCBpcyB0aGUgdHlwZSBvZiBmbG93IGRpc3Rpbmd1aXNoZXIgbWV0aG9kIFRoZSBzdXBwb3J0ZWQgdHlwZXMgYXJlIFwiQnlVc2VyXCIgYW5kIFwiQnlOYW1lc3BhY2VcIi4gUmVxdWlyZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLkZsb3dEaXN0aW5ndWlzaGVyTWV0aG9kI3R5cGVcbiAgICovXG4gIHJlYWRvbmx5IHR5cGU6IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdGbG93RGlzdGluZ3Vpc2hlck1ldGhvZFYxQmV0YTEnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0Zsb3dEaXN0aW5ndWlzaGVyTWV0aG9kVjFCZXRhMShvYmo6IEZsb3dEaXN0aW5ndWlzaGVyTWV0aG9kVjFCZXRhMSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ3R5cGUnOiBvYmoudHlwZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBQcmlvcml0eUxldmVsQ29uZmlndXJhdGlvblJlZmVyZW5jZSBjb250YWlucyBpbmZvcm1hdGlvbiB0aGF0IHBvaW50cyB0byB0aGUgXCJyZXF1ZXN0LXByaW9yaXR5XCIgYmVpbmcgdXNlZC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuZmxvd2NvbnRyb2wudjFiZXRhMS5Qcmlvcml0eUxldmVsQ29uZmlndXJhdGlvblJlZmVyZW5jZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uUmVmZXJlbmNlVjFCZXRhMSB7XG4gIC8qKlxuICAgKiBgbmFtZWAgaXMgdGhlIG5hbWUgb2YgdGhlIHByaW9yaXR5IGxldmVsIGNvbmZpZ3VyYXRpb24gYmVpbmcgcmVmZXJlbmNlZCBSZXF1aXJlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25SZWZlcmVuY2UjbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1ByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uUmVmZXJlbmNlVjFCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25SZWZlcmVuY2VWMUJldGExKG9iajogUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb25SZWZlcmVuY2VWMUJldGExIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbmFtZSc6IG9iai5uYW1lLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFBvbGljeVJ1bGVzV2l0aFN1YmplY3RzIHByZXNjcmliZXMgYSB0ZXN0IHRoYXQgYXBwbGllcyB0byBhIHJlcXVlc3QgdG8gYW4gYXBpc2VydmVyLiBUaGUgdGVzdCBjb25zaWRlcnMgdGhlIHN1YmplY3QgbWFraW5nIHRoZSByZXF1ZXN0LCB0aGUgdmVyYiBiZWluZyByZXF1ZXN0ZWQsIGFuZCB0aGUgcmVzb3VyY2UgdG8gYmUgYWN0ZWQgdXBvbi4gVGhpcyBQb2xpY3lSdWxlc1dpdGhTdWJqZWN0cyBtYXRjaGVzIGEgcmVxdWVzdCBpZiBhbmQgb25seSBpZiBib3RoIChhKSBhdCBsZWFzdCBvbmUgbWVtYmVyIG9mIHN1YmplY3RzIG1hdGNoZXMgdGhlIHJlcXVlc3QgYW5kIChiKSBhdCBsZWFzdCBvbmUgbWVtYmVyIG9mIHJlc291cmNlUnVsZXMgb3Igbm9uUmVzb3VyY2VSdWxlcyBtYXRjaGVzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLlBvbGljeVJ1bGVzV2l0aFN1YmplY3RzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUG9saWN5UnVsZXNXaXRoU3ViamVjdHNWMUJldGExIHtcbiAgLyoqXG4gICAqIGBub25SZXNvdXJjZVJ1bGVzYCBpcyBhIGxpc3Qgb2YgTm9uUmVzb3VyY2VQb2xpY3lSdWxlcyB0aGF0IGlkZW50aWZ5IG1hdGNoaW5nIHJlcXVlc3RzIGFjY29yZGluZyB0byB0aGVpciB2ZXJiIGFuZCB0aGUgdGFyZ2V0IG5vbi1yZXNvdXJjZSBVUkwuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLlBvbGljeVJ1bGVzV2l0aFN1YmplY3RzI25vblJlc291cmNlUnVsZXNcbiAgICovXG4gIHJlYWRvbmx5IG5vblJlc291cmNlUnVsZXM/OiBOb25SZXNvdXJjZVBvbGljeVJ1bGVWMUJldGExW107XG5cbiAgLyoqXG4gICAqIGByZXNvdXJjZVJ1bGVzYCBpcyBhIHNsaWNlIG9mIFJlc291cmNlUG9saWN5UnVsZXMgdGhhdCBpZGVudGlmeSBtYXRjaGluZyByZXF1ZXN0cyBhY2NvcmRpbmcgdG8gdGhlaXIgdmVyYiBhbmQgdGhlIHRhcmdldCByZXNvdXJjZS4gQXQgbGVhc3Qgb25lIG9mIGByZXNvdXJjZVJ1bGVzYCBhbmQgYG5vblJlc291cmNlUnVsZXNgIGhhcyB0byBiZSBub24tZW1wdHkuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLlBvbGljeVJ1bGVzV2l0aFN1YmplY3RzI3Jlc291cmNlUnVsZXNcbiAgICovXG4gIHJlYWRvbmx5IHJlc291cmNlUnVsZXM/OiBSZXNvdXJjZVBvbGljeVJ1bGVWMUJldGExW107XG5cbiAgLyoqXG4gICAqIHN1YmplY3RzIGlzIHRoZSBsaXN0IG9mIG5vcm1hbCB1c2VyLCBzZXJ2aWNlYWNjb3VudCwgb3IgZ3JvdXAgdGhhdCB0aGlzIHJ1bGUgY2FyZXMgYWJvdXQuIFRoZXJlIG11c3QgYmUgYXQgbGVhc3Qgb25lIG1lbWJlciBpbiB0aGlzIHNsaWNlLiBBIHNsaWNlIHRoYXQgaW5jbHVkZXMgYm90aCB0aGUgc3lzdGVtOmF1dGhlbnRpY2F0ZWQgYW5kIHN5c3RlbTp1bmF1dGhlbnRpY2F0ZWQgdXNlciBncm91cHMgbWF0Y2hlcyBldmVyeSByZXF1ZXN0LiBSZXF1aXJlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuUG9saWN5UnVsZXNXaXRoU3ViamVjdHMjc3ViamVjdHNcbiAgICovXG4gIHJlYWRvbmx5IHN1YmplY3RzOiBTdWJqZWN0VjFCZXRhMVtdO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1BvbGljeVJ1bGVzV2l0aFN1YmplY3RzVjFCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fUG9saWN5UnVsZXNXaXRoU3ViamVjdHNWMUJldGExKG9iajogUG9saWN5UnVsZXNXaXRoU3ViamVjdHNWMUJldGExIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbm9uUmVzb3VyY2VSdWxlcyc6IG9iai5ub25SZXNvdXJjZVJ1bGVzPy5tYXAoeSA9PiB0b0pzb25fTm9uUmVzb3VyY2VQb2xpY3lSdWxlVjFCZXRhMSh5KSksXG4gICAgJ3Jlc291cmNlUnVsZXMnOiBvYmoucmVzb3VyY2VSdWxlcz8ubWFwKHkgPT4gdG9Kc29uX1Jlc291cmNlUG9saWN5UnVsZVYxQmV0YTEoeSkpLFxuICAgICdzdWJqZWN0cyc6IG9iai5zdWJqZWN0cz8ubWFwKHkgPT4gdG9Kc29uX1N1YmplY3RWMUJldGExKHkpKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBMaW1pdGVkUHJpb3JpdHlMZXZlbENvbmZpZ3VyYXRpb24gc3BlY2lmaWVzIGhvdyB0byBoYW5kbGUgcmVxdWVzdHMgdGhhdCBhcmUgc3ViamVjdCB0byBsaW1pdHMuIEl0IGFkZHJlc3NlcyB0d28gaXNzdWVzOlxuICogKiBIb3cgYXJlIHJlcXVlc3RzIGZvciB0aGlzIHByaW9yaXR5IGxldmVsIGxpbWl0ZWQ/XG4gKiAqIFdoYXQgc2hvdWxkIGJlIGRvbmUgd2l0aCByZXF1ZXN0cyB0aGF0IGV4Y2VlZCB0aGUgbGltaXQ/XG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuTGltaXRlZFByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGltaXRlZFByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uVjFCZXRhMSB7XG4gIC8qKlxuICAgKiBgYXNzdXJlZENvbmN1cnJlbmN5U2hhcmVzYCAoQUNTKSBjb25maWd1cmVzIHRoZSBleGVjdXRpb24gbGltaXQsIHdoaWNoIGlzIGEgbGltaXQgb24gdGhlIG51bWJlciBvZiByZXF1ZXN0cyBvZiB0aGlzIHByaW9yaXR5IGxldmVsIHRoYXQgbWF5IGJlIGV4ZXVjdGluZyBhdCBhIGdpdmVuIHRpbWUuICBBQ1MgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlci4gVGhlIHNlcnZlcidzIGNvbmN1cnJlbmN5IGxpbWl0IChTQ0wpIGlzIGRpdmlkZWQgYW1vbmcgdGhlIGNvbmN1cnJlbmN5LWNvbnRyb2xsZWQgcHJpb3JpdHkgbGV2ZWxzIGluIHByb3BvcnRpb24gdG8gdGhlaXIgYXNzdXJlZCBjb25jdXJyZW5jeSBzaGFyZXMuIFRoaXMgcHJvZHVjZXMgdGhlIGFzc3VyZWQgY29uY3VycmVuY3kgdmFsdWUgKEFDVikgLS0tIHRoZSBudW1iZXIgb2YgcmVxdWVzdHMgdGhhdCBtYXkgYmUgZXhlY3V0aW5nIGF0IGEgdGltZSAtLS0gZm9yIGVhY2ggc3VjaCBwcmlvcml0eSBsZXZlbDpcbiAgICpcbiAgICogQUNWKGwpID0gY2VpbCggU0NMICogQUNTKGwpIC8gKCBzdW1bcHJpb3JpdHkgbGV2ZWxzIGtdIEFDUyhrKSApIClcbiAgICpcbiAgICogYmlnZ2VyIG51bWJlcnMgb2YgQUNTIG1lYW4gbW9yZSByZXNlcnZlZCBjb25jdXJyZW50IHJlcXVlc3RzIChhdCB0aGUgZXhwZW5zZSBvZiBldmVyeSBvdGhlciBQTCkuIFRoaXMgZmllbGQgaGFzIGEgZGVmYXVsdCB2YWx1ZSBvZiAzMC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuTGltaXRlZFByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uI2Fzc3VyZWRDb25jdXJyZW5jeVNoYXJlc1xuICAgKi9cbiAgcmVhZG9ubHkgYXNzdXJlZENvbmN1cnJlbmN5U2hhcmVzPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBgbGltaXRSZXNwb25zZWAgaW5kaWNhdGVzIHdoYXQgdG8gZG8gd2l0aCByZXF1ZXN0cyB0aGF0IGNhbiBub3QgYmUgZXhlY3V0ZWQgcmlnaHQgbm93XG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLkxpbWl0ZWRQcmlvcml0eUxldmVsQ29uZmlndXJhdGlvbiNsaW1pdFJlc3BvbnNlXG4gICAqL1xuICByZWFkb25seSBsaW1pdFJlc3BvbnNlPzogTGltaXRSZXNwb25zZVYxQmV0YTE7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnTGltaXRlZFByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uVjFCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fTGltaXRlZFByaW9yaXR5TGV2ZWxDb25maWd1cmF0aW9uVjFCZXRhMShvYmo6IExpbWl0ZWRQcmlvcml0eUxldmVsQ29uZmlndXJhdGlvblYxQmV0YTEgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdhc3N1cmVkQ29uY3VycmVuY3lTaGFyZXMnOiBvYmouYXNzdXJlZENvbmN1cnJlbmN5U2hhcmVzLFxuICAgICdsaW1pdFJlc3BvbnNlJzogdG9Kc29uX0xpbWl0UmVzcG9uc2VWMUJldGExKG9iai5saW1pdFJlc3BvbnNlKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBJbmdyZXNzQmFja2VuZCBkZXNjcmliZXMgYWxsIGVuZHBvaW50cyBmb3IgYSBnaXZlbiBzZXJ2aWNlIGFuZCBwb3J0LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3NCYWNrZW5kXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5ncmVzc0JhY2tlbmQge1xuICAvKipcbiAgICogUmVzb3VyY2UgaXMgYW4gT2JqZWN0UmVmIHRvIGFub3RoZXIgS3ViZXJuZXRlcyByZXNvdXJjZSBpbiB0aGUgbmFtZXNwYWNlIG9mIHRoZSBJbmdyZXNzIG9iamVjdC4gSWYgcmVzb3VyY2UgaXMgc3BlY2lmaWVkLCBhIHNlcnZpY2UuTmFtZSBhbmQgc2VydmljZS5Qb3J0IG11c3Qgbm90IGJlIHNwZWNpZmllZC4gVGhpcyBpcyBhIG11dHVhbGx5IGV4Y2x1c2l2ZSBzZXR0aW5nIHdpdGggXCJTZXJ2aWNlXCIuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3NCYWNrZW5kI3Jlc291cmNlXG4gICAqL1xuICByZWFkb25seSByZXNvdXJjZT86IFR5cGVkTG9jYWxPYmplY3RSZWZlcmVuY2U7XG5cbiAgLyoqXG4gICAqIFNlcnZpY2UgcmVmZXJlbmNlcyBhIFNlcnZpY2UgYXMgYSBCYWNrZW5kLiBUaGlzIGlzIGEgbXV0dWFsbHkgZXhjbHVzaXZlIHNldHRpbmcgd2l0aCBcIlJlc291cmNlXCIuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3NCYWNrZW5kI3NlcnZpY2VcbiAgICovXG4gIHJlYWRvbmx5IHNlcnZpY2U/OiBJbmdyZXNzU2VydmljZUJhY2tlbmQ7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnSW5ncmVzc0JhY2tlbmQnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0luZ3Jlc3NCYWNrZW5kKG9iajogSW5ncmVzc0JhY2tlbmQgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdyZXNvdXJjZSc6IHRvSnNvbl9UeXBlZExvY2FsT2JqZWN0UmVmZXJlbmNlKG9iai5yZXNvdXJjZSksXG4gICAgJ3NlcnZpY2UnOiB0b0pzb25fSW5ncmVzc1NlcnZpY2VCYWNrZW5kKG9iai5zZXJ2aWNlKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBJbmdyZXNzUnVsZSByZXByZXNlbnRzIHRoZSBydWxlcyBtYXBwaW5nIHRoZSBwYXRocyB1bmRlciBhIHNwZWNpZmllZCBob3N0IHRvIHRoZSByZWxhdGVkIGJhY2tlbmQgc2VydmljZXMuIEluY29taW5nIHJlcXVlc3RzIGFyZSBmaXJzdCBldmFsdWF0ZWQgZm9yIGEgaG9zdCBtYXRjaCwgdGhlbiByb3V0ZWQgdG8gdGhlIGJhY2tlbmQgYXNzb2NpYXRlZCB3aXRoIHRoZSBtYXRjaGluZyBJbmdyZXNzUnVsZVZhbHVlLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3NSdWxlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5ncmVzc1J1bGUge1xuICAvKipcbiAgICogSG9zdCBpcyB0aGUgZnVsbHkgcXVhbGlmaWVkIGRvbWFpbiBuYW1lIG9mIGEgbmV0d29yayBob3N0LCBhcyBkZWZpbmVkIGJ5IFJGQyAzOTg2LiBOb3RlIHRoZSBmb2xsb3dpbmcgZGV2aWF0aW9ucyBmcm9tIHRoZSBcImhvc3RcIiBwYXJ0IG9mIHRoZSBVUkkgYXMgZGVmaW5lZCBpbiBSRkMgMzk4NjogMS4gSVBzIGFyZSBub3QgYWxsb3dlZC4gQ3VycmVudGx5IGFuIEluZ3Jlc3NSdWxlVmFsdWUgY2FuIG9ubHkgYXBwbHkgdG9cbiAgICogdGhlIElQIGluIHRoZSBTcGVjIG9mIHRoZSBwYXJlbnQgSW5ncmVzcy5cbiAgICogMi4gVGhlIGA6YCBkZWxpbWl0ZXIgaXMgbm90IHJlc3BlY3RlZCBiZWNhdXNlIHBvcnRzIGFyZSBub3QgYWxsb3dlZC5cbiAgICogQ3VycmVudGx5IHRoZSBwb3J0IG9mIGFuIEluZ3Jlc3MgaXMgaW1wbGljaXRseSA6ODAgZm9yIGh0dHAgYW5kXG4gICAqIDo0NDMgZm9yIGh0dHBzLlxuICAgKiBCb3RoIHRoZXNlIG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS4gSW5jb21pbmcgcmVxdWVzdHMgYXJlIG1hdGNoZWQgYWdhaW5zdCB0aGUgaG9zdCBiZWZvcmUgdGhlIEluZ3Jlc3NSdWxlVmFsdWUuIElmIHRoZSBob3N0IGlzIHVuc3BlY2lmaWVkLCB0aGUgSW5ncmVzcyByb3V0ZXMgYWxsIHRyYWZmaWMgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBJbmdyZXNzUnVsZVZhbHVlLlxuICAgKlxuICAgKiBIb3N0IGNhbiBiZSBcInByZWNpc2VcIiB3aGljaCBpcyBhIGRvbWFpbiBuYW1lIHdpdGhvdXQgdGhlIHRlcm1pbmF0aW5nIGRvdCBvZiBhIG5ldHdvcmsgaG9zdCAoZS5nLiBcImZvby5iYXIuY29tXCIpIG9yIFwid2lsZGNhcmRcIiwgd2hpY2ggaXMgYSBkb21haW4gbmFtZSBwcmVmaXhlZCB3aXRoIGEgc2luZ2xlIHdpbGRjYXJkIGxhYmVsIChlLmcuIFwiKi5mb28uY29tXCIpLiBUaGUgd2lsZGNhcmQgY2hhcmFjdGVyICcqJyBtdXN0IGFwcGVhciBieSBpdHNlbGYgYXMgdGhlIGZpcnN0IEROUyBsYWJlbCBhbmQgbWF0Y2hlcyBvbmx5IGEgc2luZ2xlIGxhYmVsLiBZb3UgY2Fubm90IGhhdmUgYSB3aWxkY2FyZCBsYWJlbCBieSBpdHNlbGYgKGUuZy4gSG9zdCA9PSBcIipcIikuIFJlcXVlc3RzIHdpbGwgYmUgbWF0Y2hlZCBhZ2FpbnN0IHRoZSBIb3N0IGZpZWxkIGluIHRoZSBmb2xsb3dpbmcgd2F5OiAxLiBJZiBIb3N0IGlzIHByZWNpc2UsIHRoZSByZXF1ZXN0IG1hdGNoZXMgdGhpcyBydWxlIGlmIHRoZSBodHRwIGhvc3QgaGVhZGVyIGlzIGVxdWFsIHRvIEhvc3QuIDIuIElmIEhvc3QgaXMgYSB3aWxkY2FyZCwgdGhlbiB0aGUgcmVxdWVzdCBtYXRjaGVzIHRoaXMgcnVsZSBpZiB0aGUgaHR0cCBob3N0IGhlYWRlciBpcyB0byBlcXVhbCB0byB0aGUgc3VmZml4IChyZW1vdmluZyB0aGUgZmlyc3QgbGFiZWwpIG9mIHRoZSB3aWxkY2FyZCBydWxlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5JbmdyZXNzUnVsZSNob3N0XG4gICAqL1xuICByZWFkb25seSBob3N0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5JbmdyZXNzUnVsZSNodHRwXG4gICAqL1xuICByZWFkb25seSBodHRwPzogSHR0cEluZ3Jlc3NSdWxlVmFsdWU7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnSW5ncmVzc1J1bGUnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0luZ3Jlc3NSdWxlKG9iajogSW5ncmVzc1J1bGUgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdob3N0Jzogb2JqLmhvc3QsXG4gICAgJ2h0dHAnOiB0b0pzb25fSHR0cEluZ3Jlc3NSdWxlVmFsdWUob2JqLmh0dHApLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEluZ3Jlc3NUTFMgZGVzY3JpYmVzIHRoZSB0cmFuc3BvcnQgbGF5ZXIgc2VjdXJpdHkgYXNzb2NpYXRlZCB3aXRoIGFuIEluZ3Jlc3MuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuSW5ncmVzc1RMU1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEluZ3Jlc3NUbHMge1xuICAvKipcbiAgICogSG9zdHMgYXJlIGEgbGlzdCBvZiBob3N0cyBpbmNsdWRlZCBpbiB0aGUgVExTIGNlcnRpZmljYXRlLiBUaGUgdmFsdWVzIGluIHRoaXMgbGlzdCBtdXN0IG1hdGNoIHRoZSBuYW1lL3MgdXNlZCBpbiB0aGUgdGxzU2VjcmV0LiBEZWZhdWx0cyB0byB0aGUgd2lsZGNhcmQgaG9zdCBzZXR0aW5nIGZvciB0aGUgbG9hZGJhbGFuY2VyIGNvbnRyb2xsZXIgZnVsZmlsbGluZyB0aGlzIEluZ3Jlc3MsIGlmIGxlZnQgdW5zcGVjaWZpZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRoZSB3aWxkY2FyZCBob3N0IHNldHRpbmcgZm9yIHRoZSBsb2FkYmFsYW5jZXIgY29udHJvbGxlciBmdWxmaWxsaW5nIHRoaXMgSW5ncmVzcywgaWYgbGVmdCB1bnNwZWNpZmllZC5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuSW5ncmVzc1RMUyNob3N0c1xuICAgKi9cbiAgcmVhZG9ubHkgaG9zdHM/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogU2VjcmV0TmFtZSBpcyB0aGUgbmFtZSBvZiB0aGUgc2VjcmV0IHVzZWQgdG8gdGVybWluYXRlIFRMUyB0cmFmZmljIG9uIHBvcnQgNDQzLiBGaWVsZCBpcyBsZWZ0IG9wdGlvbmFsIHRvIGFsbG93IFRMUyByb3V0aW5nIGJhc2VkIG9uIFNOSSBob3N0bmFtZSBhbG9uZS4gSWYgdGhlIFNOSSBob3N0IGluIGEgbGlzdGVuZXIgY29uZmxpY3RzIHdpdGggdGhlIFwiSG9zdFwiIGhlYWRlciBmaWVsZCB1c2VkIGJ5IGFuIEluZ3Jlc3NSdWxlLCB0aGUgU05JIGhvc3QgaXMgdXNlZCBmb3IgdGVybWluYXRpb24gYW5kIHZhbHVlIG9mIHRoZSBIb3N0IGhlYWRlciBpcyB1c2VkIGZvciByb3V0aW5nLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5JbmdyZXNzVExTI3NlY3JldE5hbWVcbiAgICovXG4gIHJlYWRvbmx5IHNlY3JldE5hbWU/OiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnSW5ncmVzc1RscycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fSW5ncmVzc1RscyhvYmo6IEluZ3Jlc3NUbHMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdob3N0cyc6IG9iai5ob3N0cz8ubWFwKHkgPT4geSksXG4gICAgJ3NlY3JldE5hbWUnOiBvYmouc2VjcmV0TmFtZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBJbmdyZXNzQ2xhc3NQYXJhbWV0ZXJzUmVmZXJlbmNlIGlkZW50aWZpZXMgYW4gQVBJIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGEgY2x1c3RlciBvciBuYW1lc3BhY2Utc2NvcGVkIHJlc291cmNlLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3NDbGFzc1BhcmFtZXRlcnNSZWZlcmVuY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbmdyZXNzQ2xhc3NQYXJhbWV0ZXJzUmVmZXJlbmNlIHtcbiAgLyoqXG4gICAqIEFQSUdyb3VwIGlzIHRoZSBncm91cCBmb3IgdGhlIHJlc291cmNlIGJlaW5nIHJlZmVyZW5jZWQuIElmIEFQSUdyb3VwIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBzcGVjaWZpZWQgS2luZCBtdXN0IGJlIGluIHRoZSBjb3JlIEFQSSBncm91cC4gRm9yIGFueSBvdGhlciB0aGlyZC1wYXJ0eSB0eXBlcywgQVBJR3JvdXAgaXMgcmVxdWlyZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3NDbGFzc1BhcmFtZXRlcnNSZWZlcmVuY2UjYXBpR3JvdXBcbiAgICovXG4gIHJlYWRvbmx5IGFwaUdyb3VwPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBLaW5kIGlzIHRoZSB0eXBlIG9mIHJlc291cmNlIGJlaW5nIHJlZmVyZW5jZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3NDbGFzc1BhcmFtZXRlcnNSZWZlcmVuY2Uja2luZFxuICAgKi9cbiAgcmVhZG9ubHkga2luZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBOYW1lIGlzIHRoZSBuYW1lIG9mIHJlc291cmNlIGJlaW5nIHJlZmVyZW5jZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3NDbGFzc1BhcmFtZXRlcnNSZWZlcmVuY2UjbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBOYW1lc3BhY2UgaXMgdGhlIG5hbWVzcGFjZSBvZiB0aGUgcmVzb3VyY2UgYmVpbmcgcmVmZXJlbmNlZC4gVGhpcyBmaWVsZCBpcyByZXF1aXJlZCB3aGVuIHNjb3BlIGlzIHNldCB0byBcIk5hbWVzcGFjZVwiIGFuZCBtdXN0IGJlIHVuc2V0IHdoZW4gc2NvcGUgaXMgc2V0IHRvIFwiQ2x1c3RlclwiLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5JbmdyZXNzQ2xhc3NQYXJhbWV0ZXJzUmVmZXJlbmNlI25hbWVzcGFjZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZXNwYWNlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTY29wZSByZXByZXNlbnRzIGlmIHRoaXMgcmVmZXJzIHRvIGEgY2x1c3RlciBvciBuYW1lc3BhY2Ugc2NvcGVkIHJlc291cmNlLiBUaGlzIG1heSBiZSBzZXQgdG8gXCJDbHVzdGVyXCIgKGRlZmF1bHQpIG9yIFwiTmFtZXNwYWNlXCIuIEZpZWxkIGNhbiBiZSBlbmFibGVkIHdpdGggSW5ncmVzc0NsYXNzTmFtZXNwYWNlZFBhcmFtcyBmZWF0dXJlIGdhdGUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3NDbGFzc1BhcmFtZXRlcnNSZWZlcmVuY2Ujc2NvcGVcbiAgICovXG4gIHJlYWRvbmx5IHNjb3BlPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0luZ3Jlc3NDbGFzc1BhcmFtZXRlcnNSZWZlcmVuY2UnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0luZ3Jlc3NDbGFzc1BhcmFtZXRlcnNSZWZlcmVuY2Uob2JqOiBJbmdyZXNzQ2xhc3NQYXJhbWV0ZXJzUmVmZXJlbmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnYXBpR3JvdXAnOiBvYmouYXBpR3JvdXAsXG4gICAgJ2tpbmQnOiBvYmoua2luZCxcbiAgICAnbmFtZSc6IG9iai5uYW1lLFxuICAgICduYW1lc3BhY2UnOiBvYmoubmFtZXNwYWNlLFxuICAgICdzY29wZSc6IG9iai5zY29wZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBOZXR3b3JrUG9saWN5RWdyZXNzUnVsZSBkZXNjcmliZXMgYSBwYXJ0aWN1bGFyIHNldCBvZiB0cmFmZmljIHRoYXQgaXMgYWxsb3dlZCBvdXQgb2YgcG9kcyBtYXRjaGVkIGJ5IGEgTmV0d29ya1BvbGljeVNwZWMncyBwb2RTZWxlY3Rvci4gVGhlIHRyYWZmaWMgbXVzdCBtYXRjaCBib3RoIHBvcnRzIGFuZCB0by4gVGhpcyB0eXBlIGlzIGJldGEtbGV2ZWwgaW4gMS44XG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuTmV0d29ya1BvbGljeUVncmVzc1J1bGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXR3b3JrUG9saWN5RWdyZXNzUnVsZSB7XG4gIC8qKlxuICAgKiBMaXN0IG9mIGRlc3RpbmF0aW9uIHBvcnRzIGZvciBvdXRnb2luZyB0cmFmZmljLiBFYWNoIGl0ZW0gaW4gdGhpcyBsaXN0IGlzIGNvbWJpbmVkIHVzaW5nIGEgbG9naWNhbCBPUi4gSWYgdGhpcyBmaWVsZCBpcyBlbXB0eSBvciBtaXNzaW5nLCB0aGlzIHJ1bGUgbWF0Y2hlcyBhbGwgcG9ydHMgKHRyYWZmaWMgbm90IHJlc3RyaWN0ZWQgYnkgcG9ydCkuIElmIHRoaXMgZmllbGQgaXMgcHJlc2VudCBhbmQgY29udGFpbnMgYXQgbGVhc3Qgb25lIGl0ZW0sIHRoZW4gdGhpcyBydWxlIGFsbG93cyB0cmFmZmljIG9ubHkgaWYgdGhlIHRyYWZmaWMgbWF0Y2hlcyBhdCBsZWFzdCBvbmUgcG9ydCBpbiB0aGUgbGlzdC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuTmV0d29ya1BvbGljeUVncmVzc1J1bGUjcG9ydHNcbiAgICovXG4gIHJlYWRvbmx5IHBvcnRzPzogTmV0d29ya1BvbGljeVBvcnRbXTtcblxuICAvKipcbiAgICogTGlzdCBvZiBkZXN0aW5hdGlvbnMgZm9yIG91dGdvaW5nIHRyYWZmaWMgb2YgcG9kcyBzZWxlY3RlZCBmb3IgdGhpcyBydWxlLiBJdGVtcyBpbiB0aGlzIGxpc3QgYXJlIGNvbWJpbmVkIHVzaW5nIGEgbG9naWNhbCBPUiBvcGVyYXRpb24uIElmIHRoaXMgZmllbGQgaXMgZW1wdHkgb3IgbWlzc2luZywgdGhpcyBydWxlIG1hdGNoZXMgYWxsIGRlc3RpbmF0aW9ucyAodHJhZmZpYyBub3QgcmVzdHJpY3RlZCBieSBkZXN0aW5hdGlvbikuIElmIHRoaXMgZmllbGQgaXMgcHJlc2VudCBhbmQgY29udGFpbnMgYXQgbGVhc3Qgb25lIGl0ZW0sIHRoaXMgcnVsZSBhbGxvd3MgdHJhZmZpYyBvbmx5IGlmIHRoZSB0cmFmZmljIG1hdGNoZXMgYXQgbGVhc3Qgb25lIGl0ZW0gaW4gdGhlIHRvIGxpc3QuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLk5ldHdvcmtQb2xpY3lFZ3Jlc3NSdWxlI3RvXG4gICAqL1xuICByZWFkb25seSB0bz86IE5ldHdvcmtQb2xpY3lQZWVyW107XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnTmV0d29ya1BvbGljeUVncmVzc1J1bGUnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX05ldHdvcmtQb2xpY3lFZ3Jlc3NSdWxlKG9iajogTmV0d29ya1BvbGljeUVncmVzc1J1bGUgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdwb3J0cyc6IG9iai5wb3J0cz8ubWFwKHkgPT4gdG9Kc29uX05ldHdvcmtQb2xpY3lQb3J0KHkpKSxcbiAgICAndG8nOiBvYmoudG8/Lm1hcCh5ID0+IHRvSnNvbl9OZXR3b3JrUG9saWN5UGVlcih5KSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogTmV0d29ya1BvbGljeUluZ3Jlc3NSdWxlIGRlc2NyaWJlcyBhIHBhcnRpY3VsYXIgc2V0IG9mIHRyYWZmaWMgdGhhdCBpcyBhbGxvd2VkIHRvIHRoZSBwb2RzIG1hdGNoZWQgYnkgYSBOZXR3b3JrUG9saWN5U3BlYydzIHBvZFNlbGVjdG9yLiBUaGUgdHJhZmZpYyBtdXN0IG1hdGNoIGJvdGggcG9ydHMgYW5kIGZyb20uXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuTmV0d29ya1BvbGljeUluZ3Jlc3NSdWxlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV0d29ya1BvbGljeUluZ3Jlc3NSdWxlIHtcbiAgLyoqXG4gICAqIExpc3Qgb2Ygc291cmNlcyB3aGljaCBzaG91bGQgYmUgYWJsZSB0byBhY2Nlc3MgdGhlIHBvZHMgc2VsZWN0ZWQgZm9yIHRoaXMgcnVsZS4gSXRlbXMgaW4gdGhpcyBsaXN0IGFyZSBjb21iaW5lZCB1c2luZyBhIGxvZ2ljYWwgT1Igb3BlcmF0aW9uLiBJZiB0aGlzIGZpZWxkIGlzIGVtcHR5IG9yIG1pc3NpbmcsIHRoaXMgcnVsZSBtYXRjaGVzIGFsbCBzb3VyY2VzICh0cmFmZmljIG5vdCByZXN0cmljdGVkIGJ5IHNvdXJjZSkuIElmIHRoaXMgZmllbGQgaXMgcHJlc2VudCBhbmQgY29udGFpbnMgYXQgbGVhc3Qgb25lIGl0ZW0sIHRoaXMgcnVsZSBhbGxvd3MgdHJhZmZpYyBvbmx5IGlmIHRoZSB0cmFmZmljIG1hdGNoZXMgYXQgbGVhc3Qgb25lIGl0ZW0gaW4gdGhlIGZyb20gbGlzdC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuTmV0d29ya1BvbGljeUluZ3Jlc3NSdWxlI2Zyb21cbiAgICovXG4gIHJlYWRvbmx5IGZyb20/OiBOZXR3b3JrUG9saWN5UGVlcltdO1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIHBvcnRzIHdoaWNoIHNob3VsZCBiZSBtYWRlIGFjY2Vzc2libGUgb24gdGhlIHBvZHMgc2VsZWN0ZWQgZm9yIHRoaXMgcnVsZS4gRWFjaCBpdGVtIGluIHRoaXMgbGlzdCBpcyBjb21iaW5lZCB1c2luZyBhIGxvZ2ljYWwgT1IuIElmIHRoaXMgZmllbGQgaXMgZW1wdHkgb3IgbWlzc2luZywgdGhpcyBydWxlIG1hdGNoZXMgYWxsIHBvcnRzICh0cmFmZmljIG5vdCByZXN0cmljdGVkIGJ5IHBvcnQpLiBJZiB0aGlzIGZpZWxkIGlzIHByZXNlbnQgYW5kIGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBpdGVtLCB0aGVuIHRoaXMgcnVsZSBhbGxvd3MgdHJhZmZpYyBvbmx5IGlmIHRoZSB0cmFmZmljIG1hdGNoZXMgYXQgbGVhc3Qgb25lIHBvcnQgaW4gdGhlIGxpc3QuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLk5ldHdvcmtQb2xpY3lJbmdyZXNzUnVsZSNwb3J0c1xuICAgKi9cbiAgcmVhZG9ubHkgcG9ydHM/OiBOZXR3b3JrUG9saWN5UG9ydFtdO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ05ldHdvcmtQb2xpY3lJbmdyZXNzUnVsZScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fTmV0d29ya1BvbGljeUluZ3Jlc3NSdWxlKG9iajogTmV0d29ya1BvbGljeUluZ3Jlc3NSdWxlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZnJvbSc6IG9iai5mcm9tPy5tYXAoeSA9PiB0b0pzb25fTmV0d29ya1BvbGljeVBlZXIoeSkpLFxuICAgICdwb3J0cyc6IG9iai5wb3J0cz8ubWFwKHkgPT4gdG9Kc29uX05ldHdvcmtQb2xpY3lQb3J0KHkpKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBPdmVyaGVhZCBzdHJ1Y3R1cmUgcmVwcmVzZW50cyB0aGUgcmVzb3VyY2Ugb3ZlcmhlYWQgYXNzb2NpYXRlZCB3aXRoIHJ1bm5pbmcgYSBwb2QuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLm5vZGUudjFhbHBoYTEuT3ZlcmhlYWRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBPdmVyaGVhZFYxQWxwaGExIHtcbiAgLyoqXG4gICAqIFBvZEZpeGVkIHJlcHJlc2VudHMgdGhlIGZpeGVkIHJlc291cmNlIG92ZXJoZWFkIGFzc29jaWF0ZWQgd2l0aCBydW5uaW5nIGEgcG9kLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubm9kZS52MWFscGhhMS5PdmVyaGVhZCNwb2RGaXhlZFxuICAgKi9cbiAgcmVhZG9ubHkgcG9kRml4ZWQ/OiB7IFtrZXk6IHN0cmluZ106IFF1YW50aXR5IH07XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnT3ZlcmhlYWRWMUFscGhhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fT3ZlcmhlYWRWMUFscGhhMShvYmo6IE92ZXJoZWFkVjFBbHBoYTEgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdwb2RGaXhlZCc6ICgob2JqLnBvZEZpeGVkKSA9PT0gdW5kZWZpbmVkKSA/IHVuZGVmaW5lZCA6IChPYmplY3QuZW50cmllcyhvYmoucG9kRml4ZWQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdPy52YWx1ZSB9KSwge30pKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBTY2hlZHVsaW5nIHNwZWNpZmllcyB0aGUgc2NoZWR1bGluZyBjb25zdHJhaW50cyBmb3Igbm9kZXMgc3VwcG9ydGluZyBhIFJ1bnRpbWVDbGFzcy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkubm9kZS52MWFscGhhMS5TY2hlZHVsaW5nXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2NoZWR1bGluZ1YxQWxwaGExIHtcbiAgLyoqXG4gICAqIG5vZGVTZWxlY3RvciBsaXN0cyBsYWJlbHMgdGhhdCBtdXN0IGJlIHByZXNlbnQgb24gbm9kZXMgdGhhdCBzdXBwb3J0IHRoaXMgUnVudGltZUNsYXNzLiBQb2RzIHVzaW5nIHRoaXMgUnVudGltZUNsYXNzIGNhbiBvbmx5IGJlIHNjaGVkdWxlZCB0byBhIG5vZGUgbWF0Y2hlZCBieSB0aGlzIHNlbGVjdG9yLiBUaGUgUnVudGltZUNsYXNzIG5vZGVTZWxlY3RvciBpcyBtZXJnZWQgd2l0aCBhIHBvZCdzIGV4aXN0aW5nIG5vZGVTZWxlY3Rvci4gQW55IGNvbmZsaWN0cyB3aWxsIGNhdXNlIHRoZSBwb2QgdG8gYmUgcmVqZWN0ZWQgaW4gYWRtaXNzaW9uLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubm9kZS52MWFscGhhMS5TY2hlZHVsaW5nI25vZGVTZWxlY3RvclxuICAgKi9cbiAgcmVhZG9ubHkgbm9kZVNlbGVjdG9yPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcblxuICAvKipcbiAgICogdG9sZXJhdGlvbnMgYXJlIGFwcGVuZGVkIChleGNsdWRpbmcgZHVwbGljYXRlcykgdG8gcG9kcyBydW5uaW5nIHdpdGggdGhpcyBSdW50aW1lQ2xhc3MgZHVyaW5nIGFkbWlzc2lvbiwgZWZmZWN0aXZlbHkgdW5pb25pbmcgdGhlIHNldCBvZiBub2RlcyB0b2xlcmF0ZWQgYnkgdGhlIHBvZCBhbmQgdGhlIFJ1bnRpbWVDbGFzcy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5vZGUudjFhbHBoYTEuU2NoZWR1bGluZyN0b2xlcmF0aW9uc1xuICAgKi9cbiAgcmVhZG9ubHkgdG9sZXJhdGlvbnM/OiBUb2xlcmF0aW9uW107XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnU2NoZWR1bGluZ1YxQWxwaGExJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9TY2hlZHVsaW5nVjFBbHBoYTEob2JqOiBTY2hlZHVsaW5nVjFBbHBoYTEgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdub2RlU2VsZWN0b3InOiAoKG9iai5ub2RlU2VsZWN0b3IpID09PSB1bmRlZmluZWQpID8gdW5kZWZpbmVkIDogKE9iamVjdC5lbnRyaWVzKG9iai5ub2RlU2VsZWN0b3IpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSkpLFxuICAgICd0b2xlcmF0aW9ucyc6IG9iai50b2xlcmF0aW9ucz8ubWFwKHkgPT4gdG9Kc29uX1RvbGVyYXRpb24oeSkpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEtpbmQgaXMgYSBzdHJpbmcgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBSRVNUIHJlc291cmNlIHRoaXMgb2JqZWN0IHJlcHJlc2VudHMuIFNlcnZlcnMgbWF5IGluZmVyIHRoaXMgZnJvbSB0aGUgZW5kcG9pbnQgdGhlIGNsaWVudCBzdWJtaXRzIHJlcXVlc3RzIHRvLiBDYW5ub3QgYmUgdXBkYXRlZC4gSW4gQ2FtZWxDYXNlLiBNb3JlIGluZm86IGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3R5cGVzLWtpbmRzXG4gKlxuICogQHNjaGVtYSBJb0s4U0FwaW1hY2hpbmVyeVBrZ0FwaXNNZXRhVjFEZWxldGVPcHRpb25zS2luZFxuICovXG5leHBvcnQgZW51bSBJb0s4U0FwaW1hY2hpbmVyeVBrZ0FwaXNNZXRhVjFEZWxldGVPcHRpb25zS2luZCB7XG4gIC8qKiBEZWxldGVPcHRpb25zICovXG4gIERFTEVURV9PUFRJT05TID0gJ0RlbGV0ZU9wdGlvbnMnLFxufVxuXG4vKipcbiAqIFByZWNvbmRpdGlvbnMgbXVzdCBiZSBmdWxmaWxsZWQgYmVmb3JlIGFuIG9wZXJhdGlvbiAodXBkYXRlLCBkZWxldGUsIGV0Yy4pIGlzIGNhcnJpZWQgb3V0LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLlByZWNvbmRpdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcmVjb25kaXRpb25zIHtcbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgdGFyZ2V0IFJlc291cmNlVmVyc2lvblxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5QcmVjb25kaXRpb25zI3Jlc291cmNlVmVyc2lvblxuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VWZXJzaW9uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIHRhcmdldCBVSUQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLlByZWNvbmRpdGlvbnMjdWlkXG4gICAqL1xuICByZWFkb25seSB1aWQ/OiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnUHJlY29uZGl0aW9ucycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fUHJlY29uZGl0aW9ucyhvYmo6IFByZWNvbmRpdGlvbnMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdyZXNvdXJjZVZlcnNpb24nOiBvYmoucmVzb3VyY2VWZXJzaW9uLFxuICAgICd1aWQnOiBvYmoudWlkLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cudXRpbC5pbnRzdHIuSW50T3JTdHJpbmdcbiAqL1xuZXhwb3J0IGNsYXNzIEludE9yU3RyaW5nIHtcbiAgcHVibGljIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlOiBzdHJpbmcpOiBJbnRPclN0cmluZyB7XG4gICAgcmV0dXJuIG5ldyBJbnRPclN0cmluZyh2YWx1ZSk7XG4gIH1cbiAgcHVibGljIHN0YXRpYyBmcm9tTnVtYmVyKHZhbHVlOiBudW1iZXIpOiBJbnRPclN0cmluZyB7XG4gICAgcmV0dXJuIG5ldyBJbnRPclN0cmluZyh2YWx1ZSk7XG4gIH1cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgdmFsdWU6IGFueSkge1xuICB9XG59XG5cbi8qKlxuICogQWxsb3dlZENTSURyaXZlciByZXByZXNlbnRzIGEgc2luZ2xlIGlubGluZSBDU0kgRHJpdmVyIHRoYXQgaXMgYWxsb3dlZCB0byBiZSB1c2VkLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5BbGxvd2VkQ1NJRHJpdmVyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWxsb3dlZENzaURyaXZlclYxQmV0YTEge1xuICAvKipcbiAgICogTmFtZSBpcyB0aGUgcmVnaXN0ZXJlZCBuYW1lIG9mIHRoZSBDU0kgZHJpdmVyXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5BbGxvd2VkQ1NJRHJpdmVyI25hbWVcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdBbGxvd2VkQ3NpRHJpdmVyVjFCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fQWxsb3dlZENzaURyaXZlclYxQmV0YTEob2JqOiBBbGxvd2VkQ3NpRHJpdmVyVjFCZXRhMSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ25hbWUnOiBvYmoubmFtZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBBbGxvd2VkRmxleFZvbHVtZSByZXByZXNlbnRzIGEgc2luZ2xlIEZsZXh2b2x1bWUgdGhhdCBpcyBhbGxvd2VkIHRvIGJlIHVzZWQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLkFsbG93ZWRGbGV4Vm9sdW1lXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWxsb3dlZEZsZXhWb2x1bWVWMUJldGExIHtcbiAgLyoqXG4gICAqIGRyaXZlciBpcyB0aGUgbmFtZSBvZiB0aGUgRmxleHZvbHVtZSBkcml2ZXIuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5BbGxvd2VkRmxleFZvbHVtZSNkcml2ZXJcbiAgICovXG4gIHJlYWRvbmx5IGRyaXZlcjogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0FsbG93ZWRGbGV4Vm9sdW1lVjFCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fQWxsb3dlZEZsZXhWb2x1bWVWMUJldGExKG9iajogQWxsb3dlZEZsZXhWb2x1bWVWMUJldGExIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZHJpdmVyJzogb2JqLmRyaXZlcixcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBBbGxvd2VkSG9zdFBhdGggZGVmaW5lcyB0aGUgaG9zdCB2b2x1bWUgY29uZGl0aW9ucyB0aGF0IHdpbGwgYmUgZW5hYmxlZCBieSBhIHBvbGljeSBmb3IgcG9kcyB0byB1c2UuIEl0IHJlcXVpcmVzIHRoZSBwYXRoIHByZWZpeCB0byBiZSBkZWZpbmVkLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5BbGxvd2VkSG9zdFBhdGhcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBbGxvd2VkSG9zdFBhdGhWMUJldGExIHtcbiAgLyoqXG4gICAqIHBhdGhQcmVmaXggaXMgdGhlIHBhdGggcHJlZml4IHRoYXQgdGhlIGhvc3Qgdm9sdW1lIG11c3QgbWF0Y2guIEl0IGRvZXMgbm90IHN1cHBvcnQgYCpgLiBUcmFpbGluZyBzbGFzaGVzIGFyZSB0cmltbWVkIHdoZW4gdmFsaWRhdGluZyB0aGUgcGF0aCBwcmVmaXggd2l0aCBhIGhvc3QgcGF0aC5cbiAgICpcbiAgICogRXhhbXBsZXM6IGAvZm9vYCB3b3VsZCBhbGxvdyBgL2Zvb2AsIGAvZm9vL2AgYW5kIGAvZm9vL2JhcmAgYC9mb29gIHdvdWxkIG5vdCBhbGxvdyBgL2Zvb2RgIG9yIGAvZXRjL2Zvb2BcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLkFsbG93ZWRIb3N0UGF0aCNwYXRoUHJlZml4XG4gICAqL1xuICByZWFkb25seSBwYXRoUHJlZml4Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiB3aGVuIHNldCB0byB0cnVlLCB3aWxsIGFsbG93IGhvc3Qgdm9sdW1lcyBtYXRjaGluZyB0aGUgcGF0aFByZWZpeCBvbmx5IGlmIGFsbCB2b2x1bWUgbW91bnRzIGFyZSByZWFkT25seS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLkFsbG93ZWRIb3N0UGF0aCNyZWFkT25seVxuICAgKi9cbiAgcmVhZG9ubHkgcmVhZE9ubHk/OiBib29sZWFuO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0FsbG93ZWRIb3N0UGF0aFYxQmV0YTEnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0FsbG93ZWRIb3N0UGF0aFYxQmV0YTEob2JqOiBBbGxvd2VkSG9zdFBhdGhWMUJldGExIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAncGF0aFByZWZpeCc6IG9iai5wYXRoUHJlZml4LFxuICAgICdyZWFkT25seSc6IG9iai5yZWFkT25seSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBGU0dyb3VwU3RyYXRlZ3lPcHRpb25zIGRlZmluZXMgdGhlIHN0cmF0ZWd5IHR5cGUgYW5kIG9wdGlvbnMgdXNlZCB0byBjcmVhdGUgdGhlIHN0cmF0ZWd5LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5GU0dyb3VwU3RyYXRlZ3lPcHRpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRnNHcm91cFN0cmF0ZWd5T3B0aW9uc1YxQmV0YTEge1xuICAvKipcbiAgICogcmFuZ2VzIGFyZSB0aGUgYWxsb3dlZCByYW5nZXMgb2YgZnMgZ3JvdXBzLiAgSWYgeW91IHdvdWxkIGxpa2UgdG8gZm9yY2UgYSBzaW5nbGUgZnMgZ3JvdXAgdGhlbiBzdXBwbHkgYSBzaW5nbGUgcmFuZ2Ugd2l0aCB0aGUgc2FtZSBzdGFydCBhbmQgZW5kLiBSZXF1aXJlZCBmb3IgTXVzdFJ1bkFzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucG9saWN5LnYxYmV0YTEuRlNHcm91cFN0cmF0ZWd5T3B0aW9ucyNyYW5nZXNcbiAgICovXG4gIHJlYWRvbmx5IHJhbmdlcz86IElkUmFuZ2VWMUJldGExW107XG5cbiAgLyoqXG4gICAqIHJ1bGUgaXMgdGhlIHN0cmF0ZWd5IHRoYXQgd2lsbCBkaWN0YXRlIHdoYXQgRlNHcm91cCBpcyB1c2VkIGluIHRoZSBTZWN1cml0eUNvbnRleHQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5GU0dyb3VwU3RyYXRlZ3lPcHRpb25zI3J1bGVcbiAgICovXG4gIHJlYWRvbmx5IHJ1bGU/OiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnRnNHcm91cFN0cmF0ZWd5T3B0aW9uc1YxQmV0YTEnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0ZzR3JvdXBTdHJhdGVneU9wdGlvbnNWMUJldGExKG9iajogRnNHcm91cFN0cmF0ZWd5T3B0aW9uc1YxQmV0YTEgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdyYW5nZXMnOiBvYmoucmFuZ2VzPy5tYXAoeSA9PiB0b0pzb25fSWRSYW5nZVYxQmV0YTEoeSkpLFxuICAgICdydWxlJzogb2JqLnJ1bGUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogSG9zdFBvcnRSYW5nZSBkZWZpbmVzIGEgcmFuZ2Ugb2YgaG9zdCBwb3J0cyB0aGF0IHdpbGwgYmUgZW5hYmxlZCBieSBhIHBvbGljeSBmb3IgcG9kcyB0byB1c2UuICBJdCByZXF1aXJlcyBib3RoIHRoZSBzdGFydCBhbmQgZW5kIHRvIGJlIGRlZmluZWQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLkhvc3RQb3J0UmFuZ2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIb3N0UG9ydFJhbmdlVjFCZXRhMSB7XG4gIC8qKlxuICAgKiBtYXggaXMgdGhlIGVuZCBvZiB0aGUgcmFuZ2UsIGluY2x1c2l2ZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLkhvc3RQb3J0UmFuZ2UjbWF4XG4gICAqL1xuICByZWFkb25seSBtYXg6IG51bWJlcjtcblxuICAvKipcbiAgICogbWluIGlzIHRoZSBzdGFydCBvZiB0aGUgcmFuZ2UsIGluY2x1c2l2ZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLkhvc3RQb3J0UmFuZ2UjbWluXG4gICAqL1xuICByZWFkb25seSBtaW46IG51bWJlcjtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdIb3N0UG9ydFJhbmdlVjFCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fSG9zdFBvcnRSYW5nZVYxQmV0YTEob2JqOiBIb3N0UG9ydFJhbmdlVjFCZXRhMSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21heCc6IG9iai5tYXgsXG4gICAgJ21pbic6IG9iai5taW4sXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUnVuQXNHcm91cFN0cmF0ZWd5T3B0aW9ucyBkZWZpbmVzIHRoZSBzdHJhdGVneSB0eXBlIGFuZCBhbnkgb3B0aW9ucyB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RyYXRlZ3kuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlJ1bkFzR3JvdXBTdHJhdGVneU9wdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSdW5Bc0dyb3VwU3RyYXRlZ3lPcHRpb25zVjFCZXRhMSB7XG4gIC8qKlxuICAgKiByYW5nZXMgYXJlIHRoZSBhbGxvd2VkIHJhbmdlcyBvZiBnaWRzIHRoYXQgbWF5IGJlIHVzZWQuIElmIHlvdSB3b3VsZCBsaWtlIHRvIGZvcmNlIGEgc2luZ2xlIGdpZCB0aGVuIHN1cHBseSBhIHNpbmdsZSByYW5nZSB3aXRoIHRoZSBzYW1lIHN0YXJ0IGFuZCBlbmQuIFJlcXVpcmVkIGZvciBNdXN0UnVuQXMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5SdW5Bc0dyb3VwU3RyYXRlZ3lPcHRpb25zI3Jhbmdlc1xuICAgKi9cbiAgcmVhZG9ubHkgcmFuZ2VzPzogSWRSYW5nZVYxQmV0YTFbXTtcblxuICAvKipcbiAgICogcnVsZSBpcyB0aGUgc3RyYXRlZ3kgdGhhdCB3aWxsIGRpY3RhdGUgdGhlIGFsbG93YWJsZSBSdW5Bc0dyb3VwIHZhbHVlcyB0aGF0IG1heSBiZSBzZXQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5SdW5Bc0dyb3VwU3RyYXRlZ3lPcHRpb25zI3J1bGVcbiAgICovXG4gIHJlYWRvbmx5IHJ1bGU6IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdSdW5Bc0dyb3VwU3RyYXRlZ3lPcHRpb25zVjFCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fUnVuQXNHcm91cFN0cmF0ZWd5T3B0aW9uc1YxQmV0YTEob2JqOiBSdW5Bc0dyb3VwU3RyYXRlZ3lPcHRpb25zVjFCZXRhMSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ3Jhbmdlcyc6IG9iai5yYW5nZXM/Lm1hcCh5ID0+IHRvSnNvbl9JZFJhbmdlVjFCZXRhMSh5KSksXG4gICAgJ3J1bGUnOiBvYmoucnVsZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBSdW5Bc1VzZXJTdHJhdGVneU9wdGlvbnMgZGVmaW5lcyB0aGUgc3RyYXRlZ3kgdHlwZSBhbmQgYW55IG9wdGlvbnMgdXNlZCB0byBjcmVhdGUgdGhlIHN0cmF0ZWd5LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5SdW5Bc1VzZXJTdHJhdGVneU9wdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSdW5Bc1VzZXJTdHJhdGVneU9wdGlvbnNWMUJldGExIHtcbiAgLyoqXG4gICAqIHJhbmdlcyBhcmUgdGhlIGFsbG93ZWQgcmFuZ2VzIG9mIHVpZHMgdGhhdCBtYXkgYmUgdXNlZC4gSWYgeW91IHdvdWxkIGxpa2UgdG8gZm9yY2UgYSBzaW5nbGUgdWlkIHRoZW4gc3VwcGx5IGEgc2luZ2xlIHJhbmdlIHdpdGggdGhlIHNhbWUgc3RhcnQgYW5kIGVuZC4gUmVxdWlyZWQgZm9yIE11c3RSdW5Bcy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlJ1bkFzVXNlclN0cmF0ZWd5T3B0aW9ucyNyYW5nZXNcbiAgICovXG4gIHJlYWRvbmx5IHJhbmdlcz86IElkUmFuZ2VWMUJldGExW107XG5cbiAgLyoqXG4gICAqIHJ1bGUgaXMgdGhlIHN0cmF0ZWd5IHRoYXQgd2lsbCBkaWN0YXRlIHRoZSBhbGxvd2FibGUgUnVuQXNVc2VyIHZhbHVlcyB0aGF0IG1heSBiZSBzZXQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5SdW5Bc1VzZXJTdHJhdGVneU9wdGlvbnMjcnVsZVxuICAgKi9cbiAgcmVhZG9ubHkgcnVsZTogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1J1bkFzVXNlclN0cmF0ZWd5T3B0aW9uc1YxQmV0YTEnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1J1bkFzVXNlclN0cmF0ZWd5T3B0aW9uc1YxQmV0YTEob2JqOiBSdW5Bc1VzZXJTdHJhdGVneU9wdGlvbnNWMUJldGExIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAncmFuZ2VzJzogb2JqLnJhbmdlcz8ubWFwKHkgPT4gdG9Kc29uX0lkUmFuZ2VWMUJldGExKHkpKSxcbiAgICAncnVsZSc6IG9iai5ydWxlLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFJ1bnRpbWVDbGFzc1N0cmF0ZWd5T3B0aW9ucyBkZWZpbmUgdGhlIHN0cmF0ZWd5IHRoYXQgd2lsbCBkaWN0YXRlIHRoZSBhbGxvd2FibGUgUnVudGltZUNsYXNzZXMgZm9yIGEgcG9kLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5SdW50aW1lQ2xhc3NTdHJhdGVneU9wdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSdW50aW1lQ2xhc3NTdHJhdGVneU9wdGlvbnNWMUJldGExIHtcbiAgLyoqXG4gICAqIGFsbG93ZWRSdW50aW1lQ2xhc3NOYW1lcyBpcyBhbiBhbGxvd2xpc3Qgb2YgUnVudGltZUNsYXNzIG5hbWVzIHRoYXQgbWF5IGJlIHNwZWNpZmllZCBvbiBhIHBvZC4gQSB2YWx1ZSBvZiBcIipcIiBtZWFucyB0aGF0IGFueSBSdW50aW1lQ2xhc3MgbmFtZSBpcyBhbGxvd2VkLCBhbmQgbXVzdCBiZSB0aGUgb25seSBpdGVtIGluIHRoZSBsaXN0LiBBbiBlbXB0eSBsaXN0IHJlcXVpcmVzIHRoZSBSdW50aW1lQ2xhc3NOYW1lIGZpZWxkIHRvIGJlIHVuc2V0LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucG9saWN5LnYxYmV0YTEuUnVudGltZUNsYXNzU3RyYXRlZ3lPcHRpb25zI2FsbG93ZWRSdW50aW1lQ2xhc3NOYW1lc1xuICAgKi9cbiAgcmVhZG9ubHkgYWxsb3dlZFJ1bnRpbWVDbGFzc05hbWVzOiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogZGVmYXVsdFJ1bnRpbWVDbGFzc05hbWUgaXMgdGhlIGRlZmF1bHQgUnVudGltZUNsYXNzTmFtZSB0byBzZXQgb24gdGhlIHBvZC4gVGhlIGRlZmF1bHQgTVVTVCBiZSBhbGxvd2VkIGJ5IHRoZSBhbGxvd2VkUnVudGltZUNsYXNzTmFtZXMgbGlzdC4gQSB2YWx1ZSBvZiBuaWwgZG9lcyBub3QgbXV0YXRlIHRoZSBQb2QuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5SdW50aW1lQ2xhc3NTdHJhdGVneU9wdGlvbnMjZGVmYXVsdFJ1bnRpbWVDbGFzc05hbWVcbiAgICovXG4gIHJlYWRvbmx5IGRlZmF1bHRSdW50aW1lQ2xhc3NOYW1lPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1J1bnRpbWVDbGFzc1N0cmF0ZWd5T3B0aW9uc1YxQmV0YTEnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1J1bnRpbWVDbGFzc1N0cmF0ZWd5T3B0aW9uc1YxQmV0YTEob2JqOiBSdW50aW1lQ2xhc3NTdHJhdGVneU9wdGlvbnNWMUJldGExIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnYWxsb3dlZFJ1bnRpbWVDbGFzc05hbWVzJzogb2JqLmFsbG93ZWRSdW50aW1lQ2xhc3NOYW1lcz8ubWFwKHkgPT4geSksXG4gICAgJ2RlZmF1bHRSdW50aW1lQ2xhc3NOYW1lJzogb2JqLmRlZmF1bHRSdW50aW1lQ2xhc3NOYW1lLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFNFTGludXhTdHJhdGVneU9wdGlvbnMgZGVmaW5lcyB0aGUgc3RyYXRlZ3kgdHlwZSBhbmQgYW55IG9wdGlvbnMgdXNlZCB0byBjcmVhdGUgdGhlIHN0cmF0ZWd5LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5TRUxpbnV4U3RyYXRlZ3lPcHRpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VMaW51eFN0cmF0ZWd5T3B0aW9uc1YxQmV0YTEge1xuICAvKipcbiAgICogcnVsZSBpcyB0aGUgc3RyYXRlZ3kgdGhhdCB3aWxsIGRpY3RhdGUgdGhlIGFsbG93YWJsZSBsYWJlbHMgdGhhdCBtYXkgYmUgc2V0LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkucG9saWN5LnYxYmV0YTEuU0VMaW51eFN0cmF0ZWd5T3B0aW9ucyNydWxlXG4gICAqL1xuICByZWFkb25seSBydWxlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIHNlTGludXhPcHRpb25zIHJlcXVpcmVkIHRvIHJ1biBhczsgcmVxdWlyZWQgZm9yIE11c3RSdW5BcyBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL3Rhc2tzL2NvbmZpZ3VyZS1wb2QtY29udGFpbmVyL3NlY3VyaXR5LWNvbnRleHQvXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5TRUxpbnV4U3RyYXRlZ3lPcHRpb25zI3NlTGludXhPcHRpb25zXG4gICAqL1xuICByZWFkb25seSBzZUxpbnV4T3B0aW9ucz86IFNlTGludXhPcHRpb25zO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1NlTGludXhTdHJhdGVneU9wdGlvbnNWMUJldGExJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9TZUxpbnV4U3RyYXRlZ3lPcHRpb25zVjFCZXRhMShvYmo6IFNlTGludXhTdHJhdGVneU9wdGlvbnNWMUJldGExIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAncnVsZSc6IG9iai5ydWxlLFxuICAgICdzZUxpbnV4T3B0aW9ucyc6IHRvSnNvbl9TZUxpbnV4T3B0aW9ucyhvYmouc2VMaW51eE9wdGlvbnMpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFN1cHBsZW1lbnRhbEdyb3Vwc1N0cmF0ZWd5T3B0aW9ucyBkZWZpbmVzIHRoZSBzdHJhdGVneSB0eXBlIGFuZCBvcHRpb25zIHVzZWQgdG8gY3JlYXRlIHRoZSBzdHJhdGVneS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkucG9saWN5LnYxYmV0YTEuU3VwcGxlbWVudGFsR3JvdXBzU3RyYXRlZ3lPcHRpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3VwcGxlbWVudGFsR3JvdXBzU3RyYXRlZ3lPcHRpb25zVjFCZXRhMSB7XG4gIC8qKlxuICAgKiByYW5nZXMgYXJlIHRoZSBhbGxvd2VkIHJhbmdlcyBvZiBzdXBwbGVtZW50YWwgZ3JvdXBzLiAgSWYgeW91IHdvdWxkIGxpa2UgdG8gZm9yY2UgYSBzaW5nbGUgc3VwcGxlbWVudGFsIGdyb3VwIHRoZW4gc3VwcGx5IGEgc2luZ2xlIHJhbmdlIHdpdGggdGhlIHNhbWUgc3RhcnQgYW5kIGVuZC4gUmVxdWlyZWQgZm9yIE11c3RSdW5Bcy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLlN1cHBsZW1lbnRhbEdyb3Vwc1N0cmF0ZWd5T3B0aW9ucyNyYW5nZXNcbiAgICovXG4gIHJlYWRvbmx5IHJhbmdlcz86IElkUmFuZ2VWMUJldGExW107XG5cbiAgLyoqXG4gICAqIHJ1bGUgaXMgdGhlIHN0cmF0ZWd5IHRoYXQgd2lsbCBkaWN0YXRlIHdoYXQgc3VwcGxlbWVudGFsIGdyb3VwcyBpcyB1c2VkIGluIHRoZSBTZWN1cml0eUNvbnRleHQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5wb2xpY3kudjFiZXRhMS5TdXBwbGVtZW50YWxHcm91cHNTdHJhdGVneU9wdGlvbnMjcnVsZVxuICAgKi9cbiAgcmVhZG9ubHkgcnVsZT86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdTdXBwbGVtZW50YWxHcm91cHNTdHJhdGVneU9wdGlvbnNWMUJldGExJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9TdXBwbGVtZW50YWxHcm91cHNTdHJhdGVneU9wdGlvbnNWMUJldGExKG9iajogU3VwcGxlbWVudGFsR3JvdXBzU3RyYXRlZ3lPcHRpb25zVjFCZXRhMSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ3Jhbmdlcyc6IG9iai5yYW5nZXM/Lm1hcCh5ID0+IHRvSnNvbl9JZFJhbmdlVjFCZXRhMSh5KSksXG4gICAgJ3J1bGUnOiBvYmoucnVsZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBUb2tlblJlcXVlc3QgY29udGFpbnMgcGFyYW1ldGVycyBvZiBhIHNlcnZpY2UgYWNjb3VudCB0b2tlbi5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5Ub2tlblJlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUb2tlblJlcXVlc3Qge1xuICAvKipcbiAgICogQXVkaWVuY2UgaXMgdGhlIGludGVuZGVkIGF1ZGllbmNlIG9mIHRoZSB0b2tlbiBpbiBcIlRva2VuUmVxdWVzdFNwZWNcIi4gSXQgd2lsbCBkZWZhdWx0IHRvIHRoZSBhdWRpZW5jZXMgb2Yga3ViZSBhcGlzZXJ2ZXIuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxLlRva2VuUmVxdWVzdCNhdWRpZW5jZVxuICAgKi9cbiAgcmVhZG9ubHkgYXVkaWVuY2U6IHN0cmluZztcblxuICAvKipcbiAgICogRXhwaXJhdGlvblNlY29uZHMgaXMgdGhlIGR1cmF0aW9uIG9mIHZhbGlkaXR5IG9mIHRoZSB0b2tlbiBpbiBcIlRva2VuUmVxdWVzdFNwZWNcIi4gSXQgaGFzIHRoZSBzYW1lIGRlZmF1bHQgdmFsdWUgb2YgXCJFeHBpcmF0aW9uU2Vjb25kc1wiIGluIFwiVG9rZW5SZXF1ZXN0U3BlY1wiLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5Ub2tlblJlcXVlc3QjZXhwaXJhdGlvblNlY29uZHNcbiAgICovXG4gIHJlYWRvbmx5IGV4cGlyYXRpb25TZWNvbmRzPzogbnVtYmVyO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1Rva2VuUmVxdWVzdCcgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fVG9rZW5SZXF1ZXN0KG9iajogVG9rZW5SZXF1ZXN0IHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnYXVkaWVuY2UnOiBvYmouYXVkaWVuY2UsXG4gICAgJ2V4cGlyYXRpb25TZWNvbmRzJzogb2JqLmV4cGlyYXRpb25TZWNvbmRzLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIENTSU5vZGVEcml2ZXIgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHNwZWNpZmljYXRpb24gb2Ygb25lIENTSSBkcml2ZXIgaW5zdGFsbGVkIG9uIGEgbm9kZVxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxLkNTSU5vZGVEcml2ZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDc2lOb2RlRHJpdmVyIHtcbiAgLyoqXG4gICAqIGFsbG9jYXRhYmxlIHJlcHJlc2VudHMgdGhlIHZvbHVtZSByZXNvdXJjZXMgb2YgYSBub2RlIHRoYXQgYXJlIGF2YWlsYWJsZSBmb3Igc2NoZWR1bGluZy4gVGhpcyBmaWVsZCBpcyBiZXRhLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5DU0lOb2RlRHJpdmVyI2FsbG9jYXRhYmxlXG4gICAqL1xuICByZWFkb25seSBhbGxvY2F0YWJsZT86IFZvbHVtZU5vZGVSZXNvdXJjZXM7XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIENTSSBkcml2ZXIgdGhhdCB0aGlzIG9iamVjdCByZWZlcnMgdG8uIFRoaXMgTVVTVCBiZSB0aGUgc2FtZSBuYW1lIHJldHVybmVkIGJ5IHRoZSBDU0kgR2V0UGx1Z2luTmFtZSgpIGNhbGwgZm9yIHRoYXQgZHJpdmVyLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5DU0lOb2RlRHJpdmVyI25hbWVcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogbm9kZUlEIG9mIHRoZSBub2RlIGZyb20gdGhlIGRyaXZlciBwb2ludCBvZiB2aWV3LiBUaGlzIGZpZWxkIGVuYWJsZXMgS3ViZXJuZXRlcyB0byBjb21tdW5pY2F0ZSB3aXRoIHN0b3JhZ2Ugc3lzdGVtcyB0aGF0IGRvIG5vdCBzaGFyZSB0aGUgc2FtZSBub21lbmNsYXR1cmUgZm9yIG5vZGVzLiBGb3IgZXhhbXBsZSwgS3ViZXJuZXRlcyBtYXkgcmVmZXIgdG8gYSBnaXZlbiBub2RlIGFzIFwibm9kZTFcIiwgYnV0IHRoZSBzdG9yYWdlIHN5c3RlbSBtYXkgcmVmZXIgdG8gdGhlIHNhbWUgbm9kZSBhcyBcIm5vZGVBXCIuIFdoZW4gS3ViZXJuZXRlcyBpc3N1ZXMgYSBjb21tYW5kIHRvIHRoZSBzdG9yYWdlIHN5c3RlbSB0byBhdHRhY2ggYSB2b2x1bWUgdG8gYSBzcGVjaWZpYyBub2RlLCBpdCBjYW4gdXNlIHRoaXMgZmllbGQgdG8gcmVmZXIgdG8gdGhlIG5vZGUgbmFtZSB1c2luZyB0aGUgSUQgdGhhdCB0aGUgc3RvcmFnZSBzeXN0ZW0gd2lsbCB1bmRlcnN0YW5kLCBlLmcuIFwibm9kZUFcIiBpbnN0ZWFkIG9mIFwibm9kZTFcIi4gVGhpcyBmaWVsZCBpcyByZXF1aXJlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjEuQ1NJTm9kZURyaXZlciNub2RlSURcbiAgICovXG4gIHJlYWRvbmx5IG5vZGVJZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiB0b3BvbG9neUtleXMgaXMgdGhlIGxpc3Qgb2Yga2V5cyBzdXBwb3J0ZWQgYnkgdGhlIGRyaXZlci4gV2hlbiBhIGRyaXZlciBpcyBpbml0aWFsaXplZCBvbiBhIGNsdXN0ZXIsIGl0IHByb3ZpZGVzIGEgc2V0IG9mIHRvcG9sb2d5IGtleXMgdGhhdCBpdCB1bmRlcnN0YW5kcyAoZS5nLiBcImNvbXBhbnkuY29tL3pvbmVcIiwgXCJjb21wYW55LmNvbS9yZWdpb25cIikuIFdoZW4gYSBkcml2ZXIgaXMgaW5pdGlhbGl6ZWQgb24gYSBub2RlLCBpdCBwcm92aWRlcyB0aGUgc2FtZSB0b3BvbG9neSBrZXlzIGFsb25nIHdpdGggdmFsdWVzLiBLdWJlbGV0IHdpbGwgZXhwb3NlIHRoZXNlIHRvcG9sb2d5IGtleXMgYXMgbGFiZWxzIG9uIGl0cyBvd24gbm9kZSBvYmplY3QuIFdoZW4gS3ViZXJuZXRlcyBkb2VzIHRvcG9sb2d5IGF3YXJlIHByb3Zpc2lvbmluZywgaXQgY2FuIHVzZSB0aGlzIGxpc3QgdG8gZGV0ZXJtaW5lIHdoaWNoIGxhYmVscyBpdCBzaG91bGQgcmV0cmlldmUgZnJvbSB0aGUgbm9kZSBvYmplY3QgYW5kIHBhc3MgYmFjayB0byB0aGUgZHJpdmVyLiBJdCBpcyBwb3NzaWJsZSBmb3IgZGlmZmVyZW50IG5vZGVzIHRvIHVzZSBkaWZmZXJlbnQgdG9wb2xvZ3kga2V5cy4gVGhpcyBjYW4gYmUgZW1wdHkgaWYgZHJpdmVyIGRvZXMgbm90IHN1cHBvcnQgdG9wb2xvZ3kuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxLkNTSU5vZGVEcml2ZXIjdG9wb2xvZ3lLZXlzXG4gICAqL1xuICByZWFkb25seSB0b3BvbG9neUtleXM/OiBzdHJpbmdbXTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdDc2lOb2RlRHJpdmVyJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Dc2lOb2RlRHJpdmVyKG9iajogQ3NpTm9kZURyaXZlciB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2FsbG9jYXRhYmxlJzogdG9Kc29uX1ZvbHVtZU5vZGVSZXNvdXJjZXMob2JqLmFsbG9jYXRhYmxlKSxcbiAgICAnbmFtZSc6IG9iai5uYW1lLFxuICAgICdub2RlSUQnOiBvYmoubm9kZUlkLFxuICAgICd0b3BvbG9neUtleXMnOiBvYmoudG9wb2xvZ3lLZXlzPy5tYXAoeSA9PiB5KSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBBIHRvcG9sb2d5IHNlbGVjdG9yIHJlcXVpcmVtZW50IGlzIGEgc2VsZWN0b3IgdGhhdCBtYXRjaGVzIGdpdmVuIGxhYmVsLiBUaGlzIGlzIGFuIGFscGhhIGZlYXR1cmUgYW5kIG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Ub3BvbG9neVNlbGVjdG9yTGFiZWxSZXF1aXJlbWVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRvcG9sb2d5U2VsZWN0b3JMYWJlbFJlcXVpcmVtZW50IHtcbiAgLyoqXG4gICAqIFRoZSBsYWJlbCBrZXkgdGhhdCB0aGUgc2VsZWN0b3IgYXBwbGllcyB0by5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVG9wb2xvZ3lTZWxlY3RvckxhYmVsUmVxdWlyZW1lbnQja2V5XG4gICAqL1xuICByZWFkb25seSBrZXk6IHN0cmluZztcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2Ygc3RyaW5nIHZhbHVlcy4gT25lIHZhbHVlIG11c3QgbWF0Y2ggdGhlIGxhYmVsIHRvIGJlIHNlbGVjdGVkLiBFYWNoIGVudHJ5IGluIFZhbHVlcyBpcyBPUmVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Ub3BvbG9neVNlbGVjdG9yTGFiZWxSZXF1aXJlbWVudCN2YWx1ZXNcbiAgICovXG4gIHJlYWRvbmx5IHZhbHVlczogc3RyaW5nW107XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnVG9wb2xvZ3lTZWxlY3RvckxhYmVsUmVxdWlyZW1lbnQnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1RvcG9sb2d5U2VsZWN0b3JMYWJlbFJlcXVpcmVtZW50KG9iajogVG9wb2xvZ3lTZWxlY3RvckxhYmVsUmVxdWlyZW1lbnQgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdrZXknOiBvYmoua2V5LFxuICAgICd2YWx1ZXMnOiBvYmoudmFsdWVzPy5tYXAoeSA9PiB5KSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBWb2x1bWVBdHRhY2htZW50U291cmNlIHJlcHJlc2VudHMgYSB2b2x1bWUgdGhhdCBzaG91bGQgYmUgYXR0YWNoZWQuIFJpZ2h0IG5vdyBvbmx5IFBlcnNpc3RlblZvbHVtZXMgY2FuIGJlIGF0dGFjaGVkIHZpYSBleHRlcm5hbCBhdHRhY2hlciwgaW4gZnV0dXJlIHdlIG1heSBhbGxvdyBhbHNvIGlubGluZSB2b2x1bWVzIGluIHBvZHMuIEV4YWN0bHkgb25lIG1lbWJlciBjYW4gYmUgc2V0LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxLlZvbHVtZUF0dGFjaG1lbnRTb3VyY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWb2x1bWVBdHRhY2htZW50U291cmNlIHtcbiAgLyoqXG4gICAqIGlubGluZVZvbHVtZVNwZWMgY29udGFpbnMgYWxsIHRoZSBpbmZvcm1hdGlvbiBuZWNlc3NhcnkgdG8gYXR0YWNoIGEgcGVyc2lzdGVudCB2b2x1bWUgZGVmaW5lZCBieSBhIHBvZCdzIGlubGluZSBWb2x1bWVTb3VyY2UuIFRoaXMgZmllbGQgaXMgcG9wdWxhdGVkIG9ubHkgZm9yIHRoZSBDU0lNaWdyYXRpb24gZmVhdHVyZS4gSXQgY29udGFpbnMgdHJhbnNsYXRlZCBmaWVsZHMgZnJvbSBhIHBvZCdzIGlubGluZSBWb2x1bWVTb3VyY2UgdG8gYSBQZXJzaXN0ZW50Vm9sdW1lU3BlYy4gVGhpcyBmaWVsZCBpcyBiZXRhLWxldmVsIGFuZCBpcyBvbmx5IGhvbm9yZWQgYnkgc2VydmVycyB0aGF0IGVuYWJsZWQgdGhlIENTSU1pZ3JhdGlvbiBmZWF0dXJlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5Wb2x1bWVBdHRhY2htZW50U291cmNlI2lubGluZVZvbHVtZVNwZWNcbiAgICovXG4gIHJlYWRvbmx5IGlubGluZVZvbHVtZVNwZWM/OiBQZXJzaXN0ZW50Vm9sdW1lU3BlYztcblxuICAvKipcbiAgICogTmFtZSBvZiB0aGUgcGVyc2lzdGVudCB2b2x1bWUgdG8gYXR0YWNoLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5Wb2x1bWVBdHRhY2htZW50U291cmNlI3BlcnNpc3RlbnRWb2x1bWVOYW1lXG4gICAqL1xuICByZWFkb25seSBwZXJzaXN0ZW50Vm9sdW1lTmFtZT86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdWb2x1bWVBdHRhY2htZW50U291cmNlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Wb2x1bWVBdHRhY2htZW50U291cmNlKG9iajogVm9sdW1lQXR0YWNobWVudFNvdXJjZSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2lubGluZVZvbHVtZVNwZWMnOiB0b0pzb25fUGVyc2lzdGVudFZvbHVtZVNwZWMob2JqLmlubGluZVZvbHVtZVNwZWMpLFxuICAgICdwZXJzaXN0ZW50Vm9sdW1lTmFtZSc6IG9iai5wZXJzaXN0ZW50Vm9sdW1lTmFtZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBBIGxhYmVsIHNlbGVjdG9yIHJlcXVpcmVtZW50IGlzIGEgc2VsZWN0b3IgdGhhdCBjb250YWlucyB2YWx1ZXMsIGEga2V5LCBhbmQgYW4gb3BlcmF0b3IgdGhhdCByZWxhdGVzIHRoZSBrZXkgYW5kIHZhbHVlcy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5MYWJlbFNlbGVjdG9yUmVxdWlyZW1lbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMYWJlbFNlbGVjdG9yUmVxdWlyZW1lbnQge1xuICAvKipcbiAgICoga2V5IGlzIHRoZSBsYWJlbCBrZXkgdGhhdCB0aGUgc2VsZWN0b3IgYXBwbGllcyB0by5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuTGFiZWxTZWxlY3RvclJlcXVpcmVtZW50I2tleVxuICAgKi9cbiAgcmVhZG9ubHkga2V5OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIG9wZXJhdG9yIHJlcHJlc2VudHMgYSBrZXkncyByZWxhdGlvbnNoaXAgdG8gYSBzZXQgb2YgdmFsdWVzLiBWYWxpZCBvcGVyYXRvcnMgYXJlIEluLCBOb3RJbiwgRXhpc3RzIGFuZCBEb2VzTm90RXhpc3QuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLkxhYmVsU2VsZWN0b3JSZXF1aXJlbWVudCNvcGVyYXRvclxuICAgKi9cbiAgcmVhZG9ubHkgb3BlcmF0b3I6IHN0cmluZztcblxuICAvKipcbiAgICogdmFsdWVzIGlzIGFuIGFycmF5IG9mIHN0cmluZyB2YWx1ZXMuIElmIHRoZSBvcGVyYXRvciBpcyBJbiBvciBOb3RJbiwgdGhlIHZhbHVlcyBhcnJheSBtdXN0IGJlIG5vbi1lbXB0eS4gSWYgdGhlIG9wZXJhdG9yIGlzIEV4aXN0cyBvciBEb2VzTm90RXhpc3QsIHRoZSB2YWx1ZXMgYXJyYXkgbXVzdCBiZSBlbXB0eS4gVGhpcyBhcnJheSBpcyByZXBsYWNlZCBkdXJpbmcgYSBzdHJhdGVnaWMgbWVyZ2UgcGF0Y2guXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLkxhYmVsU2VsZWN0b3JSZXF1aXJlbWVudCN2YWx1ZXNcbiAgICovXG4gIHJlYWRvbmx5IHZhbHVlcz86IHN0cmluZ1tdO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0xhYmVsU2VsZWN0b3JSZXF1aXJlbWVudCcgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fTGFiZWxTZWxlY3RvclJlcXVpcmVtZW50KG9iajogTGFiZWxTZWxlY3RvclJlcXVpcmVtZW50IHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAna2V5Jzogb2JqLmtleSxcbiAgICAnb3BlcmF0b3InOiBvYmoub3BlcmF0b3IsXG4gICAgJ3ZhbHVlcyc6IG9iai52YWx1ZXM/Lm1hcCh5ID0+IHkpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFZvbHVtZUF0dGFjaG1lbnRTb3VyY2UgcmVwcmVzZW50cyBhIHZvbHVtZSB0aGF0IHNob3VsZCBiZSBhdHRhY2hlZC4gUmlnaHQgbm93IG9ubHkgUGVyc2lzdGVuVm9sdW1lcyBjYW4gYmUgYXR0YWNoZWQgdmlhIGV4dGVybmFsIGF0dGFjaGVyLCBpbiBmdXR1cmUgd2UgbWF5IGFsbG93IGFsc28gaW5saW5lIHZvbHVtZXMgaW4gcG9kcy4gRXhhY3RseSBvbmUgbWVtYmVyIGNhbiBiZSBzZXQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjFhbHBoYTEuVm9sdW1lQXR0YWNobWVudFNvdXJjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZvbHVtZUF0dGFjaG1lbnRTb3VyY2VWMUFscGhhMSB7XG4gIC8qKlxuICAgKiBpbmxpbmVWb2x1bWVTcGVjIGNvbnRhaW5zIGFsbCB0aGUgaW5mb3JtYXRpb24gbmVjZXNzYXJ5IHRvIGF0dGFjaCBhIHBlcnNpc3RlbnQgdm9sdW1lIGRlZmluZWQgYnkgYSBwb2QncyBpbmxpbmUgVm9sdW1lU291cmNlLiBUaGlzIGZpZWxkIGlzIHBvcHVsYXRlZCBvbmx5IGZvciB0aGUgQ1NJTWlncmF0aW9uIGZlYXR1cmUuIEl0IGNvbnRhaW5zIHRyYW5zbGF0ZWQgZmllbGRzIGZyb20gYSBwb2QncyBpbmxpbmUgVm9sdW1lU291cmNlIHRvIGEgUGVyc2lzdGVudFZvbHVtZVNwZWMuIFRoaXMgZmllbGQgaXMgYWxwaGEtbGV2ZWwgYW5kIGlzIG9ubHkgaG9ub3JlZCBieSBzZXJ2ZXJzIHRoYXQgZW5hYmxlZCB0aGUgQ1NJTWlncmF0aW9uIGZlYXR1cmUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxYWxwaGExLlZvbHVtZUF0dGFjaG1lbnRTb3VyY2UjaW5saW5lVm9sdW1lU3BlY1xuICAgKi9cbiAgcmVhZG9ubHkgaW5saW5lVm9sdW1lU3BlYz86IFBlcnNpc3RlbnRWb2x1bWVTcGVjO1xuXG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBwZXJzaXN0ZW50IHZvbHVtZSB0byBhdHRhY2guXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5zdG9yYWdlLnYxYWxwaGExLlZvbHVtZUF0dGFjaG1lbnRTb3VyY2UjcGVyc2lzdGVudFZvbHVtZU5hbWVcbiAgICovXG4gIHJlYWRvbmx5IHBlcnNpc3RlbnRWb2x1bWVOYW1lPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1ZvbHVtZUF0dGFjaG1lbnRTb3VyY2VWMUFscGhhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fVm9sdW1lQXR0YWNobWVudFNvdXJjZVYxQWxwaGExKG9iajogVm9sdW1lQXR0YWNobWVudFNvdXJjZVYxQWxwaGExIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaW5saW5lVm9sdW1lU3BlYyc6IHRvSnNvbl9QZXJzaXN0ZW50Vm9sdW1lU3BlYyhvYmouaW5saW5lVm9sdW1lU3BlYyksXG4gICAgJ3BlcnNpc3RlbnRWb2x1bWVOYW1lJzogb2JqLnBlcnNpc3RlbnRWb2x1bWVOYW1lLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEN1c3RvbVJlc291cmNlQ29udmVyc2lvbiBkZXNjcmliZXMgaG93IHRvIGNvbnZlcnQgZGlmZmVyZW50IHZlcnNpb25zIG9mIGEgQ1IuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5DdXN0b21SZXNvdXJjZUNvbnZlcnNpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDdXN0b21SZXNvdXJjZUNvbnZlcnNpb24ge1xuICAvKipcbiAgICogc3RyYXRlZ3kgc3BlY2lmaWVzIGhvdyBjdXN0b20gcmVzb3VyY2VzIGFyZSBjb252ZXJ0ZWQgYmV0d2VlbiB2ZXJzaW9ucy4gQWxsb3dlZCB2YWx1ZXMgYXJlOiAtIGBOb25lYDogVGhlIGNvbnZlcnRlciBvbmx5IGNoYW5nZSB0aGUgYXBpVmVyc2lvbiBhbmQgd291bGQgbm90IHRvdWNoIGFueSBvdGhlciBmaWVsZCBpbiB0aGUgY3VzdG9tIHJlc291cmNlLiAtIGBXZWJob29rYDogQVBJIFNlcnZlciB3aWxsIGNhbGwgdG8gYW4gZXh0ZXJuYWwgd2ViaG9vayB0byBkbyB0aGUgY29udmVyc2lvbi4gQWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICAgKiBpcyBuZWVkZWQgZm9yIHRoaXMgb3B0aW9uLiBUaGlzIHJlcXVpcmVzIHNwZWMucHJlc2VydmVVbmtub3duRmllbGRzIHRvIGJlIGZhbHNlLCBhbmQgc3BlYy5jb252ZXJzaW9uLndlYmhvb2sgdG8gYmUgc2V0LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkN1c3RvbVJlc291cmNlQ29udmVyc2lvbiNzdHJhdGVneVxuICAgKi9cbiAgcmVhZG9ubHkgc3RyYXRlZ3k6IHN0cmluZztcblxuICAvKipcbiAgICogd2ViaG9vayBkZXNjcmliZXMgaG93IHRvIGNhbGwgdGhlIGNvbnZlcnNpb24gd2ViaG9vay4gUmVxdWlyZWQgd2hlbiBgc3RyYXRlZ3lgIGlzIHNldCB0byBgV2ViaG9va2AuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuQ3VzdG9tUmVzb3VyY2VDb252ZXJzaW9uI3dlYmhvb2tcbiAgICovXG4gIHJlYWRvbmx5IHdlYmhvb2s/OiBXZWJob29rQ29udmVyc2lvbjtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdDdXN0b21SZXNvdXJjZUNvbnZlcnNpb24nIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0N1c3RvbVJlc291cmNlQ29udmVyc2lvbihvYmo6IEN1c3RvbVJlc291cmNlQ29udmVyc2lvbiB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ3N0cmF0ZWd5Jzogb2JqLnN0cmF0ZWd5LFxuICAgICd3ZWJob29rJzogdG9Kc29uX1dlYmhvb2tDb252ZXJzaW9uKG9iai53ZWJob29rKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBDdXN0b21SZXNvdXJjZURlZmluaXRpb25OYW1lcyBpbmRpY2F0ZXMgdGhlIG5hbWVzIHRvIHNlcnZlIHRoaXMgQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5DdXN0b21SZXNvdXJjZURlZmluaXRpb25OYW1lc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbVJlc291cmNlRGVmaW5pdGlvbk5hbWVzIHtcbiAgLyoqXG4gICAqIGNhdGVnb3JpZXMgaXMgYSBsaXN0IG9mIGdyb3VwZWQgcmVzb3VyY2VzIHRoaXMgY3VzdG9tIHJlc291cmNlIGJlbG9uZ3MgdG8gKGUuZy4gJ2FsbCcpLiBUaGlzIGlzIHB1Ymxpc2hlZCBpbiBBUEkgZGlzY292ZXJ5IGRvY3VtZW50cywgYW5kIHVzZWQgYnkgY2xpZW50cyB0byBzdXBwb3J0IGludm9jYXRpb25zIGxpa2UgYGt1YmVjdGwgZ2V0IGFsbGAuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uTmFtZXMjY2F0ZWdvcmllc1xuICAgKi9cbiAgcmVhZG9ubHkgY2F0ZWdvcmllcz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBraW5kIGlzIHRoZSBzZXJpYWxpemVkIGtpbmQgb2YgdGhlIHJlc291cmNlLiBJdCBpcyBub3JtYWxseSBDYW1lbENhc2UgYW5kIHNpbmd1bGFyLiBDdXN0b20gcmVzb3VyY2UgaW5zdGFuY2VzIHdpbGwgdXNlIHRoaXMgdmFsdWUgYXMgdGhlIGBraW5kYCBhdHRyaWJ1dGUgaW4gQVBJIGNhbGxzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkN1c3RvbVJlc291cmNlRGVmaW5pdGlvbk5hbWVzI2tpbmRcbiAgICovXG4gIHJlYWRvbmx5IGtpbmQ6IHN0cmluZztcblxuICAvKipcbiAgICogbGlzdEtpbmQgaXMgdGhlIHNlcmlhbGl6ZWQga2luZCBvZiB0aGUgbGlzdCBmb3IgdGhpcyByZXNvdXJjZS4gRGVmYXVsdHMgdG8gXCJga2luZGBMaXN0XCIuXG4gICAqXG4gICAqIEBkZWZhdWx0IGtpbmRgTGlzdFwiLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkN1c3RvbVJlc291cmNlRGVmaW5pdGlvbk5hbWVzI2xpc3RLaW5kXG4gICAqL1xuICByZWFkb25seSBsaXN0S2luZD86IHN0cmluZztcblxuICAvKipcbiAgICogcGx1cmFsIGlzIHRoZSBwbHVyYWwgbmFtZSBvZiB0aGUgcmVzb3VyY2UgdG8gc2VydmUuIFRoZSBjdXN0b20gcmVzb3VyY2VzIGFyZSBzZXJ2ZWQgdW5kZXIgYC9hcGlzLzxncm91cD4vPHZlcnNpb24+Ly4uLi88cGx1cmFsPmAuIE11c3QgbWF0Y2ggdGhlIG5hbWUgb2YgdGhlIEN1c3RvbVJlc291cmNlRGVmaW5pdGlvbiAoaW4gdGhlIGZvcm0gYDxuYW1lcy5wbHVyYWw+Ljxncm91cD5gKS4gTXVzdCBiZSBhbGwgbG93ZXJjYXNlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkN1c3RvbVJlc291cmNlRGVmaW5pdGlvbk5hbWVzI3BsdXJhbFxuICAgKi9cbiAgcmVhZG9ubHkgcGx1cmFsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIHNob3J0TmFtZXMgYXJlIHNob3J0IG5hbWVzIGZvciB0aGUgcmVzb3VyY2UsIGV4cG9zZWQgaW4gQVBJIGRpc2NvdmVyeSBkb2N1bWVudHMsIGFuZCB1c2VkIGJ5IGNsaWVudHMgdG8gc3VwcG9ydCBpbnZvY2F0aW9ucyBsaWtlIGBrdWJlY3RsIGdldCA8c2hvcnRuYW1lPmAuIEl0IG11c3QgYmUgYWxsIGxvd2VyY2FzZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5DdXN0b21SZXNvdXJjZURlZmluaXRpb25OYW1lcyNzaG9ydE5hbWVzXG4gICAqL1xuICByZWFkb25seSBzaG9ydE5hbWVzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIHNpbmd1bGFyIGlzIHRoZSBzaW5ndWxhciBuYW1lIG9mIHRoZSByZXNvdXJjZS4gSXQgbXVzdCBiZSBhbGwgbG93ZXJjYXNlLiBEZWZhdWx0cyB0byBsb3dlcmNhc2VkIGBraW5kYC5cbiAgICpcbiAgICogQGRlZmF1bHQgbG93ZXJjYXNlZCBga2luZGAuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uTmFtZXMjc2luZ3VsYXJcbiAgICovXG4gIHJlYWRvbmx5IHNpbmd1bGFyPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0N1c3RvbVJlc291cmNlRGVmaW5pdGlvbk5hbWVzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9DdXN0b21SZXNvdXJjZURlZmluaXRpb25OYW1lcyhvYmo6IEN1c3RvbVJlc291cmNlRGVmaW5pdGlvbk5hbWVzIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnY2F0ZWdvcmllcyc6IG9iai5jYXRlZ29yaWVzPy5tYXAoeSA9PiB5KSxcbiAgICAna2luZCc6IG9iai5raW5kLFxuICAgICdsaXN0S2luZCc6IG9iai5saXN0S2luZCxcbiAgICAncGx1cmFsJzogb2JqLnBsdXJhbCxcbiAgICAnc2hvcnROYW1lcyc6IG9iai5zaG9ydE5hbWVzPy5tYXAoeSA9PiB5KSxcbiAgICAnc2luZ3VsYXInOiBvYmouc2luZ3VsYXIsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uVmVyc2lvbiBkZXNjcmliZXMgYSB2ZXJzaW9uIGZvciBDUkQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5DdXN0b21SZXNvdXJjZURlZmluaXRpb25WZXJzaW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uVmVyc2lvbiB7XG4gIC8qKlxuICAgKiBhZGRpdGlvbmFsUHJpbnRlckNvbHVtbnMgc3BlY2lmaWVzIGFkZGl0aW9uYWwgY29sdW1ucyByZXR1cm5lZCBpbiBUYWJsZSBvdXRwdXQuIFNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9yZWZlcmVuY2UvdXNpbmctYXBpL2FwaS1jb25jZXB0cy8jcmVjZWl2aW5nLXJlc291cmNlcy1hcy10YWJsZXMgZm9yIGRldGFpbHMuIElmIG5vIGNvbHVtbnMgYXJlIHNwZWNpZmllZCwgYSBzaW5nbGUgY29sdW1uIGRpc3BsYXlpbmcgdGhlIGFnZSBvZiB0aGUgY3VzdG9tIHJlc291cmNlIGlzIHVzZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uVmVyc2lvbiNhZGRpdGlvbmFsUHJpbnRlckNvbHVtbnNcbiAgICovXG4gIHJlYWRvbmx5IGFkZGl0aW9uYWxQcmludGVyQ29sdW1ucz86IEN1c3RvbVJlc291cmNlQ29sdW1uRGVmaW5pdGlvbltdO1xuXG4gIC8qKlxuICAgKiBkZXByZWNhdGVkIGluZGljYXRlcyB0aGlzIHZlcnNpb24gb2YgdGhlIGN1c3RvbSByZXNvdXJjZSBBUEkgaXMgZGVwcmVjYXRlZC4gV2hlbiBzZXQgdG8gdHJ1ZSwgQVBJIHJlcXVlc3RzIHRvIHRoaXMgdmVyc2lvbiByZWNlaXZlIGEgd2FybmluZyBoZWFkZXIgaW4gdGhlIHNlcnZlciByZXNwb25zZS4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkN1c3RvbVJlc291cmNlRGVmaW5pdGlvblZlcnNpb24jZGVwcmVjYXRlZFxuICAgKi9cbiAgcmVhZG9ubHkgZGVwcmVjYXRlZD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIGRlcHJlY2F0aW9uV2FybmluZyBvdmVycmlkZXMgdGhlIGRlZmF1bHQgd2FybmluZyByZXR1cm5lZCB0byBBUEkgY2xpZW50cy4gTWF5IG9ubHkgYmUgc2V0IHdoZW4gYGRlcHJlY2F0ZWRgIGlzIHRydWUuIFRoZSBkZWZhdWx0IHdhcm5pbmcgaW5kaWNhdGVzIHRoaXMgdmVyc2lvbiBpcyBkZXByZWNhdGVkIGFuZCByZWNvbW1lbmRzIHVzZSBvZiB0aGUgbmV3ZXN0IHNlcnZlZCB2ZXJzaW9uIG9mIGVxdWFsIG9yIGdyZWF0ZXIgc3RhYmlsaXR5LCBpZiBvbmUgZXhpc3RzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkN1c3RvbVJlc291cmNlRGVmaW5pdGlvblZlcnNpb24jZGVwcmVjYXRpb25XYXJuaW5nXG4gICAqL1xuICByZWFkb25seSBkZXByZWNhdGlvbldhcm5pbmc/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIG5hbWUgaXMgdGhlIHZlcnNpb24gbmFtZSwgZS5nLiDigJx2MeKAnSwg4oCcdjJiZXRhMeKAnSwgZXRjLiBUaGUgY3VzdG9tIHJlc291cmNlcyBhcmUgc2VydmVkIHVuZGVyIHRoaXMgdmVyc2lvbiBhdCBgL2FwaXMvPGdyb3VwPi88dmVyc2lvbj4vLi4uYCBpZiBgc2VydmVkYCBpcyB0cnVlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkN1c3RvbVJlc291cmNlRGVmaW5pdGlvblZlcnNpb24jbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBzY2hlbWEgZGVzY3JpYmVzIHRoZSBzY2hlbWEgdXNlZCBmb3IgdmFsaWRhdGlvbiwgcHJ1bmluZywgYW5kIGRlZmF1bHRpbmcgb2YgdGhpcyB2ZXJzaW9uIG9mIHRoZSBjdXN0b20gcmVzb3VyY2UuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uVmVyc2lvbiNzY2hlbWFcbiAgICovXG4gIHJlYWRvbmx5IHNjaGVtYT86IEN1c3RvbVJlc291cmNlVmFsaWRhdGlvbjtcblxuICAvKipcbiAgICogc2VydmVkIGlzIGEgZmxhZyBlbmFibGluZy9kaXNhYmxpbmcgdGhpcyB2ZXJzaW9uIGZyb20gYmVpbmcgc2VydmVkIHZpYSBSRVNUIEFQSXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5DdXN0b21SZXNvdXJjZURlZmluaXRpb25WZXJzaW9uI3NlcnZlZFxuICAgKi9cbiAgcmVhZG9ubHkgc2VydmVkOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBzdG9yYWdlIGluZGljYXRlcyB0aGlzIHZlcnNpb24gc2hvdWxkIGJlIHVzZWQgd2hlbiBwZXJzaXN0aW5nIGN1c3RvbSByZXNvdXJjZXMgdG8gc3RvcmFnZS4gVGhlcmUgbXVzdCBiZSBleGFjdGx5IG9uZSB2ZXJzaW9uIHdpdGggc3RvcmFnZT10cnVlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkN1c3RvbVJlc291cmNlRGVmaW5pdGlvblZlcnNpb24jc3RvcmFnZVxuICAgKi9cbiAgcmVhZG9ubHkgc3RvcmFnZTogYm9vbGVhbjtcblxuICAvKipcbiAgICogc3VicmVzb3VyY2VzIHNwZWNpZnkgd2hhdCBzdWJyZXNvdXJjZXMgdGhpcyB2ZXJzaW9uIG9mIHRoZSBkZWZpbmVkIGN1c3RvbSByZXNvdXJjZSBoYXZlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkN1c3RvbVJlc291cmNlRGVmaW5pdGlvblZlcnNpb24jc3VicmVzb3VyY2VzXG4gICAqL1xuICByZWFkb25seSBzdWJyZXNvdXJjZXM/OiBDdXN0b21SZXNvdXJjZVN1YnJlc291cmNlcztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdDdXN0b21SZXNvdXJjZURlZmluaXRpb25WZXJzaW9uJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9DdXN0b21SZXNvdXJjZURlZmluaXRpb25WZXJzaW9uKG9iajogQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uVmVyc2lvbiB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2FkZGl0aW9uYWxQcmludGVyQ29sdW1ucyc6IG9iai5hZGRpdGlvbmFsUHJpbnRlckNvbHVtbnM/Lm1hcCh5ID0+IHRvSnNvbl9DdXN0b21SZXNvdXJjZUNvbHVtbkRlZmluaXRpb24oeSkpLFxuICAgICdkZXByZWNhdGVkJzogb2JqLmRlcHJlY2F0ZWQsXG4gICAgJ2RlcHJlY2F0aW9uV2FybmluZyc6IG9iai5kZXByZWNhdGlvbldhcm5pbmcsXG4gICAgJ25hbWUnOiBvYmoubmFtZSxcbiAgICAnc2NoZW1hJzogdG9Kc29uX0N1c3RvbVJlc291cmNlVmFsaWRhdGlvbihvYmouc2NoZW1hKSxcbiAgICAnc2VydmVkJzogb2JqLnNlcnZlZCxcbiAgICAnc3RvcmFnZSc6IG9iai5zdG9yYWdlLFxuICAgICdzdWJyZXNvdXJjZXMnOiB0b0pzb25fQ3VzdG9tUmVzb3VyY2VTdWJyZXNvdXJjZXMob2JqLnN1YnJlc291cmNlcyksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogU3RhdHVzQ2F1c2UgcHJvdmlkZXMgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBhbiBhcGkuU3RhdHVzIGZhaWx1cmUsIGluY2x1ZGluZyBjYXNlcyB3aGVuIG11bHRpcGxlIGVycm9ycyBhcmUgZW5jb3VudGVyZWQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuU3RhdHVzQ2F1c2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdGF0dXNDYXVzZSB7XG4gIC8qKlxuICAgKiBUaGUgZmllbGQgb2YgdGhlIHJlc291cmNlIHRoYXQgaGFzIGNhdXNlZCB0aGlzIGVycm9yLCBhcyBuYW1lZCBieSBpdHMgSlNPTiBzZXJpYWxpemF0aW9uLiBNYXkgaW5jbHVkZSBkb3QgYW5kIHBvc3RmaXggbm90YXRpb24gZm9yIG5lc3RlZCBhdHRyaWJ1dGVzLiBBcnJheXMgYXJlIHplcm8taW5kZXhlZC4gIEZpZWxkcyBtYXkgYXBwZWFyIG1vcmUgdGhhbiBvbmNlIGluIGFuIGFycmF5IG9mIGNhdXNlcyBkdWUgdG8gZmllbGRzIGhhdmluZyBtdWx0aXBsZSBlcnJvcnMuIE9wdGlvbmFsLlxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICogXCJuYW1lXCIgLSB0aGUgZmllbGQgXCJuYW1lXCIgb24gdGhlIGN1cnJlbnQgcmVzb3VyY2VcbiAgICogXCJpdGVtc1swXS5uYW1lXCIgLSB0aGUgZmllbGQgXCJuYW1lXCIgb24gdGhlIGZpcnN0IGFycmF5IGVudHJ5IGluIFwiaXRlbXNcIlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5TdGF0dXNDYXVzZSNmaWVsZFxuICAgKi9cbiAgcmVhZG9ubHkgZmllbGQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgaHVtYW4tcmVhZGFibGUgZGVzY3JpcHRpb24gb2YgdGhlIGNhdXNlIG9mIHRoZSBlcnJvci4gIFRoaXMgZmllbGQgbWF5IGJlIHByZXNlbnRlZCBhcy1pcyB0byBhIHJlYWRlci5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuU3RhdHVzQ2F1c2UjbWVzc2FnZVxuICAgKi9cbiAgcmVhZG9ubHkgbWVzc2FnZT86IHN0cmluZztcblxuICAvKipcbiAgICogQSBtYWNoaW5lLXJlYWRhYmxlIGRlc2NyaXB0aW9uIG9mIHRoZSBjYXVzZSBvZiB0aGUgZXJyb3IuIElmIHRoaXMgdmFsdWUgaXMgZW1wdHkgdGhlcmUgaXMgbm8gaW5mb3JtYXRpb24gYXZhaWxhYmxlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5TdGF0dXNDYXVzZSNyZWFzb25cbiAgICovXG4gIHJlYWRvbmx5IHJlYXNvbj86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdTdGF0dXNDYXVzZScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fU3RhdHVzQ2F1c2Uob2JqOiBTdGF0dXNDYXVzZSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2ZpZWxkJzogb2JqLmZpZWxkLFxuICAgICdtZXNzYWdlJzogb2JqLm1lc3NhZ2UsXG4gICAgJ3JlYXNvbic6IG9iai5yZWFzb24sXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogU2VydmljZVJlZmVyZW5jZSBob2xkcyBhIHJlZmVyZW5jZSB0byBTZXJ2aWNlLmxlZ2FjeS5rOHMuaW9cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYWRtaXNzaW9ucmVnaXN0cmF0aW9uLnYxLlNlcnZpY2VSZWZlcmVuY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZXJ2aWNlUmVmZXJlbmNlIHtcbiAgLyoqXG4gICAqIGBuYW1lYCBpcyB0aGUgbmFtZSBvZiB0aGUgc2VydmljZS4gUmVxdWlyZWRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFkbWlzc2lvbnJlZ2lzdHJhdGlvbi52MS5TZXJ2aWNlUmVmZXJlbmNlI25hbWVcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogYG5hbWVzcGFjZWAgaXMgdGhlIG5hbWVzcGFjZSBvZiB0aGUgc2VydmljZS4gUmVxdWlyZWRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFkbWlzc2lvbnJlZ2lzdHJhdGlvbi52MS5TZXJ2aWNlUmVmZXJlbmNlI25hbWVzcGFjZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZXNwYWNlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGBwYXRoYCBpcyBhbiBvcHRpb25hbCBVUkwgcGF0aCB3aGljaCB3aWxsIGJlIHNlbnQgaW4gYW55IHJlcXVlc3QgdG8gdGhpcyBzZXJ2aWNlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYWRtaXNzaW9ucmVnaXN0cmF0aW9uLnYxLlNlcnZpY2VSZWZlcmVuY2UjcGF0aFxuICAgKi9cbiAgcmVhZG9ubHkgcGF0aD86IHN0cmluZztcblxuICAvKipcbiAgICogSWYgc3BlY2lmaWVkLCB0aGUgcG9ydCBvbiB0aGUgc2VydmljZSB0aGF0IGhvc3Rpbmcgd2ViaG9vay4gRGVmYXVsdCB0byA0NDMgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuIGBwb3J0YCBzaG91bGQgYmUgYSB2YWxpZCBwb3J0IG51bWJlciAoMS02NTUzNSwgaW5jbHVzaXZlKS5cbiAgICpcbiAgICogQGRlZmF1bHQgNDQzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBgcG9ydGAgc2hvdWxkIGJlIGEgdmFsaWQgcG9ydCBudW1iZXIgKDEtNjU1MzUsIGluY2x1c2l2ZSkuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hZG1pc3Npb25yZWdpc3RyYXRpb24udjEuU2VydmljZVJlZmVyZW5jZSNwb3J0XG4gICAqL1xuICByZWFkb25seSBwb3J0PzogbnVtYmVyO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1NlcnZpY2VSZWZlcmVuY2UnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1NlcnZpY2VSZWZlcmVuY2Uob2JqOiBTZXJ2aWNlUmVmZXJlbmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbmFtZSc6IG9iai5uYW1lLFxuICAgICduYW1lc3BhY2UnOiBvYmoubmFtZXNwYWNlLFxuICAgICdwYXRoJzogb2JqLnBhdGgsXG4gICAgJ3BvcnQnOiBvYmoucG9ydCxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBTcGVjIHRvIGNvbnRyb2wgdGhlIGRlc2lyZWQgYmVoYXZpb3Igb2YgZGFlbW9uIHNldCByb2xsaW5nIHVwZGF0ZS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5Sb2xsaW5nVXBkYXRlRGFlbW9uU2V0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm9sbGluZ1VwZGF0ZURhZW1vblNldCB7XG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2Ygbm9kZXMgd2l0aCBhbiBleGlzdGluZyBhdmFpbGFibGUgRGFlbW9uU2V0IHBvZCB0aGF0IGNhbiBoYXZlIGFuIHVwZGF0ZWQgRGFlbW9uU2V0IHBvZCBkdXJpbmcgZHVyaW5nIGFuIHVwZGF0ZS4gVmFsdWUgY2FuIGJlIGFuIGFic29sdXRlIG51bWJlciAoZXg6IDUpIG9yIGEgcGVyY2VudGFnZSBvZiBkZXNpcmVkIHBvZHMgKGV4OiAxMCUpLiBUaGlzIGNhbiBub3QgYmUgMCBpZiBNYXhVbmF2YWlsYWJsZSBpcyAwLiBBYnNvbHV0ZSBudW1iZXIgaXMgY2FsY3VsYXRlZCBmcm9tIHBlcmNlbnRhZ2UgYnkgcm91bmRpbmcgdXAgdG8gYSBtaW5pbXVtIG9mIDEuIERlZmF1bHQgdmFsdWUgaXMgMC4gRXhhbXBsZTogd2hlbiB0aGlzIGlzIHNldCB0byAzMCUsIGF0IG1vc3QgMzAlIG9mIHRoZSB0b3RhbCBudW1iZXIgb2Ygbm9kZXMgdGhhdCBzaG91bGQgYmUgcnVubmluZyB0aGUgZGFlbW9uIHBvZCAoaS5lLiBzdGF0dXMuZGVzaXJlZE51bWJlclNjaGVkdWxlZCkgY2FuIGhhdmUgdGhlaXIgYSBuZXcgcG9kIGNyZWF0ZWQgYmVmb3JlIHRoZSBvbGQgcG9kIGlzIG1hcmtlZCBhcyBkZWxldGVkLiBUaGUgdXBkYXRlIHN0YXJ0cyBieSBsYXVuY2hpbmcgbmV3IHBvZHMgb24gMzAlIG9mIG5vZGVzLiBPbmNlIGFuIHVwZGF0ZWQgcG9kIGlzIGF2YWlsYWJsZSAoUmVhZHkgZm9yIGF0IGxlYXN0IG1pblJlYWR5U2Vjb25kcykgdGhlIG9sZCBEYWVtb25TZXQgcG9kIG9uIHRoYXQgbm9kZSBpcyBtYXJrZWQgZGVsZXRlZC4gSWYgdGhlIG9sZCBwb2QgYmVjb21lcyB1bmF2YWlsYWJsZSBmb3IgYW55IHJlYXNvbiAoUmVhZHkgdHJhbnNpdGlvbnMgdG8gZmFsc2UsIGlzIGV2aWN0ZWQsIG9yIGlzIGRyYWluZWQpIGFuIHVwZGF0ZWQgcG9kIGlzIGltbWVkaWF0ZWRseSBjcmVhdGVkIG9uIHRoYXQgbm9kZSB3aXRob3V0IGNvbnNpZGVyaW5nIHN1cmdlIGxpbWl0cy4gQWxsb3dpbmcgc3VyZ2UgaW1wbGllcyB0aGUgcG9zc2liaWxpdHkgdGhhdCB0aGUgcmVzb3VyY2VzIGNvbnN1bWVkIGJ5IHRoZSBkYWVtb25zZXQgb24gYW55IGdpdmVuIG5vZGUgY2FuIGRvdWJsZSBpZiB0aGUgcmVhZGluZXNzIGNoZWNrIGZhaWxzLCBhbmQgc28gcmVzb3VyY2UgaW50ZW5zaXZlIGRhZW1vbnNldHMgc2hvdWxkIHRha2UgaW50byBhY2NvdW50IHRoYXQgdGhleSBtYXkgY2F1c2UgZXZpY3Rpb25zIGR1cmluZyBkaXNydXB0aW9uLiBUaGlzIGlzIGJldGEgZmllbGQgYW5kIGVuYWJsZWQvZGlzYWJsZWQgYnkgRGFlbW9uU2V0VXBkYXRlU3VyZ2UgZmVhdHVyZSBnYXRlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5Sb2xsaW5nVXBkYXRlRGFlbW9uU2V0I21heFN1cmdlXG4gICAqL1xuICByZWFkb25seSBtYXhTdXJnZT86IEludE9yU3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgRGFlbW9uU2V0IHBvZHMgdGhhdCBjYW4gYmUgdW5hdmFpbGFibGUgZHVyaW5nIHRoZSB1cGRhdGUuIFZhbHVlIGNhbiBiZSBhbiBhYnNvbHV0ZSBudW1iZXIgKGV4OiA1KSBvciBhIHBlcmNlbnRhZ2Ugb2YgdG90YWwgbnVtYmVyIG9mIERhZW1vblNldCBwb2RzIGF0IHRoZSBzdGFydCBvZiB0aGUgdXBkYXRlIChleDogMTAlKS4gQWJzb2x1dGUgbnVtYmVyIGlzIGNhbGN1bGF0ZWQgZnJvbSBwZXJjZW50YWdlIGJ5IHJvdW5kaW5nIHVwLiBUaGlzIGNhbm5vdCBiZSAwIGlmIE1heFN1cmdlIGlzIDAgRGVmYXVsdCB2YWx1ZSBpcyAxLiBFeGFtcGxlOiB3aGVuIHRoaXMgaXMgc2V0IHRvIDMwJSwgYXQgbW9zdCAzMCUgb2YgdGhlIHRvdGFsIG51bWJlciBvZiBub2RlcyB0aGF0IHNob3VsZCBiZSBydW5uaW5nIHRoZSBkYWVtb24gcG9kIChpLmUuIHN0YXR1cy5kZXNpcmVkTnVtYmVyU2NoZWR1bGVkKSBjYW4gaGF2ZSB0aGVpciBwb2RzIHN0b3BwZWQgZm9yIGFuIHVwZGF0ZSBhdCBhbnkgZ2l2ZW4gdGltZS4gVGhlIHVwZGF0ZSBzdGFydHMgYnkgc3RvcHBpbmcgYXQgbW9zdCAzMCUgb2YgdGhvc2UgRGFlbW9uU2V0IHBvZHMgYW5kIHRoZW4gYnJpbmdzIHVwIG5ldyBEYWVtb25TZXQgcG9kcyBpbiB0aGVpciBwbGFjZS4gT25jZSB0aGUgbmV3IHBvZHMgYXJlIGF2YWlsYWJsZSwgaXQgdGhlbiBwcm9jZWVkcyBvbnRvIG90aGVyIERhZW1vblNldCBwb2RzLCB0aHVzIGVuc3VyaW5nIHRoYXQgYXQgbGVhc3QgNzAlIG9mIG9yaWdpbmFsIG51bWJlciBvZiBEYWVtb25TZXQgcG9kcyBhcmUgYXZhaWxhYmxlIGF0IGFsbCB0aW1lcyBkdXJpbmcgdGhlIHVwZGF0ZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmFwcHMudjEuUm9sbGluZ1VwZGF0ZURhZW1vblNldCNtYXhVbmF2YWlsYWJsZVxuICAgKi9cbiAgcmVhZG9ubHkgbWF4VW5hdmFpbGFibGU/OiBJbnRPclN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdSb2xsaW5nVXBkYXRlRGFlbW9uU2V0JyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Sb2xsaW5nVXBkYXRlRGFlbW9uU2V0KG9iajogUm9sbGluZ1VwZGF0ZURhZW1vblNldCB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21heFN1cmdlJzogb2JqLm1heFN1cmdlPy52YWx1ZSxcbiAgICAnbWF4VW5hdmFpbGFibGUnOiBvYmoubWF4VW5hdmFpbGFibGU/LnZhbHVlLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFNwZWMgdG8gY29udHJvbCB0aGUgZGVzaXJlZCBiZWhhdmlvciBvZiByb2xsaW5nIHVwZGF0ZS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5Sb2xsaW5nVXBkYXRlRGVwbG95bWVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvbGxpbmdVcGRhdGVEZXBsb3ltZW50IHtcbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBwb2RzIHRoYXQgY2FuIGJlIHNjaGVkdWxlZCBhYm92ZSB0aGUgZGVzaXJlZCBudW1iZXIgb2YgcG9kcy4gVmFsdWUgY2FuIGJlIGFuIGFic29sdXRlIG51bWJlciAoZXg6IDUpIG9yIGEgcGVyY2VudGFnZSBvZiBkZXNpcmVkIHBvZHMgKGV4OiAxMCUpLiBUaGlzIGNhbiBub3QgYmUgMCBpZiBNYXhVbmF2YWlsYWJsZSBpcyAwLiBBYnNvbHV0ZSBudW1iZXIgaXMgY2FsY3VsYXRlZCBmcm9tIHBlcmNlbnRhZ2UgYnkgcm91bmRpbmcgdXAuIERlZmF1bHRzIHRvIDI1JS4gRXhhbXBsZTogd2hlbiB0aGlzIGlzIHNldCB0byAzMCUsIHRoZSBuZXcgUmVwbGljYVNldCBjYW4gYmUgc2NhbGVkIHVwIGltbWVkaWF0ZWx5IHdoZW4gdGhlIHJvbGxpbmcgdXBkYXRlIHN0YXJ0cywgc3VjaCB0aGF0IHRoZSB0b3RhbCBudW1iZXIgb2Ygb2xkIGFuZCBuZXcgcG9kcyBkbyBub3QgZXhjZWVkIDEzMCUgb2YgZGVzaXJlZCBwb2RzLiBPbmNlIG9sZCBwb2RzIGhhdmUgYmVlbiBraWxsZWQsIG5ldyBSZXBsaWNhU2V0IGNhbiBiZSBzY2FsZWQgdXAgZnVydGhlciwgZW5zdXJpbmcgdGhhdCB0b3RhbCBudW1iZXIgb2YgcG9kcyBydW5uaW5nIGF0IGFueSB0aW1lIGR1cmluZyB0aGUgdXBkYXRlIGlzIGF0IG1vc3QgMTMwJSBvZiBkZXNpcmVkIHBvZHMuXG4gICAqXG4gICAqIEBkZWZhdWx0IDI1JS4gRXhhbXBsZTogd2hlbiB0aGlzIGlzIHNldCB0byAzMCUsIHRoZSBuZXcgUmVwbGljYVNldCBjYW4gYmUgc2NhbGVkIHVwIGltbWVkaWF0ZWx5IHdoZW4gdGhlIHJvbGxpbmcgdXBkYXRlIHN0YXJ0cywgc3VjaCB0aGF0IHRoZSB0b3RhbCBudW1iZXIgb2Ygb2xkIGFuZCBuZXcgcG9kcyBkbyBub3QgZXhjZWVkIDEzMCUgb2YgZGVzaXJlZCBwb2RzLiBPbmNlIG9sZCBwb2RzIGhhdmUgYmVlbiBraWxsZWQsIG5ldyBSZXBsaWNhU2V0IGNhbiBiZSBzY2FsZWQgdXAgZnVydGhlciwgZW5zdXJpbmcgdGhhdCB0b3RhbCBudW1iZXIgb2YgcG9kcyBydW5uaW5nIGF0IGFueSB0aW1lIGR1cmluZyB0aGUgdXBkYXRlIGlzIGF0IG1vc3QgMTMwJSBvZiBkZXNpcmVkIHBvZHMuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLlJvbGxpbmdVcGRhdGVEZXBsb3ltZW50I21heFN1cmdlXG4gICAqL1xuICByZWFkb25seSBtYXhTdXJnZT86IEludE9yU3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcG9kcyB0aGF0IGNhbiBiZSB1bmF2YWlsYWJsZSBkdXJpbmcgdGhlIHVwZGF0ZS4gVmFsdWUgY2FuIGJlIGFuIGFic29sdXRlIG51bWJlciAoZXg6IDUpIG9yIGEgcGVyY2VudGFnZSBvZiBkZXNpcmVkIHBvZHMgKGV4OiAxMCUpLiBBYnNvbHV0ZSBudW1iZXIgaXMgY2FsY3VsYXRlZCBmcm9tIHBlcmNlbnRhZ2UgYnkgcm91bmRpbmcgZG93bi4gVGhpcyBjYW4gbm90IGJlIDAgaWYgTWF4U3VyZ2UgaXMgMC4gRGVmYXVsdHMgdG8gMjUlLiBFeGFtcGxlOiB3aGVuIHRoaXMgaXMgc2V0IHRvIDMwJSwgdGhlIG9sZCBSZXBsaWNhU2V0IGNhbiBiZSBzY2FsZWQgZG93biB0byA3MCUgb2YgZGVzaXJlZCBwb2RzIGltbWVkaWF0ZWx5IHdoZW4gdGhlIHJvbGxpbmcgdXBkYXRlIHN0YXJ0cy4gT25jZSBuZXcgcG9kcyBhcmUgcmVhZHksIG9sZCBSZXBsaWNhU2V0IGNhbiBiZSBzY2FsZWQgZG93biBmdXJ0aGVyLCBmb2xsb3dlZCBieSBzY2FsaW5nIHVwIHRoZSBuZXcgUmVwbGljYVNldCwgZW5zdXJpbmcgdGhhdCB0aGUgdG90YWwgbnVtYmVyIG9mIHBvZHMgYXZhaWxhYmxlIGF0IGFsbCB0aW1lcyBkdXJpbmcgdGhlIHVwZGF0ZSBpcyBhdCBsZWFzdCA3MCUgb2YgZGVzaXJlZCBwb2RzLlxuICAgKlxuICAgKiBAZGVmYXVsdCAyNSUuIEV4YW1wbGU6IHdoZW4gdGhpcyBpcyBzZXQgdG8gMzAlLCB0aGUgb2xkIFJlcGxpY2FTZXQgY2FuIGJlIHNjYWxlZCBkb3duIHRvIDcwJSBvZiBkZXNpcmVkIHBvZHMgaW1tZWRpYXRlbHkgd2hlbiB0aGUgcm9sbGluZyB1cGRhdGUgc3RhcnRzLiBPbmNlIG5ldyBwb2RzIGFyZSByZWFkeSwgb2xkIFJlcGxpY2FTZXQgY2FuIGJlIHNjYWxlZCBkb3duIGZ1cnRoZXIsIGZvbGxvd2VkIGJ5IHNjYWxpbmcgdXAgdGhlIG5ldyBSZXBsaWNhU2V0LCBlbnN1cmluZyB0aGF0IHRoZSB0b3RhbCBudW1iZXIgb2YgcG9kcyBhdmFpbGFibGUgYXQgYWxsIHRpbWVzIGR1cmluZyB0aGUgdXBkYXRlIGlzIGF0IGxlYXN0IDcwJSBvZiBkZXNpcmVkIHBvZHMuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hcHBzLnYxLlJvbGxpbmdVcGRhdGVEZXBsb3ltZW50I21heFVuYXZhaWxhYmxlXG4gICAqL1xuICByZWFkb25seSBtYXhVbmF2YWlsYWJsZT86IEludE9yU3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1JvbGxpbmdVcGRhdGVEZXBsb3ltZW50JyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Sb2xsaW5nVXBkYXRlRGVwbG95bWVudChvYmo6IFJvbGxpbmdVcGRhdGVEZXBsb3ltZW50IHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWF4U3VyZ2UnOiBvYmoubWF4U3VyZ2U/LnZhbHVlLFxuICAgICdtYXhVbmF2YWlsYWJsZSc6IG9iai5tYXhVbmF2YWlsYWJsZT8udmFsdWUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUm9sbGluZ1VwZGF0ZVN0YXRlZnVsU2V0U3RyYXRlZ3kgaXMgdXNlZCB0byBjb21tdW5pY2F0ZSBwYXJhbWV0ZXIgZm9yIFJvbGxpbmdVcGRhdGVTdGF0ZWZ1bFNldFN0cmF0ZWd5VHlwZS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5Sb2xsaW5nVXBkYXRlU3RhdGVmdWxTZXRTdHJhdGVneVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvbGxpbmdVcGRhdGVTdGF0ZWZ1bFNldFN0cmF0ZWd5IHtcbiAgLyoqXG4gICAqIFBhcnRpdGlvbiBpbmRpY2F0ZXMgdGhlIG9yZGluYWwgYXQgd2hpY2ggdGhlIFN0YXRlZnVsU2V0IHNob3VsZCBiZSBwYXJ0aXRpb25lZC4gRGVmYXVsdCB2YWx1ZSBpcyAwLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXBwcy52MS5Sb2xsaW5nVXBkYXRlU3RhdGVmdWxTZXRTdHJhdGVneSNwYXJ0aXRpb25cbiAgICovXG4gIHJlYWRvbmx5IHBhcnRpdGlvbj86IG51bWJlcjtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdSb2xsaW5nVXBkYXRlU3RhdGVmdWxTZXRTdHJhdGVneScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fUm9sbGluZ1VwZGF0ZVN0YXRlZnVsU2V0U3RyYXRlZ3kob2JqOiBSb2xsaW5nVXBkYXRlU3RhdGVmdWxTZXRTdHJhdGVneSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ3BhcnRpdGlvbic6IG9iai5wYXJ0aXRpb24sXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQ29udGFpbmVyUmVzb3VyY2VNZXRyaWNTb3VyY2UgaW5kaWNhdGVzIGhvdyB0byBzY2FsZSBvbiBhIHJlc291cmNlIG1ldHJpYyBrbm93biB0byBLdWJlcm5ldGVzLCBhcyBzcGVjaWZpZWQgaW4gcmVxdWVzdHMgYW5kIGxpbWl0cywgZGVzY3JpYmluZyBlYWNoIHBvZCBpbiB0aGUgY3VycmVudCBzY2FsZSB0YXJnZXQgKGUuZy4gQ1BVIG9yIG1lbW9yeSkuICBUaGUgdmFsdWVzIHdpbGwgYmUgYXZlcmFnZWQgdG9nZXRoZXIgYmVmb3JlIGJlaW5nIGNvbXBhcmVkIHRvIHRoZSB0YXJnZXQuICBTdWNoIG1ldHJpY3MgYXJlIGJ1aWx0IGluIHRvIEt1YmVybmV0ZXMsIGFuZCBoYXZlIHNwZWNpYWwgc2NhbGluZyBvcHRpb25zIG9uIHRvcCBvZiB0aG9zZSBhdmFpbGFibGUgdG8gbm9ybWFsIHBlci1wb2QgbWV0cmljcyB1c2luZyB0aGUgXCJwb2RzXCIgc291cmNlLiAgT25seSBvbmUgXCJ0YXJnZXRcIiB0eXBlIHNob3VsZCBiZSBzZXQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTEuQ29udGFpbmVyUmVzb3VyY2VNZXRyaWNTb3VyY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb250YWluZXJSZXNvdXJjZU1ldHJpY1NvdXJjZVYyQmV0YTEge1xuICAvKipcbiAgICogY29udGFpbmVyIGlzIHRoZSBuYW1lIG9mIHRoZSBjb250YWluZXIgaW4gdGhlIHBvZHMgb2YgdGhlIHNjYWxpbmcgdGFyZ2V0XG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGExLkNvbnRhaW5lclJlc291cmNlTWV0cmljU291cmNlI2NvbnRhaW5lclxuICAgKi9cbiAgcmVhZG9ubHkgY29udGFpbmVyOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIG5hbWUgaXMgdGhlIG5hbWUgb2YgdGhlIHJlc291cmNlIGluIHF1ZXN0aW9uLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMS5Db250YWluZXJSZXNvdXJjZU1ldHJpY1NvdXJjZSNuYW1lXG4gICAqL1xuICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIHRhcmdldEF2ZXJhZ2VVdGlsaXphdGlvbiBpcyB0aGUgdGFyZ2V0IHZhbHVlIG9mIHRoZSBhdmVyYWdlIG9mIHRoZSByZXNvdXJjZSBtZXRyaWMgYWNyb3NzIGFsbCByZWxldmFudCBwb2RzLCByZXByZXNlbnRlZCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIHJlcXVlc3RlZCB2YWx1ZSBvZiB0aGUgcmVzb3VyY2UgZm9yIHRoZSBwb2RzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMS5Db250YWluZXJSZXNvdXJjZU1ldHJpY1NvdXJjZSN0YXJnZXRBdmVyYWdlVXRpbGl6YXRpb25cbiAgICovXG4gIHJlYWRvbmx5IHRhcmdldEF2ZXJhZ2VVdGlsaXphdGlvbj86IG51bWJlcjtcblxuICAvKipcbiAgICogdGFyZ2V0QXZlcmFnZVZhbHVlIGlzIHRoZSB0YXJnZXQgdmFsdWUgb2YgdGhlIGF2ZXJhZ2Ugb2YgdGhlIHJlc291cmNlIG1ldHJpYyBhY3Jvc3MgYWxsIHJlbGV2YW50IHBvZHMsIGFzIGEgcmF3IHZhbHVlIChpbnN0ZWFkIG9mIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgcmVxdWVzdCksIHNpbWlsYXIgdG8gdGhlIFwicG9kc1wiIG1ldHJpYyBzb3VyY2UgdHlwZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTEuQ29udGFpbmVyUmVzb3VyY2VNZXRyaWNTb3VyY2UjdGFyZ2V0QXZlcmFnZVZhbHVlXG4gICAqL1xuICByZWFkb25seSB0YXJnZXRBdmVyYWdlVmFsdWU/OiBRdWFudGl0eTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdDb250YWluZXJSZXNvdXJjZU1ldHJpY1NvdXJjZVYyQmV0YTEnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0NvbnRhaW5lclJlc291cmNlTWV0cmljU291cmNlVjJCZXRhMShvYmo6IENvbnRhaW5lclJlc291cmNlTWV0cmljU291cmNlVjJCZXRhMSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2NvbnRhaW5lcic6IG9iai5jb250YWluZXIsXG4gICAgJ25hbWUnOiBvYmoubmFtZSxcbiAgICAndGFyZ2V0QXZlcmFnZVV0aWxpemF0aW9uJzogb2JqLnRhcmdldEF2ZXJhZ2VVdGlsaXphdGlvbixcbiAgICAndGFyZ2V0QXZlcmFnZVZhbHVlJzogb2JqLnRhcmdldEF2ZXJhZ2VWYWx1ZT8udmFsdWUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogRXh0ZXJuYWxNZXRyaWNTb3VyY2UgaW5kaWNhdGVzIGhvdyB0byBzY2FsZSBvbiBhIG1ldHJpYyBub3QgYXNzb2NpYXRlZCB3aXRoIGFueSBLdWJlcm5ldGVzIG9iamVjdCAoZm9yIGV4YW1wbGUgbGVuZ3RoIG9mIHF1ZXVlIGluIGNsb3VkIG1lc3NhZ2luZyBzZXJ2aWNlLCBvciBRUFMgZnJvbSBsb2FkYmFsYW5jZXIgcnVubmluZyBvdXRzaWRlIG9mIGNsdXN0ZXIpLiBFeGFjdGx5IG9uZSBcInRhcmdldFwiIHR5cGUgc2hvdWxkIGJlIHNldC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMS5FeHRlcm5hbE1ldHJpY1NvdXJjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEV4dGVybmFsTWV0cmljU291cmNlVjJCZXRhMSB7XG4gIC8qKlxuICAgKiBtZXRyaWNOYW1lIGlzIHRoZSBuYW1lIG9mIHRoZSBtZXRyaWMgaW4gcXVlc3Rpb24uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGExLkV4dGVybmFsTWV0cmljU291cmNlI21ldHJpY05hbWVcbiAgICovXG4gIHJlYWRvbmx5IG1ldHJpY05hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogbWV0cmljU2VsZWN0b3IgaXMgdXNlZCB0byBpZGVudGlmeSBhIHNwZWNpZmljIHRpbWUgc2VyaWVzIHdpdGhpbiBhIGdpdmVuIG1ldHJpYy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTEuRXh0ZXJuYWxNZXRyaWNTb3VyY2UjbWV0cmljU2VsZWN0b3JcbiAgICovXG4gIHJlYWRvbmx5IG1ldHJpY1NlbGVjdG9yPzogTGFiZWxTZWxlY3RvcjtcblxuICAvKipcbiAgICogdGFyZ2V0QXZlcmFnZVZhbHVlIGlzIHRoZSB0YXJnZXQgcGVyLXBvZCB2YWx1ZSBvZiBnbG9iYWwgbWV0cmljIChhcyBhIHF1YW50aXR5KS4gTXV0dWFsbHkgZXhjbHVzaXZlIHdpdGggVGFyZ2V0VmFsdWUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGExLkV4dGVybmFsTWV0cmljU291cmNlI3RhcmdldEF2ZXJhZ2VWYWx1ZVxuICAgKi9cbiAgcmVhZG9ubHkgdGFyZ2V0QXZlcmFnZVZhbHVlPzogUXVhbnRpdHk7XG5cbiAgLyoqXG4gICAqIHRhcmdldFZhbHVlIGlzIHRoZSB0YXJnZXQgdmFsdWUgb2YgdGhlIG1ldHJpYyAoYXMgYSBxdWFudGl0eSkuIE11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoIFRhcmdldEF2ZXJhZ2VWYWx1ZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTEuRXh0ZXJuYWxNZXRyaWNTb3VyY2UjdGFyZ2V0VmFsdWVcbiAgICovXG4gIHJlYWRvbmx5IHRhcmdldFZhbHVlPzogUXVhbnRpdHk7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnRXh0ZXJuYWxNZXRyaWNTb3VyY2VWMkJldGExJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9FeHRlcm5hbE1ldHJpY1NvdXJjZVYyQmV0YTEob2JqOiBFeHRlcm5hbE1ldHJpY1NvdXJjZVYyQmV0YTEgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtZXRyaWNOYW1lJzogb2JqLm1ldHJpY05hbWUsXG4gICAgJ21ldHJpY1NlbGVjdG9yJzogdG9Kc29uX0xhYmVsU2VsZWN0b3Iob2JqLm1ldHJpY1NlbGVjdG9yKSxcbiAgICAndGFyZ2V0QXZlcmFnZVZhbHVlJzogb2JqLnRhcmdldEF2ZXJhZ2VWYWx1ZT8udmFsdWUsXG4gICAgJ3RhcmdldFZhbHVlJzogb2JqLnRhcmdldFZhbHVlPy52YWx1ZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBPYmplY3RNZXRyaWNTb3VyY2UgaW5kaWNhdGVzIGhvdyB0byBzY2FsZSBvbiBhIG1ldHJpYyBkZXNjcmliaW5nIGEga3ViZXJuZXRlcyBvYmplY3QgKGZvciBleGFtcGxlLCBoaXRzLXBlci1zZWNvbmQgb24gYW4gSW5ncmVzcyBvYmplY3QpLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGExLk9iamVjdE1ldHJpY1NvdXJjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIE9iamVjdE1ldHJpY1NvdXJjZVYyQmV0YTEge1xuICAvKipcbiAgICogYXZlcmFnZVZhbHVlIGlzIHRoZSB0YXJnZXQgdmFsdWUgb2YgdGhlIGF2ZXJhZ2Ugb2YgdGhlIG1ldHJpYyBhY3Jvc3MgYWxsIHJlbGV2YW50IHBvZHMgKGFzIGEgcXVhbnRpdHkpXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGExLk9iamVjdE1ldHJpY1NvdXJjZSNhdmVyYWdlVmFsdWVcbiAgICovXG4gIHJlYWRvbmx5IGF2ZXJhZ2VWYWx1ZT86IFF1YW50aXR5O1xuXG4gIC8qKlxuICAgKiBtZXRyaWNOYW1lIGlzIHRoZSBuYW1lIG9mIHRoZSBtZXRyaWMgaW4gcXVlc3Rpb24uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGExLk9iamVjdE1ldHJpY1NvdXJjZSNtZXRyaWNOYW1lXG4gICAqL1xuICByZWFkb25seSBtZXRyaWNOYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIHNlbGVjdG9yIGlzIHRoZSBzdHJpbmctZW5jb2RlZCBmb3JtIG9mIGEgc3RhbmRhcmQga3ViZXJuZXRlcyBsYWJlbCBzZWxlY3RvciBmb3IgdGhlIGdpdmVuIG1ldHJpYyBXaGVuIHNldCwgaXQgaXMgcGFzc2VkIGFzIGFuIGFkZGl0aW9uYWwgcGFyYW1ldGVyIHRvIHRoZSBtZXRyaWNzIHNlcnZlciBmb3IgbW9yZSBzcGVjaWZpYyBtZXRyaWNzIHNjb3BpbmcgV2hlbiB1bnNldCwganVzdCB0aGUgbWV0cmljTmFtZSB3aWxsIGJlIHVzZWQgdG8gZ2F0aGVyIG1ldHJpY3MuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGExLk9iamVjdE1ldHJpY1NvdXJjZSNzZWxlY3RvclxuICAgKi9cbiAgcmVhZG9ubHkgc2VsZWN0b3I/OiBMYWJlbFNlbGVjdG9yO1xuXG4gIC8qKlxuICAgKiB0YXJnZXQgaXMgdGhlIGRlc2NyaWJlZCBLdWJlcm5ldGVzIG9iamVjdC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTEuT2JqZWN0TWV0cmljU291cmNlI3RhcmdldFxuICAgKi9cbiAgcmVhZG9ubHkgdGFyZ2V0OiBDcm9zc1ZlcnNpb25PYmplY3RSZWZlcmVuY2VWMkJldGExO1xuXG4gIC8qKlxuICAgKiB0YXJnZXRWYWx1ZSBpcyB0aGUgdGFyZ2V0IHZhbHVlIG9mIHRoZSBtZXRyaWMgKGFzIGEgcXVhbnRpdHkpLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMS5PYmplY3RNZXRyaWNTb3VyY2UjdGFyZ2V0VmFsdWVcbiAgICovXG4gIHJlYWRvbmx5IHRhcmdldFZhbHVlOiBRdWFudGl0eTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdPYmplY3RNZXRyaWNTb3VyY2VWMkJldGExJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9PYmplY3RNZXRyaWNTb3VyY2VWMkJldGExKG9iajogT2JqZWN0TWV0cmljU291cmNlVjJCZXRhMSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2F2ZXJhZ2VWYWx1ZSc6IG9iai5hdmVyYWdlVmFsdWU/LnZhbHVlLFxuICAgICdtZXRyaWNOYW1lJzogb2JqLm1ldHJpY05hbWUsXG4gICAgJ3NlbGVjdG9yJzogdG9Kc29uX0xhYmVsU2VsZWN0b3Iob2JqLnNlbGVjdG9yKSxcbiAgICAndGFyZ2V0JzogdG9Kc29uX0Nyb3NzVmVyc2lvbk9iamVjdFJlZmVyZW5jZVYyQmV0YTEob2JqLnRhcmdldCksXG4gICAgJ3RhcmdldFZhbHVlJzogb2JqLnRhcmdldFZhbHVlPy52YWx1ZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBQb2RzTWV0cmljU291cmNlIGluZGljYXRlcyBob3cgdG8gc2NhbGUgb24gYSBtZXRyaWMgZGVzY3JpYmluZyBlYWNoIHBvZCBpbiB0aGUgY3VycmVudCBzY2FsZSB0YXJnZXQgKGZvciBleGFtcGxlLCB0cmFuc2FjdGlvbnMtcHJvY2Vzc2VkLXBlci1zZWNvbmQpLiBUaGUgdmFsdWVzIHdpbGwgYmUgYXZlcmFnZWQgdG9nZXRoZXIgYmVmb3JlIGJlaW5nIGNvbXBhcmVkIHRvIHRoZSB0YXJnZXQgdmFsdWUuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTEuUG9kc01ldHJpY1NvdXJjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBvZHNNZXRyaWNTb3VyY2VWMkJldGExIHtcbiAgLyoqXG4gICAqIG1ldHJpY05hbWUgaXMgdGhlIG5hbWUgb2YgdGhlIG1ldHJpYyBpbiBxdWVzdGlvblxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMS5Qb2RzTWV0cmljU291cmNlI21ldHJpY05hbWVcbiAgICovXG4gIHJlYWRvbmx5IG1ldHJpY05hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogc2VsZWN0b3IgaXMgdGhlIHN0cmluZy1lbmNvZGVkIGZvcm0gb2YgYSBzdGFuZGFyZCBrdWJlcm5ldGVzIGxhYmVsIHNlbGVjdG9yIGZvciB0aGUgZ2l2ZW4gbWV0cmljIFdoZW4gc2V0LCBpdCBpcyBwYXNzZWQgYXMgYW4gYWRkaXRpb25hbCBwYXJhbWV0ZXIgdG8gdGhlIG1ldHJpY3Mgc2VydmVyIGZvciBtb3JlIHNwZWNpZmljIG1ldHJpY3Mgc2NvcGluZyBXaGVuIHVuc2V0LCBqdXN0IHRoZSBtZXRyaWNOYW1lIHdpbGwgYmUgdXNlZCB0byBnYXRoZXIgbWV0cmljcy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTEuUG9kc01ldHJpY1NvdXJjZSNzZWxlY3RvclxuICAgKi9cbiAgcmVhZG9ubHkgc2VsZWN0b3I/OiBMYWJlbFNlbGVjdG9yO1xuXG4gIC8qKlxuICAgKiB0YXJnZXRBdmVyYWdlVmFsdWUgaXMgdGhlIHRhcmdldCB2YWx1ZSBvZiB0aGUgYXZlcmFnZSBvZiB0aGUgbWV0cmljIGFjcm9zcyBhbGwgcmVsZXZhbnQgcG9kcyAoYXMgYSBxdWFudGl0eSlcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTEuUG9kc01ldHJpY1NvdXJjZSN0YXJnZXRBdmVyYWdlVmFsdWVcbiAgICovXG4gIHJlYWRvbmx5IHRhcmdldEF2ZXJhZ2VWYWx1ZTogUXVhbnRpdHk7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnUG9kc01ldHJpY1NvdXJjZVYyQmV0YTEnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1BvZHNNZXRyaWNTb3VyY2VWMkJldGExKG9iajogUG9kc01ldHJpY1NvdXJjZVYyQmV0YTEgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtZXRyaWNOYW1lJzogb2JqLm1ldHJpY05hbWUsXG4gICAgJ3NlbGVjdG9yJzogdG9Kc29uX0xhYmVsU2VsZWN0b3Iob2JqLnNlbGVjdG9yKSxcbiAgICAndGFyZ2V0QXZlcmFnZVZhbHVlJzogb2JqLnRhcmdldEF2ZXJhZ2VWYWx1ZT8udmFsdWUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUmVzb3VyY2VNZXRyaWNTb3VyY2UgaW5kaWNhdGVzIGhvdyB0byBzY2FsZSBvbiBhIHJlc291cmNlIG1ldHJpYyBrbm93biB0byBLdWJlcm5ldGVzLCBhcyBzcGVjaWZpZWQgaW4gcmVxdWVzdHMgYW5kIGxpbWl0cywgZGVzY3JpYmluZyBlYWNoIHBvZCBpbiB0aGUgY3VycmVudCBzY2FsZSB0YXJnZXQgKGUuZy4gQ1BVIG9yIG1lbW9yeSkuICBUaGUgdmFsdWVzIHdpbGwgYmUgYXZlcmFnZWQgdG9nZXRoZXIgYmVmb3JlIGJlaW5nIGNvbXBhcmVkIHRvIHRoZSB0YXJnZXQuICBTdWNoIG1ldHJpY3MgYXJlIGJ1aWx0IGluIHRvIEt1YmVybmV0ZXMsIGFuZCBoYXZlIHNwZWNpYWwgc2NhbGluZyBvcHRpb25zIG9uIHRvcCBvZiB0aG9zZSBhdmFpbGFibGUgdG8gbm9ybWFsIHBlci1wb2QgbWV0cmljcyB1c2luZyB0aGUgXCJwb2RzXCIgc291cmNlLiAgT25seSBvbmUgXCJ0YXJnZXRcIiB0eXBlIHNob3VsZCBiZSBzZXQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTEuUmVzb3VyY2VNZXRyaWNTb3VyY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNvdXJjZU1ldHJpY1NvdXJjZVYyQmV0YTEge1xuICAvKipcbiAgICogbmFtZSBpcyB0aGUgbmFtZSBvZiB0aGUgcmVzb3VyY2UgaW4gcXVlc3Rpb24uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGExLlJlc291cmNlTWV0cmljU291cmNlI25hbWVcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogdGFyZ2V0QXZlcmFnZVV0aWxpemF0aW9uIGlzIHRoZSB0YXJnZXQgdmFsdWUgb2YgdGhlIGF2ZXJhZ2Ugb2YgdGhlIHJlc291cmNlIG1ldHJpYyBhY3Jvc3MgYWxsIHJlbGV2YW50IHBvZHMsIHJlcHJlc2VudGVkIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgcmVxdWVzdGVkIHZhbHVlIG9mIHRoZSByZXNvdXJjZSBmb3IgdGhlIHBvZHMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGExLlJlc291cmNlTWV0cmljU291cmNlI3RhcmdldEF2ZXJhZ2VVdGlsaXphdGlvblxuICAgKi9cbiAgcmVhZG9ubHkgdGFyZ2V0QXZlcmFnZVV0aWxpemF0aW9uPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiB0YXJnZXRBdmVyYWdlVmFsdWUgaXMgdGhlIHRhcmdldCB2YWx1ZSBvZiB0aGUgYXZlcmFnZSBvZiB0aGUgcmVzb3VyY2UgbWV0cmljIGFjcm9zcyBhbGwgcmVsZXZhbnQgcG9kcywgYXMgYSByYXcgdmFsdWUgKGluc3RlYWQgb2YgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSByZXF1ZXN0KSwgc2ltaWxhciB0byB0aGUgXCJwb2RzXCIgbWV0cmljIHNvdXJjZSB0eXBlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMS5SZXNvdXJjZU1ldHJpY1NvdXJjZSN0YXJnZXRBdmVyYWdlVmFsdWVcbiAgICovXG4gIHJlYWRvbmx5IHRhcmdldEF2ZXJhZ2VWYWx1ZT86IFF1YW50aXR5O1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1Jlc291cmNlTWV0cmljU291cmNlVjJCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fUmVzb3VyY2VNZXRyaWNTb3VyY2VWMkJldGExKG9iajogUmVzb3VyY2VNZXRyaWNTb3VyY2VWMkJldGExIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbmFtZSc6IG9iai5uYW1lLFxuICAgICd0YXJnZXRBdmVyYWdlVXRpbGl6YXRpb24nOiBvYmoudGFyZ2V0QXZlcmFnZVV0aWxpemF0aW9uLFxuICAgICd0YXJnZXRBdmVyYWdlVmFsdWUnOiBvYmoudGFyZ2V0QXZlcmFnZVZhbHVlPy52YWx1ZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBIUEFTY2FsaW5nUnVsZXMgY29uZmlndXJlcyB0aGUgc2NhbGluZyBiZWhhdmlvciBmb3Igb25lIGRpcmVjdGlvbi4gVGhlc2UgUnVsZXMgYXJlIGFwcGxpZWQgYWZ0ZXIgY2FsY3VsYXRpbmcgRGVzaXJlZFJlcGxpY2FzIGZyb20gbWV0cmljcyBmb3IgdGhlIEhQQS4gVGhleSBjYW4gbGltaXQgdGhlIHNjYWxpbmcgdmVsb2NpdHkgYnkgc3BlY2lmeWluZyBzY2FsaW5nIHBvbGljaWVzLiBUaGV5IGNhbiBwcmV2ZW50IGZsYXBwaW5nIGJ5IHNwZWNpZnlpbmcgdGhlIHN0YWJpbGl6YXRpb24gd2luZG93LCBzbyB0aGF0IHRoZSBudW1iZXIgb2YgcmVwbGljYXMgaXMgbm90IHNldCBpbnN0YW50bHksIGluc3RlYWQsIHRoZSBzYWZlc3QgdmFsdWUgZnJvbSB0aGUgc3RhYmlsaXphdGlvbiB3aW5kb3cgaXMgY2hvc2VuLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGEyLkhQQVNjYWxpbmdSdWxlc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEhwYVNjYWxpbmdSdWxlc1YyQmV0YTIge1xuICAvKipcbiAgICogcG9saWNpZXMgaXMgYSBsaXN0IG9mIHBvdGVudGlhbCBzY2FsaW5nIHBvbGljZXMgd2hpY2ggY2FuIGJlIHVzZWQgZHVyaW5nIHNjYWxpbmcuIEF0IGxlYXN0IG9uZSBwb2xpY3kgbXVzdCBiZSBzcGVjaWZpZWQsIG90aGVyd2lzZSB0aGUgSFBBU2NhbGluZ1J1bGVzIHdpbGwgYmUgZGlzY2FyZGVkIGFzIGludmFsaWRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuSFBBU2NhbGluZ1J1bGVzI3BvbGljaWVzXG4gICAqL1xuICByZWFkb25seSBwb2xpY2llcz86IEhwYVNjYWxpbmdQb2xpY3lWMkJldGEyW107XG5cbiAgLyoqXG4gICAqIHNlbGVjdFBvbGljeSBpcyB1c2VkIHRvIHNwZWNpZnkgd2hpY2ggcG9saWN5IHNob3VsZCBiZSB1c2VkLiBJZiBub3Qgc2V0LCB0aGUgZGVmYXVsdCB2YWx1ZSBNYXhQb2xpY3lTZWxlY3QgaXMgdXNlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuSFBBU2NhbGluZ1J1bGVzI3NlbGVjdFBvbGljeVxuICAgKi9cbiAgcmVhZG9ubHkgc2VsZWN0UG9saWN5Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTdGFiaWxpemF0aW9uV2luZG93U2Vjb25kcyBpcyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgZm9yIHdoaWNoIHBhc3QgcmVjb21tZW5kYXRpb25zIHNob3VsZCBiZSBjb25zaWRlcmVkIHdoaWxlIHNjYWxpbmcgdXAgb3Igc2NhbGluZyBkb3duLiBTdGFiaWxpemF0aW9uV2luZG93U2Vjb25kcyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMzYwMCAob25lIGhvdXIpLiBJZiBub3Qgc2V0LCB1c2UgdGhlIGRlZmF1bHQgdmFsdWVzOiAtIEZvciBzY2FsZSB1cDogMCAoaS5lLiBubyBzdGFiaWxpemF0aW9uIGlzIGRvbmUpLiAtIEZvciBzY2FsZSBkb3duOiAzMDAgKGkuZS4gdGhlIHN0YWJpbGl6YXRpb24gd2luZG93IGlzIDMwMCBzZWNvbmRzIGxvbmcpLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMi5IUEFTY2FsaW5nUnVsZXMjc3RhYmlsaXphdGlvbldpbmRvd1NlY29uZHNcbiAgICovXG4gIHJlYWRvbmx5IHN0YWJpbGl6YXRpb25XaW5kb3dTZWNvbmRzPzogbnVtYmVyO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0hwYVNjYWxpbmdSdWxlc1YyQmV0YTInIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0hwYVNjYWxpbmdSdWxlc1YyQmV0YTIob2JqOiBIcGFTY2FsaW5nUnVsZXNWMkJldGEyIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAncG9saWNpZXMnOiBvYmoucG9saWNpZXM/Lm1hcCh5ID0+IHRvSnNvbl9IcGFTY2FsaW5nUG9saWN5VjJCZXRhMih5KSksXG4gICAgJ3NlbGVjdFBvbGljeSc6IG9iai5zZWxlY3RQb2xpY3ksXG4gICAgJ3N0YWJpbGl6YXRpb25XaW5kb3dTZWNvbmRzJzogb2JqLnN0YWJpbGl6YXRpb25XaW5kb3dTZWNvbmRzLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIENvbnRhaW5lclJlc291cmNlTWV0cmljU291cmNlIGluZGljYXRlcyBob3cgdG8gc2NhbGUgb24gYSByZXNvdXJjZSBtZXRyaWMga25vd24gdG8gS3ViZXJuZXRlcywgYXMgc3BlY2lmaWVkIGluIHJlcXVlc3RzIGFuZCBsaW1pdHMsIGRlc2NyaWJpbmcgZWFjaCBwb2QgaW4gdGhlIGN1cnJlbnQgc2NhbGUgdGFyZ2V0IChlLmcuIENQVSBvciBtZW1vcnkpLiAgVGhlIHZhbHVlcyB3aWxsIGJlIGF2ZXJhZ2VkIHRvZ2V0aGVyIGJlZm9yZSBiZWluZyBjb21wYXJlZCB0byB0aGUgdGFyZ2V0LiAgU3VjaCBtZXRyaWNzIGFyZSBidWlsdCBpbiB0byBLdWJlcm5ldGVzLCBhbmQgaGF2ZSBzcGVjaWFsIHNjYWxpbmcgb3B0aW9ucyBvbiB0b3Agb2YgdGhvc2UgYXZhaWxhYmxlIHRvIG5vcm1hbCBwZXItcG9kIG1ldHJpY3MgdXNpbmcgdGhlIFwicG9kc1wiIHNvdXJjZS4gIE9ubHkgb25lIFwidGFyZ2V0XCIgdHlwZSBzaG91bGQgYmUgc2V0LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGEyLkNvbnRhaW5lclJlc291cmNlTWV0cmljU291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGFpbmVyUmVzb3VyY2VNZXRyaWNTb3VyY2VWMkJldGEyIHtcbiAgLyoqXG4gICAqIGNvbnRhaW5lciBpcyB0aGUgbmFtZSBvZiB0aGUgY29udGFpbmVyIGluIHRoZSBwb2RzIG9mIHRoZSBzY2FsaW5nIHRhcmdldFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMi5Db250YWluZXJSZXNvdXJjZU1ldHJpY1NvdXJjZSNjb250YWluZXJcbiAgICovXG4gIHJlYWRvbmx5IGNvbnRhaW5lcjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBuYW1lIGlzIHRoZSBuYW1lIG9mIHRoZSByZXNvdXJjZSBpbiBxdWVzdGlvbi5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuQ29udGFpbmVyUmVzb3VyY2VNZXRyaWNTb3VyY2UjbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiB0YXJnZXQgc3BlY2lmaWVzIHRoZSB0YXJnZXQgdmFsdWUgZm9yIHRoZSBnaXZlbiBtZXRyaWNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuQ29udGFpbmVyUmVzb3VyY2VNZXRyaWNTb3VyY2UjdGFyZ2V0XG4gICAqL1xuICByZWFkb25seSB0YXJnZXQ6IE1ldHJpY1RhcmdldFYyQmV0YTI7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnQ29udGFpbmVyUmVzb3VyY2VNZXRyaWNTb3VyY2VWMkJldGEyJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Db250YWluZXJSZXNvdXJjZU1ldHJpY1NvdXJjZVYyQmV0YTIob2JqOiBDb250YWluZXJSZXNvdXJjZU1ldHJpY1NvdXJjZVYyQmV0YTIgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdjb250YWluZXInOiBvYmouY29udGFpbmVyLFxuICAgICduYW1lJzogb2JqLm5hbWUsXG4gICAgJ3RhcmdldCc6IHRvSnNvbl9NZXRyaWNUYXJnZXRWMkJldGEyKG9iai50YXJnZXQpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEV4dGVybmFsTWV0cmljU291cmNlIGluZGljYXRlcyBob3cgdG8gc2NhbGUgb24gYSBtZXRyaWMgbm90IGFzc29jaWF0ZWQgd2l0aCBhbnkgS3ViZXJuZXRlcyBvYmplY3QgKGZvciBleGFtcGxlIGxlbmd0aCBvZiBxdWV1ZSBpbiBjbG91ZCBtZXNzYWdpbmcgc2VydmljZSwgb3IgUVBTIGZyb20gbG9hZGJhbGFuY2VyIHJ1bm5pbmcgb3V0c2lkZSBvZiBjbHVzdGVyKS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMi5FeHRlcm5hbE1ldHJpY1NvdXJjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEV4dGVybmFsTWV0cmljU291cmNlVjJCZXRhMiB7XG4gIC8qKlxuICAgKiBtZXRyaWMgaWRlbnRpZmllcyB0aGUgdGFyZ2V0IG1ldHJpYyBieSBuYW1lIGFuZCBzZWxlY3RvclxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMi5FeHRlcm5hbE1ldHJpY1NvdXJjZSNtZXRyaWNcbiAgICovXG4gIHJlYWRvbmx5IG1ldHJpYzogTWV0cmljSWRlbnRpZmllclYyQmV0YTI7XG5cbiAgLyoqXG4gICAqIHRhcmdldCBzcGVjaWZpZXMgdGhlIHRhcmdldCB2YWx1ZSBmb3IgdGhlIGdpdmVuIG1ldHJpY1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMi5FeHRlcm5hbE1ldHJpY1NvdXJjZSN0YXJnZXRcbiAgICovXG4gIHJlYWRvbmx5IHRhcmdldDogTWV0cmljVGFyZ2V0VjJCZXRhMjtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdFeHRlcm5hbE1ldHJpY1NvdXJjZVYyQmV0YTInIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0V4dGVybmFsTWV0cmljU291cmNlVjJCZXRhMihvYmo6IEV4dGVybmFsTWV0cmljU291cmNlVjJCZXRhMiB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21ldHJpYyc6IHRvSnNvbl9NZXRyaWNJZGVudGlmaWVyVjJCZXRhMihvYmoubWV0cmljKSxcbiAgICAndGFyZ2V0JzogdG9Kc29uX01ldHJpY1RhcmdldFYyQmV0YTIob2JqLnRhcmdldCksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogT2JqZWN0TWV0cmljU291cmNlIGluZGljYXRlcyBob3cgdG8gc2NhbGUgb24gYSBtZXRyaWMgZGVzY3JpYmluZyBhIGt1YmVybmV0ZXMgb2JqZWN0IChmb3IgZXhhbXBsZSwgaGl0cy1wZXItc2Vjb25kIG9uIGFuIEluZ3Jlc3Mgb2JqZWN0KS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMi5PYmplY3RNZXRyaWNTb3VyY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBPYmplY3RNZXRyaWNTb3VyY2VWMkJldGEyIHtcbiAgLyoqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGEyLk9iamVjdE1ldHJpY1NvdXJjZSNkZXNjcmliZWRPYmplY3RcbiAgICovXG4gIHJlYWRvbmx5IGRlc2NyaWJlZE9iamVjdDogQ3Jvc3NWZXJzaW9uT2JqZWN0UmVmZXJlbmNlVjJCZXRhMjtcblxuICAvKipcbiAgICogbWV0cmljIGlkZW50aWZpZXMgdGhlIHRhcmdldCBtZXRyaWMgYnkgbmFtZSBhbmQgc2VsZWN0b3JcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuT2JqZWN0TWV0cmljU291cmNlI21ldHJpY1xuICAgKi9cbiAgcmVhZG9ubHkgbWV0cmljOiBNZXRyaWNJZGVudGlmaWVyVjJCZXRhMjtcblxuICAvKipcbiAgICogdGFyZ2V0IHNwZWNpZmllcyB0aGUgdGFyZ2V0IHZhbHVlIGZvciB0aGUgZ2l2ZW4gbWV0cmljXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGEyLk9iamVjdE1ldHJpY1NvdXJjZSN0YXJnZXRcbiAgICovXG4gIHJlYWRvbmx5IHRhcmdldDogTWV0cmljVGFyZ2V0VjJCZXRhMjtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdPYmplY3RNZXRyaWNTb3VyY2VWMkJldGEyJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9PYmplY3RNZXRyaWNTb3VyY2VWMkJldGEyKG9iajogT2JqZWN0TWV0cmljU291cmNlVjJCZXRhMiB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2Rlc2NyaWJlZE9iamVjdCc6IHRvSnNvbl9Dcm9zc1ZlcnNpb25PYmplY3RSZWZlcmVuY2VWMkJldGEyKG9iai5kZXNjcmliZWRPYmplY3QpLFxuICAgICdtZXRyaWMnOiB0b0pzb25fTWV0cmljSWRlbnRpZmllclYyQmV0YTIob2JqLm1ldHJpYyksXG4gICAgJ3RhcmdldCc6IHRvSnNvbl9NZXRyaWNUYXJnZXRWMkJldGEyKG9iai50YXJnZXQpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFBvZHNNZXRyaWNTb3VyY2UgaW5kaWNhdGVzIGhvdyB0byBzY2FsZSBvbiBhIG1ldHJpYyBkZXNjcmliaW5nIGVhY2ggcG9kIGluIHRoZSBjdXJyZW50IHNjYWxlIHRhcmdldCAoZm9yIGV4YW1wbGUsIHRyYW5zYWN0aW9ucy1wcm9jZXNzZWQtcGVyLXNlY29uZCkuIFRoZSB2YWx1ZXMgd2lsbCBiZSBhdmVyYWdlZCB0b2dldGhlciBiZWZvcmUgYmVpbmcgY29tcGFyZWQgdG8gdGhlIHRhcmdldCB2YWx1ZS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMi5Qb2RzTWV0cmljU291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUG9kc01ldHJpY1NvdXJjZVYyQmV0YTIge1xuICAvKipcbiAgICogbWV0cmljIGlkZW50aWZpZXMgdGhlIHRhcmdldCBtZXRyaWMgYnkgbmFtZSBhbmQgc2VsZWN0b3JcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuUG9kc01ldHJpY1NvdXJjZSNtZXRyaWNcbiAgICovXG4gIHJlYWRvbmx5IG1ldHJpYzogTWV0cmljSWRlbnRpZmllclYyQmV0YTI7XG5cbiAgLyoqXG4gICAqIHRhcmdldCBzcGVjaWZpZXMgdGhlIHRhcmdldCB2YWx1ZSBmb3IgdGhlIGdpdmVuIG1ldHJpY1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMi5Qb2RzTWV0cmljU291cmNlI3RhcmdldFxuICAgKi9cbiAgcmVhZG9ubHkgdGFyZ2V0OiBNZXRyaWNUYXJnZXRWMkJldGEyO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1BvZHNNZXRyaWNTb3VyY2VWMkJldGEyJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Qb2RzTWV0cmljU291cmNlVjJCZXRhMihvYmo6IFBvZHNNZXRyaWNTb3VyY2VWMkJldGEyIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbWV0cmljJzogdG9Kc29uX01ldHJpY0lkZW50aWZpZXJWMkJldGEyKG9iai5tZXRyaWMpLFxuICAgICd0YXJnZXQnOiB0b0pzb25fTWV0cmljVGFyZ2V0VjJCZXRhMihvYmoudGFyZ2V0KSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBSZXNvdXJjZU1ldHJpY1NvdXJjZSBpbmRpY2F0ZXMgaG93IHRvIHNjYWxlIG9uIGEgcmVzb3VyY2UgbWV0cmljIGtub3duIHRvIEt1YmVybmV0ZXMsIGFzIHNwZWNpZmllZCBpbiByZXF1ZXN0cyBhbmQgbGltaXRzLCBkZXNjcmliaW5nIGVhY2ggcG9kIGluIHRoZSBjdXJyZW50IHNjYWxlIHRhcmdldCAoZS5nLiBDUFUgb3IgbWVtb3J5KS4gIFRoZSB2YWx1ZXMgd2lsbCBiZSBhdmVyYWdlZCB0b2dldGhlciBiZWZvcmUgYmVpbmcgY29tcGFyZWQgdG8gdGhlIHRhcmdldC4gIFN1Y2ggbWV0cmljcyBhcmUgYnVpbHQgaW4gdG8gS3ViZXJuZXRlcywgYW5kIGhhdmUgc3BlY2lhbCBzY2FsaW5nIG9wdGlvbnMgb24gdG9wIG9mIHRob3NlIGF2YWlsYWJsZSB0byBub3JtYWwgcGVyLXBvZCBtZXRyaWNzIHVzaW5nIHRoZSBcInBvZHNcIiBzb3VyY2UuICBPbmx5IG9uZSBcInRhcmdldFwiIHR5cGUgc2hvdWxkIGJlIHNldC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMi5SZXNvdXJjZU1ldHJpY1NvdXJjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc291cmNlTWV0cmljU291cmNlVjJCZXRhMiB7XG4gIC8qKlxuICAgKiBuYW1lIGlzIHRoZSBuYW1lIG9mIHRoZSByZXNvdXJjZSBpbiBxdWVzdGlvbi5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuUmVzb3VyY2VNZXRyaWNTb3VyY2UjbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiB0YXJnZXQgc3BlY2lmaWVzIHRoZSB0YXJnZXQgdmFsdWUgZm9yIHRoZSBnaXZlbiBtZXRyaWNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuUmVzb3VyY2VNZXRyaWNTb3VyY2UjdGFyZ2V0XG4gICAqL1xuICByZWFkb25seSB0YXJnZXQ6IE1ldHJpY1RhcmdldFYyQmV0YTI7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnUmVzb3VyY2VNZXRyaWNTb3VyY2VWMkJldGEyJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9SZXNvdXJjZU1ldHJpY1NvdXJjZVYyQmV0YTIob2JqOiBSZXNvdXJjZU1ldHJpY1NvdXJjZVYyQmV0YTIgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICduYW1lJzogb2JqLm5hbWUsXG4gICAgJ3RhcmdldCc6IHRvSnNvbl9NZXRyaWNUYXJnZXRWMkJldGEyKG9iai50YXJnZXQpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIENvbmZpZ01hcE5vZGVDb25maWdTb3VyY2UgY29udGFpbnMgdGhlIGluZm9ybWF0aW9uIHRvIHJlZmVyZW5jZSBhIENvbmZpZ01hcCBhcyBhIGNvbmZpZyBzb3VyY2UgZm9yIHRoZSBOb2RlLiBUaGlzIEFQSSBpcyBkZXByZWNhdGVkIHNpbmNlIDEuMjI6IGh0dHBzOi8vZ2l0Lms4cy5pby9lbmhhbmNlbWVudHMva2Vwcy9zaWctbm9kZS8yODEtZHluYW1pYy1rdWJlbGV0LWNvbmZpZ3VyYXRpb25cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db25maWdNYXBOb2RlQ29uZmlnU291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29uZmlnTWFwTm9kZUNvbmZpZ1NvdXJjZSB7XG4gIC8qKlxuICAgKiBLdWJlbGV0Q29uZmlnS2V5IGRlY2xhcmVzIHdoaWNoIGtleSBvZiB0aGUgcmVmZXJlbmNlZCBDb25maWdNYXAgY29ycmVzcG9uZHMgdG8gdGhlIEt1YmVsZXRDb25maWd1cmF0aW9uIHN0cnVjdHVyZSBUaGlzIGZpZWxkIGlzIHJlcXVpcmVkIGluIGFsbCBjYXNlcy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ29uZmlnTWFwTm9kZUNvbmZpZ1NvdXJjZSNrdWJlbGV0Q29uZmlnS2V5XG4gICAqL1xuICByZWFkb25seSBrdWJlbGV0Q29uZmlnS2V5OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE5hbWUgaXMgdGhlIG1ldGFkYXRhLm5hbWUgb2YgdGhlIHJlZmVyZW5jZWQgQ29uZmlnTWFwLiBUaGlzIGZpZWxkIGlzIHJlcXVpcmVkIGluIGFsbCBjYXNlcy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ29uZmlnTWFwTm9kZUNvbmZpZ1NvdXJjZSNuYW1lXG4gICAqL1xuICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE5hbWVzcGFjZSBpcyB0aGUgbWV0YWRhdGEubmFtZXNwYWNlIG9mIHRoZSByZWZlcmVuY2VkIENvbmZpZ01hcC4gVGhpcyBmaWVsZCBpcyByZXF1aXJlZCBpbiBhbGwgY2FzZXMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbmZpZ01hcE5vZGVDb25maWdTb3VyY2UjbmFtZXNwYWNlXG4gICAqL1xuICByZWFkb25seSBuYW1lc3BhY2U6IHN0cmluZztcblxuICAvKipcbiAgICogUmVzb3VyY2VWZXJzaW9uIGlzIHRoZSBtZXRhZGF0YS5SZXNvdXJjZVZlcnNpb24gb2YgdGhlIHJlZmVyZW5jZWQgQ29uZmlnTWFwLiBUaGlzIGZpZWxkIGlzIGZvcmJpZGRlbiBpbiBOb2RlLlNwZWMsIGFuZCByZXF1aXJlZCBpbiBOb2RlLlN0YXR1cy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ29uZmlnTWFwTm9kZUNvbmZpZ1NvdXJjZSNyZXNvdXJjZVZlcnNpb25cbiAgICovXG4gIHJlYWRvbmx5IHJlc291cmNlVmVyc2lvbj86IHN0cmluZztcblxuICAvKipcbiAgICogVUlEIGlzIHRoZSBtZXRhZGF0YS5VSUQgb2YgdGhlIHJlZmVyZW5jZWQgQ29uZmlnTWFwLiBUaGlzIGZpZWxkIGlzIGZvcmJpZGRlbiBpbiBOb2RlLlNwZWMsIGFuZCByZXF1aXJlZCBpbiBOb2RlLlN0YXR1cy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ29uZmlnTWFwTm9kZUNvbmZpZ1NvdXJjZSN1aWRcbiAgICovXG4gIHJlYWRvbmx5IHVpZD86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdDb25maWdNYXBOb2RlQ29uZmlnU291cmNlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Db25maWdNYXBOb2RlQ29uZmlnU291cmNlKG9iajogQ29uZmlnTWFwTm9kZUNvbmZpZ1NvdXJjZSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2t1YmVsZXRDb25maWdLZXknOiBvYmoua3ViZWxldENvbmZpZ0tleSxcbiAgICAnbmFtZSc6IG9iai5uYW1lLFxuICAgICduYW1lc3BhY2UnOiBvYmoubmFtZXNwYWNlLFxuICAgICdyZXNvdXJjZVZlcnNpb24nOiBvYmoucmVzb3VyY2VWZXJzaW9uLFxuICAgICd1aWQnOiBvYmoudWlkLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFNlY3JldFJlZmVyZW5jZSByZXByZXNlbnRzIGEgU2VjcmV0IFJlZmVyZW5jZS4gSXQgaGFzIGVub3VnaCBpbmZvcm1hdGlvbiB0byByZXRyaWV2ZSBzZWNyZXQgaW4gYW55IG5hbWVzcGFjZVxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlY3JldFJlZmVyZW5jZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlY3JldFJlZmVyZW5jZSB7XG4gIC8qKlxuICAgKiBOYW1lIGlzIHVuaXF1ZSB3aXRoaW4gYSBuYW1lc3BhY2UgdG8gcmVmZXJlbmNlIGEgc2VjcmV0IHJlc291cmNlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZWNyZXRSZWZlcmVuY2UjbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogTmFtZXNwYWNlIGRlZmluZXMgdGhlIHNwYWNlIHdpdGhpbiB3aGljaCB0aGUgc2VjcmV0IG5hbWUgbXVzdCBiZSB1bmlxdWUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlY3JldFJlZmVyZW5jZSNuYW1lc3BhY2VcbiAgICovXG4gIHJlYWRvbmx5IG5hbWVzcGFjZT86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdTZWNyZXRSZWZlcmVuY2UnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1NlY3JldFJlZmVyZW5jZShvYmo6IFNlY3JldFJlZmVyZW5jZSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ25hbWUnOiBvYmoubmFtZSxcbiAgICAnbmFtZXNwYWNlJzogb2JqLm5hbWVzcGFjZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBBIG5vZGUgc2VsZWN0b3IgcmVwcmVzZW50cyB0aGUgdW5pb24gb2YgdGhlIHJlc3VsdHMgb2Ygb25lIG9yIG1vcmUgbGFiZWwgcXVlcmllcyBvdmVyIGEgc2V0IG9mIG5vZGVzOyB0aGF0IGlzLCBpdCByZXByZXNlbnRzIHRoZSBPUiBvZiB0aGUgc2VsZWN0b3JzIHJlcHJlc2VudGVkIGJ5IHRoZSBub2RlIHNlbGVjdG9yIHRlcm1zLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLk5vZGVTZWxlY3RvclxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5vZGVTZWxlY3RvciB7XG4gIC8qKlxuICAgKiBSZXF1aXJlZC4gQSBsaXN0IG9mIG5vZGUgc2VsZWN0b3IgdGVybXMuIFRoZSB0ZXJtcyBhcmUgT1JlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTm9kZVNlbGVjdG9yI25vZGVTZWxlY3RvclRlcm1zXG4gICAqL1xuICByZWFkb25seSBub2RlU2VsZWN0b3JUZXJtczogTm9kZVNlbGVjdG9yVGVybVtdO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ05vZGVTZWxlY3RvcicgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fTm9kZVNlbGVjdG9yKG9iajogTm9kZVNlbGVjdG9yIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbm9kZVNlbGVjdG9yVGVybXMnOiBvYmoubm9kZVNlbGVjdG9yVGVybXM/Lm1hcCh5ID0+IHRvSnNvbl9Ob2RlU2VsZWN0b3JUZXJtKHkpKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBOb2RlIGFmZmluaXR5IGlzIGEgZ3JvdXAgb2Ygbm9kZSBhZmZpbml0eSBzY2hlZHVsaW5nIHJ1bGVzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLk5vZGVBZmZpbml0eVxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5vZGVBZmZpbml0eSB7XG4gIC8qKlxuICAgKiBUaGUgc2NoZWR1bGVyIHdpbGwgcHJlZmVyIHRvIHNjaGVkdWxlIHBvZHMgdG8gbm9kZXMgdGhhdCBzYXRpc2Z5IHRoZSBhZmZpbml0eSBleHByZXNzaW9ucyBzcGVjaWZpZWQgYnkgdGhpcyBmaWVsZCwgYnV0IGl0IG1heSBjaG9vc2UgYSBub2RlIHRoYXQgdmlvbGF0ZXMgb25lIG9yIG1vcmUgb2YgdGhlIGV4cHJlc3Npb25zLiBUaGUgbm9kZSB0aGF0IGlzIG1vc3QgcHJlZmVycmVkIGlzIHRoZSBvbmUgd2l0aCB0aGUgZ3JlYXRlc3Qgc3VtIG9mIHdlaWdodHMsIGkuZS4gZm9yIGVhY2ggbm9kZSB0aGF0IG1lZXRzIGFsbCBvZiB0aGUgc2NoZWR1bGluZyByZXF1aXJlbWVudHMgKHJlc291cmNlIHJlcXVlc3QsIHJlcXVpcmVkRHVyaW5nU2NoZWR1bGluZyBhZmZpbml0eSBleHByZXNzaW9ucywgZXRjLiksIGNvbXB1dGUgYSBzdW0gYnkgaXRlcmF0aW5nIHRocm91Z2ggdGhlIGVsZW1lbnRzIG9mIHRoaXMgZmllbGQgYW5kIGFkZGluZyBcIndlaWdodFwiIHRvIHRoZSBzdW0gaWYgdGhlIG5vZGUgbWF0Y2hlcyB0aGUgY29ycmVzcG9uZGluZyBtYXRjaEV4cHJlc3Npb25zOyB0aGUgbm9kZShzKSB3aXRoIHRoZSBoaWdoZXN0IHN1bSBhcmUgdGhlIG1vc3QgcHJlZmVycmVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Ob2RlQWZmaW5pdHkjcHJlZmVycmVkRHVyaW5nU2NoZWR1bGluZ0lnbm9yZWREdXJpbmdFeGVjdXRpb25cbiAgICovXG4gIHJlYWRvbmx5IHByZWZlcnJlZER1cmluZ1NjaGVkdWxpbmdJZ25vcmVkRHVyaW5nRXhlY3V0aW9uPzogUHJlZmVycmVkU2NoZWR1bGluZ1Rlcm1bXTtcblxuICAvKipcbiAgICogSWYgdGhlIGFmZmluaXR5IHJlcXVpcmVtZW50cyBzcGVjaWZpZWQgYnkgdGhpcyBmaWVsZCBhcmUgbm90IG1ldCBhdCBzY2hlZHVsaW5nIHRpbWUsIHRoZSBwb2Qgd2lsbCBub3QgYmUgc2NoZWR1bGVkIG9udG8gdGhlIG5vZGUuIElmIHRoZSBhZmZpbml0eSByZXF1aXJlbWVudHMgc3BlY2lmaWVkIGJ5IHRoaXMgZmllbGQgY2Vhc2UgdG8gYmUgbWV0IGF0IHNvbWUgcG9pbnQgZHVyaW5nIHBvZCBleGVjdXRpb24gKGUuZy4gZHVlIHRvIGFuIHVwZGF0ZSksIHRoZSBzeXN0ZW0gbWF5IG9yIG1heSBub3QgdHJ5IHRvIGV2ZW50dWFsbHkgZXZpY3QgdGhlIHBvZCBmcm9tIGl0cyBub2RlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Ob2RlQWZmaW5pdHkjcmVxdWlyZWREdXJpbmdTY2hlZHVsaW5nSWdub3JlZER1cmluZ0V4ZWN1dGlvblxuICAgKi9cbiAgcmVhZG9ubHkgcmVxdWlyZWREdXJpbmdTY2hlZHVsaW5nSWdub3JlZER1cmluZ0V4ZWN1dGlvbj86IE5vZGVTZWxlY3RvcjtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdOb2RlQWZmaW5pdHknIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX05vZGVBZmZpbml0eShvYmo6IE5vZGVBZmZpbml0eSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ3ByZWZlcnJlZER1cmluZ1NjaGVkdWxpbmdJZ25vcmVkRHVyaW5nRXhlY3V0aW9uJzogb2JqLnByZWZlcnJlZER1cmluZ1NjaGVkdWxpbmdJZ25vcmVkRHVyaW5nRXhlY3V0aW9uPy5tYXAoeSA9PiB0b0pzb25fUHJlZmVycmVkU2NoZWR1bGluZ1Rlcm0oeSkpLFxuICAgICdyZXF1aXJlZER1cmluZ1NjaGVkdWxpbmdJZ25vcmVkRHVyaW5nRXhlY3V0aW9uJzogdG9Kc29uX05vZGVTZWxlY3RvcihvYmoucmVxdWlyZWREdXJpbmdTY2hlZHVsaW5nSWdub3JlZER1cmluZ0V4ZWN1dGlvbiksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUG9kIGFmZmluaXR5IGlzIGEgZ3JvdXAgb2YgaW50ZXIgcG9kIGFmZmluaXR5IHNjaGVkdWxpbmcgcnVsZXMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kQWZmaW5pdHlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQb2RBZmZpbml0eSB7XG4gIC8qKlxuICAgKiBUaGUgc2NoZWR1bGVyIHdpbGwgcHJlZmVyIHRvIHNjaGVkdWxlIHBvZHMgdG8gbm9kZXMgdGhhdCBzYXRpc2Z5IHRoZSBhZmZpbml0eSBleHByZXNzaW9ucyBzcGVjaWZpZWQgYnkgdGhpcyBmaWVsZCwgYnV0IGl0IG1heSBjaG9vc2UgYSBub2RlIHRoYXQgdmlvbGF0ZXMgb25lIG9yIG1vcmUgb2YgdGhlIGV4cHJlc3Npb25zLiBUaGUgbm9kZSB0aGF0IGlzIG1vc3QgcHJlZmVycmVkIGlzIHRoZSBvbmUgd2l0aCB0aGUgZ3JlYXRlc3Qgc3VtIG9mIHdlaWdodHMsIGkuZS4gZm9yIGVhY2ggbm9kZSB0aGF0IG1lZXRzIGFsbCBvZiB0aGUgc2NoZWR1bGluZyByZXF1aXJlbWVudHMgKHJlc291cmNlIHJlcXVlc3QsIHJlcXVpcmVkRHVyaW5nU2NoZWR1bGluZyBhZmZpbml0eSBleHByZXNzaW9ucywgZXRjLiksIGNvbXB1dGUgYSBzdW0gYnkgaXRlcmF0aW5nIHRocm91Z2ggdGhlIGVsZW1lbnRzIG9mIHRoaXMgZmllbGQgYW5kIGFkZGluZyBcIndlaWdodFwiIHRvIHRoZSBzdW0gaWYgdGhlIG5vZGUgaGFzIHBvZHMgd2hpY2ggbWF0Y2hlcyB0aGUgY29ycmVzcG9uZGluZyBwb2RBZmZpbml0eVRlcm07IHRoZSBub2RlKHMpIHdpdGggdGhlIGhpZ2hlc3Qgc3VtIGFyZSB0aGUgbW9zdCBwcmVmZXJyZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZEFmZmluaXR5I3ByZWZlcnJlZER1cmluZ1NjaGVkdWxpbmdJZ25vcmVkRHVyaW5nRXhlY3V0aW9uXG4gICAqL1xuICByZWFkb25seSBwcmVmZXJyZWREdXJpbmdTY2hlZHVsaW5nSWdub3JlZER1cmluZ0V4ZWN1dGlvbj86IFdlaWdodGVkUG9kQWZmaW5pdHlUZXJtW107XG5cbiAgLyoqXG4gICAqIElmIHRoZSBhZmZpbml0eSByZXF1aXJlbWVudHMgc3BlY2lmaWVkIGJ5IHRoaXMgZmllbGQgYXJlIG5vdCBtZXQgYXQgc2NoZWR1bGluZyB0aW1lLCB0aGUgcG9kIHdpbGwgbm90IGJlIHNjaGVkdWxlZCBvbnRvIHRoZSBub2RlLiBJZiB0aGUgYWZmaW5pdHkgcmVxdWlyZW1lbnRzIHNwZWNpZmllZCBieSB0aGlzIGZpZWxkIGNlYXNlIHRvIGJlIG1ldCBhdCBzb21lIHBvaW50IGR1cmluZyBwb2QgZXhlY3V0aW9uIChlLmcuIGR1ZSB0byBhIHBvZCBsYWJlbCB1cGRhdGUpLCB0aGUgc3lzdGVtIG1heSBvciBtYXkgbm90IHRyeSB0byBldmVudHVhbGx5IGV2aWN0IHRoZSBwb2QgZnJvbSBpdHMgbm9kZS4gV2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgZWxlbWVudHMsIHRoZSBsaXN0cyBvZiBub2RlcyBjb3JyZXNwb25kaW5nIHRvIGVhY2ggcG9kQWZmaW5pdHlUZXJtIGFyZSBpbnRlcnNlY3RlZCwgaS5lLiBhbGwgdGVybXMgbXVzdCBiZSBzYXRpc2ZpZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZEFmZmluaXR5I3JlcXVpcmVkRHVyaW5nU2NoZWR1bGluZ0lnbm9yZWREdXJpbmdFeGVjdXRpb25cbiAgICovXG4gIHJlYWRvbmx5IHJlcXVpcmVkRHVyaW5nU2NoZWR1bGluZ0lnbm9yZWREdXJpbmdFeGVjdXRpb24/OiBQb2RBZmZpbml0eVRlcm1bXTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdQb2RBZmZpbml0eScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fUG9kQWZmaW5pdHkob2JqOiBQb2RBZmZpbml0eSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ3ByZWZlcnJlZER1cmluZ1NjaGVkdWxpbmdJZ25vcmVkRHVyaW5nRXhlY3V0aW9uJzogb2JqLnByZWZlcnJlZER1cmluZ1NjaGVkdWxpbmdJZ25vcmVkRHVyaW5nRXhlY3V0aW9uPy5tYXAoeSA9PiB0b0pzb25fV2VpZ2h0ZWRQb2RBZmZpbml0eVRlcm0oeSkpLFxuICAgICdyZXF1aXJlZER1cmluZ1NjaGVkdWxpbmdJZ25vcmVkRHVyaW5nRXhlY3V0aW9uJzogb2JqLnJlcXVpcmVkRHVyaW5nU2NoZWR1bGluZ0lnbm9yZWREdXJpbmdFeGVjdXRpb24/Lm1hcCh5ID0+IHRvSnNvbl9Qb2RBZmZpbml0eVRlcm0oeSkpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFBvZCBhbnRpIGFmZmluaXR5IGlzIGEgZ3JvdXAgb2YgaW50ZXIgcG9kIGFudGkgYWZmaW5pdHkgc2NoZWR1bGluZyBydWxlcy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RBbnRpQWZmaW5pdHlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQb2RBbnRpQWZmaW5pdHkge1xuICAvKipcbiAgICogVGhlIHNjaGVkdWxlciB3aWxsIHByZWZlciB0byBzY2hlZHVsZSBwb2RzIHRvIG5vZGVzIHRoYXQgc2F0aXNmeSB0aGUgYW50aS1hZmZpbml0eSBleHByZXNzaW9ucyBzcGVjaWZpZWQgYnkgdGhpcyBmaWVsZCwgYnV0IGl0IG1heSBjaG9vc2UgYSBub2RlIHRoYXQgdmlvbGF0ZXMgb25lIG9yIG1vcmUgb2YgdGhlIGV4cHJlc3Npb25zLiBUaGUgbm9kZSB0aGF0IGlzIG1vc3QgcHJlZmVycmVkIGlzIHRoZSBvbmUgd2l0aCB0aGUgZ3JlYXRlc3Qgc3VtIG9mIHdlaWdodHMsIGkuZS4gZm9yIGVhY2ggbm9kZSB0aGF0IG1lZXRzIGFsbCBvZiB0aGUgc2NoZWR1bGluZyByZXF1aXJlbWVudHMgKHJlc291cmNlIHJlcXVlc3QsIHJlcXVpcmVkRHVyaW5nU2NoZWR1bGluZyBhbnRpLWFmZmluaXR5IGV4cHJlc3Npb25zLCBldGMuKSwgY29tcHV0ZSBhIHN1bSBieSBpdGVyYXRpbmcgdGhyb3VnaCB0aGUgZWxlbWVudHMgb2YgdGhpcyBmaWVsZCBhbmQgYWRkaW5nIFwid2VpZ2h0XCIgdG8gdGhlIHN1bSBpZiB0aGUgbm9kZSBoYXMgcG9kcyB3aGljaCBtYXRjaGVzIHRoZSBjb3JyZXNwb25kaW5nIHBvZEFmZmluaXR5VGVybTsgdGhlIG5vZGUocykgd2l0aCB0aGUgaGlnaGVzdCBzdW0gYXJlIHRoZSBtb3N0IHByZWZlcnJlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kQW50aUFmZmluaXR5I3ByZWZlcnJlZER1cmluZ1NjaGVkdWxpbmdJZ25vcmVkRHVyaW5nRXhlY3V0aW9uXG4gICAqL1xuICByZWFkb25seSBwcmVmZXJyZWREdXJpbmdTY2hlZHVsaW5nSWdub3JlZER1cmluZ0V4ZWN1dGlvbj86IFdlaWdodGVkUG9kQWZmaW5pdHlUZXJtW107XG5cbiAgLyoqXG4gICAqIElmIHRoZSBhbnRpLWFmZmluaXR5IHJlcXVpcmVtZW50cyBzcGVjaWZpZWQgYnkgdGhpcyBmaWVsZCBhcmUgbm90IG1ldCBhdCBzY2hlZHVsaW5nIHRpbWUsIHRoZSBwb2Qgd2lsbCBub3QgYmUgc2NoZWR1bGVkIG9udG8gdGhlIG5vZGUuIElmIHRoZSBhbnRpLWFmZmluaXR5IHJlcXVpcmVtZW50cyBzcGVjaWZpZWQgYnkgdGhpcyBmaWVsZCBjZWFzZSB0byBiZSBtZXQgYXQgc29tZSBwb2ludCBkdXJpbmcgcG9kIGV4ZWN1dGlvbiAoZS5nLiBkdWUgdG8gYSBwb2QgbGFiZWwgdXBkYXRlKSwgdGhlIHN5c3RlbSBtYXkgb3IgbWF5IG5vdCB0cnkgdG8gZXZlbnR1YWxseSBldmljdCB0aGUgcG9kIGZyb20gaXRzIG5vZGUuIFdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGVsZW1lbnRzLCB0aGUgbGlzdHMgb2Ygbm9kZXMgY29ycmVzcG9uZGluZyB0byBlYWNoIHBvZEFmZmluaXR5VGVybSBhcmUgaW50ZXJzZWN0ZWQsIGkuZS4gYWxsIHRlcm1zIG11c3QgYmUgc2F0aXNmaWVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RBbnRpQWZmaW5pdHkjcmVxdWlyZWREdXJpbmdTY2hlZHVsaW5nSWdub3JlZER1cmluZ0V4ZWN1dGlvblxuICAgKi9cbiAgcmVhZG9ubHkgcmVxdWlyZWREdXJpbmdTY2hlZHVsaW5nSWdub3JlZER1cmluZ0V4ZWN1dGlvbj86IFBvZEFmZmluaXR5VGVybVtdO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1BvZEFudGlBZmZpbml0eScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fUG9kQW50aUFmZmluaXR5KG9iajogUG9kQW50aUFmZmluaXR5IHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAncHJlZmVycmVkRHVyaW5nU2NoZWR1bGluZ0lnbm9yZWREdXJpbmdFeGVjdXRpb24nOiBvYmoucHJlZmVycmVkRHVyaW5nU2NoZWR1bGluZ0lnbm9yZWREdXJpbmdFeGVjdXRpb24/Lm1hcCh5ID0+IHRvSnNvbl9XZWlnaHRlZFBvZEFmZmluaXR5VGVybSh5KSksXG4gICAgJ3JlcXVpcmVkRHVyaW5nU2NoZWR1bGluZ0lnbm9yZWREdXJpbmdFeGVjdXRpb24nOiBvYmoucmVxdWlyZWREdXJpbmdTY2hlZHVsaW5nSWdub3JlZER1cmluZ0V4ZWN1dGlvbj8ubWFwKHkgPT4gdG9Kc29uX1BvZEFmZmluaXR5VGVybSh5KSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogRW52VmFyIHJlcHJlc2VudHMgYW4gZW52aXJvbm1lbnQgdmFyaWFibGUgcHJlc2VudCBpbiBhIENvbnRhaW5lci5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FbnZWYXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFbnZWYXIge1xuICAvKipcbiAgICogTmFtZSBvZiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUuIE11c3QgYmUgYSBDX0lERU5USUZJRVIuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkVudlZhciNuYW1lXG4gICAqL1xuICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFZhcmlhYmxlIHJlZmVyZW5jZXMgJChWQVJfTkFNRSkgYXJlIGV4cGFuZGVkIHVzaW5nIHRoZSBwcmV2aW91c2x5IGRlZmluZWQgZW52aXJvbm1lbnQgdmFyaWFibGVzIGluIHRoZSBjb250YWluZXIgYW5kIGFueSBzZXJ2aWNlIGVudmlyb25tZW50IHZhcmlhYmxlcy4gSWYgYSB2YXJpYWJsZSBjYW5ub3QgYmUgcmVzb2x2ZWQsIHRoZSByZWZlcmVuY2UgaW4gdGhlIGlucHV0IHN0cmluZyB3aWxsIGJlIHVuY2hhbmdlZC4gRG91YmxlICQkIGFyZSByZWR1Y2VkIHRvIGEgc2luZ2xlICQsIHdoaWNoIGFsbG93cyBmb3IgZXNjYXBpbmcgdGhlICQoVkFSX05BTUUpIHN5bnRheDogaS5lLiBcIiQkKFZBUl9OQU1FKVwiIHdpbGwgcHJvZHVjZSB0aGUgc3RyaW5nIGxpdGVyYWwgXCIkKFZBUl9OQU1FKVwiLiBFc2NhcGVkIHJlZmVyZW5jZXMgd2lsbCBuZXZlciBiZSBleHBhbmRlZCwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSB2YXJpYWJsZSBleGlzdHMgb3Igbm90LiBEZWZhdWx0cyB0byBcIlwiLlxuICAgKlxuICAgKiBAZGVmYXVsdCAuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkVudlZhciN2YWx1ZVxuICAgKi9cbiAgcmVhZG9ubHkgdmFsdWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNvdXJjZSBmb3IgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlJ3MgdmFsdWUuIENhbm5vdCBiZSB1c2VkIGlmIHZhbHVlIGlzIG5vdCBlbXB0eS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRW52VmFyI3ZhbHVlRnJvbVxuICAgKi9cbiAgcmVhZG9ubHkgdmFsdWVGcm9tPzogRW52VmFyU291cmNlO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0VudlZhcicgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fRW52VmFyKG9iajogRW52VmFyIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbmFtZSc6IG9iai5uYW1lLFxuICAgICd2YWx1ZSc6IG9iai52YWx1ZSxcbiAgICAndmFsdWVGcm9tJzogdG9Kc29uX0VudlZhclNvdXJjZShvYmoudmFsdWVGcm9tKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBFbnZGcm9tU291cmNlIHJlcHJlc2VudHMgdGhlIHNvdXJjZSBvZiBhIHNldCBvZiBDb25maWdNYXBzXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRW52RnJvbVNvdXJjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVudkZyb21Tb3VyY2Uge1xuICAvKipcbiAgICogVGhlIENvbmZpZ01hcCB0byBzZWxlY3QgZnJvbVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FbnZGcm9tU291cmNlI2NvbmZpZ01hcFJlZlxuICAgKi9cbiAgcmVhZG9ubHkgY29uZmlnTWFwUmVmPzogQ29uZmlnTWFwRW52U291cmNlO1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBpZGVudGlmaWVyIHRvIHByZXBlbmQgdG8gZWFjaCBrZXkgaW4gdGhlIENvbmZpZ01hcC4gTXVzdCBiZSBhIENfSURFTlRJRklFUi5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRW52RnJvbVNvdXJjZSNwcmVmaXhcbiAgICovXG4gIHJlYWRvbmx5IHByZWZpeD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFNlY3JldCB0byBzZWxlY3QgZnJvbVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FbnZGcm9tU291cmNlI3NlY3JldFJlZlxuICAgKi9cbiAgcmVhZG9ubHkgc2VjcmV0UmVmPzogU2VjcmV0RW52U291cmNlO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0VudkZyb21Tb3VyY2UnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0VudkZyb21Tb3VyY2Uob2JqOiBFbnZGcm9tU291cmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnY29uZmlnTWFwUmVmJzogdG9Kc29uX0NvbmZpZ01hcEVudlNvdXJjZShvYmouY29uZmlnTWFwUmVmKSxcbiAgICAncHJlZml4Jzogb2JqLnByZWZpeCxcbiAgICAnc2VjcmV0UmVmJzogdG9Kc29uX1NlY3JldEVudlNvdXJjZShvYmouc2VjcmV0UmVmKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBMaWZlY3ljbGUgZGVzY3JpYmVzIGFjdGlvbnMgdGhhdCB0aGUgbWFuYWdlbWVudCBzeXN0ZW0gc2hvdWxkIHRha2UgaW4gcmVzcG9uc2UgdG8gY29udGFpbmVyIGxpZmVjeWNsZSBldmVudHMuIEZvciB0aGUgUG9zdFN0YXJ0IGFuZCBQcmVTdG9wIGxpZmVjeWNsZSBoYW5kbGVycywgbWFuYWdlbWVudCBvZiB0aGUgY29udGFpbmVyIGJsb2NrcyB1bnRpbCB0aGUgYWN0aW9uIGlzIGNvbXBsZXRlLCB1bmxlc3MgdGhlIGNvbnRhaW5lciBwcm9jZXNzIGZhaWxzLCBpbiB3aGljaCBjYXNlIHRoZSBoYW5kbGVyIGlzIGFib3J0ZWQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTGlmZWN5Y2xlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGlmZWN5Y2xlIHtcbiAgLyoqXG4gICAqIFBvc3RTdGFydCBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYSBjb250YWluZXIgaXMgY3JlYXRlZC4gSWYgdGhlIGhhbmRsZXIgZmFpbHMsIHRoZSBjb250YWluZXIgaXMgdGVybWluYXRlZCBhbmQgcmVzdGFydGVkIGFjY29yZGluZyB0byBpdHMgcmVzdGFydCBwb2xpY3kuIE90aGVyIG1hbmFnZW1lbnQgb2YgdGhlIGNvbnRhaW5lciBibG9ja3MgdW50aWwgdGhlIGhvb2sgY29tcGxldGVzLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL2NvbnRhaW5lcnMvY29udGFpbmVyLWxpZmVjeWNsZS1ob29rcy8jY29udGFpbmVyLWhvb2tzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkxpZmVjeWNsZSNwb3N0U3RhcnRcbiAgICovXG4gIHJlYWRvbmx5IHBvc3RTdGFydD86IEhhbmRsZXI7XG5cbiAgLyoqXG4gICAqIFByZVN0b3AgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGJlZm9yZSBhIGNvbnRhaW5lciBpcyB0ZXJtaW5hdGVkIGR1ZSB0byBhbiBBUEkgcmVxdWVzdCBvciBtYW5hZ2VtZW50IGV2ZW50IHN1Y2ggYXMgbGl2ZW5lc3Mvc3RhcnR1cCBwcm9iZSBmYWlsdXJlLCBwcmVlbXB0aW9uLCByZXNvdXJjZSBjb250ZW50aW9uLCBldGMuIFRoZSBoYW5kbGVyIGlzIG5vdCBjYWxsZWQgaWYgdGhlIGNvbnRhaW5lciBjcmFzaGVzIG9yIGV4aXRzLiBUaGUgcmVhc29uIGZvciB0ZXJtaW5hdGlvbiBpcyBwYXNzZWQgdG8gdGhlIGhhbmRsZXIuIFRoZSBQb2QncyB0ZXJtaW5hdGlvbiBncmFjZSBwZXJpb2QgY291bnRkb3duIGJlZ2lucyBiZWZvcmUgdGhlIFByZVN0b3AgaG9va2VkIGlzIGV4ZWN1dGVkLiBSZWdhcmRsZXNzIG9mIHRoZSBvdXRjb21lIG9mIHRoZSBoYW5kbGVyLCB0aGUgY29udGFpbmVyIHdpbGwgZXZlbnR1YWxseSB0ZXJtaW5hdGUgd2l0aGluIHRoZSBQb2QncyB0ZXJtaW5hdGlvbiBncmFjZSBwZXJpb2QuIE90aGVyIG1hbmFnZW1lbnQgb2YgdGhlIGNvbnRhaW5lciBibG9ja3MgdW50aWwgdGhlIGhvb2sgY29tcGxldGVzIG9yIHVudGlsIHRoZSB0ZXJtaW5hdGlvbiBncmFjZSBwZXJpb2QgaXMgcmVhY2hlZC4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9jb250YWluZXJzL2NvbnRhaW5lci1saWZlY3ljbGUtaG9va3MvI2NvbnRhaW5lci1ob29rc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5MaWZlY3ljbGUjcHJlU3RvcFxuICAgKi9cbiAgcmVhZG9ubHkgcHJlU3RvcD86IEhhbmRsZXI7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnTGlmZWN5Y2xlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9MaWZlY3ljbGUob2JqOiBMaWZlY3ljbGUgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdwb3N0U3RhcnQnOiB0b0pzb25fSGFuZGxlcihvYmoucG9zdFN0YXJ0KSxcbiAgICAncHJlU3RvcCc6IHRvSnNvbl9IYW5kbGVyKG9iai5wcmVTdG9wKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBQcm9iZSBkZXNjcmliZXMgYSBoZWFsdGggY2hlY2sgdG8gYmUgcGVyZm9ybWVkIGFnYWluc3QgYSBjb250YWluZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgaXQgaXMgYWxpdmUgb3IgcmVhZHkgdG8gcmVjZWl2ZSB0cmFmZmljLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlByb2JlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJvYmUge1xuICAvKipcbiAgICogT25lIGFuZCBvbmx5IG9uZSBvZiB0aGUgZm9sbG93aW5nIHNob3VsZCBiZSBzcGVjaWZpZWQuIEV4ZWMgc3BlY2lmaWVzIHRoZSBhY3Rpb24gdG8gdGFrZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUHJvYmUjZXhlY1xuICAgKi9cbiAgcmVhZG9ubHkgZXhlYz86IEV4ZWNBY3Rpb247XG5cbiAgLyoqXG4gICAqIE1pbmltdW0gY29uc2VjdXRpdmUgZmFpbHVyZXMgZm9yIHRoZSBwcm9iZSB0byBiZSBjb25zaWRlcmVkIGZhaWxlZCBhZnRlciBoYXZpbmcgc3VjY2VlZGVkLiBEZWZhdWx0cyB0byAzLiBNaW5pbXVtIHZhbHVlIGlzIDEuXG4gICAqXG4gICAqIEBkZWZhdWx0IDMuIE1pbmltdW0gdmFsdWUgaXMgMS5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUHJvYmUjZmFpbHVyZVRocmVzaG9sZFxuICAgKi9cbiAgcmVhZG9ubHkgZmFpbHVyZVRocmVzaG9sZD86IG51bWJlcjtcblxuICAvKipcbiAgICogSFRUUEdldCBzcGVjaWZpZXMgdGhlIGh0dHAgcmVxdWVzdCB0byBwZXJmb3JtLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qcm9iZSNodHRwR2V0XG4gICAqL1xuICByZWFkb25seSBodHRwR2V0PzogSHR0cEdldEFjdGlvbjtcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHNlY29uZHMgYWZ0ZXIgdGhlIGNvbnRhaW5lciBoYXMgc3RhcnRlZCBiZWZvcmUgbGl2ZW5lc3MgcHJvYmVzIGFyZSBpbml0aWF0ZWQuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL3BvZHMvcG9kLWxpZmVjeWNsZSNjb250YWluZXItcHJvYmVzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlByb2JlI2luaXRpYWxEZWxheVNlY29uZHNcbiAgICovXG4gIHJlYWRvbmx5IGluaXRpYWxEZWxheVNlY29uZHM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEhvdyBvZnRlbiAoaW4gc2Vjb25kcykgdG8gcGVyZm9ybSB0aGUgcHJvYmUuIERlZmF1bHQgdG8gMTAgc2Vjb25kcy4gTWluaW11bSB2YWx1ZSBpcyAxLlxuICAgKlxuICAgKiBAZGVmYXVsdCAxMCBzZWNvbmRzLiBNaW5pbXVtIHZhbHVlIGlzIDEuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlByb2JlI3BlcmlvZFNlY29uZHNcbiAgICovXG4gIHJlYWRvbmx5IHBlcmlvZFNlY29uZHM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE1pbmltdW0gY29uc2VjdXRpdmUgc3VjY2Vzc2VzIGZvciB0aGUgcHJvYmUgdG8gYmUgY29uc2lkZXJlZCBzdWNjZXNzZnVsIGFmdGVyIGhhdmluZyBmYWlsZWQuIERlZmF1bHRzIHRvIDEuIE11c3QgYmUgMSBmb3IgbGl2ZW5lc3MgYW5kIHN0YXJ0dXAuIE1pbmltdW0gdmFsdWUgaXMgMS5cbiAgICpcbiAgICogQGRlZmF1bHQgMS4gTXVzdCBiZSAxIGZvciBsaXZlbmVzcyBhbmQgc3RhcnR1cC4gTWluaW11bSB2YWx1ZSBpcyAxLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qcm9iZSNzdWNjZXNzVGhyZXNob2xkXG4gICAqL1xuICByZWFkb25seSBzdWNjZXNzVGhyZXNob2xkPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUQ1BTb2NrZXQgc3BlY2lmaWVzIGFuIGFjdGlvbiBpbnZvbHZpbmcgYSBUQ1AgcG9ydC4gVENQIGhvb2tzIG5vdCB5ZXQgc3VwcG9ydGVkXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlByb2JlI3RjcFNvY2tldFxuICAgKi9cbiAgcmVhZG9ubHkgdGNwU29ja2V0PzogVGNwU29ja2V0QWN0aW9uO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBkdXJhdGlvbiBpbiBzZWNvbmRzIHRoZSBwb2QgbmVlZHMgdG8gdGVybWluYXRlIGdyYWNlZnVsbHkgdXBvbiBwcm9iZSBmYWlsdXJlLiBUaGUgZ3JhY2UgcGVyaW9kIGlzIHRoZSBkdXJhdGlvbiBpbiBzZWNvbmRzIGFmdGVyIHRoZSBwcm9jZXNzZXMgcnVubmluZyBpbiB0aGUgcG9kIGFyZSBzZW50IGEgdGVybWluYXRpb24gc2lnbmFsIGFuZCB0aGUgdGltZSB3aGVuIHRoZSBwcm9jZXNzZXMgYXJlIGZvcmNpYmx5IGhhbHRlZCB3aXRoIGEga2lsbCBzaWduYWwuIFNldCB0aGlzIHZhbHVlIGxvbmdlciB0aGFuIHRoZSBleHBlY3RlZCBjbGVhbnVwIHRpbWUgZm9yIHlvdXIgcHJvY2Vzcy4gSWYgdGhpcyB2YWx1ZSBpcyBuaWwsIHRoZSBwb2QncyB0ZXJtaW5hdGlvbkdyYWNlUGVyaW9kU2Vjb25kcyB3aWxsIGJlIHVzZWQuIE90aGVyd2lzZSwgdGhpcyB2YWx1ZSBvdmVycmlkZXMgdGhlIHZhbHVlIHByb3ZpZGVkIGJ5IHRoZSBwb2Qgc3BlYy4gVmFsdWUgbXVzdCBiZSBub24tbmVnYXRpdmUgaW50ZWdlci4gVGhlIHZhbHVlIHplcm8gaW5kaWNhdGVzIHN0b3AgaW1tZWRpYXRlbHkgdmlhIHRoZSBraWxsIHNpZ25hbCAobm8gb3Bwb3J0dW5pdHkgdG8gc2h1dCBkb3duKS4gVGhpcyBpcyBhIGJldGEgZmllbGQgYW5kIHJlcXVpcmVzIGVuYWJsaW5nIFByb2JlVGVybWluYXRpb25HcmFjZVBlcmlvZCBmZWF0dXJlIGdhdGUuIE1pbmltdW0gdmFsdWUgaXMgMS4gc3BlYy50ZXJtaW5hdGlvbkdyYWNlUGVyaW9kU2Vjb25kcyBpcyB1c2VkIGlmIHVuc2V0LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qcm9iZSN0ZXJtaW5hdGlvbkdyYWNlUGVyaW9kU2Vjb25kc1xuICAgKi9cbiAgcmVhZG9ubHkgdGVybWluYXRpb25HcmFjZVBlcmlvZFNlY29uZHM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBzZWNvbmRzIGFmdGVyIHdoaWNoIHRoZSBwcm9iZSB0aW1lcyBvdXQuIERlZmF1bHRzIHRvIDEgc2Vjb25kLiBNaW5pbXVtIHZhbHVlIGlzIDEuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL3BvZHMvcG9kLWxpZmVjeWNsZSNjb250YWluZXItcHJvYmVzXG4gICAqXG4gICAqIEBkZWZhdWx0IDEgc2Vjb25kLiBNaW5pbXVtIHZhbHVlIGlzIDEuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL3BvZHMvcG9kLWxpZmVjeWNsZSNjb250YWluZXItcHJvYmVzXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlByb2JlI3RpbWVvdXRTZWNvbmRzXG4gICAqL1xuICByZWFkb25seSB0aW1lb3V0U2Vjb25kcz86IG51bWJlcjtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdQcm9iZScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fUHJvYmUob2JqOiBQcm9iZSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2V4ZWMnOiB0b0pzb25fRXhlY0FjdGlvbihvYmouZXhlYyksXG4gICAgJ2ZhaWx1cmVUaHJlc2hvbGQnOiBvYmouZmFpbHVyZVRocmVzaG9sZCxcbiAgICAnaHR0cEdldCc6IHRvSnNvbl9IdHRwR2V0QWN0aW9uKG9iai5odHRwR2V0KSxcbiAgICAnaW5pdGlhbERlbGF5U2Vjb25kcyc6IG9iai5pbml0aWFsRGVsYXlTZWNvbmRzLFxuICAgICdwZXJpb2RTZWNvbmRzJzogb2JqLnBlcmlvZFNlY29uZHMsXG4gICAgJ3N1Y2Nlc3NUaHJlc2hvbGQnOiBvYmouc3VjY2Vzc1RocmVzaG9sZCxcbiAgICAndGNwU29ja2V0JzogdG9Kc29uX1RjcFNvY2tldEFjdGlvbihvYmoudGNwU29ja2V0KSxcbiAgICAndGVybWluYXRpb25HcmFjZVBlcmlvZFNlY29uZHMnOiBvYmoudGVybWluYXRpb25HcmFjZVBlcmlvZFNlY29uZHMsXG4gICAgJ3RpbWVvdXRTZWNvbmRzJzogb2JqLnRpbWVvdXRTZWNvbmRzLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIENvbnRhaW5lclBvcnQgcmVwcmVzZW50cyBhIG5ldHdvcmsgcG9ydCBpbiBhIHNpbmdsZSBjb250YWluZXIuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ29udGFpbmVyUG9ydFxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbnRhaW5lclBvcnQge1xuICAvKipcbiAgICogTnVtYmVyIG9mIHBvcnQgdG8gZXhwb3NlIG9uIHRoZSBwb2QncyBJUCBhZGRyZXNzLiBUaGlzIG11c3QgYmUgYSB2YWxpZCBwb3J0IG51bWJlciwgMCA8IHggPCA2NTUzNi5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ29udGFpbmVyUG9ydCNjb250YWluZXJQb3J0XG4gICAqL1xuICByZWFkb25seSBjb250YWluZXJQb3J0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFdoYXQgaG9zdCBJUCB0byBiaW5kIHRoZSBleHRlcm5hbCBwb3J0IHRvLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db250YWluZXJQb3J0I2hvc3RJUFxuICAgKi9cbiAgcmVhZG9ubHkgaG9zdElwPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgcG9ydCB0byBleHBvc2Ugb24gdGhlIGhvc3QuIElmIHNwZWNpZmllZCwgdGhpcyBtdXN0IGJlIGEgdmFsaWQgcG9ydCBudW1iZXIsIDAgPCB4IDwgNjU1MzYuIElmIEhvc3ROZXR3b3JrIGlzIHNwZWNpZmllZCwgdGhpcyBtdXN0IG1hdGNoIENvbnRhaW5lclBvcnQuIE1vc3QgY29udGFpbmVycyBkbyBub3QgbmVlZCB0aGlzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db250YWluZXJQb3J0I2hvc3RQb3J0XG4gICAqL1xuICByZWFkb25seSBob3N0UG9ydD86IG51bWJlcjtcblxuICAvKipcbiAgICogSWYgc3BlY2lmaWVkLCB0aGlzIG11c3QgYmUgYW4gSUFOQV9TVkNfTkFNRSBhbmQgdW5pcXVlIHdpdGhpbiB0aGUgcG9kLiBFYWNoIG5hbWVkIHBvcnQgaW4gYSBwb2QgbXVzdCBoYXZlIGEgdW5pcXVlIG5hbWUuIE5hbWUgZm9yIHRoZSBwb3J0IHRoYXQgY2FuIGJlIHJlZmVycmVkIHRvIGJ5IHNlcnZpY2VzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db250YWluZXJQb3J0I25hbWVcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFByb3RvY29sIGZvciBwb3J0LiBNdXN0IGJlIFVEUCwgVENQLCBvciBTQ1RQLiBEZWZhdWx0cyB0byBcIlRDUFwiLlxuICAgKlxuICAgKiBAZGVmYXVsdCBUQ1BcIi5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ29udGFpbmVyUG9ydCNwcm90b2NvbFxuICAgKi9cbiAgcmVhZG9ubHkgcHJvdG9jb2w/OiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnQ29udGFpbmVyUG9ydCcgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fQ29udGFpbmVyUG9ydChvYmo6IENvbnRhaW5lclBvcnQgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdjb250YWluZXJQb3J0Jzogb2JqLmNvbnRhaW5lclBvcnQsXG4gICAgJ2hvc3RJUCc6IG9iai5ob3N0SXAsXG4gICAgJ2hvc3RQb3J0Jzogb2JqLmhvc3RQb3J0LFxuICAgICduYW1lJzogb2JqLm5hbWUsXG4gICAgJ3Byb3RvY29sJzogb2JqLnByb3RvY29sLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFNlY3VyaXR5Q29udGV4dCBob2xkcyBzZWN1cml0eSBjb25maWd1cmF0aW9uIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGEgY29udGFpbmVyLiBTb21lIGZpZWxkcyBhcmUgcHJlc2VudCBpbiBib3RoIFNlY3VyaXR5Q29udGV4dCBhbmQgUG9kU2VjdXJpdHlDb250ZXh0LiAgV2hlbiBib3RoIGFyZSBzZXQsIHRoZSB2YWx1ZXMgaW4gU2VjdXJpdHlDb250ZXh0IHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZWN1cml0eUNvbnRleHRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZWN1cml0eUNvbnRleHQge1xuICAvKipcbiAgICogQWxsb3dQcml2aWxlZ2VFc2NhbGF0aW9uIGNvbnRyb2xzIHdoZXRoZXIgYSBwcm9jZXNzIGNhbiBnYWluIG1vcmUgcHJpdmlsZWdlcyB0aGFuIGl0cyBwYXJlbnQgcHJvY2Vzcy4gVGhpcyBib29sIGRpcmVjdGx5IGNvbnRyb2xzIGlmIHRoZSBub19uZXdfcHJpdnMgZmxhZyB3aWxsIGJlIHNldCBvbiB0aGUgY29udGFpbmVyIHByb2Nlc3MuIEFsbG93UHJpdmlsZWdlRXNjYWxhdGlvbiBpcyB0cnVlIGFsd2F5cyB3aGVuIHRoZSBjb250YWluZXIgaXM6IDEpIHJ1biBhcyBQcml2aWxlZ2VkIDIpIGhhcyBDQVBfU1lTX0FETUlOXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlY3VyaXR5Q29udGV4dCNhbGxvd1ByaXZpbGVnZUVzY2FsYXRpb25cbiAgICovXG4gIHJlYWRvbmx5IGFsbG93UHJpdmlsZWdlRXNjYWxhdGlvbj86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSBjYXBhYmlsaXRpZXMgdG8gYWRkL2Ryb3Agd2hlbiBydW5uaW5nIGNvbnRhaW5lcnMuIERlZmF1bHRzIHRvIHRoZSBkZWZhdWx0IHNldCBvZiBjYXBhYmlsaXRpZXMgZ3JhbnRlZCBieSB0aGUgY29udGFpbmVyIHJ1bnRpbWUuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRoZSBkZWZhdWx0IHNldCBvZiBjYXBhYmlsaXRpZXMgZ3JhbnRlZCBieSB0aGUgY29udGFpbmVyIHJ1bnRpbWUuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlY3VyaXR5Q29udGV4dCNjYXBhYmlsaXRpZXNcbiAgICovXG4gIHJlYWRvbmx5IGNhcGFiaWxpdGllcz86IENhcGFiaWxpdGllcztcblxuICAvKipcbiAgICogUnVuIGNvbnRhaW5lciBpbiBwcml2aWxlZ2VkIG1vZGUuIFByb2Nlc3NlcyBpbiBwcml2aWxlZ2VkIGNvbnRhaW5lcnMgYXJlIGVzc2VudGlhbGx5IGVxdWl2YWxlbnQgdG8gcm9vdCBvbiB0aGUgaG9zdC4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZWN1cml0eUNvbnRleHQjcHJpdmlsZWdlZFxuICAgKi9cbiAgcmVhZG9ubHkgcHJpdmlsZWdlZD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHByb2NNb3VudCBkZW5vdGVzIHRoZSB0eXBlIG9mIHByb2MgbW91bnQgdG8gdXNlIGZvciB0aGUgY29udGFpbmVycy4gVGhlIGRlZmF1bHQgaXMgRGVmYXVsdFByb2NNb3VudCB3aGljaCB1c2VzIHRoZSBjb250YWluZXIgcnVudGltZSBkZWZhdWx0cyBmb3IgcmVhZG9ubHkgcGF0aHMgYW5kIG1hc2tlZCBwYXRocy4gVGhpcyByZXF1aXJlcyB0aGUgUHJvY01vdW50VHlwZSBmZWF0dXJlIGZsYWcgdG8gYmUgZW5hYmxlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VjdXJpdHlDb250ZXh0I3Byb2NNb3VudFxuICAgKi9cbiAgcmVhZG9ubHkgcHJvY01vdW50Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgY29udGFpbmVyIGhhcyBhIHJlYWQtb25seSByb290IGZpbGVzeXN0ZW0uIERlZmF1bHQgaXMgZmFsc2UuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZWN1cml0eUNvbnRleHQjcmVhZE9ubHlSb290RmlsZXN5c3RlbVxuICAgKi9cbiAgcmVhZG9ubHkgcmVhZE9ubHlSb290RmlsZXN5c3RlbT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSBHSUQgdG8gcnVuIHRoZSBlbnRyeXBvaW50IG9mIHRoZSBjb250YWluZXIgcHJvY2Vzcy4gVXNlcyBydW50aW1lIGRlZmF1bHQgaWYgdW5zZXQuIE1heSBhbHNvIGJlIHNldCBpbiBQb2RTZWN1cml0eUNvbnRleHQuICBJZiBzZXQgaW4gYm90aCBTZWN1cml0eUNvbnRleHQgYW5kIFBvZFNlY3VyaXR5Q29udGV4dCwgdGhlIHZhbHVlIHNwZWNpZmllZCBpbiBTZWN1cml0eUNvbnRleHQgdGFrZXMgcHJlY2VkZW5jZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VjdXJpdHlDb250ZXh0I3J1bkFzR3JvdXBcbiAgICovXG4gIHJlYWRvbmx5IHJ1bkFzR3JvdXA/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGF0IHRoZSBjb250YWluZXIgbXVzdCBydW4gYXMgYSBub24tcm9vdCB1c2VyLiBJZiB0cnVlLCB0aGUgS3ViZWxldCB3aWxsIHZhbGlkYXRlIHRoZSBpbWFnZSBhdCBydW50aW1lIHRvIGVuc3VyZSB0aGF0IGl0IGRvZXMgbm90IHJ1biBhcyBVSUQgMCAocm9vdCkgYW5kIGZhaWwgdG8gc3RhcnQgdGhlIGNvbnRhaW5lciBpZiBpdCBkb2VzLiBJZiB1bnNldCBvciBmYWxzZSwgbm8gc3VjaCB2YWxpZGF0aW9uIHdpbGwgYmUgcGVyZm9ybWVkLiBNYXkgYWxzbyBiZSBzZXQgaW4gUG9kU2VjdXJpdHlDb250ZXh0LiAgSWYgc2V0IGluIGJvdGggU2VjdXJpdHlDb250ZXh0IGFuZCBQb2RTZWN1cml0eUNvbnRleHQsIHRoZSB2YWx1ZSBzcGVjaWZpZWQgaW4gU2VjdXJpdHlDb250ZXh0IHRha2VzIHByZWNlZGVuY2UuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlY3VyaXR5Q29udGV4dCNydW5Bc05vblJvb3RcbiAgICovXG4gIHJlYWRvbmx5IHJ1bkFzTm9uUm9vdD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSBVSUQgdG8gcnVuIHRoZSBlbnRyeXBvaW50IG9mIHRoZSBjb250YWluZXIgcHJvY2Vzcy4gRGVmYXVsdHMgdG8gdXNlciBzcGVjaWZpZWQgaW4gaW1hZ2UgbWV0YWRhdGEgaWYgdW5zcGVjaWZpZWQuIE1heSBhbHNvIGJlIHNldCBpbiBQb2RTZWN1cml0eUNvbnRleHQuICBJZiBzZXQgaW4gYm90aCBTZWN1cml0eUNvbnRleHQgYW5kIFBvZFNlY3VyaXR5Q29udGV4dCwgdGhlIHZhbHVlIHNwZWNpZmllZCBpbiBTZWN1cml0eUNvbnRleHQgdGFrZXMgcHJlY2VkZW5jZS5cbiAgICpcbiAgICogQGRlZmF1bHQgdXNlciBzcGVjaWZpZWQgaW4gaW1hZ2UgbWV0YWRhdGEgaWYgdW5zcGVjaWZpZWQuIE1heSBhbHNvIGJlIHNldCBpbiBQb2RTZWN1cml0eUNvbnRleHQuICBJZiBzZXQgaW4gYm90aCBTZWN1cml0eUNvbnRleHQgYW5kIFBvZFNlY3VyaXR5Q29udGV4dCwgdGhlIHZhbHVlIHNwZWNpZmllZCBpbiBTZWN1cml0eUNvbnRleHQgdGFrZXMgcHJlY2VkZW5jZS5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VjdXJpdHlDb250ZXh0I3J1bkFzVXNlclxuICAgKi9cbiAgcmVhZG9ubHkgcnVuQXNVc2VyPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgU0VMaW51eCBjb250ZXh0IHRvIGJlIGFwcGxpZWQgdG8gdGhlIGNvbnRhaW5lci4gSWYgdW5zcGVjaWZpZWQsIHRoZSBjb250YWluZXIgcnVudGltZSB3aWxsIGFsbG9jYXRlIGEgcmFuZG9tIFNFTGludXggY29udGV4dCBmb3IgZWFjaCBjb250YWluZXIuICBNYXkgYWxzbyBiZSBzZXQgaW4gUG9kU2VjdXJpdHlDb250ZXh0LiAgSWYgc2V0IGluIGJvdGggU2VjdXJpdHlDb250ZXh0IGFuZCBQb2RTZWN1cml0eUNvbnRleHQsIHRoZSB2YWx1ZSBzcGVjaWZpZWQgaW4gU2VjdXJpdHlDb250ZXh0IHRha2VzIHByZWNlZGVuY2UuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlY3VyaXR5Q29udGV4dCNzZUxpbnV4T3B0aW9uc1xuICAgKi9cbiAgcmVhZG9ubHkgc2VMaW51eE9wdGlvbnM/OiBTZUxpbnV4T3B0aW9ucztcblxuICAvKipcbiAgICogVGhlIHNlY2NvbXAgb3B0aW9ucyB0byB1c2UgYnkgdGhpcyBjb250YWluZXIuIElmIHNlY2NvbXAgb3B0aW9ucyBhcmUgcHJvdmlkZWQgYXQgYm90aCB0aGUgcG9kICYgY29udGFpbmVyIGxldmVsLCB0aGUgY29udGFpbmVyIG9wdGlvbnMgb3ZlcnJpZGUgdGhlIHBvZCBvcHRpb25zLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZWN1cml0eUNvbnRleHQjc2VjY29tcFByb2ZpbGVcbiAgICovXG4gIHJlYWRvbmx5IHNlY2NvbXBQcm9maWxlPzogU2VjY29tcFByb2ZpbGU7XG5cbiAgLyoqXG4gICAqIFRoZSBXaW5kb3dzIHNwZWNpZmljIHNldHRpbmdzIGFwcGxpZWQgdG8gYWxsIGNvbnRhaW5lcnMuIElmIHVuc3BlY2lmaWVkLCB0aGUgb3B0aW9ucyBmcm9tIHRoZSBQb2RTZWN1cml0eUNvbnRleHQgd2lsbCBiZSB1c2VkLiBJZiBzZXQgaW4gYm90aCBTZWN1cml0eUNvbnRleHQgYW5kIFBvZFNlY3VyaXR5Q29udGV4dCwgdGhlIHZhbHVlIHNwZWNpZmllZCBpbiBTZWN1cml0eUNvbnRleHQgdGFrZXMgcHJlY2VkZW5jZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VjdXJpdHlDb250ZXh0I3dpbmRvd3NPcHRpb25zXG4gICAqL1xuICByZWFkb25seSB3aW5kb3dzT3B0aW9ucz86IFdpbmRvd3NTZWN1cml0eUNvbnRleHRPcHRpb25zO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1NlY3VyaXR5Q29udGV4dCcgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fU2VjdXJpdHlDb250ZXh0KG9iajogU2VjdXJpdHlDb250ZXh0IHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnYWxsb3dQcml2aWxlZ2VFc2NhbGF0aW9uJzogb2JqLmFsbG93UHJpdmlsZWdlRXNjYWxhdGlvbixcbiAgICAnY2FwYWJpbGl0aWVzJzogdG9Kc29uX0NhcGFiaWxpdGllcyhvYmouY2FwYWJpbGl0aWVzKSxcbiAgICAncHJpdmlsZWdlZCc6IG9iai5wcml2aWxlZ2VkLFxuICAgICdwcm9jTW91bnQnOiBvYmoucHJvY01vdW50LFxuICAgICdyZWFkT25seVJvb3RGaWxlc3lzdGVtJzogb2JqLnJlYWRPbmx5Um9vdEZpbGVzeXN0ZW0sXG4gICAgJ3J1bkFzR3JvdXAnOiBvYmoucnVuQXNHcm91cCxcbiAgICAncnVuQXNOb25Sb290Jzogb2JqLnJ1bkFzTm9uUm9vdCxcbiAgICAncnVuQXNVc2VyJzogb2JqLnJ1bkFzVXNlcixcbiAgICAnc2VMaW51eE9wdGlvbnMnOiB0b0pzb25fU2VMaW51eE9wdGlvbnMob2JqLnNlTGludXhPcHRpb25zKSxcbiAgICAnc2VjY29tcFByb2ZpbGUnOiB0b0pzb25fU2VjY29tcFByb2ZpbGUob2JqLnNlY2NvbXBQcm9maWxlKSxcbiAgICAnd2luZG93c09wdGlvbnMnOiB0b0pzb25fV2luZG93c1NlY3VyaXR5Q29udGV4dE9wdGlvbnMob2JqLndpbmRvd3NPcHRpb25zKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiB2b2x1bWVEZXZpY2UgZGVzY3JpYmVzIGEgbWFwcGluZyBvZiBhIHJhdyBibG9jayBkZXZpY2Ugd2l0aGluIGEgY29udGFpbmVyLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlZvbHVtZURldmljZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZvbHVtZURldmljZSB7XG4gIC8qKlxuICAgKiBkZXZpY2VQYXRoIGlzIHRoZSBwYXRoIGluc2lkZSBvZiB0aGUgY29udGFpbmVyIHRoYXQgdGhlIGRldmljZSB3aWxsIGJlIG1hcHBlZCB0by5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVm9sdW1lRGV2aWNlI2RldmljZVBhdGhcbiAgICovXG4gIHJlYWRvbmx5IGRldmljZVBhdGg6IHN0cmluZztcblxuICAvKipcbiAgICogbmFtZSBtdXN0IG1hdGNoIHRoZSBuYW1lIG9mIGEgcGVyc2lzdGVudFZvbHVtZUNsYWltIGluIHRoZSBwb2RcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVm9sdW1lRGV2aWNlI25hbWVcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdWb2x1bWVEZXZpY2UnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1ZvbHVtZURldmljZShvYmo6IFZvbHVtZURldmljZSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2RldmljZVBhdGgnOiBvYmouZGV2aWNlUGF0aCxcbiAgICAnbmFtZSc6IG9iai5uYW1lLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFZvbHVtZU1vdW50IGRlc2NyaWJlcyBhIG1vdW50aW5nIG9mIGEgVm9sdW1lIHdpdGhpbiBhIGNvbnRhaW5lci5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Wb2x1bWVNb3VudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZvbHVtZU1vdW50IHtcbiAgLyoqXG4gICAqIFBhdGggd2l0aGluIHRoZSBjb250YWluZXIgYXQgd2hpY2ggdGhlIHZvbHVtZSBzaG91bGQgYmUgbW91bnRlZC4gIE11c3Qgbm90IGNvbnRhaW4gJzonLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Wb2x1bWVNb3VudCNtb3VudFBhdGhcbiAgICovXG4gIHJlYWRvbmx5IG1vdW50UGF0aDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBtb3VudFByb3BhZ2F0aW9uIGRldGVybWluZXMgaG93IG1vdW50cyBhcmUgcHJvcGFnYXRlZCBmcm9tIHRoZSBob3N0IHRvIGNvbnRhaW5lciBhbmQgdGhlIG90aGVyIHdheSBhcm91bmQuIFdoZW4gbm90IHNldCwgTW91bnRQcm9wYWdhdGlvbk5vbmUgaXMgdXNlZC4gVGhpcyBmaWVsZCBpcyBiZXRhIGluIDEuMTAuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlZvbHVtZU1vdW50I21vdW50UHJvcGFnYXRpb25cbiAgICovXG4gIHJlYWRvbmx5IG1vdW50UHJvcGFnYXRpb24/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoaXMgbXVzdCBtYXRjaCB0aGUgTmFtZSBvZiBhIFZvbHVtZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVm9sdW1lTW91bnQjbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBNb3VudGVkIHJlYWQtb25seSBpZiB0cnVlLCByZWFkLXdyaXRlIG90aGVyd2lzZSAoZmFsc2Ugb3IgdW5zcGVjaWZpZWQpLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2UuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlZvbHVtZU1vdW50I3JlYWRPbmx5XG4gICAqL1xuICByZWFkb25seSByZWFkT25seT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFBhdGggd2l0aGluIHRoZSB2b2x1bWUgZnJvbSB3aGljaCB0aGUgY29udGFpbmVyJ3Mgdm9sdW1lIHNob3VsZCBiZSBtb3VudGVkLiBEZWZhdWx0cyB0byBcIlwiICh2b2x1bWUncyByb290KS5cbiAgICpcbiAgICogQGRlZmF1bHQgdm9sdW1lJ3Mgcm9vdCkuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlZvbHVtZU1vdW50I3N1YlBhdGhcbiAgICovXG4gIHJlYWRvbmx5IHN1YlBhdGg/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEV4cGFuZGVkIHBhdGggd2l0aGluIHRoZSB2b2x1bWUgZnJvbSB3aGljaCB0aGUgY29udGFpbmVyJ3Mgdm9sdW1lIHNob3VsZCBiZSBtb3VudGVkLiBCZWhhdmVzIHNpbWlsYXJseSB0byBTdWJQYXRoIGJ1dCBlbnZpcm9ubWVudCB2YXJpYWJsZSByZWZlcmVuY2VzICQoVkFSX05BTUUpIGFyZSBleHBhbmRlZCB1c2luZyB0aGUgY29udGFpbmVyJ3MgZW52aXJvbm1lbnQuIERlZmF1bHRzIHRvIFwiXCIgKHZvbHVtZSdzIHJvb3QpLiBTdWJQYXRoRXhwciBhbmQgU3ViUGF0aCBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLlxuICAgKlxuICAgKiBAZGVmYXVsdCB2b2x1bWUncyByb290KS4gU3ViUGF0aEV4cHIgYW5kIFN1YlBhdGggYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZS5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVm9sdW1lTW91bnQjc3ViUGF0aEV4cHJcbiAgICovXG4gIHJlYWRvbmx5IHN1YlBhdGhFeHByPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1ZvbHVtZU1vdW50JyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Wb2x1bWVNb3VudChvYmo6IFZvbHVtZU1vdW50IHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbW91bnRQYXRoJzogb2JqLm1vdW50UGF0aCxcbiAgICAnbW91bnRQcm9wYWdhdGlvbic6IG9iai5tb3VudFByb3BhZ2F0aW9uLFxuICAgICduYW1lJzogb2JqLm5hbWUsXG4gICAgJ3JlYWRPbmx5Jzogb2JqLnJlYWRPbmx5LFxuICAgICdzdWJQYXRoJzogb2JqLnN1YlBhdGgsXG4gICAgJ3N1YlBhdGhFeHByJzogb2JqLnN1YlBhdGhFeHByLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFBvZEROU0NvbmZpZ09wdGlvbiBkZWZpbmVzIEROUyByZXNvbHZlciBvcHRpb25zIG9mIGEgcG9kLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZEROU0NvbmZpZ09wdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBvZERuc0NvbmZpZ09wdGlvbiB7XG4gIC8qKlxuICAgKiBSZXF1aXJlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUG9kRE5TQ29uZmlnT3B0aW9uI25hbWVcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZEROU0NvbmZpZ09wdGlvbiN2YWx1ZVxuICAgKi9cbiAgcmVhZG9ubHkgdmFsdWU/OiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnUG9kRG5zQ29uZmlnT3B0aW9uJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Qb2REbnNDb25maWdPcHRpb24ob2JqOiBQb2REbnNDb25maWdPcHRpb24gfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICduYW1lJzogb2JqLm5hbWUsXG4gICAgJ3ZhbHVlJzogb2JqLnZhbHVlLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFNFTGludXhPcHRpb25zIGFyZSB0aGUgbGFiZWxzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGNvbnRhaW5lclxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNFTGludXhPcHRpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VMaW51eE9wdGlvbnMge1xuICAvKipcbiAgICogTGV2ZWwgaXMgU0VMaW51eCBsZXZlbCBsYWJlbCB0aGF0IGFwcGxpZXMgdG8gdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU0VMaW51eE9wdGlvbnMjbGV2ZWxcbiAgICovXG4gIHJlYWRvbmx5IGxldmVsPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSb2xlIGlzIGEgU0VMaW51eCByb2xlIGxhYmVsIHRoYXQgYXBwbGllcyB0byB0aGUgY29udGFpbmVyLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TRUxpbnV4T3B0aW9ucyNyb2xlXG4gICAqL1xuICByZWFkb25seSByb2xlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUeXBlIGlzIGEgU0VMaW51eCB0eXBlIGxhYmVsIHRoYXQgYXBwbGllcyB0byB0aGUgY29udGFpbmVyLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TRUxpbnV4T3B0aW9ucyN0eXBlXG4gICAqL1xuICByZWFkb25seSB0eXBlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBVc2VyIGlzIGEgU0VMaW51eCB1c2VyIGxhYmVsIHRoYXQgYXBwbGllcyB0byB0aGUgY29udGFpbmVyLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TRUxpbnV4T3B0aW9ucyN1c2VyXG4gICAqL1xuICByZWFkb25seSB1c2VyPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1NlTGludXhPcHRpb25zJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9TZUxpbnV4T3B0aW9ucyhvYmo6IFNlTGludXhPcHRpb25zIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbGV2ZWwnOiBvYmoubGV2ZWwsXG4gICAgJ3JvbGUnOiBvYmoucm9sZSxcbiAgICAndHlwZSc6IG9iai50eXBlLFxuICAgICd1c2VyJzogb2JqLnVzZXIsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogU2VjY29tcFByb2ZpbGUgZGVmaW5lcyBhIHBvZC9jb250YWluZXIncyBzZWNjb21wIHByb2ZpbGUgc2V0dGluZ3MuIE9ubHkgb25lIHByb2ZpbGUgc291cmNlIG1heSBiZSBzZXQuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VjY29tcFByb2ZpbGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZWNjb21wUHJvZmlsZSB7XG4gIC8qKlxuICAgKiBsb2NhbGhvc3RQcm9maWxlIGluZGljYXRlcyBhIHByb2ZpbGUgZGVmaW5lZCBpbiBhIGZpbGUgb24gdGhlIG5vZGUgc2hvdWxkIGJlIHVzZWQuIFRoZSBwcm9maWxlIG11c3QgYmUgcHJlY29uZmlndXJlZCBvbiB0aGUgbm9kZSB0byB3b3JrLiBNdXN0IGJlIGEgZGVzY2VuZGluZyBwYXRoLCByZWxhdGl2ZSB0byB0aGUga3ViZWxldCdzIGNvbmZpZ3VyZWQgc2VjY29tcCBwcm9maWxlIGxvY2F0aW9uLiBNdXN0IG9ubHkgYmUgc2V0IGlmIHR5cGUgaXMgXCJMb2NhbGhvc3RcIi5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VjY29tcFByb2ZpbGUjbG9jYWxob3N0UHJvZmlsZVxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYWxob3N0UHJvZmlsZT86IHN0cmluZztcblxuICAvKipcbiAgICogdHlwZSBpbmRpY2F0ZXMgd2hpY2gga2luZCBvZiBzZWNjb21wIHByb2ZpbGUgd2lsbCBiZSBhcHBsaWVkLiBWYWxpZCBvcHRpb25zIGFyZTpcbiAgICpcbiAgICogTG9jYWxob3N0IC0gYSBwcm9maWxlIGRlZmluZWQgaW4gYSBmaWxlIG9uIHRoZSBub2RlIHNob3VsZCBiZSB1c2VkLiBSdW50aW1lRGVmYXVsdCAtIHRoZSBjb250YWluZXIgcnVudGltZSBkZWZhdWx0IHByb2ZpbGUgc2hvdWxkIGJlIHVzZWQuIFVuY29uZmluZWQgLSBubyBwcm9maWxlIHNob3VsZCBiZSBhcHBsaWVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZWNjb21wUHJvZmlsZSN0eXBlXG4gICAqL1xuICByZWFkb25seSB0eXBlOiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnU2VjY29tcFByb2ZpbGUnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1NlY2NvbXBQcm9maWxlKG9iajogU2VjY29tcFByb2ZpbGUgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdsb2NhbGhvc3RQcm9maWxlJzogb2JqLmxvY2FsaG9zdFByb2ZpbGUsXG4gICAgJ3R5cGUnOiBvYmoudHlwZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBTeXNjdGwgZGVmaW5lcyBhIGtlcm5lbCBwYXJhbWV0ZXIgdG8gYmUgc2V0XG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU3lzY3RsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3lzY3RsIHtcbiAgLyoqXG4gICAqIE5hbWUgb2YgYSBwcm9wZXJ0eSB0byBzZXRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU3lzY3RsI25hbWVcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogVmFsdWUgb2YgYSBwcm9wZXJ0eSB0byBzZXRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU3lzY3RsI3ZhbHVlXG4gICAqL1xuICByZWFkb25seSB2YWx1ZTogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1N5c2N0bCcgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fU3lzY3RsKG9iajogU3lzY3RsIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbmFtZSc6IG9iai5uYW1lLFxuICAgICd2YWx1ZSc6IG9iai52YWx1ZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBXaW5kb3dzU2VjdXJpdHlDb250ZXh0T3B0aW9ucyBjb250YWluIFdpbmRvd3Mtc3BlY2lmaWMgb3B0aW9ucyBhbmQgY3JlZGVudGlhbHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuV2luZG93c1NlY3VyaXR5Q29udGV4dE9wdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBXaW5kb3dzU2VjdXJpdHlDb250ZXh0T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBHTVNBQ3JlZGVudGlhbFNwZWMgaXMgd2hlcmUgdGhlIEdNU0EgYWRtaXNzaW9uIHdlYmhvb2sgKGh0dHBzOi8vZ2l0aHViLmNvbS9rdWJlcm5ldGVzLXNpZ3Mvd2luZG93cy1nbXNhKSBpbmxpbmVzIHRoZSBjb250ZW50cyBvZiB0aGUgR01TQSBjcmVkZW50aWFsIHNwZWMgbmFtZWQgYnkgdGhlIEdNU0FDcmVkZW50aWFsU3BlY05hbWUgZmllbGQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLldpbmRvd3NTZWN1cml0eUNvbnRleHRPcHRpb25zI2dtc2FDcmVkZW50aWFsU3BlY1xuICAgKi9cbiAgcmVhZG9ubHkgZ21zYUNyZWRlbnRpYWxTcGVjPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBHTVNBQ3JlZGVudGlhbFNwZWNOYW1lIGlzIHRoZSBuYW1lIG9mIHRoZSBHTVNBIGNyZWRlbnRpYWwgc3BlYyB0byB1c2UuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLldpbmRvd3NTZWN1cml0eUNvbnRleHRPcHRpb25zI2dtc2FDcmVkZW50aWFsU3BlY05hbWVcbiAgICovXG4gIHJlYWRvbmx5IGdtc2FDcmVkZW50aWFsU3BlY05hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEhvc3RQcm9jZXNzIGRldGVybWluZXMgaWYgYSBjb250YWluZXIgc2hvdWxkIGJlIHJ1biBhcyBhICdIb3N0IFByb2Nlc3MnIGNvbnRhaW5lci4gVGhpcyBmaWVsZCBpcyBhbHBoYS1sZXZlbCBhbmQgd2lsbCBvbmx5IGJlIGhvbm9yZWQgYnkgY29tcG9uZW50cyB0aGF0IGVuYWJsZSB0aGUgV2luZG93c0hvc3RQcm9jZXNzQ29udGFpbmVycyBmZWF0dXJlIGZsYWcuIFNldHRpbmcgdGhpcyBmaWVsZCB3aXRob3V0IHRoZSBmZWF0dXJlIGZsYWcgd2lsbCByZXN1bHQgaW4gZXJyb3JzIHdoZW4gdmFsaWRhdGluZyB0aGUgUG9kLiBBbGwgb2YgYSBQb2QncyBjb250YWluZXJzIG11c3QgaGF2ZSB0aGUgc2FtZSBlZmZlY3RpdmUgSG9zdFByb2Nlc3MgdmFsdWUgKGl0IGlzIG5vdCBhbGxvd2VkIHRvIGhhdmUgYSBtaXggb2YgSG9zdFByb2Nlc3MgY29udGFpbmVycyBhbmQgbm9uLUhvc3RQcm9jZXNzIGNvbnRhaW5lcnMpLiAgSW4gYWRkaXRpb24sIGlmIEhvc3RQcm9jZXNzIGlzIHRydWUgdGhlbiBIb3N0TmV0d29yayBtdXN0IGFsc28gYmUgc2V0IHRvIHRydWUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLldpbmRvd3NTZWN1cml0eUNvbnRleHRPcHRpb25zI2hvc3RQcm9jZXNzXG4gICAqL1xuICByZWFkb25seSBob3N0UHJvY2Vzcz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSBVc2VyTmFtZSBpbiBXaW5kb3dzIHRvIHJ1biB0aGUgZW50cnlwb2ludCBvZiB0aGUgY29udGFpbmVyIHByb2Nlc3MuIERlZmF1bHRzIHRvIHRoZSB1c2VyIHNwZWNpZmllZCBpbiBpbWFnZSBtZXRhZGF0YSBpZiB1bnNwZWNpZmllZC4gTWF5IGFsc28gYmUgc2V0IGluIFBvZFNlY3VyaXR5Q29udGV4dC4gSWYgc2V0IGluIGJvdGggU2VjdXJpdHlDb250ZXh0IGFuZCBQb2RTZWN1cml0eUNvbnRleHQsIHRoZSB2YWx1ZSBzcGVjaWZpZWQgaW4gU2VjdXJpdHlDb250ZXh0IHRha2VzIHByZWNlZGVuY2UuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRoZSB1c2VyIHNwZWNpZmllZCBpbiBpbWFnZSBtZXRhZGF0YSBpZiB1bnNwZWNpZmllZC4gTWF5IGFsc28gYmUgc2V0IGluIFBvZFNlY3VyaXR5Q29udGV4dC4gSWYgc2V0IGluIGJvdGggU2VjdXJpdHlDb250ZXh0IGFuZCBQb2RTZWN1cml0eUNvbnRleHQsIHRoZSB2YWx1ZSBzcGVjaWZpZWQgaW4gU2VjdXJpdHlDb250ZXh0IHRha2VzIHByZWNlZGVuY2UuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLldpbmRvd3NTZWN1cml0eUNvbnRleHRPcHRpb25zI3J1bkFzVXNlck5hbWVcbiAgICovXG4gIHJlYWRvbmx5IHJ1bkFzVXNlck5hbWU/OiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnV2luZG93c1NlY3VyaXR5Q29udGV4dE9wdGlvbnMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1dpbmRvd3NTZWN1cml0eUNvbnRleHRPcHRpb25zKG9iajogV2luZG93c1NlY3VyaXR5Q29udGV4dE9wdGlvbnMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdnbXNhQ3JlZGVudGlhbFNwZWMnOiBvYmouZ21zYUNyZWRlbnRpYWxTcGVjLFxuICAgICdnbXNhQ3JlZGVudGlhbFNwZWNOYW1lJzogb2JqLmdtc2FDcmVkZW50aWFsU3BlY05hbWUsXG4gICAgJ2hvc3RQcm9jZXNzJzogb2JqLmhvc3RQcm9jZXNzLFxuICAgICdydW5Bc1VzZXJOYW1lJzogb2JqLnJ1bkFzVXNlck5hbWUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQXp1cmVGaWxlIHJlcHJlc2VudHMgYW4gQXp1cmUgRmlsZSBTZXJ2aWNlIG1vdW50IG9uIHRoZSBob3N0IGFuZCBiaW5kIG1vdW50IHRvIHRoZSBwb2QuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQXp1cmVGaWxlVm9sdW1lU291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXp1cmVGaWxlVm9sdW1lU291cmNlIHtcbiAgLyoqXG4gICAqIERlZmF1bHRzIHRvIGZhbHNlIChyZWFkL3dyaXRlKS4gUmVhZE9ubHkgaGVyZSB3aWxsIGZvcmNlIHRoZSBSZWFkT25seSBzZXR0aW5nIGluIFZvbHVtZU1vdW50cy5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2UgKHJlYWQvd3JpdGUpLiBSZWFkT25seSBoZXJlIHdpbGwgZm9yY2UgdGhlIFJlYWRPbmx5IHNldHRpbmcgaW4gVm9sdW1lTW91bnRzLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5BenVyZUZpbGVWb2x1bWVTb3VyY2UjcmVhZE9ubHlcbiAgICovXG4gIHJlYWRvbmx5IHJlYWRPbmx5PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogdGhlIG5hbWUgb2Ygc2VjcmV0IHRoYXQgY29udGFpbnMgQXp1cmUgU3RvcmFnZSBBY2NvdW50IE5hbWUgYW5kIEtleVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5BenVyZUZpbGVWb2x1bWVTb3VyY2Ujc2VjcmV0TmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgc2VjcmV0TmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTaGFyZSBOYW1lXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkF6dXJlRmlsZVZvbHVtZVNvdXJjZSNzaGFyZU5hbWVcbiAgICovXG4gIHJlYWRvbmx5IHNoYXJlTmFtZTogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0F6dXJlRmlsZVZvbHVtZVNvdXJjZScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fQXp1cmVGaWxlVm9sdW1lU291cmNlKG9iajogQXp1cmVGaWxlVm9sdW1lU291cmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAncmVhZE9ubHknOiBvYmoucmVhZE9ubHksXG4gICAgJ3NlY3JldE5hbWUnOiBvYmouc2VjcmV0TmFtZSxcbiAgICAnc2hhcmVOYW1lJzogb2JqLnNoYXJlTmFtZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgQ2VwaCBGaWxlc3lzdGVtIG1vdW50IHRoYXQgbGFzdHMgdGhlIGxpZmV0aW1lIG9mIGEgcG9kIENlcGhmcyB2b2x1bWVzIGRvIG5vdCBzdXBwb3J0IG93bmVyc2hpcCBtYW5hZ2VtZW50IG9yIFNFTGludXggcmVsYWJlbGluZy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5DZXBoRlNWb2x1bWVTb3VyY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDZXBoRnNWb2x1bWVTb3VyY2Uge1xuICAvKipcbiAgICogUmVxdWlyZWQ6IE1vbml0b3JzIGlzIGEgY29sbGVjdGlvbiBvZiBDZXBoIG1vbml0b3JzIE1vcmUgaW5mbzogaHR0cHM6Ly9leGFtcGxlcy5rOHMuaW8vdm9sdW1lcy9jZXBoZnMvUkVBRE1FLm1kI2hvdy10by11c2UtaXRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ2VwaEZTVm9sdW1lU291cmNlI21vbml0b3JzXG4gICAqL1xuICByZWFkb25seSBtb25pdG9yczogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsOiBVc2VkIGFzIHRoZSBtb3VudGVkIHJvb3QsIHJhdGhlciB0aGFuIHRoZSBmdWxsIENlcGggdHJlZSwgZGVmYXVsdCBpcyAvXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNlcGhGU1ZvbHVtZVNvdXJjZSNwYXRoXG4gICAqL1xuICByZWFkb25seSBwYXRoPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbDogRGVmYXVsdHMgdG8gZmFsc2UgKHJlYWQvd3JpdGUpLiBSZWFkT25seSBoZXJlIHdpbGwgZm9yY2UgdGhlIFJlYWRPbmx5IHNldHRpbmcgaW4gVm9sdW1lTW91bnRzLiBNb3JlIGluZm86IGh0dHBzOi8vZXhhbXBsZXMuazhzLmlvL3ZvbHVtZXMvY2VwaGZzL1JFQURNRS5tZCNob3ctdG8tdXNlLWl0XG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlIChyZWFkL3dyaXRlKS4gUmVhZE9ubHkgaGVyZSB3aWxsIGZvcmNlIHRoZSBSZWFkT25seSBzZXR0aW5nIGluIFZvbHVtZU1vdW50cy4gTW9yZSBpbmZvOiBodHRwczovL2V4YW1wbGVzLms4cy5pby92b2x1bWVzL2NlcGhmcy9SRUFETUUubWQjaG93LXRvLXVzZS1pdFxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5DZXBoRlNWb2x1bWVTb3VyY2UjcmVhZE9ubHlcbiAgICovXG4gIHJlYWRvbmx5IHJlYWRPbmx5PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogT3B0aW9uYWw6IFNlY3JldEZpbGUgaXMgdGhlIHBhdGggdG8ga2V5IHJpbmcgZm9yIFVzZXIsIGRlZmF1bHQgaXMgL2V0Yy9jZXBoL3VzZXIuc2VjcmV0IE1vcmUgaW5mbzogaHR0cHM6Ly9leGFtcGxlcy5rOHMuaW8vdm9sdW1lcy9jZXBoZnMvUkVBRE1FLm1kI2hvdy10by11c2UtaXRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ2VwaEZTVm9sdW1lU291cmNlI3NlY3JldEZpbGVcbiAgICovXG4gIHJlYWRvbmx5IHNlY3JldEZpbGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsOiBTZWNyZXRSZWYgaXMgcmVmZXJlbmNlIHRvIHRoZSBhdXRoZW50aWNhdGlvbiBzZWNyZXQgZm9yIFVzZXIsIGRlZmF1bHQgaXMgZW1wdHkuIE1vcmUgaW5mbzogaHR0cHM6Ly9leGFtcGxlcy5rOHMuaW8vdm9sdW1lcy9jZXBoZnMvUkVBRE1FLm1kI2hvdy10by11c2UtaXRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ2VwaEZTVm9sdW1lU291cmNlI3NlY3JldFJlZlxuICAgKi9cbiAgcmVhZG9ubHkgc2VjcmV0UmVmPzogTG9jYWxPYmplY3RSZWZlcmVuY2U7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsOiBVc2VyIGlzIHRoZSByYWRvcyB1c2VyIG5hbWUsIGRlZmF1bHQgaXMgYWRtaW4gTW9yZSBpbmZvOiBodHRwczovL2V4YW1wbGVzLms4cy5pby92b2x1bWVzL2NlcGhmcy9SRUFETUUubWQjaG93LXRvLXVzZS1pdFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5DZXBoRlNWb2x1bWVTb3VyY2UjdXNlclxuICAgKi9cbiAgcmVhZG9ubHkgdXNlcj86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdDZXBoRnNWb2x1bWVTb3VyY2UnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0NlcGhGc1ZvbHVtZVNvdXJjZShvYmo6IENlcGhGc1ZvbHVtZVNvdXJjZSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21vbml0b3JzJzogb2JqLm1vbml0b3JzPy5tYXAoeSA9PiB5KSxcbiAgICAncGF0aCc6IG9iai5wYXRoLFxuICAgICdyZWFkT25seSc6IG9iai5yZWFkT25seSxcbiAgICAnc2VjcmV0RmlsZSc6IG9iai5zZWNyZXRGaWxlLFxuICAgICdzZWNyZXRSZWYnOiB0b0pzb25fTG9jYWxPYmplY3RSZWZlcmVuY2Uob2JqLnNlY3JldFJlZiksXG4gICAgJ3VzZXInOiBvYmoudXNlcixcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2luZGVyIHZvbHVtZSByZXNvdXJjZSBpbiBPcGVuc3RhY2suIEEgQ2luZGVyIHZvbHVtZSBtdXN0IGV4aXN0IGJlZm9yZSBtb3VudGluZyB0byBhIGNvbnRhaW5lci4gVGhlIHZvbHVtZSBtdXN0IGFsc28gYmUgaW4gdGhlIHNhbWUgcmVnaW9uIGFzIHRoZSBrdWJlbGV0LiBDaW5kZXIgdm9sdW1lcyBzdXBwb3J0IG93bmVyc2hpcCBtYW5hZ2VtZW50IGFuZCBTRUxpbnV4IHJlbGFiZWxpbmcuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ2luZGVyVm9sdW1lU291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2luZGVyVm9sdW1lU291cmNlIHtcbiAgLyoqXG4gICAqIEZpbGVzeXN0ZW0gdHlwZSB0byBtb3VudC4gTXVzdCBiZSBhIGZpbGVzeXN0ZW0gdHlwZSBzdXBwb3J0ZWQgYnkgdGhlIGhvc3Qgb3BlcmF0aW5nIHN5c3RlbS4gRXhhbXBsZXM6IFwiZXh0NFwiLCBcInhmc1wiLCBcIm50ZnNcIi4gSW1wbGljaXRseSBpbmZlcnJlZCB0byBiZSBcImV4dDRcIiBpZiB1bnNwZWNpZmllZC4gTW9yZSBpbmZvOiBodHRwczovL2V4YW1wbGVzLms4cy5pby9teXNxbC1jaW5kZXItcGQvUkVBRE1FLm1kXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNpbmRlclZvbHVtZVNvdXJjZSNmc1R5cGVcbiAgICovXG4gIHJlYWRvbmx5IGZzVHlwZT86IHN0cmluZztcblxuICAvKipcbiAgICogT3B0aW9uYWw6IERlZmF1bHRzIHRvIGZhbHNlIChyZWFkL3dyaXRlKS4gUmVhZE9ubHkgaGVyZSB3aWxsIGZvcmNlIHRoZSBSZWFkT25seSBzZXR0aW5nIGluIFZvbHVtZU1vdW50cy4gTW9yZSBpbmZvOiBodHRwczovL2V4YW1wbGVzLms4cy5pby9teXNxbC1jaW5kZXItcGQvUkVBRE1FLm1kXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlIChyZWFkL3dyaXRlKS4gUmVhZE9ubHkgaGVyZSB3aWxsIGZvcmNlIHRoZSBSZWFkT25seSBzZXR0aW5nIGluIFZvbHVtZU1vdW50cy4gTW9yZSBpbmZvOiBodHRwczovL2V4YW1wbGVzLms4cy5pby9teXNxbC1jaW5kZXItcGQvUkVBRE1FLm1kXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNpbmRlclZvbHVtZVNvdXJjZSNyZWFkT25seVxuICAgKi9cbiAgcmVhZG9ubHkgcmVhZE9ubHk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbDogcG9pbnRzIHRvIGEgc2VjcmV0IG9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnMgdXNlZCB0byBjb25uZWN0IHRvIE9wZW5TdGFjay5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ2luZGVyVm9sdW1lU291cmNlI3NlY3JldFJlZlxuICAgKi9cbiAgcmVhZG9ubHkgc2VjcmV0UmVmPzogTG9jYWxPYmplY3RSZWZlcmVuY2U7XG5cbiAgLyoqXG4gICAqIHZvbHVtZSBpZCB1c2VkIHRvIGlkZW50aWZ5IHRoZSB2b2x1bWUgaW4gY2luZGVyLiBNb3JlIGluZm86IGh0dHBzOi8vZXhhbXBsZXMuazhzLmlvL215c3FsLWNpbmRlci1wZC9SRUFETUUubWRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ2luZGVyVm9sdW1lU291cmNlI3ZvbHVtZUlEXG4gICAqL1xuICByZWFkb25seSB2b2x1bWVJZDogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0NpbmRlclZvbHVtZVNvdXJjZScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fQ2luZGVyVm9sdW1lU291cmNlKG9iajogQ2luZGVyVm9sdW1lU291cmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZnNUeXBlJzogb2JqLmZzVHlwZSxcbiAgICAncmVhZE9ubHknOiBvYmoucmVhZE9ubHksXG4gICAgJ3NlY3JldFJlZic6IHRvSnNvbl9Mb2NhbE9iamVjdFJlZmVyZW5jZShvYmouc2VjcmV0UmVmKSxcbiAgICAndm9sdW1lSUQnOiBvYmoudm9sdW1lSWQsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQWRhcHRzIGEgQ29uZmlnTWFwIGludG8gYSB2b2x1bWUuXG4gKlxuICogVGhlIGNvbnRlbnRzIG9mIHRoZSB0YXJnZXQgQ29uZmlnTWFwJ3MgRGF0YSBmaWVsZCB3aWxsIGJlIHByZXNlbnRlZCBpbiBhIHZvbHVtZSBhcyBmaWxlcyB1c2luZyB0aGUga2V5cyBpbiB0aGUgRGF0YSBmaWVsZCBhcyB0aGUgZmlsZSBuYW1lcywgdW5sZXNzIHRoZSBpdGVtcyBlbGVtZW50IGlzIHBvcHVsYXRlZCB3aXRoIHNwZWNpZmljIG1hcHBpbmdzIG9mIGtleXMgdG8gcGF0aHMuIENvbmZpZ01hcCB2b2x1bWVzIHN1cHBvcnQgb3duZXJzaGlwIG1hbmFnZW1lbnQgYW5kIFNFTGludXggcmVsYWJlbGluZy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db25maWdNYXBWb2x1bWVTb3VyY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb25maWdNYXBWb2x1bWVTb3VyY2Uge1xuICAvKipcbiAgICogT3B0aW9uYWw6IG1vZGUgYml0cyB1c2VkIHRvIHNldCBwZXJtaXNzaW9ucyBvbiBjcmVhdGVkIGZpbGVzIGJ5IGRlZmF1bHQuIE11c3QgYmUgYW4gb2N0YWwgdmFsdWUgYmV0d2VlbiAwMDAwIGFuZCAwNzc3IG9yIGEgZGVjaW1hbCB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDUxMS4gWUFNTCBhY2NlcHRzIGJvdGggb2N0YWwgYW5kIGRlY2ltYWwgdmFsdWVzLCBKU09OIHJlcXVpcmVzIGRlY2ltYWwgdmFsdWVzIGZvciBtb2RlIGJpdHMuIERlZmF1bHRzIHRvIDA2NDQuIERpcmVjdG9yaWVzIHdpdGhpbiB0aGUgcGF0aCBhcmUgbm90IGFmZmVjdGVkIGJ5IHRoaXMgc2V0dGluZy4gVGhpcyBtaWdodCBiZSBpbiBjb25mbGljdCB3aXRoIG90aGVyIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIGZpbGUgbW9kZSwgbGlrZSBmc0dyb3VwLCBhbmQgdGhlIHJlc3VsdCBjYW4gYmUgb3RoZXIgbW9kZSBiaXRzIHNldC5cbiAgICpcbiAgICogQGRlZmF1bHQgMDY0NC4gRGlyZWN0b3JpZXMgd2l0aGluIHRoZSBwYXRoIGFyZSBub3QgYWZmZWN0ZWQgYnkgdGhpcyBzZXR0aW5nLiBUaGlzIG1pZ2h0IGJlIGluIGNvbmZsaWN0IHdpdGggb3RoZXIgb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgZmlsZSBtb2RlLCBsaWtlIGZzR3JvdXAsIGFuZCB0aGUgcmVzdWx0IGNhbiBiZSBvdGhlciBtb2RlIGJpdHMgc2V0LlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db25maWdNYXBWb2x1bWVTb3VyY2UjZGVmYXVsdE1vZGVcbiAgICovXG4gIHJlYWRvbmx5IGRlZmF1bHRNb2RlPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBJZiB1bnNwZWNpZmllZCwgZWFjaCBrZXktdmFsdWUgcGFpciBpbiB0aGUgRGF0YSBmaWVsZCBvZiB0aGUgcmVmZXJlbmNlZCBDb25maWdNYXAgd2lsbCBiZSBwcm9qZWN0ZWQgaW50byB0aGUgdm9sdW1lIGFzIGEgZmlsZSB3aG9zZSBuYW1lIGlzIHRoZSBrZXkgYW5kIGNvbnRlbnQgaXMgdGhlIHZhbHVlLiBJZiBzcGVjaWZpZWQsIHRoZSBsaXN0ZWQga2V5cyB3aWxsIGJlIHByb2plY3RlZCBpbnRvIHRoZSBzcGVjaWZpZWQgcGF0aHMsIGFuZCB1bmxpc3RlZCBrZXlzIHdpbGwgbm90IGJlIHByZXNlbnQuIElmIGEga2V5IGlzIHNwZWNpZmllZCB3aGljaCBpcyBub3QgcHJlc2VudCBpbiB0aGUgQ29uZmlnTWFwLCB0aGUgdm9sdW1lIHNldHVwIHdpbGwgZXJyb3IgdW5sZXNzIGl0IGlzIG1hcmtlZCBvcHRpb25hbC4gUGF0aHMgbXVzdCBiZSByZWxhdGl2ZSBhbmQgbWF5IG5vdCBjb250YWluIHRoZSAnLi4nIHBhdGggb3Igc3RhcnQgd2l0aCAnLi4nLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db25maWdNYXBWb2x1bWVTb3VyY2UjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zPzogS2V5VG9QYXRoW107XG5cbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIHJlZmVyZW50LiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL292ZXJ2aWV3L3dvcmtpbmctd2l0aC1vYmplY3RzL25hbWVzLyNuYW1lc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db25maWdNYXBWb2x1bWVTb3VyY2UjbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogU3BlY2lmeSB3aGV0aGVyIHRoZSBDb25maWdNYXAgb3IgaXRzIGtleXMgbXVzdCBiZSBkZWZpbmVkXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbmZpZ01hcFZvbHVtZVNvdXJjZSNvcHRpb25hbFxuICAgKi9cbiAgcmVhZG9ubHkgb3B0aW9uYWw/OiBib29sZWFuO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0NvbmZpZ01hcFZvbHVtZVNvdXJjZScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fQ29uZmlnTWFwVm9sdW1lU291cmNlKG9iajogQ29uZmlnTWFwVm9sdW1lU291cmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZGVmYXVsdE1vZGUnOiBvYmouZGVmYXVsdE1vZGUsXG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fS2V5VG9QYXRoKHkpKSxcbiAgICAnbmFtZSc6IG9iai5uYW1lLFxuICAgICdvcHRpb25hbCc6IG9iai5vcHRpb25hbCxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc291cmNlIGxvY2F0aW9uIG9mIGEgdm9sdW1lIHRvIG1vdW50LCBtYW5hZ2VkIGJ5IGFuIGV4dGVybmFsIENTSSBkcml2ZXJcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5DU0lWb2x1bWVTb3VyY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDc2lWb2x1bWVTb3VyY2Uge1xuICAvKipcbiAgICogRHJpdmVyIGlzIHRoZSBuYW1lIG9mIHRoZSBDU0kgZHJpdmVyIHRoYXQgaGFuZGxlcyB0aGlzIHZvbHVtZS4gQ29uc3VsdCB3aXRoIHlvdXIgYWRtaW4gZm9yIHRoZSBjb3JyZWN0IG5hbWUgYXMgcmVnaXN0ZXJlZCBpbiB0aGUgY2x1c3Rlci5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ1NJVm9sdW1lU291cmNlI2RyaXZlclxuICAgKi9cbiAgcmVhZG9ubHkgZHJpdmVyOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEZpbGVzeXN0ZW0gdHlwZSB0byBtb3VudC4gRXguIFwiZXh0NFwiLCBcInhmc1wiLCBcIm50ZnNcIi4gSWYgbm90IHByb3ZpZGVkLCB0aGUgZW1wdHkgdmFsdWUgaXMgcGFzc2VkIHRvIHRoZSBhc3NvY2lhdGVkIENTSSBkcml2ZXIgd2hpY2ggd2lsbCBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgZmlsZXN5c3RlbSB0byBhcHBseS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ1NJVm9sdW1lU291cmNlI2ZzVHlwZVxuICAgKi9cbiAgcmVhZG9ubHkgZnNUeXBlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBOb2RlUHVibGlzaFNlY3JldFJlZiBpcyBhIHJlZmVyZW5jZSB0byB0aGUgc2VjcmV0IG9iamVjdCBjb250YWluaW5nIHNlbnNpdGl2ZSBpbmZvcm1hdGlvbiB0byBwYXNzIHRvIHRoZSBDU0kgZHJpdmVyIHRvIGNvbXBsZXRlIHRoZSBDU0kgTm9kZVB1Ymxpc2hWb2x1bWUgYW5kIE5vZGVVbnB1Ymxpc2hWb2x1bWUgY2FsbHMuIFRoaXMgZmllbGQgaXMgb3B0aW9uYWwsIGFuZCAgbWF5IGJlIGVtcHR5IGlmIG5vIHNlY3JldCBpcyByZXF1aXJlZC4gSWYgdGhlIHNlY3JldCBvYmplY3QgY29udGFpbnMgbW9yZSB0aGFuIG9uZSBzZWNyZXQsIGFsbCBzZWNyZXQgcmVmZXJlbmNlcyBhcmUgcGFzc2VkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5DU0lWb2x1bWVTb3VyY2Ujbm9kZVB1Ymxpc2hTZWNyZXRSZWZcbiAgICovXG4gIHJlYWRvbmx5IG5vZGVQdWJsaXNoU2VjcmV0UmVmPzogTG9jYWxPYmplY3RSZWZlcmVuY2U7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyBhIHJlYWQtb25seSBjb25maWd1cmF0aW9uIGZvciB0aGUgdm9sdW1lLiBEZWZhdWx0cyB0byBmYWxzZSAocmVhZC93cml0ZSkuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlIChyZWFkL3dyaXRlKS5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ1NJVm9sdW1lU291cmNlI3JlYWRPbmx5XG4gICAqL1xuICByZWFkb25seSByZWFkT25seT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFZvbHVtZUF0dHJpYnV0ZXMgc3RvcmVzIGRyaXZlci1zcGVjaWZpYyBwcm9wZXJ0aWVzIHRoYXQgYXJlIHBhc3NlZCB0byB0aGUgQ1NJIGRyaXZlci4gQ29uc3VsdCB5b3VyIGRyaXZlcidzIGRvY3VtZW50YXRpb24gZm9yIHN1cHBvcnRlZCB2YWx1ZXMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNTSVZvbHVtZVNvdXJjZSN2b2x1bWVBdHRyaWJ1dGVzXG4gICAqL1xuICByZWFkb25seSB2b2x1bWVBdHRyaWJ1dGVzPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdDc2lWb2x1bWVTb3VyY2UnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0NzaVZvbHVtZVNvdXJjZShvYmo6IENzaVZvbHVtZVNvdXJjZSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2RyaXZlcic6IG9iai5kcml2ZXIsXG4gICAgJ2ZzVHlwZSc6IG9iai5mc1R5cGUsXG4gICAgJ25vZGVQdWJsaXNoU2VjcmV0UmVmJzogdG9Kc29uX0xvY2FsT2JqZWN0UmVmZXJlbmNlKG9iai5ub2RlUHVibGlzaFNlY3JldFJlZiksXG4gICAgJ3JlYWRPbmx5Jzogb2JqLnJlYWRPbmx5LFxuICAgICd2b2x1bWVBdHRyaWJ1dGVzJzogKChvYmoudm9sdW1lQXR0cmlidXRlcykgPT09IHVuZGVmaW5lZCkgPyB1bmRlZmluZWQgOiAoT2JqZWN0LmVudHJpZXMob2JqLnZvbHVtZUF0dHJpYnV0ZXMpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSkpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIERvd253YXJkQVBJVm9sdW1lU291cmNlIHJlcHJlc2VudHMgYSB2b2x1bWUgY29udGFpbmluZyBkb3dud2FyZCBBUEkgaW5mby4gRG93bndhcmQgQVBJIHZvbHVtZXMgc3VwcG9ydCBvd25lcnNoaXAgbWFuYWdlbWVudCBhbmQgU0VMaW51eCByZWxhYmVsaW5nLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkRvd253YXJkQVBJVm9sdW1lU291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRG93bndhcmRBcGlWb2x1bWVTb3VyY2Uge1xuICAvKipcbiAgICogT3B0aW9uYWw6IG1vZGUgYml0cyB0byB1c2Ugb24gY3JlYXRlZCBmaWxlcyBieSBkZWZhdWx0LiBNdXN0IGJlIGEgT3B0aW9uYWw6IG1vZGUgYml0cyB1c2VkIHRvIHNldCBwZXJtaXNzaW9ucyBvbiBjcmVhdGVkIGZpbGVzIGJ5IGRlZmF1bHQuIE11c3QgYmUgYW4gb2N0YWwgdmFsdWUgYmV0d2VlbiAwMDAwIGFuZCAwNzc3IG9yIGEgZGVjaW1hbCB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDUxMS4gWUFNTCBhY2NlcHRzIGJvdGggb2N0YWwgYW5kIGRlY2ltYWwgdmFsdWVzLCBKU09OIHJlcXVpcmVzIGRlY2ltYWwgdmFsdWVzIGZvciBtb2RlIGJpdHMuIERlZmF1bHRzIHRvIDA2NDQuIERpcmVjdG9yaWVzIHdpdGhpbiB0aGUgcGF0aCBhcmUgbm90IGFmZmVjdGVkIGJ5IHRoaXMgc2V0dGluZy4gVGhpcyBtaWdodCBiZSBpbiBjb25mbGljdCB3aXRoIG90aGVyIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIGZpbGUgbW9kZSwgbGlrZSBmc0dyb3VwLCBhbmQgdGhlIHJlc3VsdCBjYW4gYmUgb3RoZXIgbW9kZSBiaXRzIHNldC5cbiAgICpcbiAgICogQGRlZmF1bHQgMDY0NC4gRGlyZWN0b3JpZXMgd2l0aGluIHRoZSBwYXRoIGFyZSBub3QgYWZmZWN0ZWQgYnkgdGhpcyBzZXR0aW5nLiBUaGlzIG1pZ2h0IGJlIGluIGNvbmZsaWN0IHdpdGggb3RoZXIgb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgZmlsZSBtb2RlLCBsaWtlIGZzR3JvdXAsIGFuZCB0aGUgcmVzdWx0IGNhbiBiZSBvdGhlciBtb2RlIGJpdHMgc2V0LlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Eb3dud2FyZEFQSVZvbHVtZVNvdXJjZSNkZWZhdWx0TW9kZVxuICAgKi9cbiAgcmVhZG9ubHkgZGVmYXVsdE1vZGU/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEl0ZW1zIGlzIGEgbGlzdCBvZiBkb3dud2FyZCBBUEkgdm9sdW1lIGZpbGVcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRG93bndhcmRBUElWb2x1bWVTb3VyY2UjaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zPzogRG93bndhcmRBcGlWb2x1bWVGaWxlW107XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnRG93bndhcmRBcGlWb2x1bWVTb3VyY2UnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0Rvd253YXJkQXBpVm9sdW1lU291cmNlKG9iajogRG93bndhcmRBcGlWb2x1bWVTb3VyY2UgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdkZWZhdWx0TW9kZSc6IG9iai5kZWZhdWx0TW9kZSxcbiAgICAnaXRlbXMnOiBvYmouaXRlbXM/Lm1hcCh5ID0+IHRvSnNvbl9Eb3dud2FyZEFwaVZvbHVtZUZpbGUoeSkpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZW1wdHkgZGlyZWN0b3J5IGZvciBhIHBvZC4gRW1wdHkgZGlyZWN0b3J5IHZvbHVtZXMgc3VwcG9ydCBvd25lcnNoaXAgbWFuYWdlbWVudCBhbmQgU0VMaW51eCByZWxhYmVsaW5nLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkVtcHR5RGlyVm9sdW1lU291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRW1wdHlEaXJWb2x1bWVTb3VyY2Uge1xuICAvKipcbiAgICogV2hhdCB0eXBlIG9mIHN0b3JhZ2UgbWVkaXVtIHNob3VsZCBiYWNrIHRoaXMgZGlyZWN0b3J5LiBUaGUgZGVmYXVsdCBpcyBcIlwiIHdoaWNoIG1lYW5zIHRvIHVzZSB0aGUgbm9kZSdzIGRlZmF1bHQgbWVkaXVtLiBNdXN0IGJlIGFuIGVtcHR5IHN0cmluZyAoZGVmYXVsdCkgb3IgTWVtb3J5LiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2Uvdm9sdW1lcyNlbXB0eWRpclxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FbXB0eURpclZvbHVtZVNvdXJjZSNtZWRpdW1cbiAgICovXG4gIHJlYWRvbmx5IG1lZGl1bT86IHN0cmluZztcblxuICAvKipcbiAgICogVG90YWwgYW1vdW50IG9mIGxvY2FsIHN0b3JhZ2UgcmVxdWlyZWQgZm9yIHRoaXMgRW1wdHlEaXIgdm9sdW1lLiBUaGUgc2l6ZSBsaW1pdCBpcyBhbHNvIGFwcGxpY2FibGUgZm9yIG1lbW9yeSBtZWRpdW0uIFRoZSBtYXhpbXVtIHVzYWdlIG9uIG1lbW9yeSBtZWRpdW0gRW1wdHlEaXIgd291bGQgYmUgdGhlIG1pbmltdW0gdmFsdWUgYmV0d2VlbiB0aGUgU2l6ZUxpbWl0IHNwZWNpZmllZCBoZXJlIGFuZCB0aGUgc3VtIG9mIG1lbW9yeSBsaW1pdHMgb2YgYWxsIGNvbnRhaW5lcnMgaW4gYSBwb2QuIFRoZSBkZWZhdWx0IGlzIG5pbCB3aGljaCBtZWFucyB0aGF0IHRoZSBsaW1pdCBpcyB1bmRlZmluZWQuIE1vcmUgaW5mbzogaHR0cDovL2t1YmVybmV0ZXMuaW8vZG9jcy91c2VyLWd1aWRlL3ZvbHVtZXMjZW1wdHlkaXJcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRW1wdHlEaXJWb2x1bWVTb3VyY2Ujc2l6ZUxpbWl0XG4gICAqL1xuICByZWFkb25seSBzaXplTGltaXQ/OiBRdWFudGl0eTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdFbXB0eURpclZvbHVtZVNvdXJjZScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fRW1wdHlEaXJWb2x1bWVTb3VyY2Uob2JqOiBFbXB0eURpclZvbHVtZVNvdXJjZSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21lZGl1bSc6IG9iai5tZWRpdW0sXG4gICAgJ3NpemVMaW1pdCc6IG9iai5zaXplTGltaXQ/LnZhbHVlLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZXBoZW1lcmFsIHZvbHVtZSB0aGF0IGlzIGhhbmRsZWQgYnkgYSBub3JtYWwgc3RvcmFnZSBkcml2ZXIuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRXBoZW1lcmFsVm9sdW1lU291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXBoZW1lcmFsVm9sdW1lU291cmNlIHtcbiAgLyoqXG4gICAqIFdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSBzdGFuZC1hbG9uZSBQVkMgdG8gcHJvdmlzaW9uIHRoZSB2b2x1bWUuIFRoZSBwb2QgaW4gd2hpY2ggdGhpcyBFcGhlbWVyYWxWb2x1bWVTb3VyY2UgaXMgZW1iZWRkZWQgd2lsbCBiZSB0aGUgb3duZXIgb2YgdGhlIFBWQywgaS5lLiB0aGUgUFZDIHdpbGwgYmUgZGVsZXRlZCB0b2dldGhlciB3aXRoIHRoZSBwb2QuICBUaGUgbmFtZSBvZiB0aGUgUFZDIHdpbGwgYmUgYDxwb2QgbmFtZT4tPHZvbHVtZSBuYW1lPmAgd2hlcmUgYDx2b2x1bWUgbmFtZT5gIGlzIHRoZSBuYW1lIGZyb20gdGhlIGBQb2RTcGVjLlZvbHVtZXNgIGFycmF5IGVudHJ5LiBQb2QgdmFsaWRhdGlvbiB3aWxsIHJlamVjdCB0aGUgcG9kIGlmIHRoZSBjb25jYXRlbmF0ZWQgbmFtZSBpcyBub3QgdmFsaWQgZm9yIGEgUFZDIChmb3IgZXhhbXBsZSwgdG9vIGxvbmcpLlxuICAgKlxuICAgKiBBbiBleGlzdGluZyBQVkMgd2l0aCB0aGF0IG5hbWUgdGhhdCBpcyBub3Qgb3duZWQgYnkgdGhlIHBvZCB3aWxsICpub3QqIGJlIHVzZWQgZm9yIHRoZSBwb2QgdG8gYXZvaWQgdXNpbmcgYW4gdW5yZWxhdGVkIHZvbHVtZSBieSBtaXN0YWtlLiBTdGFydGluZyB0aGUgcG9kIGlzIHRoZW4gYmxvY2tlZCB1bnRpbCB0aGUgdW5yZWxhdGVkIFBWQyBpcyByZW1vdmVkLiBJZiBzdWNoIGEgcHJlLWNyZWF0ZWQgUFZDIGlzIG1lYW50IHRvIGJlIHVzZWQgYnkgdGhlIHBvZCwgdGhlIFBWQyBoYXMgdG8gdXBkYXRlZCB3aXRoIGFuIG93bmVyIHJlZmVyZW5jZSB0byB0aGUgcG9kIG9uY2UgdGhlIHBvZCBleGlzdHMuIE5vcm1hbGx5IHRoaXMgc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnksIGJ1dCBpdCBtYXkgYmUgdXNlZnVsIHdoZW4gbWFudWFsbHkgcmVjb25zdHJ1Y3RpbmcgYSBicm9rZW4gY2x1c3Rlci5cbiAgICpcbiAgICogVGhpcyBmaWVsZCBpcyByZWFkLW9ubHkgYW5kIG5vIGNoYW5nZXMgd2lsbCBiZSBtYWRlIGJ5IEt1YmVybmV0ZXMgdG8gdGhlIFBWQyBhZnRlciBpdCBoYXMgYmVlbiBjcmVhdGVkLlxuICAgKlxuICAgKiBSZXF1aXJlZCwgbXVzdCBub3QgYmUgbmlsLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FcGhlbWVyYWxWb2x1bWVTb3VyY2Ujdm9sdW1lQ2xhaW1UZW1wbGF0ZVxuICAgKi9cbiAgcmVhZG9ubHkgdm9sdW1lQ2xhaW1UZW1wbGF0ZT86IFBlcnNpc3RlbnRWb2x1bWVDbGFpbVRlbXBsYXRlO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0VwaGVtZXJhbFZvbHVtZVNvdXJjZScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fRXBoZW1lcmFsVm9sdW1lU291cmNlKG9iajogRXBoZW1lcmFsVm9sdW1lU291cmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAndm9sdW1lQ2xhaW1UZW1wbGF0ZSc6IHRvSnNvbl9QZXJzaXN0ZW50Vm9sdW1lQ2xhaW1UZW1wbGF0ZShvYmoudm9sdW1lQ2xhaW1UZW1wbGF0ZSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogRmxleFZvbHVtZSByZXByZXNlbnRzIGEgZ2VuZXJpYyB2b2x1bWUgcmVzb3VyY2UgdGhhdCBpcyBwcm92aXNpb25lZC9hdHRhY2hlZCB1c2luZyBhbiBleGVjIGJhc2VkIHBsdWdpbi5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5GbGV4Vm9sdW1lU291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmxleFZvbHVtZVNvdXJjZSB7XG4gIC8qKlxuICAgKiBEcml2ZXIgaXMgdGhlIG5hbWUgb2YgdGhlIGRyaXZlciB0byB1c2UgZm9yIHRoaXMgdm9sdW1lLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5GbGV4Vm9sdW1lU291cmNlI2RyaXZlclxuICAgKi9cbiAgcmVhZG9ubHkgZHJpdmVyOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEZpbGVzeXN0ZW0gdHlwZSB0byBtb3VudC4gTXVzdCBiZSBhIGZpbGVzeXN0ZW0gdHlwZSBzdXBwb3J0ZWQgYnkgdGhlIGhvc3Qgb3BlcmF0aW5nIHN5c3RlbS4gRXguIFwiZXh0NFwiLCBcInhmc1wiLCBcIm50ZnNcIi4gVGhlIGRlZmF1bHQgZmlsZXN5c3RlbSBkZXBlbmRzIG9uIEZsZXhWb2x1bWUgc2NyaXB0LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5GbGV4Vm9sdW1lU291cmNlI2ZzVHlwZVxuICAgKi9cbiAgcmVhZG9ubHkgZnNUeXBlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbDogRXh0cmEgY29tbWFuZCBvcHRpb25zIGlmIGFueS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRmxleFZvbHVtZVNvdXJjZSNvcHRpb25zXG4gICAqL1xuICByZWFkb25seSBvcHRpb25zPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcblxuICAvKipcbiAgICogT3B0aW9uYWw6IERlZmF1bHRzIHRvIGZhbHNlIChyZWFkL3dyaXRlKS4gUmVhZE9ubHkgaGVyZSB3aWxsIGZvcmNlIHRoZSBSZWFkT25seSBzZXR0aW5nIGluIFZvbHVtZU1vdW50cy5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2UgKHJlYWQvd3JpdGUpLiBSZWFkT25seSBoZXJlIHdpbGwgZm9yY2UgdGhlIFJlYWRPbmx5IHNldHRpbmcgaW4gVm9sdW1lTW91bnRzLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5GbGV4Vm9sdW1lU291cmNlI3JlYWRPbmx5XG4gICAqL1xuICByZWFkb25seSByZWFkT25seT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsOiBTZWNyZXRSZWYgaXMgcmVmZXJlbmNlIHRvIHRoZSBzZWNyZXQgb2JqZWN0IGNvbnRhaW5pbmcgc2Vuc2l0aXZlIGluZm9ybWF0aW9uIHRvIHBhc3MgdG8gdGhlIHBsdWdpbiBzY3JpcHRzLiBUaGlzIG1heSBiZSBlbXB0eSBpZiBubyBzZWNyZXQgb2JqZWN0IGlzIHNwZWNpZmllZC4gSWYgdGhlIHNlY3JldCBvYmplY3QgY29udGFpbnMgbW9yZSB0aGFuIG9uZSBzZWNyZXQsIGFsbCBzZWNyZXRzIGFyZSBwYXNzZWQgdG8gdGhlIHBsdWdpbiBzY3JpcHRzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5GbGV4Vm9sdW1lU291cmNlI3NlY3JldFJlZlxuICAgKi9cbiAgcmVhZG9ubHkgc2VjcmV0UmVmPzogTG9jYWxPYmplY3RSZWZlcmVuY2U7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnRmxleFZvbHVtZVNvdXJjZScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fRmxleFZvbHVtZVNvdXJjZShvYmo6IEZsZXhWb2x1bWVTb3VyY2UgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdkcml2ZXInOiBvYmouZHJpdmVyLFxuICAgICdmc1R5cGUnOiBvYmouZnNUeXBlLFxuICAgICdvcHRpb25zJzogKChvYmoub3B0aW9ucykgPT09IHVuZGVmaW5lZCkgPyB1bmRlZmluZWQgOiAoT2JqZWN0LmVudHJpZXMob2JqLm9wdGlvbnMpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSkpLFxuICAgICdyZWFkT25seSc6IG9iai5yZWFkT25seSxcbiAgICAnc2VjcmV0UmVmJzogdG9Kc29uX0xvY2FsT2JqZWN0UmVmZXJlbmNlKG9iai5zZWNyZXRSZWYpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB2b2x1bWUgdGhhdCBpcyBwb3B1bGF0ZWQgd2l0aCB0aGUgY29udGVudHMgb2YgYSBnaXQgcmVwb3NpdG9yeS4gR2l0IHJlcG8gdm9sdW1lcyBkbyBub3Qgc3VwcG9ydCBvd25lcnNoaXAgbWFuYWdlbWVudC4gR2l0IHJlcG8gdm9sdW1lcyBzdXBwb3J0IFNFTGludXggcmVsYWJlbGluZy5cbiAqXG4gKiBERVBSRUNBVEVEOiBHaXRSZXBvIGlzIGRlcHJlY2F0ZWQuIFRvIHByb3Zpc2lvbiBhIGNvbnRhaW5lciB3aXRoIGEgZ2l0IHJlcG8sIG1vdW50IGFuIEVtcHR5RGlyIGludG8gYW4gSW5pdENvbnRhaW5lciB0aGF0IGNsb25lcyB0aGUgcmVwbyB1c2luZyBnaXQsIHRoZW4gbW91bnQgdGhlIEVtcHR5RGlyIGludG8gdGhlIFBvZCdzIGNvbnRhaW5lci5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5HaXRSZXBvVm9sdW1lU291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR2l0UmVwb1ZvbHVtZVNvdXJjZSB7XG4gIC8qKlxuICAgKiBUYXJnZXQgZGlyZWN0b3J5IG5hbWUuIE11c3Qgbm90IGNvbnRhaW4gb3Igc3RhcnQgd2l0aCAnLi4nLiAgSWYgJy4nIGlzIHN1cHBsaWVkLCB0aGUgdm9sdW1lIGRpcmVjdG9yeSB3aWxsIGJlIHRoZSBnaXQgcmVwb3NpdG9yeS4gIE90aGVyd2lzZSwgaWYgc3BlY2lmaWVkLCB0aGUgdm9sdW1lIHdpbGwgY29udGFpbiB0aGUgZ2l0IHJlcG9zaXRvcnkgaW4gdGhlIHN1YmRpcmVjdG9yeSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5HaXRSZXBvVm9sdW1lU291cmNlI2RpcmVjdG9yeVxuICAgKi9cbiAgcmVhZG9ubHkgZGlyZWN0b3J5Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZXBvc2l0b3J5IFVSTFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5HaXRSZXBvVm9sdW1lU291cmNlI3JlcG9zaXRvcnlcbiAgICovXG4gIHJlYWRvbmx5IHJlcG9zaXRvcnk6IHN0cmluZztcblxuICAvKipcbiAgICogQ29tbWl0IGhhc2ggZm9yIHRoZSBzcGVjaWZpZWQgcmV2aXNpb24uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkdpdFJlcG9Wb2x1bWVTb3VyY2UjcmV2aXNpb25cbiAgICovXG4gIHJlYWRvbmx5IHJldmlzaW9uPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0dpdFJlcG9Wb2x1bWVTb3VyY2UnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0dpdFJlcG9Wb2x1bWVTb3VyY2Uob2JqOiBHaXRSZXBvVm9sdW1lU291cmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZGlyZWN0b3J5Jzogb2JqLmRpcmVjdG9yeSxcbiAgICAncmVwb3NpdG9yeSc6IG9iai5yZXBvc2l0b3J5LFxuICAgICdyZXZpc2lvbic6IG9iai5yZXZpc2lvbixcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgR2x1c3RlcmZzIG1vdW50IHRoYXQgbGFzdHMgdGhlIGxpZmV0aW1lIG9mIGEgcG9kLiBHbHVzdGVyZnMgdm9sdW1lcyBkbyBub3Qgc3VwcG9ydCBvd25lcnNoaXAgbWFuYWdlbWVudCBvciBTRUxpbnV4IHJlbGFiZWxpbmcuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuR2x1c3RlcmZzVm9sdW1lU291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR2x1c3RlcmZzVm9sdW1lU291cmNlIHtcbiAgLyoqXG4gICAqIEVuZHBvaW50c05hbWUgaXMgdGhlIGVuZHBvaW50IG5hbWUgdGhhdCBkZXRhaWxzIEdsdXN0ZXJmcyB0b3BvbG9neS4gTW9yZSBpbmZvOiBodHRwczovL2V4YW1wbGVzLms4cy5pby92b2x1bWVzL2dsdXN0ZXJmcy9SRUFETUUubWQjY3JlYXRlLWEtcG9kXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkdsdXN0ZXJmc1ZvbHVtZVNvdXJjZSNlbmRwb2ludHNcbiAgICovXG4gIHJlYWRvbmx5IGVuZHBvaW50czogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBQYXRoIGlzIHRoZSBHbHVzdGVyZnMgdm9sdW1lIHBhdGguIE1vcmUgaW5mbzogaHR0cHM6Ly9leGFtcGxlcy5rOHMuaW8vdm9sdW1lcy9nbHVzdGVyZnMvUkVBRE1FLm1kI2NyZWF0ZS1hLXBvZFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5HbHVzdGVyZnNWb2x1bWVTb3VyY2UjcGF0aFxuICAgKi9cbiAgcmVhZG9ubHkgcGF0aDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZWFkT25seSBoZXJlIHdpbGwgZm9yY2UgdGhlIEdsdXN0ZXJmcyB2b2x1bWUgdG8gYmUgbW91bnRlZCB3aXRoIHJlYWQtb25seSBwZXJtaXNzaW9ucy4gRGVmYXVsdHMgdG8gZmFsc2UuIE1vcmUgaW5mbzogaHR0cHM6Ly9leGFtcGxlcy5rOHMuaW8vdm9sdW1lcy9nbHVzdGVyZnMvUkVBRE1FLm1kI2NyZWF0ZS1hLXBvZFxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZS4gTW9yZSBpbmZvOiBodHRwczovL2V4YW1wbGVzLms4cy5pby92b2x1bWVzL2dsdXN0ZXJmcy9SRUFETUUubWQjY3JlYXRlLWEtcG9kXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkdsdXN0ZXJmc1ZvbHVtZVNvdXJjZSNyZWFkT25seVxuICAgKi9cbiAgcmVhZG9ubHkgcmVhZE9ubHk/OiBib29sZWFuO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0dsdXN0ZXJmc1ZvbHVtZVNvdXJjZScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fR2x1c3RlcmZzVm9sdW1lU291cmNlKG9iajogR2x1c3RlcmZzVm9sdW1lU291cmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZW5kcG9pbnRzJzogb2JqLmVuZHBvaW50cyxcbiAgICAncGF0aCc6IG9iai5wYXRoLFxuICAgICdyZWFkT25seSc6IG9iai5yZWFkT25seSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElTQ1NJIGRpc2suIElTQ1NJIHZvbHVtZXMgY2FuIG9ubHkgYmUgbW91bnRlZCBhcyByZWFkL3dyaXRlIG9uY2UuIElTQ1NJIHZvbHVtZXMgc3VwcG9ydCBvd25lcnNoaXAgbWFuYWdlbWVudCBhbmQgU0VMaW51eCByZWxhYmVsaW5nLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLklTQ1NJVm9sdW1lU291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSXNjc2lWb2x1bWVTb3VyY2Uge1xuICAvKipcbiAgICogd2hldGhlciBzdXBwb3J0IGlTQ1NJIERpc2NvdmVyeSBDSEFQIGF1dGhlbnRpY2F0aW9uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLklTQ1NJVm9sdW1lU291cmNlI2NoYXBBdXRoRGlzY292ZXJ5XG4gICAqL1xuICByZWFkb25seSBjaGFwQXV0aERpc2NvdmVyeT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHdoZXRoZXIgc3VwcG9ydCBpU0NTSSBTZXNzaW9uIENIQVAgYXV0aGVudGljYXRpb25cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuSVNDU0lWb2x1bWVTb3VyY2UjY2hhcEF1dGhTZXNzaW9uXG4gICAqL1xuICByZWFkb25seSBjaGFwQXV0aFNlc3Npb24/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBGaWxlc3lzdGVtIHR5cGUgb2YgdGhlIHZvbHVtZSB0aGF0IHlvdSB3YW50IHRvIG1vdW50LiBUaXA6IEVuc3VyZSB0aGF0IHRoZSBmaWxlc3lzdGVtIHR5cGUgaXMgc3VwcG9ydGVkIGJ5IHRoZSBob3N0IG9wZXJhdGluZyBzeXN0ZW0uIEV4YW1wbGVzOiBcImV4dDRcIiwgXCJ4ZnNcIiwgXCJudGZzXCIuIEltcGxpY2l0bHkgaW5mZXJyZWQgdG8gYmUgXCJleHQ0XCIgaWYgdW5zcGVjaWZpZWQuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvc3RvcmFnZS92b2x1bWVzI2lzY3NpXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLklTQ1NJVm9sdW1lU291cmNlI2ZzVHlwZVxuICAgKi9cbiAgcmVhZG9ubHkgZnNUeXBlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDdXN0b20gaVNDU0kgSW5pdGlhdG9yIE5hbWUuIElmIGluaXRpYXRvck5hbWUgaXMgc3BlY2lmaWVkIHdpdGggaXNjc2lJbnRlcmZhY2Ugc2ltdWx0YW5lb3VzbHksIG5ldyBpU0NTSSBpbnRlcmZhY2UgPHRhcmdldCBwb3J0YWw+Ojx2b2x1bWUgbmFtZT4gd2lsbCBiZSBjcmVhdGVkIGZvciB0aGUgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuSVNDU0lWb2x1bWVTb3VyY2UjaW5pdGlhdG9yTmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgaW5pdGlhdG9yTmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogVGFyZ2V0IGlTQ1NJIFF1YWxpZmllZCBOYW1lLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5JU0NTSVZvbHVtZVNvdXJjZSNpcW5cbiAgICovXG4gIHJlYWRvbmx5IGlxbjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBpU0NTSSBJbnRlcmZhY2UgTmFtZSB0aGF0IHVzZXMgYW4gaVNDU0kgdHJhbnNwb3J0LiBEZWZhdWx0cyB0byAnZGVmYXVsdCcgKHRjcCkuXG4gICAqXG4gICAqIEBkZWZhdWx0IGRlZmF1bHQnICh0Y3ApLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5JU0NTSVZvbHVtZVNvdXJjZSNpc2NzaUludGVyZmFjZVxuICAgKi9cbiAgcmVhZG9ubHkgaXNjc2lJbnRlcmZhY2U/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGlTQ1NJIFRhcmdldCBMdW4gbnVtYmVyLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5JU0NTSVZvbHVtZVNvdXJjZSNsdW5cbiAgICovXG4gIHJlYWRvbmx5IGx1bjogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBpU0NTSSBUYXJnZXQgUG9ydGFsIExpc3QuIFRoZSBwb3J0YWwgaXMgZWl0aGVyIGFuIElQIG9yIGlwX2FkZHI6cG9ydCBpZiB0aGUgcG9ydCBpcyBvdGhlciB0aGFuIGRlZmF1bHQgKHR5cGljYWxseSBUQ1AgcG9ydHMgODYwIGFuZCAzMjYwKS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuSVNDU0lWb2x1bWVTb3VyY2UjcG9ydGFsc1xuICAgKi9cbiAgcmVhZG9ubHkgcG9ydGFscz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBSZWFkT25seSBoZXJlIHdpbGwgZm9yY2UgdGhlIFJlYWRPbmx5IHNldHRpbmcgaW4gVm9sdW1lTW91bnRzLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2UuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLklTQ1NJVm9sdW1lU291cmNlI3JlYWRPbmx5XG4gICAqL1xuICByZWFkb25seSByZWFkT25seT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIENIQVAgU2VjcmV0IGZvciBpU0NTSSB0YXJnZXQgYW5kIGluaXRpYXRvciBhdXRoZW50aWNhdGlvblxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5JU0NTSVZvbHVtZVNvdXJjZSNzZWNyZXRSZWZcbiAgICovXG4gIHJlYWRvbmx5IHNlY3JldFJlZj86IExvY2FsT2JqZWN0UmVmZXJlbmNlO1xuXG4gIC8qKlxuICAgKiBpU0NTSSBUYXJnZXQgUG9ydGFsLiBUaGUgUG9ydGFsIGlzIGVpdGhlciBhbiBJUCBvciBpcF9hZGRyOnBvcnQgaWYgdGhlIHBvcnQgaXMgb3RoZXIgdGhhbiBkZWZhdWx0ICh0eXBpY2FsbHkgVENQIHBvcnRzIDg2MCBhbmQgMzI2MCkuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLklTQ1NJVm9sdW1lU291cmNlI3RhcmdldFBvcnRhbFxuICAgKi9cbiAgcmVhZG9ubHkgdGFyZ2V0UG9ydGFsOiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnSXNjc2lWb2x1bWVTb3VyY2UnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0lzY3NpVm9sdW1lU291cmNlKG9iajogSXNjc2lWb2x1bWVTb3VyY2UgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdjaGFwQXV0aERpc2NvdmVyeSc6IG9iai5jaGFwQXV0aERpc2NvdmVyeSxcbiAgICAnY2hhcEF1dGhTZXNzaW9uJzogb2JqLmNoYXBBdXRoU2Vzc2lvbixcbiAgICAnZnNUeXBlJzogb2JqLmZzVHlwZSxcbiAgICAnaW5pdGlhdG9yTmFtZSc6IG9iai5pbml0aWF0b3JOYW1lLFxuICAgICdpcW4nOiBvYmouaXFuLFxuICAgICdpc2NzaUludGVyZmFjZSc6IG9iai5pc2NzaUludGVyZmFjZSxcbiAgICAnbHVuJzogb2JqLmx1bixcbiAgICAncG9ydGFscyc6IG9iai5wb3J0YWxzPy5tYXAoeSA9PiB5KSxcbiAgICAncmVhZE9ubHknOiBvYmoucmVhZE9ubHksXG4gICAgJ3NlY3JldFJlZic6IHRvSnNvbl9Mb2NhbE9iamVjdFJlZmVyZW5jZShvYmouc2VjcmV0UmVmKSxcbiAgICAndGFyZ2V0UG9ydGFsJzogb2JqLnRhcmdldFBvcnRhbCxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBQZXJzaXN0ZW50Vm9sdW1lQ2xhaW1Wb2x1bWVTb3VyY2UgcmVmZXJlbmNlcyB0aGUgdXNlcidzIFBWQyBpbiB0aGUgc2FtZSBuYW1lc3BhY2UuIFRoaXMgdm9sdW1lIGZpbmRzIHRoZSBib3VuZCBQViBhbmQgbW91bnRzIHRoYXQgdm9sdW1lIGZvciB0aGUgcG9kLiBBIFBlcnNpc3RlbnRWb2x1bWVDbGFpbVZvbHVtZVNvdXJjZSBpcywgZXNzZW50aWFsbHksIGEgd3JhcHBlciBhcm91bmQgYW5vdGhlciB0eXBlIG9mIHZvbHVtZSB0aGF0IGlzIG93bmVkIGJ5IHNvbWVvbmUgZWxzZSAodGhlIHN5c3RlbSkuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZUNsYWltVm9sdW1lU291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGVyc2lzdGVudFZvbHVtZUNsYWltVm9sdW1lU291cmNlIHtcbiAgLyoqXG4gICAqIENsYWltTmFtZSBpcyB0aGUgbmFtZSBvZiBhIFBlcnNpc3RlbnRWb2x1bWVDbGFpbSBpbiB0aGUgc2FtZSBuYW1lc3BhY2UgYXMgdGhlIHBvZCB1c2luZyB0aGlzIHZvbHVtZS4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3BlcnNpc3RlbnQtdm9sdW1lcyNwZXJzaXN0ZW50dm9sdW1lY2xhaW1zXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVDbGFpbVZvbHVtZVNvdXJjZSNjbGFpbU5hbWVcbiAgICovXG4gIHJlYWRvbmx5IGNsYWltTmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXaWxsIGZvcmNlIHRoZSBSZWFkT25seSBzZXR0aW5nIGluIFZvbHVtZU1vdW50cy4gRGVmYXVsdCBmYWxzZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZUNsYWltVm9sdW1lU291cmNlI3JlYWRPbmx5XG4gICAqL1xuICByZWFkb25seSByZWFkT25seT86IGJvb2xlYW47XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnUGVyc2lzdGVudFZvbHVtZUNsYWltVm9sdW1lU291cmNlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9QZXJzaXN0ZW50Vm9sdW1lQ2xhaW1Wb2x1bWVTb3VyY2Uob2JqOiBQZXJzaXN0ZW50Vm9sdW1lQ2xhaW1Wb2x1bWVTb3VyY2UgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdjbGFpbU5hbWUnOiBvYmouY2xhaW1OYW1lLFxuICAgICdyZWFkT25seSc6IG9iai5yZWFkT25seSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcHJvamVjdGVkIHZvbHVtZSBzb3VyY2VcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qcm9qZWN0ZWRWb2x1bWVTb3VyY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9qZWN0ZWRWb2x1bWVTb3VyY2Uge1xuICAvKipcbiAgICogTW9kZSBiaXRzIHVzZWQgdG8gc2V0IHBlcm1pc3Npb25zIG9uIGNyZWF0ZWQgZmlsZXMgYnkgZGVmYXVsdC4gTXVzdCBiZSBhbiBvY3RhbCB2YWx1ZSBiZXR3ZWVuIDAwMDAgYW5kIDA3Nzcgb3IgYSBkZWNpbWFsIHZhbHVlIGJldHdlZW4gMCBhbmQgNTExLiBZQU1MIGFjY2VwdHMgYm90aCBvY3RhbCBhbmQgZGVjaW1hbCB2YWx1ZXMsIEpTT04gcmVxdWlyZXMgZGVjaW1hbCB2YWx1ZXMgZm9yIG1vZGUgYml0cy4gRGlyZWN0b3JpZXMgd2l0aGluIHRoZSBwYXRoIGFyZSBub3QgYWZmZWN0ZWQgYnkgdGhpcyBzZXR0aW5nLiBUaGlzIG1pZ2h0IGJlIGluIGNvbmZsaWN0IHdpdGggb3RoZXIgb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgZmlsZSBtb2RlLCBsaWtlIGZzR3JvdXAsIGFuZCB0aGUgcmVzdWx0IGNhbiBiZSBvdGhlciBtb2RlIGJpdHMgc2V0LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qcm9qZWN0ZWRWb2x1bWVTb3VyY2UjZGVmYXVsdE1vZGVcbiAgICovXG4gIHJlYWRvbmx5IGRlZmF1bHRNb2RlPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBsaXN0IG9mIHZvbHVtZSBwcm9qZWN0aW9uc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qcm9qZWN0ZWRWb2x1bWVTb3VyY2Ujc291cmNlc1xuICAgKi9cbiAgcmVhZG9ubHkgc291cmNlcz86IFZvbHVtZVByb2plY3Rpb25bXTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdQcm9qZWN0ZWRWb2x1bWVTb3VyY2UnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1Byb2plY3RlZFZvbHVtZVNvdXJjZShvYmo6IFByb2plY3RlZFZvbHVtZVNvdXJjZSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2RlZmF1bHRNb2RlJzogb2JqLmRlZmF1bHRNb2RlLFxuICAgICdzb3VyY2VzJzogb2JqLnNvdXJjZXM/Lm1hcCh5ID0+IHRvSnNvbl9Wb2x1bWVQcm9qZWN0aW9uKHkpKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgUmFkb3MgQmxvY2sgRGV2aWNlIG1vdW50IHRoYXQgbGFzdHMgdGhlIGxpZmV0aW1lIG9mIGEgcG9kLiBSQkQgdm9sdW1lcyBzdXBwb3J0IG93bmVyc2hpcCBtYW5hZ2VtZW50IGFuZCBTRUxpbnV4IHJlbGFiZWxpbmcuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUkJEVm9sdW1lU291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmJkVm9sdW1lU291cmNlIHtcbiAgLyoqXG4gICAqIEZpbGVzeXN0ZW0gdHlwZSBvZiB0aGUgdm9sdW1lIHRoYXQgeW91IHdhbnQgdG8gbW91bnQuIFRpcDogRW5zdXJlIHRoYXQgdGhlIGZpbGVzeXN0ZW0gdHlwZSBpcyBzdXBwb3J0ZWQgYnkgdGhlIGhvc3Qgb3BlcmF0aW5nIHN5c3RlbS4gRXhhbXBsZXM6IFwiZXh0NFwiLCBcInhmc1wiLCBcIm50ZnNcIi4gSW1wbGljaXRseSBpbmZlcnJlZCB0byBiZSBcImV4dDRcIiBpZiB1bnNwZWNpZmllZC4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3ZvbHVtZXMjcmJkXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlJCRFZvbHVtZVNvdXJjZSNmc1R5cGVcbiAgICovXG4gIHJlYWRvbmx5IGZzVHlwZT86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHJhZG9zIGltYWdlIG5hbWUuIE1vcmUgaW5mbzogaHR0cHM6Ly9leGFtcGxlcy5rOHMuaW8vdm9sdW1lcy9yYmQvUkVBRE1FLm1kI2hvdy10by11c2UtaXRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUkJEVm9sdW1lU291cmNlI2ltYWdlXG4gICAqL1xuICByZWFkb25seSBpbWFnZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBLZXlyaW5nIGlzIHRoZSBwYXRoIHRvIGtleSByaW5nIGZvciBSQkRVc2VyLiBEZWZhdWx0IGlzIC9ldGMvY2VwaC9rZXlyaW5nLiBNb3JlIGluZm86IGh0dHBzOi8vZXhhbXBsZXMuazhzLmlvL3ZvbHVtZXMvcmJkL1JFQURNRS5tZCNob3ctdG8tdXNlLWl0XG4gICAqXG4gICAqIEBkZWZhdWx0IGV0Yy9jZXBoL2tleXJpbmcuIE1vcmUgaW5mbzogaHR0cHM6Ly9leGFtcGxlcy5rOHMuaW8vdm9sdW1lcy9yYmQvUkVBRE1FLm1kI2hvdy10by11c2UtaXRcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUkJEVm9sdW1lU291cmNlI2tleXJpbmdcbiAgICovXG4gIHJlYWRvbmx5IGtleXJpbmc/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgY29sbGVjdGlvbiBvZiBDZXBoIG1vbml0b3JzLiBNb3JlIGluZm86IGh0dHBzOi8vZXhhbXBsZXMuazhzLmlvL3ZvbHVtZXMvcmJkL1JFQURNRS5tZCNob3ctdG8tdXNlLWl0XG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlJCRFZvbHVtZVNvdXJjZSNtb25pdG9yc1xuICAgKi9cbiAgcmVhZG9ubHkgbW9uaXRvcnM6IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBUaGUgcmFkb3MgcG9vbCBuYW1lLiBEZWZhdWx0IGlzIHJiZC4gTW9yZSBpbmZvOiBodHRwczovL2V4YW1wbGVzLms4cy5pby92b2x1bWVzL3JiZC9SRUFETUUubWQjaG93LXRvLXVzZS1pdFxuICAgKlxuICAgKiBAZGVmYXVsdCByYmQuIE1vcmUgaW5mbzogaHR0cHM6Ly9leGFtcGxlcy5rOHMuaW8vdm9sdW1lcy9yYmQvUkVBRE1FLm1kI2hvdy10by11c2UtaXRcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUkJEVm9sdW1lU291cmNlI3Bvb2xcbiAgICovXG4gIHJlYWRvbmx5IHBvb2w/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFJlYWRPbmx5IGhlcmUgd2lsbCBmb3JjZSB0aGUgUmVhZE9ubHkgc2V0dGluZyBpbiBWb2x1bWVNb3VudHMuIERlZmF1bHRzIHRvIGZhbHNlLiBNb3JlIGluZm86IGh0dHBzOi8vZXhhbXBsZXMuazhzLmlvL3ZvbHVtZXMvcmJkL1JFQURNRS5tZCNob3ctdG8tdXNlLWl0XG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlLiBNb3JlIGluZm86IGh0dHBzOi8vZXhhbXBsZXMuazhzLmlvL3ZvbHVtZXMvcmJkL1JFQURNRS5tZCNob3ctdG8tdXNlLWl0XG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlJCRFZvbHVtZVNvdXJjZSNyZWFkT25seVxuICAgKi9cbiAgcmVhZG9ubHkgcmVhZE9ubHk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBTZWNyZXRSZWYgaXMgbmFtZSBvZiB0aGUgYXV0aGVudGljYXRpb24gc2VjcmV0IGZvciBSQkRVc2VyLiBJZiBwcm92aWRlZCBvdmVycmlkZXMga2V5cmluZy4gRGVmYXVsdCBpcyBuaWwuIE1vcmUgaW5mbzogaHR0cHM6Ly9leGFtcGxlcy5rOHMuaW8vdm9sdW1lcy9yYmQvUkVBRE1FLm1kI2hvdy10by11c2UtaXRcbiAgICpcbiAgICogQGRlZmF1bHQgbmlsLiBNb3JlIGluZm86IGh0dHBzOi8vZXhhbXBsZXMuazhzLmlvL3ZvbHVtZXMvcmJkL1JFQURNRS5tZCNob3ctdG8tdXNlLWl0XG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlJCRFZvbHVtZVNvdXJjZSNzZWNyZXRSZWZcbiAgICovXG4gIHJlYWRvbmx5IHNlY3JldFJlZj86IExvY2FsT2JqZWN0UmVmZXJlbmNlO1xuXG4gIC8qKlxuICAgKiBUaGUgcmFkb3MgdXNlciBuYW1lLiBEZWZhdWx0IGlzIGFkbWluLiBNb3JlIGluZm86IGh0dHBzOi8vZXhhbXBsZXMuazhzLmlvL3ZvbHVtZXMvcmJkL1JFQURNRS5tZCNob3ctdG8tdXNlLWl0XG4gICAqXG4gICAqIEBkZWZhdWx0IGFkbWluLiBNb3JlIGluZm86IGh0dHBzOi8vZXhhbXBsZXMuazhzLmlvL3ZvbHVtZXMvcmJkL1JFQURNRS5tZCNob3ctdG8tdXNlLWl0XG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlJCRFZvbHVtZVNvdXJjZSN1c2VyXG4gICAqL1xuICByZWFkb25seSB1c2VyPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1JiZFZvbHVtZVNvdXJjZScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fUmJkVm9sdW1lU291cmNlKG9iajogUmJkVm9sdW1lU291cmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZnNUeXBlJzogb2JqLmZzVHlwZSxcbiAgICAnaW1hZ2UnOiBvYmouaW1hZ2UsXG4gICAgJ2tleXJpbmcnOiBvYmoua2V5cmluZyxcbiAgICAnbW9uaXRvcnMnOiBvYmoubW9uaXRvcnM/Lm1hcCh5ID0+IHkpLFxuICAgICdwb29sJzogb2JqLnBvb2wsXG4gICAgJ3JlYWRPbmx5Jzogb2JqLnJlYWRPbmx5LFxuICAgICdzZWNyZXRSZWYnOiB0b0pzb25fTG9jYWxPYmplY3RSZWZlcmVuY2Uob2JqLnNlY3JldFJlZiksXG4gICAgJ3VzZXInOiBvYmoudXNlcixcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBTY2FsZUlPVm9sdW1lU291cmNlIHJlcHJlc2VudHMgYSBwZXJzaXN0ZW50IFNjYWxlSU8gdm9sdW1lXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2NhbGVJT1ZvbHVtZVNvdXJjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNjYWxlSW9Wb2x1bWVTb3VyY2Uge1xuICAvKipcbiAgICogRmlsZXN5c3RlbSB0eXBlIHRvIG1vdW50LiBNdXN0IGJlIGEgZmlsZXN5c3RlbSB0eXBlIHN1cHBvcnRlZCBieSB0aGUgaG9zdCBvcGVyYXRpbmcgc3lzdGVtLiBFeC4gXCJleHQ0XCIsIFwieGZzXCIsIFwibnRmc1wiLiBEZWZhdWx0IGlzIFwieGZzXCIuXG4gICAqXG4gICAqIEBkZWZhdWx0IHhmc1wiLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TY2FsZUlPVm9sdW1lU291cmNlI2ZzVHlwZVxuICAgKi9cbiAgcmVhZG9ubHkgZnNUeXBlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaG9zdCBhZGRyZXNzIG9mIHRoZSBTY2FsZUlPIEFQSSBHYXRld2F5LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TY2FsZUlPVm9sdW1lU291cmNlI2dhdGV3YXlcbiAgICovXG4gIHJlYWRvbmx5IGdhdGV3YXk6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIFNjYWxlSU8gUHJvdGVjdGlvbiBEb21haW4gZm9yIHRoZSBjb25maWd1cmVkIHN0b3JhZ2UuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNjYWxlSU9Wb2x1bWVTb3VyY2UjcHJvdGVjdGlvbkRvbWFpblxuICAgKi9cbiAgcmVhZG9ubHkgcHJvdGVjdGlvbkRvbWFpbj86IHN0cmluZztcblxuICAvKipcbiAgICogRGVmYXVsdHMgdG8gZmFsc2UgKHJlYWQvd3JpdGUpLiBSZWFkT25seSBoZXJlIHdpbGwgZm9yY2UgdGhlIFJlYWRPbmx5IHNldHRpbmcgaW4gVm9sdW1lTW91bnRzLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZSAocmVhZC93cml0ZSkuIFJlYWRPbmx5IGhlcmUgd2lsbCBmb3JjZSB0aGUgUmVhZE9ubHkgc2V0dGluZyBpbiBWb2x1bWVNb3VudHMuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNjYWxlSU9Wb2x1bWVTb3VyY2UjcmVhZE9ubHlcbiAgICovXG4gIHJlYWRvbmx5IHJlYWRPbmx5PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogU2VjcmV0UmVmIHJlZmVyZW5jZXMgdG8gdGhlIHNlY3JldCBmb3IgU2NhbGVJTyB1c2VyIGFuZCBvdGhlciBzZW5zaXRpdmUgaW5mb3JtYXRpb24uIElmIHRoaXMgaXMgbm90IHByb3ZpZGVkLCBMb2dpbiBvcGVyYXRpb24gd2lsbCBmYWlsLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TY2FsZUlPVm9sdW1lU291cmNlI3NlY3JldFJlZlxuICAgKi9cbiAgcmVhZG9ubHkgc2VjcmV0UmVmOiBMb2NhbE9iamVjdFJlZmVyZW5jZTtcblxuICAvKipcbiAgICogRmxhZyB0byBlbmFibGUvZGlzYWJsZSBTU0wgY29tbXVuaWNhdGlvbiB3aXRoIEdhdGV3YXksIGRlZmF1bHQgZmFsc2VcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2NhbGVJT1ZvbHVtZVNvdXJjZSNzc2xFbmFibGVkXG4gICAqL1xuICByZWFkb25seSBzc2xFbmFibGVkPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN0b3JhZ2UgZm9yIGEgdm9sdW1lIHNob3VsZCBiZSBUaGlja1Byb3Zpc2lvbmVkIG9yIFRoaW5Qcm92aXNpb25lZC4gRGVmYXVsdCBpcyBUaGluUHJvdmlzaW9uZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IFRoaW5Qcm92aXNpb25lZC5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2NhbGVJT1ZvbHVtZVNvdXJjZSNzdG9yYWdlTW9kZVxuICAgKi9cbiAgcmVhZG9ubHkgc3RvcmFnZU1vZGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBTY2FsZUlPIFN0b3JhZ2UgUG9vbCBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3RlY3Rpb24gZG9tYWluLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TY2FsZUlPVm9sdW1lU291cmNlI3N0b3JhZ2VQb29sXG4gICAqL1xuICByZWFkb25seSBzdG9yYWdlUG9vbD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHN0b3JhZ2Ugc3lzdGVtIGFzIGNvbmZpZ3VyZWQgaW4gU2NhbGVJTy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2NhbGVJT1ZvbHVtZVNvdXJjZSNzeXN0ZW1cbiAgICovXG4gIHJlYWRvbmx5IHN5c3RlbTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiBhIHZvbHVtZSBhbHJlYWR5IGNyZWF0ZWQgaW4gdGhlIFNjYWxlSU8gc3lzdGVtIHRoYXQgaXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdm9sdW1lIHNvdXJjZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2NhbGVJT1ZvbHVtZVNvdXJjZSN2b2x1bWVOYW1lXG4gICAqL1xuICByZWFkb25seSB2b2x1bWVOYW1lPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1NjYWxlSW9Wb2x1bWVTb3VyY2UnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1NjYWxlSW9Wb2x1bWVTb3VyY2Uob2JqOiBTY2FsZUlvVm9sdW1lU291cmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZnNUeXBlJzogb2JqLmZzVHlwZSxcbiAgICAnZ2F0ZXdheSc6IG9iai5nYXRld2F5LFxuICAgICdwcm90ZWN0aW9uRG9tYWluJzogb2JqLnByb3RlY3Rpb25Eb21haW4sXG4gICAgJ3JlYWRPbmx5Jzogb2JqLnJlYWRPbmx5LFxuICAgICdzZWNyZXRSZWYnOiB0b0pzb25fTG9jYWxPYmplY3RSZWZlcmVuY2Uob2JqLnNlY3JldFJlZiksXG4gICAgJ3NzbEVuYWJsZWQnOiBvYmouc3NsRW5hYmxlZCxcbiAgICAnc3RvcmFnZU1vZGUnOiBvYmouc3RvcmFnZU1vZGUsXG4gICAgJ3N0b3JhZ2VQb29sJzogb2JqLnN0b3JhZ2VQb29sLFxuICAgICdzeXN0ZW0nOiBvYmouc3lzdGVtLFxuICAgICd2b2x1bWVOYW1lJzogb2JqLnZvbHVtZU5hbWUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQWRhcHRzIGEgU2VjcmV0IGludG8gYSB2b2x1bWUuXG4gKlxuICogVGhlIGNvbnRlbnRzIG9mIHRoZSB0YXJnZXQgU2VjcmV0J3MgRGF0YSBmaWVsZCB3aWxsIGJlIHByZXNlbnRlZCBpbiBhIHZvbHVtZSBhcyBmaWxlcyB1c2luZyB0aGUga2V5cyBpbiB0aGUgRGF0YSBmaWVsZCBhcyB0aGUgZmlsZSBuYW1lcy4gU2VjcmV0IHZvbHVtZXMgc3VwcG9ydCBvd25lcnNoaXAgbWFuYWdlbWVudCBhbmQgU0VMaW51eCByZWxhYmVsaW5nLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlY3JldFZvbHVtZVNvdXJjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlY3JldFZvbHVtZVNvdXJjZSB7XG4gIC8qKlxuICAgKiBPcHRpb25hbDogbW9kZSBiaXRzIHVzZWQgdG8gc2V0IHBlcm1pc3Npb25zIG9uIGNyZWF0ZWQgZmlsZXMgYnkgZGVmYXVsdC4gTXVzdCBiZSBhbiBvY3RhbCB2YWx1ZSBiZXR3ZWVuIDAwMDAgYW5kIDA3Nzcgb3IgYSBkZWNpbWFsIHZhbHVlIGJldHdlZW4gMCBhbmQgNTExLiBZQU1MIGFjY2VwdHMgYm90aCBvY3RhbCBhbmQgZGVjaW1hbCB2YWx1ZXMsIEpTT04gcmVxdWlyZXMgZGVjaW1hbCB2YWx1ZXMgZm9yIG1vZGUgYml0cy4gRGVmYXVsdHMgdG8gMDY0NC4gRGlyZWN0b3JpZXMgd2l0aGluIHRoZSBwYXRoIGFyZSBub3QgYWZmZWN0ZWQgYnkgdGhpcyBzZXR0aW5nLiBUaGlzIG1pZ2h0IGJlIGluIGNvbmZsaWN0IHdpdGggb3RoZXIgb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgZmlsZSBtb2RlLCBsaWtlIGZzR3JvdXAsIGFuZCB0aGUgcmVzdWx0IGNhbiBiZSBvdGhlciBtb2RlIGJpdHMgc2V0LlxuICAgKlxuICAgKiBAZGVmYXVsdCAwNjQ0LiBEaXJlY3RvcmllcyB3aXRoaW4gdGhlIHBhdGggYXJlIG5vdCBhZmZlY3RlZCBieSB0aGlzIHNldHRpbmcuIFRoaXMgbWlnaHQgYmUgaW4gY29uZmxpY3Qgd2l0aCBvdGhlciBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBmaWxlIG1vZGUsIGxpa2UgZnNHcm91cCwgYW5kIHRoZSByZXN1bHQgY2FuIGJlIG90aGVyIG1vZGUgYml0cyBzZXQuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlY3JldFZvbHVtZVNvdXJjZSNkZWZhdWx0TW9kZVxuICAgKi9cbiAgcmVhZG9ubHkgZGVmYXVsdE1vZGU/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIElmIHVuc3BlY2lmaWVkLCBlYWNoIGtleS12YWx1ZSBwYWlyIGluIHRoZSBEYXRhIGZpZWxkIG9mIHRoZSByZWZlcmVuY2VkIFNlY3JldCB3aWxsIGJlIHByb2plY3RlZCBpbnRvIHRoZSB2b2x1bWUgYXMgYSBmaWxlIHdob3NlIG5hbWUgaXMgdGhlIGtleSBhbmQgY29udGVudCBpcyB0aGUgdmFsdWUuIElmIHNwZWNpZmllZCwgdGhlIGxpc3RlZCBrZXlzIHdpbGwgYmUgcHJvamVjdGVkIGludG8gdGhlIHNwZWNpZmllZCBwYXRocywgYW5kIHVubGlzdGVkIGtleXMgd2lsbCBub3QgYmUgcHJlc2VudC4gSWYgYSBrZXkgaXMgc3BlY2lmaWVkIHdoaWNoIGlzIG5vdCBwcmVzZW50IGluIHRoZSBTZWNyZXQsIHRoZSB2b2x1bWUgc2V0dXAgd2lsbCBlcnJvciB1bmxlc3MgaXQgaXMgbWFya2VkIG9wdGlvbmFsLiBQYXRocyBtdXN0IGJlIHJlbGF0aXZlIGFuZCBtYXkgbm90IGNvbnRhaW4gdGhlICcuLicgcGF0aCBvciBzdGFydCB3aXRoICcuLicuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlY3JldFZvbHVtZVNvdXJjZSNpdGVtc1xuICAgKi9cbiAgcmVhZG9ubHkgaXRlbXM/OiBLZXlUb1BhdGhbXTtcblxuICAvKipcbiAgICogU3BlY2lmeSB3aGV0aGVyIHRoZSBTZWNyZXQgb3IgaXRzIGtleXMgbXVzdCBiZSBkZWZpbmVkXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlY3JldFZvbHVtZVNvdXJjZSNvcHRpb25hbFxuICAgKi9cbiAgcmVhZG9ubHkgb3B0aW9uYWw/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBzZWNyZXQgaW4gdGhlIHBvZCdzIG5hbWVzcGFjZSB0byB1c2UuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvc3RvcmFnZS92b2x1bWVzI3NlY3JldFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZWNyZXRWb2x1bWVTb3VyY2Ujc2VjcmV0TmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgc2VjcmV0TmFtZT86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdTZWNyZXRWb2x1bWVTb3VyY2UnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1NlY3JldFZvbHVtZVNvdXJjZShvYmo6IFNlY3JldFZvbHVtZVNvdXJjZSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2RlZmF1bHRNb2RlJzogb2JqLmRlZmF1bHRNb2RlLFxuICAgICdpdGVtcyc6IG9iai5pdGVtcz8ubWFwKHkgPT4gdG9Kc29uX0tleVRvUGF0aCh5KSksXG4gICAgJ29wdGlvbmFsJzogb2JqLm9wdGlvbmFsLFxuICAgICdzZWNyZXROYW1lJzogb2JqLnNlY3JldE5hbWUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIFN0b3JhZ2VPUyBwZXJzaXN0ZW50IHZvbHVtZSByZXNvdXJjZS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TdG9yYWdlT1NWb2x1bWVTb3VyY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdG9yYWdlT3NWb2x1bWVTb3VyY2Uge1xuICAvKipcbiAgICogRmlsZXN5c3RlbSB0eXBlIHRvIG1vdW50LiBNdXN0IGJlIGEgZmlsZXN5c3RlbSB0eXBlIHN1cHBvcnRlZCBieSB0aGUgaG9zdCBvcGVyYXRpbmcgc3lzdGVtLiBFeC4gXCJleHQ0XCIsIFwieGZzXCIsIFwibnRmc1wiLiBJbXBsaWNpdGx5IGluZmVycmVkIHRvIGJlIFwiZXh0NFwiIGlmIHVuc3BlY2lmaWVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TdG9yYWdlT1NWb2x1bWVTb3VyY2UjZnNUeXBlXG4gICAqL1xuICByZWFkb25seSBmc1R5cGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIERlZmF1bHRzIHRvIGZhbHNlIChyZWFkL3dyaXRlKS4gUmVhZE9ubHkgaGVyZSB3aWxsIGZvcmNlIHRoZSBSZWFkT25seSBzZXR0aW5nIGluIFZvbHVtZU1vdW50cy5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2UgKHJlYWQvd3JpdGUpLiBSZWFkT25seSBoZXJlIHdpbGwgZm9yY2UgdGhlIFJlYWRPbmx5IHNldHRpbmcgaW4gVm9sdW1lTW91bnRzLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TdG9yYWdlT1NWb2x1bWVTb3VyY2UjcmVhZE9ubHlcbiAgICovXG4gIHJlYWRvbmx5IHJlYWRPbmx5PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogU2VjcmV0UmVmIHNwZWNpZmllcyB0aGUgc2VjcmV0IHRvIHVzZSBmb3Igb2J0YWluaW5nIHRoZSBTdG9yYWdlT1MgQVBJIGNyZWRlbnRpYWxzLiAgSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdCB2YWx1ZXMgd2lsbCBiZSBhdHRlbXB0ZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlN0b3JhZ2VPU1ZvbHVtZVNvdXJjZSNzZWNyZXRSZWZcbiAgICovXG4gIHJlYWRvbmx5IHNlY3JldFJlZj86IExvY2FsT2JqZWN0UmVmZXJlbmNlO1xuXG4gIC8qKlxuICAgKiBWb2x1bWVOYW1lIGlzIHRoZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBTdG9yYWdlT1Mgdm9sdW1lLiAgVm9sdW1lIG5hbWVzIGFyZSBvbmx5IHVuaXF1ZSB3aXRoaW4gYSBuYW1lc3BhY2UuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlN0b3JhZ2VPU1ZvbHVtZVNvdXJjZSN2b2x1bWVOYW1lXG4gICAqL1xuICByZWFkb25seSB2b2x1bWVOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBWb2x1bWVOYW1lc3BhY2Ugc3BlY2lmaWVzIHRoZSBzY29wZSBvZiB0aGUgdm9sdW1lIHdpdGhpbiBTdG9yYWdlT1MuICBJZiBubyBuYW1lc3BhY2UgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIFBvZCdzIG5hbWVzcGFjZSB3aWxsIGJlIHVzZWQuICBUaGlzIGFsbG93cyB0aGUgS3ViZXJuZXRlcyBuYW1lIHNjb3BpbmcgdG8gYmUgbWlycm9yZWQgd2l0aGluIFN0b3JhZ2VPUyBmb3IgdGlnaHRlciBpbnRlZ3JhdGlvbi4gU2V0IFZvbHVtZU5hbWUgdG8gYW55IG5hbWUgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3VyLiBTZXQgdG8gXCJkZWZhdWx0XCIgaWYgeW91IGFyZSBub3QgdXNpbmcgbmFtZXNwYWNlcyB3aXRoaW4gU3RvcmFnZU9TLiBOYW1lc3BhY2VzIHRoYXQgZG8gbm90IHByZS1leGlzdCB3aXRoaW4gU3RvcmFnZU9TIHdpbGwgYmUgY3JlYXRlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU3RvcmFnZU9TVm9sdW1lU291cmNlI3ZvbHVtZU5hbWVzcGFjZVxuICAgKi9cbiAgcmVhZG9ubHkgdm9sdW1lTmFtZXNwYWNlPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1N0b3JhZ2VPc1ZvbHVtZVNvdXJjZScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fU3RvcmFnZU9zVm9sdW1lU291cmNlKG9iajogU3RvcmFnZU9zVm9sdW1lU291cmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZnNUeXBlJzogb2JqLmZzVHlwZSxcbiAgICAncmVhZE9ubHknOiBvYmoucmVhZE9ubHksXG4gICAgJ3NlY3JldFJlZic6IHRvSnNvbl9Mb2NhbE9iamVjdFJlZmVyZW5jZShvYmouc2VjcmV0UmVmKSxcbiAgICAndm9sdW1lTmFtZSc6IG9iai52b2x1bWVOYW1lLFxuICAgICd2b2x1bWVOYW1lc3BhY2UnOiBvYmoudm9sdW1lTmFtZXNwYWNlLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEEgc2NvcGVkLXJlc291cmNlIHNlbGVjdG9yIHJlcXVpcmVtZW50IGlzIGEgc2VsZWN0b3IgdGhhdCBjb250YWlucyB2YWx1ZXMsIGEgc2NvcGUgbmFtZSwgYW5kIGFuIG9wZXJhdG9yIHRoYXQgcmVsYXRlcyB0aGUgc2NvcGUgbmFtZSBhbmQgdmFsdWVzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNjb3BlZFJlc291cmNlU2VsZWN0b3JSZXF1aXJlbWVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNjb3BlZFJlc291cmNlU2VsZWN0b3JSZXF1aXJlbWVudCB7XG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgc2NvcGUncyByZWxhdGlvbnNoaXAgdG8gYSBzZXQgb2YgdmFsdWVzLiBWYWxpZCBvcGVyYXRvcnMgYXJlIEluLCBOb3RJbiwgRXhpc3RzLCBEb2VzTm90RXhpc3QuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNjb3BlZFJlc291cmNlU2VsZWN0b3JSZXF1aXJlbWVudCNvcGVyYXRvclxuICAgKi9cbiAgcmVhZG9ubHkgb3BlcmF0b3I6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHNjb3BlIHRoYXQgdGhlIHNlbGVjdG9yIGFwcGxpZXMgdG8uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNjb3BlZFJlc291cmNlU2VsZWN0b3JSZXF1aXJlbWVudCNzY29wZU5hbWVcbiAgICovXG4gIHJlYWRvbmx5IHNjb3BlTmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBzdHJpbmcgdmFsdWVzLiBJZiB0aGUgb3BlcmF0b3IgaXMgSW4gb3IgTm90SW4sIHRoZSB2YWx1ZXMgYXJyYXkgbXVzdCBiZSBub24tZW1wdHkuIElmIHRoZSBvcGVyYXRvciBpcyBFeGlzdHMgb3IgRG9lc05vdEV4aXN0LCB0aGUgdmFsdWVzIGFycmF5IG11c3QgYmUgZW1wdHkuIFRoaXMgYXJyYXkgaXMgcmVwbGFjZWQgZHVyaW5nIGEgc3RyYXRlZ2ljIG1lcmdlIHBhdGNoLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TY29wZWRSZXNvdXJjZVNlbGVjdG9yUmVxdWlyZW1lbnQjdmFsdWVzXG4gICAqL1xuICByZWFkb25seSB2YWx1ZXM/OiBzdHJpbmdbXTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdTY29wZWRSZXNvdXJjZVNlbGVjdG9yUmVxdWlyZW1lbnQnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1Njb3BlZFJlc291cmNlU2VsZWN0b3JSZXF1aXJlbWVudChvYmo6IFNjb3BlZFJlc291cmNlU2VsZWN0b3JSZXF1aXJlbWVudCB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ29wZXJhdG9yJzogb2JqLm9wZXJhdG9yLFxuICAgICdzY29wZU5hbWUnOiBvYmouc2NvcGVOYW1lLFxuICAgICd2YWx1ZXMnOiBvYmoudmFsdWVzPy5tYXAoeSA9PiB5KSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBDbGllbnRJUENvbmZpZyByZXByZXNlbnRzIHRoZSBjb25maWd1cmF0aW9ucyBvZiBDbGllbnQgSVAgYmFzZWQgc2Vzc2lvbiBhZmZpbml0eS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5DbGllbnRJUENvbmZpZ1xuICovXG5leHBvcnQgaW50ZXJmYWNlIENsaWVudElwQ29uZmlnIHtcbiAgLyoqXG4gICAqIHRpbWVvdXRTZWNvbmRzIHNwZWNpZmllcyB0aGUgc2Vjb25kcyBvZiBDbGllbnRJUCB0eXBlIHNlc3Npb24gc3RpY2t5IHRpbWUuIFRoZSB2YWx1ZSBtdXN0IGJlID4wICYmIDw9ODY0MDAoZm9yIDEgZGF5KSBpZiBTZXJ2aWNlQWZmaW5pdHkgPT0gXCJDbGllbnRJUFwiLiBEZWZhdWx0IHZhbHVlIGlzIDEwODAwKGZvciAzIGhvdXJzKS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ2xpZW50SVBDb25maWcjdGltZW91dFNlY29uZHNcbiAgICovXG4gIHJlYWRvbmx5IHRpbWVvdXRTZWNvbmRzPzogbnVtYmVyO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0NsaWVudElwQ29uZmlnJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9DbGllbnRJcENvbmZpZyhvYmo6IENsaWVudElwQ29uZmlnIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAndGltZW91dFNlY29uZHMnOiBvYmoudGltZW91dFNlY29uZHMsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogRm9yWm9uZSBwcm92aWRlcyBpbmZvcm1hdGlvbiBhYm91dCB3aGljaCB6b25lcyBzaG91bGQgY29uc3VtZSB0aGlzIGVuZHBvaW50LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5kaXNjb3ZlcnkudjEuRm9yWm9uZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZvclpvbmUge1xuICAvKipcbiAgICogbmFtZSByZXByZXNlbnRzIHRoZSBuYW1lIG9mIHRoZSB6b25lLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZGlzY292ZXJ5LnYxLkZvclpvbmUjbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0ZvclpvbmUnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0ZvclpvbmUob2JqOiBGb3Jab25lIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbmFtZSc6IG9iai5uYW1lLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEZvclpvbmUgcHJvdmlkZXMgaW5mb3JtYXRpb24gYWJvdXQgd2hpY2ggem9uZXMgc2hvdWxkIGNvbnN1bWUgdGhpcyBlbmRwb2ludC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuZGlzY292ZXJ5LnYxYmV0YTEuRm9yWm9uZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZvclpvbmVWMUJldGExIHtcbiAgLyoqXG4gICAqIG5hbWUgcmVwcmVzZW50cyB0aGUgbmFtZSBvZiB0aGUgem9uZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmRpc2NvdmVyeS52MWJldGExLkZvclpvbmUjbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0ZvclpvbmVWMUJldGExJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Gb3Jab25lVjFCZXRhMShvYmo6IEZvclpvbmVWMUJldGExIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbmFtZSc6IG9iai5uYW1lLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIE5vblJlc291cmNlUG9saWN5UnVsZSBpcyBhIHByZWRpY2F0ZSB0aGF0IG1hdGNoZXMgbm9uLXJlc291cmNlIHJlcXVlc3RzIGFjY29yZGluZyB0byB0aGVpciB2ZXJiIGFuZCB0aGUgdGFyZ2V0IG5vbi1yZXNvdXJjZSBVUkwuIEEgTm9uUmVzb3VyY2VQb2xpY3lSdWxlIG1hdGNoZXMgYSByZXF1ZXN0IGlmIGFuZCBvbmx5IGlmIGJvdGggKGEpIGF0IGxlYXN0IG9uZSBtZW1iZXIgb2YgdmVyYnMgbWF0Y2hlcyB0aGUgcmVxdWVzdCBhbmQgKGIpIGF0IGxlYXN0IG9uZSBtZW1iZXIgb2Ygbm9uUmVzb3VyY2VVUkxzIG1hdGNoZXMgdGhlIHJlcXVlc3QuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuTm9uUmVzb3VyY2VQb2xpY3lSdWxlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTm9uUmVzb3VyY2VQb2xpY3lSdWxlVjFCZXRhMSB7XG4gIC8qKlxuICAgKiBgbm9uUmVzb3VyY2VVUkxzYCBpcyBhIHNldCBvZiB1cmwgcHJlZml4ZXMgdGhhdCBhIHVzZXIgc2hvdWxkIGhhdmUgYWNjZXNzIHRvIGFuZCBtYXkgbm90IGJlIGVtcHR5LiBGb3IgZXhhbXBsZTpcbiAgICogLSBcIi9oZWFsdGh6XCIgaXMgbGVnYWxcbiAgICogLSBcIi9oZWEqXCIgaXMgaWxsZWdhbFxuICAgKiAtIFwiL2hlYVwiIGlzIGxlZ2FsIGJ1dCBtYXRjaGVzIG5vdGhpbmdcbiAgICogLSBcIi9oZWEvKlwiIGFsc28gbWF0Y2hlcyBub3RoaW5nXG4gICAqIC0gXCIvaGVhbHRoei8qXCIgbWF0Y2hlcyBhbGwgcGVyLWNvbXBvbmVudCBoZWFsdGggY2hlY2tzLlxuICAgKiBcIipcIiBtYXRjaGVzIGFsbCBub24tcmVzb3VyY2UgdXJscy4gaWYgaXQgaXMgcHJlc2VudCwgaXQgbXVzdCBiZSB0aGUgb25seSBlbnRyeS4gUmVxdWlyZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLk5vblJlc291cmNlUG9saWN5UnVsZSNub25SZXNvdXJjZVVSTHNcbiAgICovXG4gIHJlYWRvbmx5IG5vblJlc291cmNlVXJMczogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIGB2ZXJic2AgaXMgYSBsaXN0IG9mIG1hdGNoaW5nIHZlcmJzIGFuZCBtYXkgbm90IGJlIGVtcHR5LiBcIipcIiBtYXRjaGVzIGFsbCB2ZXJicy4gSWYgaXQgaXMgcHJlc2VudCwgaXQgbXVzdCBiZSB0aGUgb25seSBlbnRyeS4gUmVxdWlyZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLk5vblJlc291cmNlUG9saWN5UnVsZSN2ZXJic1xuICAgKi9cbiAgcmVhZG9ubHkgdmVyYnM6IHN0cmluZ1tdO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ05vblJlc291cmNlUG9saWN5UnVsZVYxQmV0YTEnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX05vblJlc291cmNlUG9saWN5UnVsZVYxQmV0YTEob2JqOiBOb25SZXNvdXJjZVBvbGljeVJ1bGVWMUJldGExIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbm9uUmVzb3VyY2VVUkxzJzogb2JqLm5vblJlc291cmNlVXJMcz8ubWFwKHkgPT4geSksXG4gICAgJ3ZlcmJzJzogb2JqLnZlcmJzPy5tYXAoeSA9PiB5KSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBSZXNvdXJjZVBvbGljeVJ1bGUgaXMgYSBwcmVkaWNhdGUgdGhhdCBtYXRjaGVzIHNvbWUgcmVzb3VyY2UgcmVxdWVzdHMsIHRlc3RpbmcgdGhlIHJlcXVlc3QncyB2ZXJiIGFuZCB0aGUgdGFyZ2V0IHJlc291cmNlLiBBIFJlc291cmNlUG9saWN5UnVsZSBtYXRjaGVzIGEgcmVzb3VyY2UgcmVxdWVzdCBpZiBhbmQgb25seSBpZjogKGEpIGF0IGxlYXN0IG9uZSBtZW1iZXIgb2YgdmVyYnMgbWF0Y2hlcyB0aGUgcmVxdWVzdCwgKGIpIGF0IGxlYXN0IG9uZSBtZW1iZXIgb2YgYXBpR3JvdXBzIG1hdGNoZXMgdGhlIHJlcXVlc3QsIChjKSBhdCBsZWFzdCBvbmUgbWVtYmVyIG9mIHJlc291cmNlcyBtYXRjaGVzIHRoZSByZXF1ZXN0LCBhbmQgKGQpIGxlYXN0IG9uZSBtZW1iZXIgb2YgbmFtZXNwYWNlcyBtYXRjaGVzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLlJlc291cmNlUG9saWN5UnVsZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc291cmNlUG9saWN5UnVsZVYxQmV0YTEge1xuICAvKipcbiAgICogYGFwaUdyb3Vwc2AgaXMgYSBsaXN0IG9mIG1hdGNoaW5nIEFQSSBncm91cHMgYW5kIG1heSBub3QgYmUgZW1wdHkuIFwiKlwiIG1hdGNoZXMgYWxsIEFQSSBncm91cHMgYW5kLCBpZiBwcmVzZW50LCBtdXN0IGJlIHRoZSBvbmx5IGVudHJ5LiBSZXF1aXJlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuUmVzb3VyY2VQb2xpY3lSdWxlI2FwaUdyb3Vwc1xuICAgKi9cbiAgcmVhZG9ubHkgYXBpR3JvdXBzOiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogYGNsdXN0ZXJTY29wZWAgaW5kaWNhdGVzIHdoZXRoZXIgdG8gbWF0Y2ggcmVxdWVzdHMgdGhhdCBkbyBub3Qgc3BlY2lmeSBhIG5hbWVzcGFjZSAod2hpY2ggaGFwcGVucyBlaXRoZXIgYmVjYXVzZSB0aGUgcmVzb3VyY2UgaXMgbm90IG5hbWVzcGFjZWQgb3IgdGhlIHJlcXVlc3QgdGFyZ2V0cyBhbGwgbmFtZXNwYWNlcykuIElmIHRoaXMgZmllbGQgaXMgb21pdHRlZCBvciBmYWxzZSB0aGVuIHRoZSBgbmFtZXNwYWNlc2AgZmllbGQgbXVzdCBjb250YWluIGEgbm9uLWVtcHR5IGxpc3QuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLlJlc291cmNlUG9saWN5UnVsZSNjbHVzdGVyU2NvcGVcbiAgICovXG4gIHJlYWRvbmx5IGNsdXN0ZXJTY29wZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIGBuYW1lc3BhY2VzYCBpcyBhIGxpc3Qgb2YgdGFyZ2V0IG5hbWVzcGFjZXMgdGhhdCByZXN0cmljdHMgbWF0Y2hlcy4gIEEgcmVxdWVzdCB0aGF0IHNwZWNpZmllcyBhIHRhcmdldCBuYW1lc3BhY2UgbWF0Y2hlcyBvbmx5IGlmIGVpdGhlciAoYSkgdGhpcyBsaXN0IGNvbnRhaW5zIHRoYXQgdGFyZ2V0IG5hbWVzcGFjZSBvciAoYikgdGhpcyBsaXN0IGNvbnRhaW5zIFwiKlwiLiAgTm90ZSB0aGF0IFwiKlwiIG1hdGNoZXMgYW55IHNwZWNpZmllZCBuYW1lc3BhY2UgYnV0IGRvZXMgbm90IG1hdGNoIGEgcmVxdWVzdCB0aGF0IF9kb2VzIG5vdCBzcGVjaWZ5XyBhIG5hbWVzcGFjZSAoc2VlIHRoZSBgY2x1c3RlclNjb3BlYCBmaWVsZCBmb3IgdGhhdCkuIFRoaXMgbGlzdCBtYXkgYmUgZW1wdHksIGJ1dCBvbmx5IGlmIGBjbHVzdGVyU2NvcGVgIGlzIHRydWUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLlJlc291cmNlUG9saWN5UnVsZSNuYW1lc3BhY2VzXG4gICAqL1xuICByZWFkb25seSBuYW1lc3BhY2VzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIGByZXNvdXJjZXNgIGlzIGEgbGlzdCBvZiBtYXRjaGluZyByZXNvdXJjZXMgKGkuZS4sIGxvd2VyY2FzZSBhbmQgcGx1cmFsKSB3aXRoLCBpZiBkZXNpcmVkLCBzdWJyZXNvdXJjZS4gIEZvciBleGFtcGxlLCBbIFwic2VydmljZXNcIiwgXCJub2Rlcy9zdGF0dXNcIiBdLiAgVGhpcyBsaXN0IG1heSBub3QgYmUgZW1wdHkuIFwiKlwiIG1hdGNoZXMgYWxsIHJlc291cmNlcyBhbmQsIGlmIHByZXNlbnQsIG11c3QgYmUgdGhlIG9ubHkgZW50cnkuIFJlcXVpcmVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZmxvd2NvbnRyb2wudjFiZXRhMS5SZXNvdXJjZVBvbGljeVJ1bGUjcmVzb3VyY2VzXG4gICAqL1xuICByZWFkb25seSByZXNvdXJjZXM6IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBgdmVyYnNgIGlzIGEgbGlzdCBvZiBtYXRjaGluZyB2ZXJicyBhbmQgbWF5IG5vdCBiZSBlbXB0eS4gXCIqXCIgbWF0Y2hlcyBhbGwgdmVyYnMgYW5kLCBpZiBwcmVzZW50LCBtdXN0IGJlIHRoZSBvbmx5IGVudHJ5LiBSZXF1aXJlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuUmVzb3VyY2VQb2xpY3lSdWxlI3ZlcmJzXG4gICAqL1xuICByZWFkb25seSB2ZXJiczogc3RyaW5nW107XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnUmVzb3VyY2VQb2xpY3lSdWxlVjFCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fUmVzb3VyY2VQb2xpY3lSdWxlVjFCZXRhMShvYmo6IFJlc291cmNlUG9saWN5UnVsZVYxQmV0YTEgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdhcGlHcm91cHMnOiBvYmouYXBpR3JvdXBzPy5tYXAoeSA9PiB5KSxcbiAgICAnY2x1c3RlclNjb3BlJzogb2JqLmNsdXN0ZXJTY29wZSxcbiAgICAnbmFtZXNwYWNlcyc6IG9iai5uYW1lc3BhY2VzPy5tYXAoeSA9PiB5KSxcbiAgICAncmVzb3VyY2VzJzogb2JqLnJlc291cmNlcz8ubWFwKHkgPT4geSksXG4gICAgJ3ZlcmJzJzogb2JqLnZlcmJzPy5tYXAoeSA9PiB5KSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBTdWJqZWN0IG1hdGNoZXMgdGhlIG9yaWdpbmF0b3Igb2YgYSByZXF1ZXN0LCBhcyBpZGVudGlmaWVkIGJ5IHRoZSByZXF1ZXN0IGF1dGhlbnRpY2F0aW9uIHN5c3RlbS4gVGhlcmUgYXJlIHRocmVlIHdheXMgb2YgbWF0Y2hpbmcgYW4gb3JpZ2luYXRvcjsgYnkgdXNlciwgZ3JvdXAsIG9yIHNlcnZpY2UgYWNjb3VudC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuZmxvd2NvbnRyb2wudjFiZXRhMS5TdWJqZWN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3ViamVjdFYxQmV0YTEge1xuICAvKipcbiAgICogYGdyb3VwYCBtYXRjaGVzIGJhc2VkIG9uIHVzZXIgZ3JvdXAgbmFtZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuU3ViamVjdCNncm91cFxuICAgKi9cbiAgcmVhZG9ubHkgZ3JvdXA/OiBHcm91cFN1YmplY3RWMUJldGExO1xuXG4gIC8qKlxuICAgKiBga2luZGAgaW5kaWNhdGVzIHdoaWNoIG9uZSBvZiB0aGUgb3RoZXIgZmllbGRzIGlzIG5vbi1lbXB0eS4gUmVxdWlyZWRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuU3ViamVjdCNraW5kXG4gICAqL1xuICByZWFkb25seSBraW5kOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGBzZXJ2aWNlQWNjb3VudGAgbWF0Y2hlcyBTZXJ2aWNlQWNjb3VudHMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLlN1YmplY3Qjc2VydmljZUFjY291bnRcbiAgICovXG4gIHJlYWRvbmx5IHNlcnZpY2VBY2NvdW50PzogU2VydmljZUFjY291bnRTdWJqZWN0VjFCZXRhMTtcblxuICAvKipcbiAgICogYHVzZXJgIG1hdGNoZXMgYmFzZWQgb24gdXNlcm5hbWUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLlN1YmplY3QjdXNlclxuICAgKi9cbiAgcmVhZG9ubHkgdXNlcj86IFVzZXJTdWJqZWN0VjFCZXRhMTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdTdWJqZWN0VjFCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fU3ViamVjdFYxQmV0YTEob2JqOiBTdWJqZWN0VjFCZXRhMSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2dyb3VwJzogdG9Kc29uX0dyb3VwU3ViamVjdFYxQmV0YTEob2JqLmdyb3VwKSxcbiAgICAna2luZCc6IG9iai5raW5kLFxuICAgICdzZXJ2aWNlQWNjb3VudCc6IHRvSnNvbl9TZXJ2aWNlQWNjb3VudFN1YmplY3RWMUJldGExKG9iai5zZXJ2aWNlQWNjb3VudCksXG4gICAgJ3VzZXInOiB0b0pzb25fVXNlclN1YmplY3RWMUJldGExKG9iai51c2VyKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBMaW1pdFJlc3BvbnNlIGRlZmluZXMgaG93IHRvIGhhbmRsZSByZXF1ZXN0cyB0aGF0IGNhbiBub3QgYmUgZXhlY3V0ZWQgcmlnaHQgbm93LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLkxpbWl0UmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMaW1pdFJlc3BvbnNlVjFCZXRhMSB7XG4gIC8qKlxuICAgKiBgcXVldWluZ2AgaG9sZHMgdGhlIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyBmb3IgcXVldWluZy4gVGhpcyBmaWVsZCBtYXkgYmUgbm9uLWVtcHR5IG9ubHkgaWYgYHR5cGVgIGlzIGBcIlF1ZXVlXCJgLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZmxvd2NvbnRyb2wudjFiZXRhMS5MaW1pdFJlc3BvbnNlI3F1ZXVpbmdcbiAgICovXG4gIHJlYWRvbmx5IHF1ZXVpbmc/OiBRdWV1aW5nQ29uZmlndXJhdGlvblYxQmV0YTE7XG5cbiAgLyoqXG4gICAqIGB0eXBlYCBpcyBcIlF1ZXVlXCIgb3IgXCJSZWplY3RcIi4gXCJRdWV1ZVwiIG1lYW5zIHRoYXQgcmVxdWVzdHMgdGhhdCBjYW4gbm90IGJlIGV4ZWN1dGVkIHVwb24gYXJyaXZhbCBhcmUgaGVsZCBpbiBhIHF1ZXVlIHVudGlsIHRoZXkgY2FuIGJlIGV4ZWN1dGVkIG9yIGEgcXVldWluZyBsaW1pdCBpcyByZWFjaGVkLiBcIlJlamVjdFwiIG1lYW5zIHRoYXQgcmVxdWVzdHMgdGhhdCBjYW4gbm90IGJlIGV4ZWN1dGVkIHVwb24gYXJyaXZhbCBhcmUgcmVqZWN0ZWQuIFJlcXVpcmVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuZmxvd2NvbnRyb2wudjFiZXRhMS5MaW1pdFJlc3BvbnNlI3R5cGVcbiAgICovXG4gIHJlYWRvbmx5IHR5cGU6IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdMaW1pdFJlc3BvbnNlVjFCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fTGltaXRSZXNwb25zZVYxQmV0YTEob2JqOiBMaW1pdFJlc3BvbnNlVjFCZXRhMSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ3F1ZXVpbmcnOiB0b0pzb25fUXVldWluZ0NvbmZpZ3VyYXRpb25WMUJldGExKG9iai5xdWV1aW5nKSxcbiAgICAndHlwZSc6IG9iai50eXBlLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEluZ3Jlc3NTZXJ2aWNlQmFja2VuZCByZWZlcmVuY2VzIGEgS3ViZXJuZXRlcyBTZXJ2aWNlIGFzIGEgQmFja2VuZC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5JbmdyZXNzU2VydmljZUJhY2tlbmRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbmdyZXNzU2VydmljZUJhY2tlbmQge1xuICAvKipcbiAgICogTmFtZSBpcyB0aGUgcmVmZXJlbmNlZCBzZXJ2aWNlLiBUaGUgc2VydmljZSBtdXN0IGV4aXN0IGluIHRoZSBzYW1lIG5hbWVzcGFjZSBhcyB0aGUgSW5ncmVzcyBvYmplY3QuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3NTZXJ2aWNlQmFja2VuZCNuYW1lXG4gICAqL1xuICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFBvcnQgb2YgdGhlIHJlZmVyZW5jZWQgc2VydmljZS4gQSBwb3J0IG5hbWUgb3IgcG9ydCBudW1iZXIgaXMgcmVxdWlyZWQgZm9yIGEgSW5ncmVzc1NlcnZpY2VCYWNrZW5kLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5JbmdyZXNzU2VydmljZUJhY2tlbmQjcG9ydFxuICAgKi9cbiAgcmVhZG9ubHkgcG9ydD86IFNlcnZpY2VCYWNrZW5kUG9ydDtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdJbmdyZXNzU2VydmljZUJhY2tlbmQnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0luZ3Jlc3NTZXJ2aWNlQmFja2VuZChvYmo6IEluZ3Jlc3NTZXJ2aWNlQmFja2VuZCB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ25hbWUnOiBvYmoubmFtZSxcbiAgICAncG9ydCc6IHRvSnNvbl9TZXJ2aWNlQmFja2VuZFBvcnQob2JqLnBvcnQpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEhUVFBJbmdyZXNzUnVsZVZhbHVlIGlzIGEgbGlzdCBvZiBodHRwIHNlbGVjdG9ycyBwb2ludGluZyB0byBiYWNrZW5kcy4gSW4gdGhlIGV4YW1wbGU6IGh0dHA6Ly88aG9zdD4vPHBhdGg+PzxzZWFyY2hwYXJ0PiAtPiBiYWNrZW5kIHdoZXJlIHdoZXJlIHBhcnRzIG9mIHRoZSB1cmwgY29ycmVzcG9uZCB0byBSRkMgMzk4NiwgdGhpcyByZXNvdXJjZSB3aWxsIGJlIHVzZWQgdG8gbWF0Y2ggYWdhaW5zdCBldmVyeXRoaW5nIGFmdGVyIHRoZSBsYXN0ICcvJyBhbmQgYmVmb3JlIHRoZSBmaXJzdCAnPycgb3IgJyMnLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkhUVFBJbmdyZXNzUnVsZVZhbHVlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSHR0cEluZ3Jlc3NSdWxlVmFsdWUge1xuICAvKipcbiAgICogQSBjb2xsZWN0aW9uIG9mIHBhdGhzIHRoYXQgbWFwIHJlcXVlc3RzIHRvIGJhY2tlbmRzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5IVFRQSW5ncmVzc1J1bGVWYWx1ZSNwYXRoc1xuICAgKi9cbiAgcmVhZG9ubHkgcGF0aHM6IEh0dHBJbmdyZXNzUGF0aFtdO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0h0dHBJbmdyZXNzUnVsZVZhbHVlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9IdHRwSW5ncmVzc1J1bGVWYWx1ZShvYmo6IEh0dHBJbmdyZXNzUnVsZVZhbHVlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAncGF0aHMnOiBvYmoucGF0aHM/Lm1hcCh5ID0+IHRvSnNvbl9IdHRwSW5ncmVzc1BhdGgoeSkpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIE5ldHdvcmtQb2xpY3lQb3J0IGRlc2NyaWJlcyBhIHBvcnQgdG8gYWxsb3cgdHJhZmZpYyBvblxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLk5ldHdvcmtQb2xpY3lQb3J0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV0d29ya1BvbGljeVBvcnQge1xuICAvKipcbiAgICogSWYgc2V0LCBpbmRpY2F0ZXMgdGhhdCB0aGUgcmFuZ2Ugb2YgcG9ydHMgZnJvbSBwb3J0IHRvIGVuZFBvcnQsIGluY2x1c2l2ZSwgc2hvdWxkIGJlIGFsbG93ZWQgYnkgdGhlIHBvbGljeS4gVGhpcyBmaWVsZCBjYW5ub3QgYmUgZGVmaW5lZCBpZiB0aGUgcG9ydCBmaWVsZCBpcyBub3QgZGVmaW5lZCBvciBpZiB0aGUgcG9ydCBmaWVsZCBpcyBkZWZpbmVkIGFzIGEgbmFtZWQgKHN0cmluZykgcG9ydC4gVGhlIGVuZFBvcnQgbXVzdCBiZSBlcXVhbCBvciBncmVhdGVyIHRoYW4gcG9ydC4gVGhpcyBmZWF0dXJlIGlzIGluIEJldGEgc3RhdGUgYW5kIGlzIGVuYWJsZWQgYnkgZGVmYXVsdC4gSXQgY2FuIGJlIGRpc2FibGVkIHVzaW5nIHRoZSBGZWF0dXJlIEdhdGUgXCJOZXR3b3JrUG9saWN5RW5kUG9ydFwiLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5OZXR3b3JrUG9saWN5UG9ydCNlbmRQb3J0XG4gICAqL1xuICByZWFkb25seSBlbmRQb3J0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgcG9ydCBvbiB0aGUgZ2l2ZW4gcHJvdG9jb2wuIFRoaXMgY2FuIGVpdGhlciBiZSBhIG51bWVyaWNhbCBvciBuYW1lZCBwb3J0IG9uIGEgcG9kLiBJZiB0aGlzIGZpZWxkIGlzIG5vdCBwcm92aWRlZCwgdGhpcyBtYXRjaGVzIGFsbCBwb3J0IG5hbWVzIGFuZCBudW1iZXJzLiBJZiBwcmVzZW50LCBvbmx5IHRyYWZmaWMgb24gdGhlIHNwZWNpZmllZCBwcm90b2NvbCBBTkQgcG9ydCB3aWxsIGJlIG1hdGNoZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLk5ldHdvcmtQb2xpY3lQb3J0I3BvcnRcbiAgICovXG4gIHJlYWRvbmx5IHBvcnQ/OiBJbnRPclN0cmluZztcblxuICAvKipcbiAgICogVGhlIHByb3RvY29sIChUQ1AsIFVEUCwgb3IgU0NUUCkgd2hpY2ggdHJhZmZpYyBtdXN0IG1hdGNoLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGlzIGZpZWxkIGRlZmF1bHRzIHRvIFRDUC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuTmV0d29ya1BvbGljeVBvcnQjcHJvdG9jb2xcbiAgICovXG4gIHJlYWRvbmx5IHByb3RvY29sPzogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ05ldHdvcmtQb2xpY3lQb3J0JyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9OZXR3b3JrUG9saWN5UG9ydChvYmo6IE5ldHdvcmtQb2xpY3lQb3J0IHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZW5kUG9ydCc6IG9iai5lbmRQb3J0LFxuICAgICdwb3J0Jzogb2JqLnBvcnQ/LnZhbHVlLFxuICAgICdwcm90b2NvbCc6IG9iai5wcm90b2NvbCxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBOZXR3b3JrUG9saWN5UGVlciBkZXNjcmliZXMgYSBwZWVyIHRvIGFsbG93IHRyYWZmaWMgdG8vZnJvbS4gT25seSBjZXJ0YWluIGNvbWJpbmF0aW9ucyBvZiBmaWVsZHMgYXJlIGFsbG93ZWRcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5OZXR3b3JrUG9saWN5UGVlclxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5ldHdvcmtQb2xpY3lQZWVyIHtcbiAgLyoqXG4gICAqIElQQmxvY2sgZGVmaW5lcyBwb2xpY3kgb24gYSBwYXJ0aWN1bGFyIElQQmxvY2suIElmIHRoaXMgZmllbGQgaXMgc2V0IHRoZW4gbmVpdGhlciBvZiB0aGUgb3RoZXIgZmllbGRzIGNhbiBiZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuTmV0d29ya1BvbGljeVBlZXIjaXBCbG9ja1xuICAgKi9cbiAgcmVhZG9ubHkgaXBCbG9jaz86IElwQmxvY2s7XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgTmFtZXNwYWNlcyB1c2luZyBjbHVzdGVyLXNjb3BlZCBsYWJlbHMuIFRoaXMgZmllbGQgZm9sbG93cyBzdGFuZGFyZCBsYWJlbCBzZWxlY3RvciBzZW1hbnRpY3M7IGlmIHByZXNlbnQgYnV0IGVtcHR5LCBpdCBzZWxlY3RzIGFsbCBuYW1lc3BhY2VzLlxuICAgKlxuICAgKiBJZiBQb2RTZWxlY3RvciBpcyBhbHNvIHNldCwgdGhlbiB0aGUgTmV0d29ya1BvbGljeVBlZXIgYXMgYSB3aG9sZSBzZWxlY3RzIHRoZSBQb2RzIG1hdGNoaW5nIFBvZFNlbGVjdG9yIGluIHRoZSBOYW1lc3BhY2VzIHNlbGVjdGVkIGJ5IE5hbWVzcGFjZVNlbGVjdG9yLiBPdGhlcndpc2UgaXQgc2VsZWN0cyBhbGwgUG9kcyBpbiB0aGUgTmFtZXNwYWNlcyBzZWxlY3RlZCBieSBOYW1lc3BhY2VTZWxlY3Rvci5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuTmV0d29ya1BvbGljeVBlZXIjbmFtZXNwYWNlU2VsZWN0b3JcbiAgICovXG4gIHJlYWRvbmx5IG5hbWVzcGFjZVNlbGVjdG9yPzogTGFiZWxTZWxlY3RvcjtcblxuICAvKipcbiAgICogVGhpcyBpcyBhIGxhYmVsIHNlbGVjdG9yIHdoaWNoIHNlbGVjdHMgUG9kcy4gVGhpcyBmaWVsZCBmb2xsb3dzIHN0YW5kYXJkIGxhYmVsIHNlbGVjdG9yIHNlbWFudGljczsgaWYgcHJlc2VudCBidXQgZW1wdHksIGl0IHNlbGVjdHMgYWxsIHBvZHMuXG4gICAqXG4gICAqIElmIE5hbWVzcGFjZVNlbGVjdG9yIGlzIGFsc28gc2V0LCB0aGVuIHRoZSBOZXR3b3JrUG9saWN5UGVlciBhcyBhIHdob2xlIHNlbGVjdHMgdGhlIFBvZHMgbWF0Y2hpbmcgUG9kU2VsZWN0b3IgaW4gdGhlIE5hbWVzcGFjZXMgc2VsZWN0ZWQgYnkgTmFtZXNwYWNlU2VsZWN0b3IuIE90aGVyd2lzZSBpdCBzZWxlY3RzIHRoZSBQb2RzIG1hdGNoaW5nIFBvZFNlbGVjdG9yIGluIHRoZSBwb2xpY3kncyBvd24gTmFtZXNwYWNlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5OZXR3b3JrUG9saWN5UGVlciNwb2RTZWxlY3RvclxuICAgKi9cbiAgcmVhZG9ubHkgcG9kU2VsZWN0b3I/OiBMYWJlbFNlbGVjdG9yO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ05ldHdvcmtQb2xpY3lQZWVyJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9OZXR3b3JrUG9saWN5UGVlcihvYmo6IE5ldHdvcmtQb2xpY3lQZWVyIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaXBCbG9jayc6IHRvSnNvbl9JcEJsb2NrKG9iai5pcEJsb2NrKSxcbiAgICAnbmFtZXNwYWNlU2VsZWN0b3InOiB0b0pzb25fTGFiZWxTZWxlY3RvcihvYmoubmFtZXNwYWNlU2VsZWN0b3IpLFxuICAgICdwb2RTZWxlY3Rvcic6IHRvSnNvbl9MYWJlbFNlbGVjdG9yKG9iai5wb2RTZWxlY3RvciksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogSURSYW5nZSBwcm92aWRlcyBhIG1pbi9tYXggb2YgYW4gYWxsb3dlZCByYW5nZSBvZiBJRHMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLklEUmFuZ2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJZFJhbmdlVjFCZXRhMSB7XG4gIC8qKlxuICAgKiBtYXggaXMgdGhlIGVuZCBvZiB0aGUgcmFuZ2UsIGluY2x1c2l2ZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLklEUmFuZ2UjbWF4XG4gICAqL1xuICByZWFkb25seSBtYXg6IG51bWJlcjtcblxuICAvKipcbiAgICogbWluIGlzIHRoZSBzdGFydCBvZiB0aGUgcmFuZ2UsIGluY2x1c2l2ZS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnBvbGljeS52MWJldGExLklEUmFuZ2UjbWluXG4gICAqL1xuICByZWFkb25seSBtaW46IG51bWJlcjtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdJZFJhbmdlVjFCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fSWRSYW5nZVYxQmV0YTEob2JqOiBJZFJhbmdlVjFCZXRhMSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21heCc6IG9iai5tYXgsXG4gICAgJ21pbic6IG9iai5taW4sXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogVm9sdW1lTm9kZVJlc291cmNlcyBpcyBhIHNldCBvZiByZXNvdXJjZSBsaW1pdHMgZm9yIHNjaGVkdWxpbmcgb2Ygdm9sdW1lcy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuc3RvcmFnZS52MS5Wb2x1bWVOb2RlUmVzb3VyY2VzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVm9sdW1lTm9kZVJlc291cmNlcyB7XG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiB1bmlxdWUgdm9sdW1lcyBtYW5hZ2VkIGJ5IHRoZSBDU0kgZHJpdmVyIHRoYXQgY2FuIGJlIHVzZWQgb24gYSBub2RlLiBBIHZvbHVtZSB0aGF0IGlzIGJvdGggYXR0YWNoZWQgYW5kIG1vdW50ZWQgb24gYSBub2RlIGlzIGNvbnNpZGVyZWQgdG8gYmUgdXNlZCBvbmNlLCBub3QgdHdpY2UuIFRoZSBzYW1lIHJ1bGUgYXBwbGllcyBmb3IgYSB1bmlxdWUgdm9sdW1lIHRoYXQgaXMgc2hhcmVkIGFtb25nIG11bHRpcGxlIHBvZHMgb24gdGhlIHNhbWUgbm9kZS4gSWYgdGhpcyBmaWVsZCBpcyBub3Qgc3BlY2lmaWVkLCB0aGVuIHRoZSBzdXBwb3J0ZWQgbnVtYmVyIG9mIHZvbHVtZXMgb24gdGhpcyBub2RlIGlzIHVuYm91bmRlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLnN0b3JhZ2UudjEuVm9sdW1lTm9kZVJlc291cmNlcyNjb3VudFxuICAgKi9cbiAgcmVhZG9ubHkgY291bnQ/OiBudW1iZXI7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnVm9sdW1lTm9kZVJlc291cmNlcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fVm9sdW1lTm9kZVJlc291cmNlcyhvYmo6IFZvbHVtZU5vZGVSZXNvdXJjZXMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdjb3VudCc6IG9iai5jb3VudCxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBXZWJob29rQ29udmVyc2lvbiBkZXNjcmliZXMgaG93IHRvIGNhbGwgYSBjb252ZXJzaW9uIHdlYmhvb2tcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLldlYmhvb2tDb252ZXJzaW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgV2ViaG9va0NvbnZlcnNpb24ge1xuICAvKipcbiAgICogY2xpZW50Q29uZmlnIGlzIHRoZSBpbnN0cnVjdGlvbnMgZm9yIGhvdyB0byBjYWxsIHRoZSB3ZWJob29rIGlmIHN0cmF0ZWd5IGlzIGBXZWJob29rYC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5XZWJob29rQ29udmVyc2lvbiNjbGllbnRDb25maWdcbiAgICovXG4gIHJlYWRvbmx5IGNsaWVudENvbmZpZz86IFdlYmhvb2tDbGllbnRDb25maWc7XG5cbiAgLyoqXG4gICAqIGNvbnZlcnNpb25SZXZpZXdWZXJzaW9ucyBpcyBhbiBvcmRlcmVkIGxpc3Qgb2YgcHJlZmVycmVkIGBDb252ZXJzaW9uUmV2aWV3YCB2ZXJzaW9ucyB0aGUgV2ViaG9vayBleHBlY3RzLiBUaGUgQVBJIHNlcnZlciB3aWxsIHVzZSB0aGUgZmlyc3QgdmVyc2lvbiBpbiB0aGUgbGlzdCB3aGljaCBpdCBzdXBwb3J0cy4gSWYgbm9uZSBvZiB0aGUgdmVyc2lvbnMgc3BlY2lmaWVkIGluIHRoaXMgbGlzdCBhcmUgc3VwcG9ydGVkIGJ5IEFQSSBzZXJ2ZXIsIGNvbnZlcnNpb24gd2lsbCBmYWlsIGZvciB0aGUgY3VzdG9tIHJlc291cmNlLiBJZiBhIHBlcnNpc3RlZCBXZWJob29rIGNvbmZpZ3VyYXRpb24gc3BlY2lmaWVzIGFsbG93ZWQgdmVyc2lvbnMgYW5kIGRvZXMgbm90IGluY2x1ZGUgYW55IHZlcnNpb25zIGtub3duIHRvIHRoZSBBUEkgU2VydmVyLCBjYWxscyB0byB0aGUgd2ViaG9vayB3aWxsIGZhaWwuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuV2ViaG9va0NvbnZlcnNpb24jY29udmVyc2lvblJldmlld1ZlcnNpb25zXG4gICAqL1xuICByZWFkb25seSBjb252ZXJzaW9uUmV2aWV3VmVyc2lvbnM6IHN0cmluZ1tdO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1dlYmhvb2tDb252ZXJzaW9uJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9XZWJob29rQ29udmVyc2lvbihvYmo6IFdlYmhvb2tDb252ZXJzaW9uIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnY2xpZW50Q29uZmlnJzogdG9Kc29uX1dlYmhvb2tDbGllbnRDb25maWcob2JqLmNsaWVudENvbmZpZyksXG4gICAgJ2NvbnZlcnNpb25SZXZpZXdWZXJzaW9ucyc6IG9iai5jb252ZXJzaW9uUmV2aWV3VmVyc2lvbnM/Lm1hcCh5ID0+IHkpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEN1c3RvbVJlc291cmNlQ29sdW1uRGVmaW5pdGlvbiBzcGVjaWZpZXMgYSBjb2x1bW4gZm9yIHNlcnZlciBzaWRlIHByaW50aW5nLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuQ3VzdG9tUmVzb3VyY2VDb2x1bW5EZWZpbml0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3VzdG9tUmVzb3VyY2VDb2x1bW5EZWZpbml0aW9uIHtcbiAgLyoqXG4gICAqIGRlc2NyaXB0aW9uIGlzIGEgaHVtYW4gcmVhZGFibGUgZGVzY3JpcHRpb24gb2YgdGhpcyBjb2x1bW4uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuQ3VzdG9tUmVzb3VyY2VDb2x1bW5EZWZpbml0aW9uI2Rlc2NyaXB0aW9uXG4gICAqL1xuICByZWFkb25seSBkZXNjcmlwdGlvbj86IHN0cmluZztcblxuICAvKipcbiAgICogZm9ybWF0IGlzIGFuIG9wdGlvbmFsIE9wZW5BUEkgdHlwZSBkZWZpbml0aW9uIGZvciB0aGlzIGNvbHVtbi4gVGhlICduYW1lJyBmb3JtYXQgaXMgYXBwbGllZCB0byB0aGUgcHJpbWFyeSBpZGVudGlmaWVyIGNvbHVtbiB0byBhc3Npc3QgaW4gY2xpZW50cyBpZGVudGlmeWluZyBjb2x1bW4gaXMgdGhlIHJlc291cmNlIG5hbWUuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vT0FJL09wZW5BUEktU3BlY2lmaWNhdGlvbi9ibG9iL21hc3Rlci92ZXJzaW9ucy8yLjAubWQjZGF0YS10eXBlcyBmb3IgZGV0YWlscy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5DdXN0b21SZXNvdXJjZUNvbHVtbkRlZmluaXRpb24jZm9ybWF0XG4gICAqL1xuICByZWFkb25seSBmb3JtYXQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGpzb25QYXRoIGlzIGEgc2ltcGxlIEpTT04gcGF0aCAoaS5lLiB3aXRoIGFycmF5IG5vdGF0aW9uKSB3aGljaCBpcyBldmFsdWF0ZWQgYWdhaW5zdCBlYWNoIGN1c3RvbSByZXNvdXJjZSB0byBwcm9kdWNlIHRoZSB2YWx1ZSBmb3IgdGhpcyBjb2x1bW4uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuQ3VzdG9tUmVzb3VyY2VDb2x1bW5EZWZpbml0aW9uI2pzb25QYXRoXG4gICAqL1xuICByZWFkb25seSBqc29uUGF0aDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBuYW1lIGlzIGEgaHVtYW4gcmVhZGFibGUgbmFtZSBmb3IgdGhlIGNvbHVtbi5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5DdXN0b21SZXNvdXJjZUNvbHVtbkRlZmluaXRpb24jbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBwcmlvcml0eSBpcyBhbiBpbnRlZ2VyIGRlZmluaW5nIHRoZSByZWxhdGl2ZSBpbXBvcnRhbmNlIG9mIHRoaXMgY29sdW1uIGNvbXBhcmVkIHRvIG90aGVycy4gTG93ZXIgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBoaWdoZXIgcHJpb3JpdHkuIENvbHVtbnMgdGhhdCBtYXkgYmUgb21pdHRlZCBpbiBsaW1pdGVkIHNwYWNlIHNjZW5hcmlvcyBzaG91bGQgYmUgZ2l2ZW4gYSBwcmlvcml0eSBncmVhdGVyIHRoYW4gMC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5DdXN0b21SZXNvdXJjZUNvbHVtbkRlZmluaXRpb24jcHJpb3JpdHlcbiAgICovXG4gIHJlYWRvbmx5IHByaW9yaXR5PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiB0eXBlIGlzIGFuIE9wZW5BUEkgdHlwZSBkZWZpbml0aW9uIGZvciB0aGlzIGNvbHVtbi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9PQUkvT3BlbkFQSS1TcGVjaWZpY2F0aW9uL2Jsb2IvbWFzdGVyL3ZlcnNpb25zLzIuMC5tZCNkYXRhLXR5cGVzIGZvciBkZXRhaWxzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkN1c3RvbVJlc291cmNlQ29sdW1uRGVmaW5pdGlvbiN0eXBlXG4gICAqL1xuICByZWFkb25seSB0eXBlOiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnQ3VzdG9tUmVzb3VyY2VDb2x1bW5EZWZpbml0aW9uJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9DdXN0b21SZXNvdXJjZUNvbHVtbkRlZmluaXRpb24ob2JqOiBDdXN0b21SZXNvdXJjZUNvbHVtbkRlZmluaXRpb24gfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdkZXNjcmlwdGlvbic6IG9iai5kZXNjcmlwdGlvbixcbiAgICAnZm9ybWF0Jzogb2JqLmZvcm1hdCxcbiAgICAnanNvblBhdGgnOiBvYmouanNvblBhdGgsXG4gICAgJ25hbWUnOiBvYmoubmFtZSxcbiAgICAncHJpb3JpdHknOiBvYmoucHJpb3JpdHksXG4gICAgJ3R5cGUnOiBvYmoudHlwZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBDdXN0b21SZXNvdXJjZVZhbGlkYXRpb24gaXMgYSBsaXN0IG9mIHZhbGlkYXRpb24gbWV0aG9kcyBmb3IgQ3VzdG9tUmVzb3VyY2VzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuQ3VzdG9tUmVzb3VyY2VWYWxpZGF0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3VzdG9tUmVzb3VyY2VWYWxpZGF0aW9uIHtcbiAgLyoqXG4gICAqIG9wZW5BUElWM1NjaGVtYSBpcyB0aGUgT3BlbkFQSSB2MyBzY2hlbWEgdG8gdXNlIGZvciB2YWxpZGF0aW9uIGFuZCBwcnVuaW5nLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkN1c3RvbVJlc291cmNlVmFsaWRhdGlvbiNvcGVuQVBJVjNTY2hlbWFcbiAgICovXG4gIHJlYWRvbmx5IG9wZW5BcGl2M1NjaGVtYT86IEpzb25TY2hlbWFQcm9wcztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdDdXN0b21SZXNvdXJjZVZhbGlkYXRpb24nIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0N1c3RvbVJlc291cmNlVmFsaWRhdGlvbihvYmo6IEN1c3RvbVJlc291cmNlVmFsaWRhdGlvbiB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ29wZW5BUElWM1NjaGVtYSc6IHRvSnNvbl9Kc29uU2NoZW1hUHJvcHMob2JqLm9wZW5BcGl2M1NjaGVtYSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQ3VzdG9tUmVzb3VyY2VTdWJyZXNvdXJjZXMgZGVmaW5lcyB0aGUgc3RhdHVzIGFuZCBzY2FsZSBzdWJyZXNvdXJjZXMgZm9yIEN1c3RvbVJlc291cmNlcy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkN1c3RvbVJlc291cmNlU3VicmVzb3VyY2VzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3VzdG9tUmVzb3VyY2VTdWJyZXNvdXJjZXMge1xuICAvKipcbiAgICogc2NhbGUgaW5kaWNhdGVzIHRoZSBjdXN0b20gcmVzb3VyY2Ugc2hvdWxkIHNlcnZlIGEgYC9zY2FsZWAgc3VicmVzb3VyY2UgdGhhdCByZXR1cm5zIGFuIGBhdXRvc2NhbGluZy92MWAgU2NhbGUgb2JqZWN0LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkN1c3RvbVJlc291cmNlU3VicmVzb3VyY2VzI3NjYWxlXG4gICAqL1xuICByZWFkb25seSBzY2FsZT86IEN1c3RvbVJlc291cmNlU3VicmVzb3VyY2VTY2FsZTtcblxuICAvKipcbiAgICogc3RhdHVzIGluZGljYXRlcyB0aGUgY3VzdG9tIHJlc291cmNlIHNob3VsZCBzZXJ2ZSBhIGAvc3RhdHVzYCBzdWJyZXNvdXJjZS4gV2hlbiBlbmFibGVkOiAxLiByZXF1ZXN0cyB0byB0aGUgY3VzdG9tIHJlc291cmNlIHByaW1hcnkgZW5kcG9pbnQgaWdub3JlIGNoYW5nZXMgdG8gdGhlIGBzdGF0dXNgIHN0YW56YSBvZiB0aGUgb2JqZWN0LiAyLiByZXF1ZXN0cyB0byB0aGUgY3VzdG9tIHJlc291cmNlIGAvc3RhdHVzYCBzdWJyZXNvdXJjZSBpZ25vcmUgY2hhbmdlcyB0byBhbnl0aGluZyBvdGhlciB0aGFuIHRoZSBgc3RhdHVzYCBzdGFuemEgb2YgdGhlIG9iamVjdC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5DdXN0b21SZXNvdXJjZVN1YnJlc291cmNlcyNzdGF0dXNcbiAgICovXG4gIHJlYWRvbmx5IHN0YXR1cz86IGFueTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdDdXN0b21SZXNvdXJjZVN1YnJlc291cmNlcycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fQ3VzdG9tUmVzb3VyY2VTdWJyZXNvdXJjZXMob2JqOiBDdXN0b21SZXNvdXJjZVN1YnJlc291cmNlcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ3NjYWxlJzogdG9Kc29uX0N1c3RvbVJlc291cmNlU3VicmVzb3VyY2VTY2FsZShvYmouc2NhbGUpLFxuICAgICdzdGF0dXMnOiBvYmouc3RhdHVzLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEhQQVNjYWxpbmdQb2xpY3kgaXMgYSBzaW5nbGUgcG9saWN5IHdoaWNoIG11c3QgaG9sZCB0cnVlIGZvciBhIHNwZWNpZmllZCBwYXN0IGludGVydmFsLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGEyLkhQQVNjYWxpbmdQb2xpY3lcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIcGFTY2FsaW5nUG9saWN5VjJCZXRhMiB7XG4gIC8qKlxuICAgKiBQZXJpb2RTZWNvbmRzIHNwZWNpZmllcyB0aGUgd2luZG93IG9mIHRpbWUgZm9yIHdoaWNoIHRoZSBwb2xpY3kgc2hvdWxkIGhvbGQgdHJ1ZS4gUGVyaW9kU2Vjb25kcyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMTgwMCAoMzAgbWluKS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuSFBBU2NhbGluZ1BvbGljeSNwZXJpb2RTZWNvbmRzXG4gICAqL1xuICByZWFkb25seSBwZXJpb2RTZWNvbmRzOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFR5cGUgaXMgdXNlZCB0byBzcGVjaWZ5IHRoZSBzY2FsaW5nIHBvbGljeS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuSFBBU2NhbGluZ1BvbGljeSN0eXBlXG4gICAqL1xuICByZWFkb25seSB0eXBlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFZhbHVlIGNvbnRhaW5zIHRoZSBhbW91bnQgb2YgY2hhbmdlIHdoaWNoIGlzIHBlcm1pdHRlZCBieSB0aGUgcG9saWN5LiBJdCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGEyLkhQQVNjYWxpbmdQb2xpY3kjdmFsdWVcbiAgICovXG4gIHJlYWRvbmx5IHZhbHVlOiBudW1iZXI7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnSHBhU2NhbGluZ1BvbGljeVYyQmV0YTInIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0hwYVNjYWxpbmdQb2xpY3lWMkJldGEyKG9iajogSHBhU2NhbGluZ1BvbGljeVYyQmV0YTIgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdwZXJpb2RTZWNvbmRzJzogb2JqLnBlcmlvZFNlY29uZHMsXG4gICAgJ3R5cGUnOiBvYmoudHlwZSxcbiAgICAndmFsdWUnOiBvYmoudmFsdWUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogTWV0cmljVGFyZ2V0IGRlZmluZXMgdGhlIHRhcmdldCB2YWx1ZSwgYXZlcmFnZSB2YWx1ZSwgb3IgYXZlcmFnZSB1dGlsaXphdGlvbiBvZiBhIHNwZWNpZmljIG1ldHJpY1xuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGEyLk1ldHJpY1RhcmdldFxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1ldHJpY1RhcmdldFYyQmV0YTIge1xuICAvKipcbiAgICogYXZlcmFnZVV0aWxpemF0aW9uIGlzIHRoZSB0YXJnZXQgdmFsdWUgb2YgdGhlIGF2ZXJhZ2Ugb2YgdGhlIHJlc291cmNlIG1ldHJpYyBhY3Jvc3MgYWxsIHJlbGV2YW50IHBvZHMsIHJlcHJlc2VudGVkIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgcmVxdWVzdGVkIHZhbHVlIG9mIHRoZSByZXNvdXJjZSBmb3IgdGhlIHBvZHMuIEN1cnJlbnRseSBvbmx5IHZhbGlkIGZvciBSZXNvdXJjZSBtZXRyaWMgc291cmNlIHR5cGVcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuTWV0cmljVGFyZ2V0I2F2ZXJhZ2VVdGlsaXphdGlvblxuICAgKi9cbiAgcmVhZG9ubHkgYXZlcmFnZVV0aWxpemF0aW9uPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBhdmVyYWdlVmFsdWUgaXMgdGhlIHRhcmdldCB2YWx1ZSBvZiB0aGUgYXZlcmFnZSBvZiB0aGUgbWV0cmljIGFjcm9zcyBhbGwgcmVsZXZhbnQgcG9kcyAoYXMgYSBxdWFudGl0eSlcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuTWV0cmljVGFyZ2V0I2F2ZXJhZ2VWYWx1ZVxuICAgKi9cbiAgcmVhZG9ubHkgYXZlcmFnZVZhbHVlPzogUXVhbnRpdHk7XG5cbiAgLyoqXG4gICAqIHR5cGUgcmVwcmVzZW50cyB3aGV0aGVyIHRoZSBtZXRyaWMgdHlwZSBpcyBVdGlsaXphdGlvbiwgVmFsdWUsIG9yIEF2ZXJhZ2VWYWx1ZVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMi5NZXRyaWNUYXJnZXQjdHlwZVxuICAgKi9cbiAgcmVhZG9ubHkgdHlwZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiB2YWx1ZSBpcyB0aGUgdGFyZ2V0IHZhbHVlIG9mIHRoZSBtZXRyaWMgKGFzIGEgcXVhbnRpdHkpLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMi5NZXRyaWNUYXJnZXQjdmFsdWVcbiAgICovXG4gIHJlYWRvbmx5IHZhbHVlPzogUXVhbnRpdHk7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnTWV0cmljVGFyZ2V0VjJCZXRhMicgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fTWV0cmljVGFyZ2V0VjJCZXRhMihvYmo6IE1ldHJpY1RhcmdldFYyQmV0YTIgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdhdmVyYWdlVXRpbGl6YXRpb24nOiBvYmouYXZlcmFnZVV0aWxpemF0aW9uLFxuICAgICdhdmVyYWdlVmFsdWUnOiBvYmouYXZlcmFnZVZhbHVlPy52YWx1ZSxcbiAgICAndHlwZSc6IG9iai50eXBlLFxuICAgICd2YWx1ZSc6IG9iai52YWx1ZT8udmFsdWUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogTWV0cmljSWRlbnRpZmllciBkZWZpbmVzIHRoZSBuYW1lIGFuZCBvcHRpb25hbGx5IHNlbGVjdG9yIGZvciBhIG1ldHJpY1xuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5hdXRvc2NhbGluZy52MmJldGEyLk1ldHJpY0lkZW50aWZpZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNZXRyaWNJZGVudGlmaWVyVjJCZXRhMiB7XG4gIC8qKlxuICAgKiBuYW1lIGlzIHRoZSBuYW1lIG9mIHRoZSBnaXZlbiBtZXRyaWNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmF1dG9zY2FsaW5nLnYyYmV0YTIuTWV0cmljSWRlbnRpZmllciNuYW1lXG4gICAqL1xuICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIHNlbGVjdG9yIGlzIHRoZSBzdHJpbmctZW5jb2RlZCBmb3JtIG9mIGEgc3RhbmRhcmQga3ViZXJuZXRlcyBsYWJlbCBzZWxlY3RvciBmb3IgdGhlIGdpdmVuIG1ldHJpYyBXaGVuIHNldCwgaXQgaXMgcGFzc2VkIGFzIGFuIGFkZGl0aW9uYWwgcGFyYW1ldGVyIHRvIHRoZSBtZXRyaWNzIHNlcnZlciBmb3IgbW9yZSBzcGVjaWZpYyBtZXRyaWNzIHNjb3BpbmcuIFdoZW4gdW5zZXQsIGp1c3QgdGhlIG1ldHJpY05hbWUgd2lsbCBiZSB1c2VkIHRvIGdhdGhlciBtZXRyaWNzLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuYXV0b3NjYWxpbmcudjJiZXRhMi5NZXRyaWNJZGVudGlmaWVyI3NlbGVjdG9yXG4gICAqL1xuICByZWFkb25seSBzZWxlY3Rvcj86IExhYmVsU2VsZWN0b3I7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnTWV0cmljSWRlbnRpZmllclYyQmV0YTInIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX01ldHJpY0lkZW50aWZpZXJWMkJldGEyKG9iajogTWV0cmljSWRlbnRpZmllclYyQmV0YTIgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICduYW1lJzogb2JqLm5hbWUsXG4gICAgJ3NlbGVjdG9yJzogdG9Kc29uX0xhYmVsU2VsZWN0b3Iob2JqLnNlbGVjdG9yKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBBIG51bGwgb3IgZW1wdHkgbm9kZSBzZWxlY3RvciB0ZXJtIG1hdGNoZXMgbm8gb2JqZWN0cy4gVGhlIHJlcXVpcmVtZW50cyBvZiB0aGVtIGFyZSBBTkRlZC4gVGhlIFRvcG9sb2d5U2VsZWN0b3JUZXJtIHR5cGUgaW1wbGVtZW50cyBhIHN1YnNldCBvZiB0aGUgTm9kZVNlbGVjdG9yVGVybS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Ob2RlU2VsZWN0b3JUZXJtXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTm9kZVNlbGVjdG9yVGVybSB7XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2Ygbm9kZSBzZWxlY3RvciByZXF1aXJlbWVudHMgYnkgbm9kZSdzIGxhYmVscy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTm9kZVNlbGVjdG9yVGVybSNtYXRjaEV4cHJlc3Npb25zXG4gICAqL1xuICByZWFkb25seSBtYXRjaEV4cHJlc3Npb25zPzogTm9kZVNlbGVjdG9yUmVxdWlyZW1lbnRbXTtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIG5vZGUgc2VsZWN0b3IgcmVxdWlyZW1lbnRzIGJ5IG5vZGUncyBmaWVsZHMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLk5vZGVTZWxlY3RvclRlcm0jbWF0Y2hGaWVsZHNcbiAgICovXG4gIHJlYWRvbmx5IG1hdGNoRmllbGRzPzogTm9kZVNlbGVjdG9yUmVxdWlyZW1lbnRbXTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdOb2RlU2VsZWN0b3JUZXJtJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Ob2RlU2VsZWN0b3JUZXJtKG9iajogTm9kZVNlbGVjdG9yVGVybSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ21hdGNoRXhwcmVzc2lvbnMnOiBvYmoubWF0Y2hFeHByZXNzaW9ucz8ubWFwKHkgPT4gdG9Kc29uX05vZGVTZWxlY3RvclJlcXVpcmVtZW50KHkpKSxcbiAgICAnbWF0Y2hGaWVsZHMnOiBvYmoubWF0Y2hGaWVsZHM/Lm1hcCh5ID0+IHRvSnNvbl9Ob2RlU2VsZWN0b3JSZXF1aXJlbWVudCh5KSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQW4gZW1wdHkgcHJlZmVycmVkIHNjaGVkdWxpbmcgdGVybSBtYXRjaGVzIGFsbCBvYmplY3RzIHdpdGggaW1wbGljaXQgd2VpZ2h0IDAgKGkuZS4gaXQncyBhIG5vLW9wKS4gQSBudWxsIHByZWZlcnJlZCBzY2hlZHVsaW5nIHRlcm0gbWF0Y2hlcyBubyBvYmplY3RzIChpLmUuIGlzIGFsc28gYSBuby1vcCkuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUHJlZmVycmVkU2NoZWR1bGluZ1Rlcm1cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcmVmZXJyZWRTY2hlZHVsaW5nVGVybSB7XG4gIC8qKlxuICAgKiBBIG5vZGUgc2VsZWN0b3IgdGVybSwgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHdlaWdodC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUHJlZmVycmVkU2NoZWR1bGluZ1Rlcm0jcHJlZmVyZW5jZVxuICAgKi9cbiAgcmVhZG9ubHkgcHJlZmVyZW5jZTogTm9kZVNlbGVjdG9yVGVybTtcblxuICAvKipcbiAgICogV2VpZ2h0IGFzc29jaWF0ZWQgd2l0aCBtYXRjaGluZyB0aGUgY29ycmVzcG9uZGluZyBub2RlU2VsZWN0b3JUZXJtLCBpbiB0aGUgcmFuZ2UgMS0xMDAuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlByZWZlcnJlZFNjaGVkdWxpbmdUZXJtI3dlaWdodFxuICAgKi9cbiAgcmVhZG9ubHkgd2VpZ2h0OiBudW1iZXI7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnUHJlZmVycmVkU2NoZWR1bGluZ1Rlcm0nIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1ByZWZlcnJlZFNjaGVkdWxpbmdUZXJtKG9iajogUHJlZmVycmVkU2NoZWR1bGluZ1Rlcm0gfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdwcmVmZXJlbmNlJzogdG9Kc29uX05vZGVTZWxlY3RvclRlcm0ob2JqLnByZWZlcmVuY2UpLFxuICAgICd3ZWlnaHQnOiBvYmoud2VpZ2h0LFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFRoZSB3ZWlnaHRzIG9mIGFsbCBvZiB0aGUgbWF0Y2hlZCBXZWlnaHRlZFBvZEFmZmluaXR5VGVybSBmaWVsZHMgYXJlIGFkZGVkIHBlci1ub2RlIHRvIGZpbmQgdGhlIG1vc3QgcHJlZmVycmVkIG5vZGUocylcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5XZWlnaHRlZFBvZEFmZmluaXR5VGVybVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFdlaWdodGVkUG9kQWZmaW5pdHlUZXJtIHtcbiAgLyoqXG4gICAqIFJlcXVpcmVkLiBBIHBvZCBhZmZpbml0eSB0ZXJtLCBhc3NvY2lhdGVkIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgd2VpZ2h0LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5XZWlnaHRlZFBvZEFmZmluaXR5VGVybSNwb2RBZmZpbml0eVRlcm1cbiAgICovXG4gIHJlYWRvbmx5IHBvZEFmZmluaXR5VGVybTogUG9kQWZmaW5pdHlUZXJtO1xuXG4gIC8qKlxuICAgKiB3ZWlnaHQgYXNzb2NpYXRlZCB3aXRoIG1hdGNoaW5nIHRoZSBjb3JyZXNwb25kaW5nIHBvZEFmZmluaXR5VGVybSwgaW4gdGhlIHJhbmdlIDEtMTAwLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5XZWlnaHRlZFBvZEFmZmluaXR5VGVybSN3ZWlnaHRcbiAgICovXG4gIHJlYWRvbmx5IHdlaWdodDogbnVtYmVyO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1dlaWdodGVkUG9kQWZmaW5pdHlUZXJtJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9XZWlnaHRlZFBvZEFmZmluaXR5VGVybShvYmo6IFdlaWdodGVkUG9kQWZmaW5pdHlUZXJtIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAncG9kQWZmaW5pdHlUZXJtJzogdG9Kc29uX1BvZEFmZmluaXR5VGVybShvYmoucG9kQWZmaW5pdHlUZXJtKSxcbiAgICAnd2VpZ2h0Jzogb2JqLndlaWdodCxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBEZWZpbmVzIGEgc2V0IG9mIHBvZHMgKG5hbWVseSB0aG9zZSBtYXRjaGluZyB0aGUgbGFiZWxTZWxlY3RvciByZWxhdGl2ZSB0byB0aGUgZ2l2ZW4gbmFtZXNwYWNlKHMpKSB0aGF0IHRoaXMgcG9kIHNob3VsZCBiZSBjby1sb2NhdGVkIChhZmZpbml0eSkgb3Igbm90IGNvLWxvY2F0ZWQgKGFudGktYWZmaW5pdHkpIHdpdGgsIHdoZXJlIGNvLWxvY2F0ZWQgaXMgZGVmaW5lZCBhcyBydW5uaW5nIG9uIGEgbm9kZSB3aG9zZSB2YWx1ZSBvZiB0aGUgbGFiZWwgd2l0aCBrZXkgPHRvcG9sb2d5S2V5PiBtYXRjaGVzIHRoYXQgb2YgYW55IG5vZGUgb24gd2hpY2ggYSBwb2Qgb2YgdGhlIHNldCBvZiBwb2RzIGlzIHJ1bm5pbmdcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Qb2RBZmZpbml0eVRlcm1cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQb2RBZmZpbml0eVRlcm0ge1xuICAvKipcbiAgICogQSBsYWJlbCBxdWVyeSBvdmVyIGEgc2V0IG9mIHJlc291cmNlcywgaW4gdGhpcyBjYXNlIHBvZHMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZEFmZmluaXR5VGVybSNsYWJlbFNlbGVjdG9yXG4gICAqL1xuICByZWFkb25seSBsYWJlbFNlbGVjdG9yPzogTGFiZWxTZWxlY3RvcjtcblxuICAvKipcbiAgICogQSBsYWJlbCBxdWVyeSBvdmVyIHRoZSBzZXQgb2YgbmFtZXNwYWNlcyB0aGF0IHRoZSB0ZXJtIGFwcGxpZXMgdG8uIFRoZSB0ZXJtIGlzIGFwcGxpZWQgdG8gdGhlIHVuaW9uIG9mIHRoZSBuYW1lc3BhY2VzIHNlbGVjdGVkIGJ5IHRoaXMgZmllbGQgYW5kIHRoZSBvbmVzIGxpc3RlZCBpbiB0aGUgbmFtZXNwYWNlcyBmaWVsZC4gbnVsbCBzZWxlY3RvciBhbmQgbnVsbCBvciBlbXB0eSBuYW1lc3BhY2VzIGxpc3QgbWVhbnMgXCJ0aGlzIHBvZCdzIG5hbWVzcGFjZVwiLiBBbiBlbXB0eSBzZWxlY3RvciAoe30pIG1hdGNoZXMgYWxsIG5hbWVzcGFjZXMuIFRoaXMgZmllbGQgaXMgYmV0YS1sZXZlbCBhbmQgaXMgb25seSBob25vcmVkIHdoZW4gUG9kQWZmaW5pdHlOYW1lc3BhY2VTZWxlY3RvciBmZWF0dXJlIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZEFmZmluaXR5VGVybSNuYW1lc3BhY2VTZWxlY3RvclxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZXNwYWNlU2VsZWN0b3I/OiBMYWJlbFNlbGVjdG9yO1xuXG4gIC8qKlxuICAgKiBuYW1lc3BhY2VzIHNwZWNpZmllcyBhIHN0YXRpYyBsaXN0IG9mIG5hbWVzcGFjZSBuYW1lcyB0aGF0IHRoZSB0ZXJtIGFwcGxpZXMgdG8uIFRoZSB0ZXJtIGlzIGFwcGxpZWQgdG8gdGhlIHVuaW9uIG9mIHRoZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiB0aGlzIGZpZWxkIGFuZCB0aGUgb25lcyBzZWxlY3RlZCBieSBuYW1lc3BhY2VTZWxlY3Rvci4gbnVsbCBvciBlbXB0eSBuYW1lc3BhY2VzIGxpc3QgYW5kIG51bGwgbmFtZXNwYWNlU2VsZWN0b3IgbWVhbnMgXCJ0aGlzIHBvZCdzIG5hbWVzcGFjZVwiXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZEFmZmluaXR5VGVybSNuYW1lc3BhY2VzXG4gICAqL1xuICByZWFkb25seSBuYW1lc3BhY2VzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIFRoaXMgcG9kIHNob3VsZCBiZSBjby1sb2NhdGVkIChhZmZpbml0eSkgb3Igbm90IGNvLWxvY2F0ZWQgKGFudGktYWZmaW5pdHkpIHdpdGggdGhlIHBvZHMgbWF0Y2hpbmcgdGhlIGxhYmVsU2VsZWN0b3IgaW4gdGhlIHNwZWNpZmllZCBuYW1lc3BhY2VzLCB3aGVyZSBjby1sb2NhdGVkIGlzIGRlZmluZWQgYXMgcnVubmluZyBvbiBhIG5vZGUgd2hvc2UgdmFsdWUgb2YgdGhlIGxhYmVsIHdpdGgga2V5IHRvcG9sb2d5S2V5IG1hdGNoZXMgdGhhdCBvZiBhbnkgbm9kZSBvbiB3aGljaCBhbnkgb2YgdGhlIHNlbGVjdGVkIHBvZHMgaXMgcnVubmluZy4gRW1wdHkgdG9wb2xvZ3lLZXkgaXMgbm90IGFsbG93ZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBvZEFmZmluaXR5VGVybSN0b3BvbG9neUtleVxuICAgKi9cbiAgcmVhZG9ubHkgdG9wb2xvZ3lLZXk6IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdQb2RBZmZpbml0eVRlcm0nIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1BvZEFmZmluaXR5VGVybShvYmo6IFBvZEFmZmluaXR5VGVybSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2xhYmVsU2VsZWN0b3InOiB0b0pzb25fTGFiZWxTZWxlY3RvcihvYmoubGFiZWxTZWxlY3RvciksXG4gICAgJ25hbWVzcGFjZVNlbGVjdG9yJzogdG9Kc29uX0xhYmVsU2VsZWN0b3Iob2JqLm5hbWVzcGFjZVNlbGVjdG9yKSxcbiAgICAnbmFtZXNwYWNlcyc6IG9iai5uYW1lc3BhY2VzPy5tYXAoeSA9PiB5KSxcbiAgICAndG9wb2xvZ3lLZXknOiBvYmoudG9wb2xvZ3lLZXksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogRW52VmFyU291cmNlIHJlcHJlc2VudHMgYSBzb3VyY2UgZm9yIHRoZSB2YWx1ZSBvZiBhbiBFbnZWYXIuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRW52VmFyU291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRW52VmFyU291cmNlIHtcbiAgLyoqXG4gICAqIFNlbGVjdHMgYSBrZXkgb2YgYSBDb25maWdNYXAuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkVudlZhclNvdXJjZSNjb25maWdNYXBLZXlSZWZcbiAgICovXG4gIHJlYWRvbmx5IGNvbmZpZ01hcEtleVJlZj86IENvbmZpZ01hcEtleVNlbGVjdG9yO1xuXG4gIC8qKlxuICAgKiBTZWxlY3RzIGEgZmllbGQgb2YgdGhlIHBvZDogc3VwcG9ydHMgbWV0YWRhdGEubmFtZSwgbWV0YWRhdGEubmFtZXNwYWNlLCBgbWV0YWRhdGEubGFiZWxzWyc8S0VZPiddYCwgYG1ldGFkYXRhLmFubm90YXRpb25zWyc8S0VZPiddYCwgc3BlYy5ub2RlTmFtZSwgc3BlYy5zZXJ2aWNlQWNjb3VudE5hbWUsIHN0YXR1cy5ob3N0SVAsIHN0YXR1cy5wb2RJUCwgc3RhdHVzLnBvZElQcy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRW52VmFyU291cmNlI2ZpZWxkUmVmXG4gICAqL1xuICByZWFkb25seSBmaWVsZFJlZj86IE9iamVjdEZpZWxkU2VsZWN0b3I7XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgYSByZXNvdXJjZSBvZiB0aGUgY29udGFpbmVyOiBvbmx5IHJlc291cmNlcyBsaW1pdHMgYW5kIHJlcXVlc3RzIChsaW1pdHMuY3B1LCBsaW1pdHMubWVtb3J5LCBsaW1pdHMuZXBoZW1lcmFsLXN0b3JhZ2UsIHJlcXVlc3RzLmNwdSwgcmVxdWVzdHMubWVtb3J5IGFuZCByZXF1ZXN0cy5lcGhlbWVyYWwtc3RvcmFnZSkgYXJlIGN1cnJlbnRseSBzdXBwb3J0ZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkVudlZhclNvdXJjZSNyZXNvdXJjZUZpZWxkUmVmXG4gICAqL1xuICByZWFkb25seSByZXNvdXJjZUZpZWxkUmVmPzogUmVzb3VyY2VGaWVsZFNlbGVjdG9yO1xuXG4gIC8qKlxuICAgKiBTZWxlY3RzIGEga2V5IG9mIGEgc2VjcmV0IGluIHRoZSBwb2QncyBuYW1lc3BhY2VcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRW52VmFyU291cmNlI3NlY3JldEtleVJlZlxuICAgKi9cbiAgcmVhZG9ubHkgc2VjcmV0S2V5UmVmPzogU2VjcmV0S2V5U2VsZWN0b3I7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnRW52VmFyU291cmNlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9FbnZWYXJTb3VyY2Uob2JqOiBFbnZWYXJTb3VyY2UgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdjb25maWdNYXBLZXlSZWYnOiB0b0pzb25fQ29uZmlnTWFwS2V5U2VsZWN0b3Iob2JqLmNvbmZpZ01hcEtleVJlZiksXG4gICAgJ2ZpZWxkUmVmJzogdG9Kc29uX09iamVjdEZpZWxkU2VsZWN0b3Iob2JqLmZpZWxkUmVmKSxcbiAgICAncmVzb3VyY2VGaWVsZFJlZic6IHRvSnNvbl9SZXNvdXJjZUZpZWxkU2VsZWN0b3Iob2JqLnJlc291cmNlRmllbGRSZWYpLFxuICAgICdzZWNyZXRLZXlSZWYnOiB0b0pzb25fU2VjcmV0S2V5U2VsZWN0b3Iob2JqLnNlY3JldEtleVJlZiksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQ29uZmlnTWFwRW52U291cmNlIHNlbGVjdHMgYSBDb25maWdNYXAgdG8gcG9wdWxhdGUgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcyB3aXRoLlxuICpcbiAqIFRoZSBjb250ZW50cyBvZiB0aGUgdGFyZ2V0IENvbmZpZ01hcCdzIERhdGEgZmllbGQgd2lsbCByZXByZXNlbnQgdGhlIGtleS12YWx1ZSBwYWlycyBhcyBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ29uZmlnTWFwRW52U291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29uZmlnTWFwRW52U291cmNlIHtcbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIHJlZmVyZW50LiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL292ZXJ2aWV3L3dvcmtpbmctd2l0aC1vYmplY3RzL25hbWVzLyNuYW1lc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db25maWdNYXBFbnZTb3VyY2UjbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogU3BlY2lmeSB3aGV0aGVyIHRoZSBDb25maWdNYXAgbXVzdCBiZSBkZWZpbmVkXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbmZpZ01hcEVudlNvdXJjZSNvcHRpb25hbFxuICAgKi9cbiAgcmVhZG9ubHkgb3B0aW9uYWw/OiBib29sZWFuO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0NvbmZpZ01hcEVudlNvdXJjZScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fQ29uZmlnTWFwRW52U291cmNlKG9iajogQ29uZmlnTWFwRW52U291cmNlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbmFtZSc6IG9iai5uYW1lLFxuICAgICdvcHRpb25hbCc6IG9iai5vcHRpb25hbCxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBTZWNyZXRFbnZTb3VyY2Ugc2VsZWN0cyBhIFNlY3JldCB0byBwb3B1bGF0ZSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIHdpdGguXG4gKlxuICogVGhlIGNvbnRlbnRzIG9mIHRoZSB0YXJnZXQgU2VjcmV0J3MgRGF0YSBmaWVsZCB3aWxsIHJlcHJlc2VudCB0aGUga2V5LXZhbHVlIHBhaXJzIGFzIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZWNyZXRFbnZTb3VyY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZWNyZXRFbnZTb3VyY2Uge1xuICAvKipcbiAgICogTmFtZSBvZiB0aGUgcmVmZXJlbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvb3ZlcnZpZXcvd29ya2luZy13aXRoLW9iamVjdHMvbmFtZXMvI25hbWVzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlY3JldEVudlNvdXJjZSNuYW1lXG4gICAqL1xuICByZWFkb25seSBuYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgdGhlIFNlY3JldCBtdXN0IGJlIGRlZmluZWRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VjcmV0RW52U291cmNlI29wdGlvbmFsXG4gICAqL1xuICByZWFkb25seSBvcHRpb25hbD86IGJvb2xlYW47XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnU2VjcmV0RW52U291cmNlJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9TZWNyZXRFbnZTb3VyY2Uob2JqOiBTZWNyZXRFbnZTb3VyY2UgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICduYW1lJzogb2JqLm5hbWUsXG4gICAgJ29wdGlvbmFsJzogb2JqLm9wdGlvbmFsLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEhhbmRsZXIgZGVmaW5lcyBhIHNwZWNpZmljIGFjdGlvbiB0aGF0IHNob3VsZCBiZSB0YWtlblxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkhhbmRsZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIYW5kbGVyIHtcbiAgLyoqXG4gICAqIE9uZSBhbmQgb25seSBvbmUgb2YgdGhlIGZvbGxvd2luZyBzaG91bGQgYmUgc3BlY2lmaWVkLiBFeGVjIHNwZWNpZmllcyB0aGUgYWN0aW9uIHRvIHRha2UuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkhhbmRsZXIjZXhlY1xuICAgKi9cbiAgcmVhZG9ubHkgZXhlYz86IEV4ZWNBY3Rpb247XG5cbiAgLyoqXG4gICAqIEhUVFBHZXQgc3BlY2lmaWVzIHRoZSBodHRwIHJlcXVlc3QgdG8gcGVyZm9ybS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuSGFuZGxlciNodHRwR2V0XG4gICAqL1xuICByZWFkb25seSBodHRwR2V0PzogSHR0cEdldEFjdGlvbjtcblxuICAvKipcbiAgICogVENQU29ja2V0IHNwZWNpZmllcyBhbiBhY3Rpb24gaW52b2x2aW5nIGEgVENQIHBvcnQuIFRDUCBob29rcyBub3QgeWV0IHN1cHBvcnRlZFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5IYW5kbGVyI3RjcFNvY2tldFxuICAgKi9cbiAgcmVhZG9ubHkgdGNwU29ja2V0PzogVGNwU29ja2V0QWN0aW9uO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0hhbmRsZXInIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0hhbmRsZXIob2JqOiBIYW5kbGVyIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZXhlYyc6IHRvSnNvbl9FeGVjQWN0aW9uKG9iai5leGVjKSxcbiAgICAnaHR0cEdldCc6IHRvSnNvbl9IdHRwR2V0QWN0aW9uKG9iai5odHRwR2V0KSxcbiAgICAndGNwU29ja2V0JzogdG9Kc29uX1RjcFNvY2tldEFjdGlvbihvYmoudGNwU29ja2V0KSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBFeGVjQWN0aW9uIGRlc2NyaWJlcyBhIFwicnVuIGluIGNvbnRhaW5lclwiIGFjdGlvbi5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FeGVjQWN0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXhlY0FjdGlvbiB7XG4gIC8qKlxuICAgKiBDb21tYW5kIGlzIHRoZSBjb21tYW5kIGxpbmUgdG8gZXhlY3V0ZSBpbnNpZGUgdGhlIGNvbnRhaW5lciwgdGhlIHdvcmtpbmcgZGlyZWN0b3J5IGZvciB0aGUgY29tbWFuZCAgaXMgcm9vdCAoJy8nKSBpbiB0aGUgY29udGFpbmVyJ3MgZmlsZXN5c3RlbS4gVGhlIGNvbW1hbmQgaXMgc2ltcGx5IGV4ZWMnZCwgaXQgaXMgbm90IHJ1biBpbnNpZGUgYSBzaGVsbCwgc28gdHJhZGl0aW9uYWwgc2hlbGwgaW5zdHJ1Y3Rpb25zICgnfCcsIGV0Yykgd29uJ3Qgd29yay4gVG8gdXNlIGEgc2hlbGwsIHlvdSBuZWVkIHRvIGV4cGxpY2l0bHkgY2FsbCBvdXQgdG8gdGhhdCBzaGVsbC4gRXhpdCBzdGF0dXMgb2YgMCBpcyB0cmVhdGVkIGFzIGxpdmUvaGVhbHRoeSBhbmQgbm9uLXplcm8gaXMgdW5oZWFsdGh5LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5FeGVjQWN0aW9uI2NvbW1hbmRcbiAgICovXG4gIHJlYWRvbmx5IGNvbW1hbmQ/OiBzdHJpbmdbXTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdFeGVjQWN0aW9uJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9FeGVjQWN0aW9uKG9iajogRXhlY0FjdGlvbiB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2NvbW1hbmQnOiBvYmouY29tbWFuZD8ubWFwKHkgPT4geSksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogSFRUUEdldEFjdGlvbiBkZXNjcmliZXMgYW4gYWN0aW9uIGJhc2VkIG9uIEhUVFAgR2V0IHJlcXVlc3RzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkhUVFBHZXRBY3Rpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIdHRwR2V0QWN0aW9uIHtcbiAgLyoqXG4gICAqIEhvc3QgbmFtZSB0byBjb25uZWN0IHRvLCBkZWZhdWx0cyB0byB0aGUgcG9kIElQLiBZb3UgcHJvYmFibHkgd2FudCB0byBzZXQgXCJIb3N0XCIgaW4gaHR0cEhlYWRlcnMgaW5zdGVhZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuSFRUUEdldEFjdGlvbiNob3N0XG4gICAqL1xuICByZWFkb25seSBob3N0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDdXN0b20gaGVhZGVycyB0byBzZXQgaW4gdGhlIHJlcXVlc3QuIEhUVFAgYWxsb3dzIHJlcGVhdGVkIGhlYWRlcnMuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkhUVFBHZXRBY3Rpb24jaHR0cEhlYWRlcnNcbiAgICovXG4gIHJlYWRvbmx5IGh0dHBIZWFkZXJzPzogSHR0cEhlYWRlcltdO1xuXG4gIC8qKlxuICAgKiBQYXRoIHRvIGFjY2VzcyBvbiB0aGUgSFRUUCBzZXJ2ZXIuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkhUVFBHZXRBY3Rpb24jcGF0aFxuICAgKi9cbiAgcmVhZG9ubHkgcGF0aD86IHN0cmluZztcblxuICAvKipcbiAgICogTmFtZSBvciBudW1iZXIgb2YgdGhlIHBvcnQgdG8gYWNjZXNzIG9uIHRoZSBjb250YWluZXIuIE51bWJlciBtdXN0IGJlIGluIHRoZSByYW5nZSAxIHRvIDY1NTM1LiBOYW1lIG11c3QgYmUgYW4gSUFOQV9TVkNfTkFNRS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuSFRUUEdldEFjdGlvbiNwb3J0XG4gICAqL1xuICByZWFkb25seSBwb3J0OiBJbnRPclN0cmluZztcblxuICAvKipcbiAgICogU2NoZW1lIHRvIHVzZSBmb3IgY29ubmVjdGluZyB0byB0aGUgaG9zdC4gRGVmYXVsdHMgdG8gSFRUUC5cbiAgICpcbiAgICogQGRlZmF1bHQgSFRUUC5cbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuSFRUUEdldEFjdGlvbiNzY2hlbWVcbiAgICovXG4gIHJlYWRvbmx5IHNjaGVtZT86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdIdHRwR2V0QWN0aW9uJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9IdHRwR2V0QWN0aW9uKG9iajogSHR0cEdldEFjdGlvbiB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2hvc3QnOiBvYmouaG9zdCxcbiAgICAnaHR0cEhlYWRlcnMnOiBvYmouaHR0cEhlYWRlcnM/Lm1hcCh5ID0+IHRvSnNvbl9IdHRwSGVhZGVyKHkpKSxcbiAgICAncGF0aCc6IG9iai5wYXRoLFxuICAgICdwb3J0Jzogb2JqLnBvcnQ/LnZhbHVlLFxuICAgICdzY2hlbWUnOiBvYmouc2NoZW1lLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFRDUFNvY2tldEFjdGlvbiBkZXNjcmliZXMgYW4gYWN0aW9uIGJhc2VkIG9uIG9wZW5pbmcgYSBzb2NrZXRcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5UQ1BTb2NrZXRBY3Rpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUY3BTb2NrZXRBY3Rpb24ge1xuICAvKipcbiAgICogT3B0aW9uYWw6IEhvc3QgbmFtZSB0byBjb25uZWN0IHRvLCBkZWZhdWx0cyB0byB0aGUgcG9kIElQLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5UQ1BTb2NrZXRBY3Rpb24jaG9zdFxuICAgKi9cbiAgcmVhZG9ubHkgaG9zdD86IHN0cmluZztcblxuICAvKipcbiAgICogTnVtYmVyIG9yIG5hbWUgb2YgdGhlIHBvcnQgdG8gYWNjZXNzIG9uIHRoZSBjb250YWluZXIuIE51bWJlciBtdXN0IGJlIGluIHRoZSByYW5nZSAxIHRvIDY1NTM1LiBOYW1lIG11c3QgYmUgYW4gSUFOQV9TVkNfTkFNRS5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVENQU29ja2V0QWN0aW9uI3BvcnRcbiAgICovXG4gIHJlYWRvbmx5IHBvcnQ6IEludE9yU3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1RjcFNvY2tldEFjdGlvbicgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fVGNwU29ja2V0QWN0aW9uKG9iajogVGNwU29ja2V0QWN0aW9uIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaG9zdCc6IG9iai5ob3N0LFxuICAgICdwb3J0Jzogb2JqLnBvcnQ/LnZhbHVlLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEFkZHMgYW5kIHJlbW92ZXMgUE9TSVggY2FwYWJpbGl0aWVzIGZyb20gcnVubmluZyBjb250YWluZXJzLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNhcGFiaWxpdGllc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIENhcGFiaWxpdGllcyB7XG4gIC8qKlxuICAgKiBBZGRlZCBjYXBhYmlsaXRpZXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ2FwYWJpbGl0aWVzI2FkZFxuICAgKi9cbiAgcmVhZG9ubHkgYWRkPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIFJlbW92ZWQgY2FwYWJpbGl0aWVzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNhcGFiaWxpdGllcyNkcm9wXG4gICAqL1xuICByZWFkb25seSBkcm9wPzogc3RyaW5nW107XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnQ2FwYWJpbGl0aWVzJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9DYXBhYmlsaXRpZXMob2JqOiBDYXBhYmlsaXRpZXMgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdhZGQnOiBvYmouYWRkPy5tYXAoeSA9PiB5KSxcbiAgICAnZHJvcCc6IG9iai5kcm9wPy5tYXAoeSA9PiB5KSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBNYXBzIGEgc3RyaW5nIGtleSB0byBhIHBhdGggd2l0aGluIGEgdm9sdW1lLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLktleVRvUGF0aFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEtleVRvUGF0aCB7XG4gIC8qKlxuICAgKiBUaGUga2V5IHRvIHByb2plY3QuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLktleVRvUGF0aCNrZXlcbiAgICovXG4gIHJlYWRvbmx5IGtleTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbDogbW9kZSBiaXRzIHVzZWQgdG8gc2V0IHBlcm1pc3Npb25zIG9uIHRoaXMgZmlsZS4gTXVzdCBiZSBhbiBvY3RhbCB2YWx1ZSBiZXR3ZWVuIDAwMDAgYW5kIDA3Nzcgb3IgYSBkZWNpbWFsIHZhbHVlIGJldHdlZW4gMCBhbmQgNTExLiBZQU1MIGFjY2VwdHMgYm90aCBvY3RhbCBhbmQgZGVjaW1hbCB2YWx1ZXMsIEpTT04gcmVxdWlyZXMgZGVjaW1hbCB2YWx1ZXMgZm9yIG1vZGUgYml0cy4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHZvbHVtZSBkZWZhdWx0TW9kZSB3aWxsIGJlIHVzZWQuIFRoaXMgbWlnaHQgYmUgaW4gY29uZmxpY3Qgd2l0aCBvdGhlciBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBmaWxlIG1vZGUsIGxpa2UgZnNHcm91cCwgYW5kIHRoZSByZXN1bHQgY2FuIGJlIG90aGVyIG1vZGUgYml0cyBzZXQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLktleVRvUGF0aCNtb2RlXG4gICAqL1xuICByZWFkb25seSBtb2RlPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVsYXRpdmUgcGF0aCBvZiB0aGUgZmlsZSB0byBtYXAgdGhlIGtleSB0by4gTWF5IG5vdCBiZSBhbiBhYnNvbHV0ZSBwYXRoLiBNYXkgbm90IGNvbnRhaW4gdGhlIHBhdGggZWxlbWVudCAnLi4nLiBNYXkgbm90IHN0YXJ0IHdpdGggdGhlIHN0cmluZyAnLi4nLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5LZXlUb1BhdGgjcGF0aFxuICAgKi9cbiAgcmVhZG9ubHkgcGF0aDogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0tleVRvUGF0aCcgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fS2V5VG9QYXRoKG9iajogS2V5VG9QYXRoIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAna2V5Jzogb2JqLmtleSxcbiAgICAnbW9kZSc6IG9iai5tb2RlLFxuICAgICdwYXRoJzogb2JqLnBhdGgsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogRG93bndhcmRBUElWb2x1bWVGaWxlIHJlcHJlc2VudHMgaW5mb3JtYXRpb24gdG8gY3JlYXRlIHRoZSBmaWxlIGNvbnRhaW5pbmcgdGhlIHBvZCBmaWVsZFxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkRvd253YXJkQVBJVm9sdW1lRmlsZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIERvd253YXJkQXBpVm9sdW1lRmlsZSB7XG4gIC8qKlxuICAgKiBSZXF1aXJlZDogU2VsZWN0cyBhIGZpZWxkIG9mIHRoZSBwb2Q6IG9ubHkgYW5ub3RhdGlvbnMsIGxhYmVscywgbmFtZSBhbmQgbmFtZXNwYWNlIGFyZSBzdXBwb3J0ZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkRvd253YXJkQVBJVm9sdW1lRmlsZSNmaWVsZFJlZlxuICAgKi9cbiAgcmVhZG9ubHkgZmllbGRSZWY/OiBPYmplY3RGaWVsZFNlbGVjdG9yO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbDogbW9kZSBiaXRzIHVzZWQgdG8gc2V0IHBlcm1pc3Npb25zIG9uIHRoaXMgZmlsZSwgbXVzdCBiZSBhbiBvY3RhbCB2YWx1ZSBiZXR3ZWVuIDAwMDAgYW5kIDA3Nzcgb3IgYSBkZWNpbWFsIHZhbHVlIGJldHdlZW4gMCBhbmQgNTExLiBZQU1MIGFjY2VwdHMgYm90aCBvY3RhbCBhbmQgZGVjaW1hbCB2YWx1ZXMsIEpTT04gcmVxdWlyZXMgZGVjaW1hbCB2YWx1ZXMgZm9yIG1vZGUgYml0cy4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHZvbHVtZSBkZWZhdWx0TW9kZSB3aWxsIGJlIHVzZWQuIFRoaXMgbWlnaHQgYmUgaW4gY29uZmxpY3Qgd2l0aCBvdGhlciBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBmaWxlIG1vZGUsIGxpa2UgZnNHcm91cCwgYW5kIHRoZSByZXN1bHQgY2FuIGJlIG90aGVyIG1vZGUgYml0cyBzZXQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkRvd253YXJkQVBJVm9sdW1lRmlsZSNtb2RlXG4gICAqL1xuICByZWFkb25seSBtb2RlPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBSZXF1aXJlZDogUGF0aCBpcyAgdGhlIHJlbGF0aXZlIHBhdGggbmFtZSBvZiB0aGUgZmlsZSB0byBiZSBjcmVhdGVkLiBNdXN0IG5vdCBiZSBhYnNvbHV0ZSBvciBjb250YWluIHRoZSAnLi4nIHBhdGguIE11c3QgYmUgdXRmLTggZW5jb2RlZC4gVGhlIGZpcnN0IGl0ZW0gb2YgdGhlIHJlbGF0aXZlIHBhdGggbXVzdCBub3Qgc3RhcnQgd2l0aCAnLi4nXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkRvd253YXJkQVBJVm9sdW1lRmlsZSNwYXRoXG4gICAqL1xuICByZWFkb25seSBwYXRoOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgYSByZXNvdXJjZSBvZiB0aGUgY29udGFpbmVyOiBvbmx5IHJlc291cmNlcyBsaW1pdHMgYW5kIHJlcXVlc3RzIChsaW1pdHMuY3B1LCBsaW1pdHMubWVtb3J5LCByZXF1ZXN0cy5jcHUgYW5kIHJlcXVlc3RzLm1lbW9yeSkgYXJlIGN1cnJlbnRseSBzdXBwb3J0ZWQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkRvd253YXJkQVBJVm9sdW1lRmlsZSNyZXNvdXJjZUZpZWxkUmVmXG4gICAqL1xuICByZWFkb25seSByZXNvdXJjZUZpZWxkUmVmPzogUmVzb3VyY2VGaWVsZFNlbGVjdG9yO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0Rvd253YXJkQXBpVm9sdW1lRmlsZScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fRG93bndhcmRBcGlWb2x1bWVGaWxlKG9iajogRG93bndhcmRBcGlWb2x1bWVGaWxlIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnZmllbGRSZWYnOiB0b0pzb25fT2JqZWN0RmllbGRTZWxlY3RvcihvYmouZmllbGRSZWYpLFxuICAgICdtb2RlJzogb2JqLm1vZGUsXG4gICAgJ3BhdGgnOiBvYmoucGF0aCxcbiAgICAncmVzb3VyY2VGaWVsZFJlZic6IHRvSnNvbl9SZXNvdXJjZUZpZWxkU2VsZWN0b3Iob2JqLnJlc291cmNlRmllbGRSZWYpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFBlcnNpc3RlbnRWb2x1bWVDbGFpbVRlbXBsYXRlIGlzIHVzZWQgdG8gcHJvZHVjZSBQZXJzaXN0ZW50Vm9sdW1lQ2xhaW0gb2JqZWN0cyBhcyBwYXJ0IG9mIGFuIEVwaGVtZXJhbFZvbHVtZVNvdXJjZS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lQ2xhaW1UZW1wbGF0ZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBlcnNpc3RlbnRWb2x1bWVDbGFpbVRlbXBsYXRlIHtcbiAgLyoqXG4gICAqIE1heSBjb250YWluIGxhYmVscyBhbmQgYW5ub3RhdGlvbnMgdGhhdCB3aWxsIGJlIGNvcGllZCBpbnRvIHRoZSBQVkMgd2hlbiBjcmVhdGluZyBpdC4gTm8gb3RoZXIgZmllbGRzIGFyZSBhbGxvd2VkIGFuZCB3aWxsIGJlIHJlamVjdGVkIGR1cmluZyB2YWxpZGF0aW9uLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lQ2xhaW1UZW1wbGF0ZSNtZXRhZGF0YVxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBPYmplY3RNZXRhO1xuXG4gIC8qKlxuICAgKiBUaGUgc3BlY2lmaWNhdGlvbiBmb3IgdGhlIFBlcnNpc3RlbnRWb2x1bWVDbGFpbS4gVGhlIGVudGlyZSBjb250ZW50IGlzIGNvcGllZCB1bmNoYW5nZWQgaW50byB0aGUgUFZDIHRoYXQgZ2V0cyBjcmVhdGVkIGZyb20gdGhpcyB0ZW1wbGF0ZS4gVGhlIHNhbWUgZmllbGRzIGFzIGluIGEgUGVyc2lzdGVudFZvbHVtZUNsYWltIGFyZSBhbHNvIHZhbGlkIGhlcmUuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVDbGFpbVRlbXBsYXRlI3NwZWNcbiAgICovXG4gIHJlYWRvbmx5IHNwZWM6IFBlcnNpc3RlbnRWb2x1bWVDbGFpbVNwZWM7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnUGVyc2lzdGVudFZvbHVtZUNsYWltVGVtcGxhdGUnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1BlcnNpc3RlbnRWb2x1bWVDbGFpbVRlbXBsYXRlKG9iajogUGVyc2lzdGVudFZvbHVtZUNsYWltVGVtcGxhdGUgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdtZXRhZGF0YSc6IHRvSnNvbl9PYmplY3RNZXRhKG9iai5tZXRhZGF0YSksXG4gICAgJ3NwZWMnOiB0b0pzb25fUGVyc2lzdGVudFZvbHVtZUNsYWltU3BlYyhvYmouc3BlYyksXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUHJvamVjdGlvbiB0aGF0IG1heSBiZSBwcm9qZWN0ZWQgYWxvbmcgd2l0aCBvdGhlciBzdXBwb3J0ZWQgdm9sdW1lIHR5cGVzXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVm9sdW1lUHJvamVjdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZvbHVtZVByb2plY3Rpb24ge1xuICAvKipcbiAgICogaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNvbmZpZ01hcCBkYXRhIHRvIHByb2plY3RcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVm9sdW1lUHJvamVjdGlvbiNjb25maWdNYXBcbiAgICovXG4gIHJlYWRvbmx5IGNvbmZpZ01hcD86IENvbmZpZ01hcFByb2plY3Rpb247XG5cbiAgLyoqXG4gICAqIGluZm9ybWF0aW9uIGFib3V0IHRoZSBkb3dud2FyZEFQSSBkYXRhIHRvIHByb2plY3RcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVm9sdW1lUHJvamVjdGlvbiNkb3dud2FyZEFQSVxuICAgKi9cbiAgcmVhZG9ubHkgZG93bndhcmRBcGk/OiBEb3dud2FyZEFwaVByb2plY3Rpb247XG5cbiAgLyoqXG4gICAqIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzZWNyZXQgZGF0YSB0byBwcm9qZWN0XG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlZvbHVtZVByb2plY3Rpb24jc2VjcmV0XG4gICAqL1xuICByZWFkb25seSBzZWNyZXQ/OiBTZWNyZXRQcm9qZWN0aW9uO1xuXG4gIC8qKlxuICAgKiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc2VydmljZUFjY291bnRUb2tlbiBkYXRhIHRvIHByb2plY3RcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuVm9sdW1lUHJvamVjdGlvbiNzZXJ2aWNlQWNjb3VudFRva2VuXG4gICAqL1xuICByZWFkb25seSBzZXJ2aWNlQWNjb3VudFRva2VuPzogU2VydmljZUFjY291bnRUb2tlblByb2plY3Rpb247XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnVm9sdW1lUHJvamVjdGlvbicgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fVm9sdW1lUHJvamVjdGlvbihvYmo6IFZvbHVtZVByb2plY3Rpb24gfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdjb25maWdNYXAnOiB0b0pzb25fQ29uZmlnTWFwUHJvamVjdGlvbihvYmouY29uZmlnTWFwKSxcbiAgICAnZG93bndhcmRBUEknOiB0b0pzb25fRG93bndhcmRBcGlQcm9qZWN0aW9uKG9iai5kb3dud2FyZEFwaSksXG4gICAgJ3NlY3JldCc6IHRvSnNvbl9TZWNyZXRQcm9qZWN0aW9uKG9iai5zZWNyZXQpLFxuICAgICdzZXJ2aWNlQWNjb3VudFRva2VuJzogdG9Kc29uX1NlcnZpY2VBY2NvdW50VG9rZW5Qcm9qZWN0aW9uKG9iai5zZXJ2aWNlQWNjb3VudFRva2VuKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBHcm91cFN1YmplY3QgaG9sZHMgZGV0YWlsZWQgaW5mb3JtYXRpb24gZm9yIGdyb3VwLWtpbmQgc3ViamVjdC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuZmxvd2NvbnRyb2wudjFiZXRhMS5Hcm91cFN1YmplY3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHcm91cFN1YmplY3RWMUJldGExIHtcbiAgLyoqXG4gICAqIG5hbWUgaXMgdGhlIHVzZXIgZ3JvdXAgdGhhdCBtYXRjaGVzLCBvciBcIipcIiB0byBtYXRjaCBhbGwgdXNlciBncm91cHMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20va3ViZXJuZXRlcy9hcGlzZXJ2ZXIvYmxvYi9tYXN0ZXIvcGtnL2F1dGhlbnRpY2F0aW9uL3VzZXIvdXNlci5nbyBmb3Igc29tZSB3ZWxsLWtub3duIGdyb3VwIG5hbWVzLiBSZXF1aXJlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuR3JvdXBTdWJqZWN0I25hbWVcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdHcm91cFN1YmplY3RWMUJldGExJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Hcm91cFN1YmplY3RWMUJldGExKG9iajogR3JvdXBTdWJqZWN0VjFCZXRhMSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ25hbWUnOiBvYmoubmFtZSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBTZXJ2aWNlQWNjb3VudFN1YmplY3QgaG9sZHMgZGV0YWlsZWQgaW5mb3JtYXRpb24gZm9yIHNlcnZpY2UtYWNjb3VudC1raW5kIHN1YmplY3QuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuU2VydmljZUFjY291bnRTdWJqZWN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VydmljZUFjY291bnRTdWJqZWN0VjFCZXRhMSB7XG4gIC8qKlxuICAgKiBgbmFtZWAgaXMgdGhlIG5hbWUgb2YgbWF0Y2hpbmcgU2VydmljZUFjY291bnQgb2JqZWN0cywgb3IgXCIqXCIgdG8gbWF0Y2ggcmVnYXJkbGVzcyBvZiBuYW1lLiBSZXF1aXJlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuU2VydmljZUFjY291bnRTdWJqZWN0I25hbWVcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogYG5hbWVzcGFjZWAgaXMgdGhlIG5hbWVzcGFjZSBvZiBtYXRjaGluZyBTZXJ2aWNlQWNjb3VudCBvYmplY3RzLiBSZXF1aXJlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuU2VydmljZUFjY291bnRTdWJqZWN0I25hbWVzcGFjZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZXNwYWNlOiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnU2VydmljZUFjY291bnRTdWJqZWN0VjFCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fU2VydmljZUFjY291bnRTdWJqZWN0VjFCZXRhMShvYmo6IFNlcnZpY2VBY2NvdW50U3ViamVjdFYxQmV0YTEgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICduYW1lJzogb2JqLm5hbWUsXG4gICAgJ25hbWVzcGFjZSc6IG9iai5uYW1lc3BhY2UsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogVXNlclN1YmplY3QgaG9sZHMgZGV0YWlsZWQgaW5mb3JtYXRpb24gZm9yIHVzZXIta2luZCBzdWJqZWN0LlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLlVzZXJTdWJqZWN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXNlclN1YmplY3RWMUJldGExIHtcbiAgLyoqXG4gICAqIGBuYW1lYCBpcyB0aGUgdXNlcm5hbWUgdGhhdCBtYXRjaGVzLCBvciBcIipcIiB0byBtYXRjaCBhbGwgdXNlcm5hbWVzLiBSZXF1aXJlZC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuVXNlclN1YmplY3QjbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1VzZXJTdWJqZWN0VjFCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fVXNlclN1YmplY3RWMUJldGExKG9iajogVXNlclN1YmplY3RWMUJldGExIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbmFtZSc6IG9iai5uYW1lLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFF1ZXVpbmdDb25maWd1cmF0aW9uIGhvbGRzIHRoZSBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgZm9yIHF1ZXVpbmdcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuZmxvd2NvbnRyb2wudjFiZXRhMS5RdWV1aW5nQ29uZmlndXJhdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXVpbmdDb25maWd1cmF0aW9uVjFCZXRhMSB7XG4gIC8qKlxuICAgKiBgaGFuZFNpemVgIGlzIGEgc21hbGwgcG9zaXRpdmUgbnVtYmVyIHRoYXQgY29uZmlndXJlcyB0aGUgc2h1ZmZsZSBzaGFyZGluZyBvZiByZXF1ZXN0cyBpbnRvIHF1ZXVlcy4gIFdoZW4gZW5xdWV1aW5nIGEgcmVxdWVzdCBhdCB0aGlzIHByaW9yaXR5IGxldmVsIHRoZSByZXF1ZXN0J3MgZmxvdyBpZGVudGlmaWVyIChhIHN0cmluZyBwYWlyKSBpcyBoYXNoZWQgYW5kIHRoZSBoYXNoIHZhbHVlIGlzIHVzZWQgdG8gc2h1ZmZsZSB0aGUgbGlzdCBvZiBxdWV1ZXMgYW5kIGRlYWwgYSBoYW5kIG9mIHRoZSBzaXplIHNwZWNpZmllZCBoZXJlLiAgVGhlIHJlcXVlc3QgaXMgcHV0IGludG8gb25lIG9mIHRoZSBzaG9ydGVzdCBxdWV1ZXMgaW4gdGhhdCBoYW5kLiBgaGFuZFNpemVgIG11c3QgYmUgbm8gbGFyZ2VyIHRoYW4gYHF1ZXVlc2AsIGFuZCBzaG91bGQgYmUgc2lnbmlmaWNhbnRseSBzbWFsbGVyIChzbyB0aGF0IGEgZmV3IGhlYXZ5IGZsb3dzIGRvIG5vdCBzYXR1cmF0ZSBtb3N0IG9mIHRoZSBxdWV1ZXMpLiAgU2VlIHRoZSB1c2VyLWZhY2luZyBkb2N1bWVudGF0aW9uIGZvciBtb3JlIGV4dGVuc2l2ZSBndWlkYW5jZSBvbiBzZXR0aW5nIHRoaXMgZmllbGQuICBUaGlzIGZpZWxkIGhhcyBhIGRlZmF1bHQgdmFsdWUgb2YgOC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmZsb3djb250cm9sLnYxYmV0YTEuUXVldWluZ0NvbmZpZ3VyYXRpb24jaGFuZFNpemVcbiAgICovXG4gIHJlYWRvbmx5IGhhbmRTaXplPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBgcXVldWVMZW5ndGhMaW1pdGAgaXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJlcXVlc3RzIGFsbG93ZWQgdG8gYmUgd2FpdGluZyBpbiBhIGdpdmVuIHF1ZXVlIG9mIHRoaXMgcHJpb3JpdHkgbGV2ZWwgYXQgYSB0aW1lOyBleGNlc3MgcmVxdWVzdHMgYXJlIHJlamVjdGVkLiAgVGhpcyB2YWx1ZSBtdXN0IGJlIHBvc2l0aXZlLiAgSWYgbm90IHNwZWNpZmllZCwgaXQgd2lsbCBiZSBkZWZhdWx0ZWQgdG8gNTAuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLlF1ZXVpbmdDb25maWd1cmF0aW9uI3F1ZXVlTGVuZ3RoTGltaXRcbiAgICovXG4gIHJlYWRvbmx5IHF1ZXVlTGVuZ3RoTGltaXQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIGBxdWV1ZXNgIGlzIHRoZSBudW1iZXIgb2YgcXVldWVzIGZvciB0aGlzIHByaW9yaXR5IGxldmVsLiBUaGUgcXVldWVzIGV4aXN0IGluZGVwZW5kZW50bHkgYXQgZWFjaCBhcGlzZXJ2ZXIuIFRoZSB2YWx1ZSBtdXN0IGJlIHBvc2l0aXZlLiAgU2V0dGluZyBpdCB0byAxIGVmZmVjdGl2ZWx5IHByZWNsdWRlcyBzaHVmZmxlc2hhcmRpbmcgYW5kIHRodXMgbWFrZXMgdGhlIGRpc3Rpbmd1aXNoZXIgbWV0aG9kIG9mIGFzc29jaWF0ZWQgZmxvdyBzY2hlbWFzIGlycmVsZXZhbnQuICBUaGlzIGZpZWxkIGhhcyBhIGRlZmF1bHQgdmFsdWUgb2YgNjQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5mbG93Y29udHJvbC52MWJldGExLlF1ZXVpbmdDb25maWd1cmF0aW9uI3F1ZXVlc1xuICAgKi9cbiAgcmVhZG9ubHkgcXVldWVzPzogbnVtYmVyO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1F1ZXVpbmdDb25maWd1cmF0aW9uVjFCZXRhMScgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fUXVldWluZ0NvbmZpZ3VyYXRpb25WMUJldGExKG9iajogUXVldWluZ0NvbmZpZ3VyYXRpb25WMUJldGExIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnaGFuZFNpemUnOiBvYmouaGFuZFNpemUsXG4gICAgJ3F1ZXVlTGVuZ3RoTGltaXQnOiBvYmoucXVldWVMZW5ndGhMaW1pdCxcbiAgICAncXVldWVzJzogb2JqLnF1ZXVlcyxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBTZXJ2aWNlQmFja2VuZFBvcnQgaXMgdGhlIHNlcnZpY2UgcG9ydCBiZWluZyByZWZlcmVuY2VkLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLlNlcnZpY2VCYWNrZW5kUG9ydFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZpY2VCYWNrZW5kUG9ydCB7XG4gIC8qKlxuICAgKiBOYW1lIGlzIHRoZSBuYW1lIG9mIHRoZSBwb3J0IG9uIHRoZSBTZXJ2aWNlLiBUaGlzIGlzIGEgbXV0dWFsbHkgZXhjbHVzaXZlIHNldHRpbmcgd2l0aCBcIk51bWJlclwiLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5TZXJ2aWNlQmFja2VuZFBvcnQjbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogTnVtYmVyIGlzIHRoZSBudW1lcmljYWwgcG9ydCBudW1iZXIgKGUuZy4gODApIG9uIHRoZSBTZXJ2aWNlLiBUaGlzIGlzIGEgbXV0dWFsbHkgZXhjbHVzaXZlIHNldHRpbmcgd2l0aCBcIk5hbWVcIi5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuU2VydmljZUJhY2tlbmRQb3J0I251bWJlclxuICAgKi9cbiAgcmVhZG9ubHkgbnVtYmVyPzogbnVtYmVyO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ1NlcnZpY2VCYWNrZW5kUG9ydCcgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fU2VydmljZUJhY2tlbmRQb3J0KG9iajogU2VydmljZUJhY2tlbmRQb3J0IHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnbmFtZSc6IG9iai5uYW1lLFxuICAgICdudW1iZXInOiBvYmoubnVtYmVyLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEhUVFBJbmdyZXNzUGF0aCBhc3NvY2lhdGVzIGEgcGF0aCB3aXRoIGEgYmFja2VuZC4gSW5jb21pbmcgdXJscyBtYXRjaGluZyB0aGUgcGF0aCBhcmUgZm9yd2FyZGVkIHRvIHRoZSBiYWNrZW5kLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5uZXR3b3JraW5nLnYxLkhUVFBJbmdyZXNzUGF0aFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEh0dHBJbmdyZXNzUGF0aCB7XG4gIC8qKlxuICAgKiBCYWNrZW5kIGRlZmluZXMgdGhlIHJlZmVyZW5jZWQgc2VydmljZSBlbmRwb2ludCB0byB3aGljaCB0aGUgdHJhZmZpYyB3aWxsIGJlIGZvcndhcmRlZCB0by5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuSFRUUEluZ3Jlc3NQYXRoI2JhY2tlbmRcbiAgICovXG4gIHJlYWRvbmx5IGJhY2tlbmQ6IEluZ3Jlc3NCYWNrZW5kO1xuXG4gIC8qKlxuICAgKiBQYXRoIGlzIG1hdGNoZWQgYWdhaW5zdCB0aGUgcGF0aCBvZiBhbiBpbmNvbWluZyByZXF1ZXN0LiBDdXJyZW50bHkgaXQgY2FuIGNvbnRhaW4gY2hhcmFjdGVycyBkaXNhbGxvd2VkIGZyb20gdGhlIGNvbnZlbnRpb25hbCBcInBhdGhcIiBwYXJ0IG9mIGEgVVJMIGFzIGRlZmluZWQgYnkgUkZDIDM5ODYuIFBhdGhzIG11c3QgYmVnaW4gd2l0aCBhICcvJyBhbmQgbXVzdCBiZSBwcmVzZW50IHdoZW4gdXNpbmcgUGF0aFR5cGUgd2l0aCB2YWx1ZSBcIkV4YWN0XCIgb3IgXCJQcmVmaXhcIi5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuSFRUUEluZ3Jlc3NQYXRoI3BhdGhcbiAgICovXG4gIHJlYWRvbmx5IHBhdGg/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFBhdGhUeXBlIGRldGVybWluZXMgdGhlIGludGVycHJldGF0aW9uIG9mIHRoZSBQYXRoIG1hdGNoaW5nLiBQYXRoVHlwZSBjYW4gYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiAqIEV4YWN0OiBNYXRjaGVzIHRoZSBVUkwgcGF0aCBleGFjdGx5LiAqIFByZWZpeDogTWF0Y2hlcyBiYXNlZCBvbiBhIFVSTCBwYXRoIHByZWZpeCBzcGxpdCBieSAnLycuIE1hdGNoaW5nIGlzXG4gICAqIGRvbmUgb24gYSBwYXRoIGVsZW1lbnQgYnkgZWxlbWVudCBiYXNpcy4gQSBwYXRoIGVsZW1lbnQgcmVmZXJzIGlzIHRoZVxuICAgKiBsaXN0IG9mIGxhYmVscyBpbiB0aGUgcGF0aCBzcGxpdCBieSB0aGUgJy8nIHNlcGFyYXRvci4gQSByZXF1ZXN0IGlzIGFcbiAgICogbWF0Y2ggZm9yIHBhdGggcCBpZiBldmVyeSBwIGlzIGFuIGVsZW1lbnQtd2lzZSBwcmVmaXggb2YgcCBvZiB0aGVcbiAgICogcmVxdWVzdCBwYXRoLiBOb3RlIHRoYXQgaWYgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgcGF0aCBpcyBhIHN1YnN0cmluZ1xuICAgKiBvZiB0aGUgbGFzdCBlbGVtZW50IGluIHJlcXVlc3QgcGF0aCwgaXQgaXMgbm90IGEgbWF0Y2ggKGUuZy4gL2Zvby9iYXJcbiAgICogbWF0Y2hlcyAvZm9vL2Jhci9iYXosIGJ1dCBkb2VzIG5vdCBtYXRjaCAvZm9vL2JhcmJheikuXG4gICAqICogSW1wbGVtZW50YXRpb25TcGVjaWZpYzogSW50ZXJwcmV0YXRpb24gb2YgdGhlIFBhdGggbWF0Y2hpbmcgaXMgdXAgdG9cbiAgICogdGhlIEluZ3Jlc3NDbGFzcy4gSW1wbGVtZW50YXRpb25zIGNhbiB0cmVhdCB0aGlzIGFzIGEgc2VwYXJhdGUgUGF0aFR5cGVcbiAgICogb3IgdHJlYXQgaXQgaWRlbnRpY2FsbHkgdG8gUHJlZml4IG9yIEV4YWN0IHBhdGggdHlwZXMuXG4gICAqIEltcGxlbWVudGF0aW9ucyBhcmUgcmVxdWlyZWQgdG8gc3VwcG9ydCBhbGwgcGF0aCB0eXBlcy5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuSFRUUEluZ3Jlc3NQYXRoI3BhdGhUeXBlXG4gICAqL1xuICByZWFkb25seSBwYXRoVHlwZTogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ0h0dHBJbmdyZXNzUGF0aCcgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fSHR0cEluZ3Jlc3NQYXRoKG9iajogSHR0cEluZ3Jlc3NQYXRoIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAnYmFja2VuZCc6IHRvSnNvbl9JbmdyZXNzQmFja2VuZChvYmouYmFja2VuZCksXG4gICAgJ3BhdGgnOiBvYmoucGF0aCxcbiAgICAncGF0aFR5cGUnOiBvYmoucGF0aFR5cGUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogSVBCbG9jayBkZXNjcmliZXMgYSBwYXJ0aWN1bGFyIENJRFIgKEV4LiBcIjE5Mi4xNjguMS4xLzI0XCIsXCIyMDAxOmRiOTo6LzY0XCIpIHRoYXQgaXMgYWxsb3dlZCB0byB0aGUgcG9kcyBtYXRjaGVkIGJ5IGEgTmV0d29ya1BvbGljeVNwZWMncyBwb2RTZWxlY3Rvci4gVGhlIGV4Y2VwdCBlbnRyeSBkZXNjcmliZXMgQ0lEUnMgdGhhdCBzaG91bGQgbm90IGJlIGluY2x1ZGVkIHdpdGhpbiB0aGlzIHJ1bGUuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuSVBCbG9ja1xuICovXG5leHBvcnQgaW50ZXJmYWNlIElwQmxvY2sge1xuICAvKipcbiAgICogQ0lEUiBpcyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIElQIEJsb2NrIFZhbGlkIGV4YW1wbGVzIGFyZSBcIjE5Mi4xNjguMS4xLzI0XCIgb3IgXCIyMDAxOmRiOTo6LzY0XCJcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLm5ldHdvcmtpbmcudjEuSVBCbG9jayNjaWRyXG4gICAqL1xuICByZWFkb25seSBjaWRyOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEV4Y2VwdCBpcyBhIHNsaWNlIG9mIENJRFJzIHRoYXQgc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCB3aXRoaW4gYW4gSVAgQmxvY2sgVmFsaWQgZXhhbXBsZXMgYXJlIFwiMTkyLjE2OC4xLjEvMjRcIiBvciBcIjIwMDE6ZGI5OjovNjRcIiBFeGNlcHQgdmFsdWVzIHdpbGwgYmUgcmVqZWN0ZWQgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGUgQ0lEUiByYW5nZVxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkubmV0d29ya2luZy52MS5JUEJsb2NrI2V4Y2VwdFxuICAgKi9cbiAgcmVhZG9ubHkgZXhjZXB0Pzogc3RyaW5nW107XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnSXBCbG9jaycgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fSXBCbG9jayhvYmo6IElwQmxvY2sgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdjaWRyJzogb2JqLmNpZHIsXG4gICAgJ2V4Y2VwdCc6IG9iai5leGNlcHQ/Lm1hcCh5ID0+IHkpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEpTT05TY2hlbWFQcm9wcyBpcyBhIEpTT04tU2NoZW1hIGZvbGxvd2luZyBTcGVjaWZpY2F0aW9uIERyYWZ0IDQgKGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvKS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkpTT05TY2hlbWFQcm9wc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEpzb25TY2hlbWFQcm9wcyB7XG4gIC8qKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkpTT05TY2hlbWFQcm9wcyMkcmVmXG4gICAqL1xuICByZWFkb25seSByZWY/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuSlNPTlNjaGVtYVByb3BzIyRzY2hlbWFcbiAgICovXG4gIHJlYWRvbmx5IHNjaGVtYT86IHN0cmluZztcblxuICAvKipcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5KU09OU2NoZW1hUHJvcHMjYWRkaXRpb25hbEl0ZW1zXG4gICAqL1xuICByZWFkb25seSBhZGRpdGlvbmFsSXRlbXM/OiBhbnk7XG5cbiAgLyoqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuSlNPTlNjaGVtYVByb3BzI2FkZGl0aW9uYWxQcm9wZXJ0aWVzXG4gICAqL1xuICByZWFkb25seSBhZGRpdGlvbmFsUHJvcGVydGllcz86IGFueTtcblxuICAvKipcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5KU09OU2NoZW1hUHJvcHMjYWxsT2ZcbiAgICovXG4gIHJlYWRvbmx5IGFsbE9mPzogSnNvblNjaGVtYVByb3BzW107XG5cbiAgLyoqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuSlNPTlNjaGVtYVByb3BzI2FueU9mXG4gICAqL1xuICByZWFkb25seSBhbnlPZj86IEpzb25TY2hlbWFQcm9wc1tdO1xuXG4gIC8qKlxuICAgKiBkZWZhdWx0IGlzIGEgZGVmYXVsdCB2YWx1ZSBmb3IgdW5kZWZpbmVkIG9iamVjdCBmaWVsZHMuIERlZmF1bHRpbmcgaXMgYSBiZXRhIGZlYXR1cmUgdW5kZXIgdGhlIEN1c3RvbVJlc291cmNlRGVmYXVsdGluZyBmZWF0dXJlIGdhdGUuIERlZmF1bHRpbmcgcmVxdWlyZXMgc3BlYy5wcmVzZXJ2ZVVua25vd25GaWVsZHMgdG8gYmUgZmFsc2UuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuSlNPTlNjaGVtYVByb3BzI2RlZmF1bHRcbiAgICovXG4gIHJlYWRvbmx5IGRlZmF1bHQ/OiBhbnk7XG5cbiAgLyoqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuSlNPTlNjaGVtYVByb3BzI2RlZmluaXRpb25zXG4gICAqL1xuICByZWFkb25seSBkZWZpbml0aW9ucz86IHsgW2tleTogc3RyaW5nXTogSnNvblNjaGVtYVByb3BzIH07XG5cbiAgLyoqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuSlNPTlNjaGVtYVByb3BzI2RlcGVuZGVuY2llc1xuICAgKi9cbiAgcmVhZG9ubHkgZGVwZW5kZW5jaWVzPzogeyBba2V5OiBzdHJpbmddOiBhbnkgfTtcblxuICAvKipcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5KU09OU2NoZW1hUHJvcHMjZGVzY3JpcHRpb25cbiAgICovXG4gIHJlYWRvbmx5IGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkpTT05TY2hlbWFQcm9wcyNlbnVtXG4gICAqL1xuICByZWFkb25seSBlbnVtPzogYW55W107XG5cbiAgLyoqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuSlNPTlNjaGVtYVByb3BzI2V4YW1wbGVcbiAgICovXG4gIHJlYWRvbmx5IGV4YW1wbGU/OiBhbnk7XG5cbiAgLyoqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuSlNPTlNjaGVtYVByb3BzI2V4Y2x1c2l2ZU1heGltdW1cbiAgICovXG4gIHJlYWRvbmx5IGV4Y2x1c2l2ZU1heGltdW0/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkpTT05TY2hlbWFQcm9wcyNleGNsdXNpdmVNaW5pbXVtXG4gICAqL1xuICByZWFkb25seSBleGNsdXNpdmVNaW5pbXVtPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5KU09OU2NoZW1hUHJvcHMjZXh0ZXJuYWxEb2NzXG4gICAqL1xuICByZWFkb25seSBleHRlcm5hbERvY3M/OiBFeHRlcm5hbERvY3VtZW50YXRpb247XG5cbiAgLyoqXG4gICAqIGZvcm1hdCBpcyBhbiBPcGVuQVBJIHYzIGZvcm1hdCBzdHJpbmcuIFVua25vd24gZm9ybWF0cyBhcmUgaWdub3JlZC4gVGhlIGZvbGxvd2luZyBmb3JtYXRzIGFyZSB2YWxpZGF0ZWQ6XG4gICAqXG4gICAqIC0gYnNvbm9iamVjdGlkOiBhIGJzb24gb2JqZWN0IElELCBpLmUuIGEgMjQgY2hhcmFjdGVycyBoZXggc3RyaW5nIC0gdXJpOiBhbiBVUkkgYXMgcGFyc2VkIGJ5IEdvbGFuZyBuZXQvdXJsLlBhcnNlUmVxdWVzdFVSSSAtIGVtYWlsOiBhbiBlbWFpbCBhZGRyZXNzIGFzIHBhcnNlZCBieSBHb2xhbmcgbmV0L21haWwuUGFyc2VBZGRyZXNzIC0gaG9zdG5hbWU6IGEgdmFsaWQgcmVwcmVzZW50YXRpb24gZm9yIGFuIEludGVybmV0IGhvc3QgbmFtZSwgYXMgZGVmaW5lZCBieSBSRkMgMTAzNCwgc2VjdGlvbiAzLjEgW1JGQzEwMzRdLiAtIGlwdjQ6IGFuIElQdjQgSVAgYXMgcGFyc2VkIGJ5IEdvbGFuZyBuZXQuUGFyc2VJUCAtIGlwdjY6IGFuIElQdjYgSVAgYXMgcGFyc2VkIGJ5IEdvbGFuZyBuZXQuUGFyc2VJUCAtIGNpZHI6IGEgQ0lEUiBhcyBwYXJzZWQgYnkgR29sYW5nIG5ldC5QYXJzZUNJRFIgLSBtYWM6IGEgTUFDIGFkZHJlc3MgYXMgcGFyc2VkIGJ5IEdvbGFuZyBuZXQuUGFyc2VNQUMgLSB1dWlkOiBhbiBVVUlEIHRoYXQgYWxsb3dzIHVwcGVyY2FzZSBkZWZpbmVkIGJ5IHRoZSByZWdleCAoP2kpXlswLTlhLWZdezh9LT9bMC05YS1mXXs0fS0/WzAtOWEtZl17NH0tP1swLTlhLWZdezR9LT9bMC05YS1mXXsxMn0kIC0gdXVpZDM6IGFuIFVVSUQzIHRoYXQgYWxsb3dzIHVwcGVyY2FzZSBkZWZpbmVkIGJ5IHRoZSByZWdleCAoP2kpXlswLTlhLWZdezh9LT9bMC05YS1mXXs0fS0/M1swLTlhLWZdezN9LT9bMC05YS1mXXs0fS0/WzAtOWEtZl17MTJ9JCAtIHV1aWQ0OiBhbiBVVUlENCB0aGF0IGFsbG93cyB1cHBlcmNhc2UgZGVmaW5lZCBieSB0aGUgcmVnZXggKD9pKV5bMC05YS1mXXs4fS0/WzAtOWEtZl17NH0tPzRbMC05YS1mXXszfS0/Wzg5YWJdWzAtOWEtZl17M30tP1swLTlhLWZdezEyfSQgLSB1dWlkNTogYW4gVVVJRDUgdGhhdCBhbGxvd3MgdXBwZXJjYXNlIGRlZmluZWQgYnkgdGhlIHJlZ2V4ICg/aSleWzAtOWEtZl17OH0tP1swLTlhLWZdezR9LT81WzAtOWEtZl17M30tP1s4OWFiXVswLTlhLWZdezN9LT9bMC05YS1mXXsxMn0kIC0gaXNibjogYW4gSVNCTjEwIG9yIElTQk4xMyBudW1iZXIgc3RyaW5nIGxpa2UgXCIwMzIxNzUxMDQzXCIgb3IgXCI5NzgtMDMyMTc1MTA0MVwiIC0gaXNibjEwOiBhbiBJU0JOMTAgbnVtYmVyIHN0cmluZyBsaWtlIFwiMDMyMTc1MTA0M1wiIC0gaXNibjEzOiBhbiBJU0JOMTMgbnVtYmVyIHN0cmluZyBsaWtlIFwiOTc4LTAzMjE3NTEwNDFcIiAtIGNyZWRpdGNhcmQ6IGEgY3JlZGl0IGNhcmQgbnVtYmVyIGRlZmluZWQgYnkgdGhlIHJlZ2V4IF4oPzo0WzAtOV17MTJ9KD86WzAtOV17M30pP3w1WzEtNV1bMC05XXsxNH18Nig/OjAxMXw1WzAtOV1bMC05XSlbMC05XXsxMn18M1s0N11bMC05XXsxM318Myg/OjBbMC01XXxbNjhdWzAtOV0pWzAtOV17MTF9fCg/OjIxMzF8MTgwMHwzNVxcZHszfSlcXGR7MTF9KSQgd2l0aCBhbnkgbm9uIGRpZ2l0IGNoYXJhY3RlcnMgbWl4ZWQgaW4gLSBzc246IGEgVS5TLiBzb2NpYWwgc2VjdXJpdHkgbnVtYmVyIGZvbGxvd2luZyB0aGUgcmVnZXggXlxcZHszfVstIF0/XFxkezJ9Wy0gXT9cXGR7NH0kIC0gaGV4Y29sb3I6IGFuIGhleGFkZWNpbWFsIGNvbG9yIGNvZGUgbGlrZSBcIiNGRkZGRkY6IGZvbGxvd2luZyB0aGUgcmVnZXggXiM/KFswLTlhLWZBLUZdezN9fFswLTlhLWZBLUZdezZ9KSQgLSByZ2Jjb2xvcjogYW4gUkdCIGNvbG9yIGNvZGUgbGlrZSByZ2IgbGlrZSBcInJnYigyNTUsMjU1LDI1NTlcIiAtIGJ5dGU6IGJhc2U2NCBlbmNvZGVkIGJpbmFyeSBkYXRhIC0gcGFzc3dvcmQ6IGFueSBraW5kIG9mIHN0cmluZyAtIGRhdGU6IGEgZGF0ZSBzdHJpbmcgbGlrZSBcIjIwMDYtMDEtMDJcIiBhcyBkZWZpbmVkIGJ5IGZ1bGwtZGF0ZSBpbiBSRkMzMzM5IC0gZHVyYXRpb246IGEgZHVyYXRpb24gc3RyaW5nIGxpa2UgXCIyMiBuc1wiIGFzIHBhcnNlZCBieSBHb2xhbmcgdGltZS5QYXJzZUR1cmF0aW9uIG9yIGNvbXBhdGlibGUgd2l0aCBTY2FsYSBkdXJhdGlvbiBmb3JtYXQgLSBkYXRldGltZTogYSBkYXRlIHRpbWUgc3RyaW5nIGxpa2UgXCIyMDE0LTEyLTE1VDE5OjMwOjIwLjAwMFpcIiBhcyBkZWZpbmVkIGJ5IGRhdGUtdGltZSBpbiBSRkMzMzM5LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkpTT05TY2hlbWFQcm9wcyNmb3JtYXRcbiAgICovXG4gIHJlYWRvbmx5IGZvcm1hdD86IHN0cmluZztcblxuICAvKipcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5KU09OU2NoZW1hUHJvcHMjaWRcbiAgICovXG4gIHJlYWRvbmx5IGlkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkpTT05TY2hlbWFQcm9wcyNpdGVtc1xuICAgKi9cbiAgcmVhZG9ubHkgaXRlbXM/OiBhbnk7XG5cbiAgLyoqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuSlNPTlNjaGVtYVByb3BzI21heEl0ZW1zXG4gICAqL1xuICByZWFkb25seSBtYXhJdGVtcz86IG51bWJlcjtcblxuICAvKipcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5KU09OU2NoZW1hUHJvcHMjbWF4TGVuZ3RoXG4gICAqL1xuICByZWFkb25seSBtYXhMZW5ndGg/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuSlNPTlNjaGVtYVByb3BzI21heFByb3BlcnRpZXNcbiAgICovXG4gIHJlYWRvbmx5IG1heFByb3BlcnRpZXM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuSlNPTlNjaGVtYVByb3BzI21heGltdW1cbiAgICovXG4gIHJlYWRvbmx5IG1heGltdW0/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuSlNPTlNjaGVtYVByb3BzI21pbkl0ZW1zXG4gICAqL1xuICByZWFkb25seSBtaW5JdGVtcz86IG51bWJlcjtcblxuICAvKipcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5KU09OU2NoZW1hUHJvcHMjbWluTGVuZ3RoXG4gICAqL1xuICByZWFkb25seSBtaW5MZW5ndGg/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuSlNPTlNjaGVtYVByb3BzI21pblByb3BlcnRpZXNcbiAgICovXG4gIHJlYWRvbmx5IG1pblByb3BlcnRpZXM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuSlNPTlNjaGVtYVByb3BzI21pbmltdW1cbiAgICovXG4gIHJlYWRvbmx5IG1pbmltdW0/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuSlNPTlNjaGVtYVByb3BzI211bHRpcGxlT2ZcbiAgICovXG4gIHJlYWRvbmx5IG11bHRpcGxlT2Y/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuSlNPTlNjaGVtYVByb3BzI25vdFxuICAgKi9cbiAgcmVhZG9ubHkgbm90PzogSnNvblNjaGVtYVByb3BzO1xuXG4gIC8qKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkpTT05TY2hlbWFQcm9wcyNudWxsYWJsZVxuICAgKi9cbiAgcmVhZG9ubHkgbnVsbGFibGU/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkpTT05TY2hlbWFQcm9wcyNvbmVPZlxuICAgKi9cbiAgcmVhZG9ubHkgb25lT2Y/OiBKc29uU2NoZW1hUHJvcHNbXTtcblxuICAvKipcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5KU09OU2NoZW1hUHJvcHMjcGF0dGVyblxuICAgKi9cbiAgcmVhZG9ubHkgcGF0dGVybj86IHN0cmluZztcblxuICAvKipcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5KU09OU2NoZW1hUHJvcHMjcGF0dGVyblByb3BlcnRpZXNcbiAgICovXG4gIHJlYWRvbmx5IHBhdHRlcm5Qcm9wZXJ0aWVzPzogeyBba2V5OiBzdHJpbmddOiBKc29uU2NoZW1hUHJvcHMgfTtcblxuICAvKipcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5KU09OU2NoZW1hUHJvcHMjcHJvcGVydGllc1xuICAgKi9cbiAgcmVhZG9ubHkgcHJvcGVydGllcz86IHsgW2tleTogc3RyaW5nXTogSnNvblNjaGVtYVByb3BzIH07XG5cbiAgLyoqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuSlNPTlNjaGVtYVByb3BzI3JlcXVpcmVkXG4gICAqL1xuICByZWFkb25seSByZXF1aXJlZD86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkpTT05TY2hlbWFQcm9wcyN0aXRsZVxuICAgKi9cbiAgcmVhZG9ubHkgdGl0bGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuSlNPTlNjaGVtYVByb3BzI3R5cGVcbiAgICovXG4gIHJlYWRvbmx5IHR5cGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuSlNPTlNjaGVtYVByb3BzI3VuaXF1ZUl0ZW1zXG4gICAqL1xuICByZWFkb25seSB1bmlxdWVJdGVtcz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHgta3ViZXJuZXRlcy1lbWJlZGRlZC1yZXNvdXJjZSBkZWZpbmVzIHRoYXQgdGhlIHZhbHVlIGlzIGFuIGVtYmVkZGVkIEt1YmVybmV0ZXMgcnVudGltZS5PYmplY3QsIHdpdGggVHlwZU1ldGEgYW5kIE9iamVjdE1ldGEuIFRoZSB0eXBlIG11c3QgYmUgb2JqZWN0LiBJdCBpcyBhbGxvd2VkIHRvIGZ1cnRoZXIgcmVzdHJpY3QgdGhlIGVtYmVkZGVkIG9iamVjdC4ga2luZCwgYXBpVmVyc2lvbiBhbmQgbWV0YWRhdGEgYXJlIHZhbGlkYXRlZCBhdXRvbWF0aWNhbGx5LiB4LWt1YmVybmV0ZXMtcHJlc2VydmUtdW5rbm93bi1maWVsZHMgaXMgYWxsb3dlZCB0byBiZSB0cnVlLCBidXQgZG9lcyBub3QgaGF2ZSB0byBiZSBpZiB0aGUgb2JqZWN0IGlzIGZ1bGx5IHNwZWNpZmllZCAodXAgdG8ga2luZCwgYXBpVmVyc2lvbiwgbWV0YWRhdGEpLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkpTT05TY2hlbWFQcm9wcyN4LWt1YmVybmV0ZXMtZW1iZWRkZWQtcmVzb3VyY2VcbiAgICovXG4gIHJlYWRvbmx5IHhLdWJlcm5ldGVzRW1iZWRkZWRSZXNvdXJjZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHgta3ViZXJuZXRlcy1pbnQtb3Itc3RyaW5nIHNwZWNpZmllcyB0aGF0IHRoaXMgdmFsdWUgaXMgZWl0aGVyIGFuIGludGVnZXIgb3IgYSBzdHJpbmcuIElmIHRoaXMgaXMgdHJ1ZSwgYW4gZW1wdHkgdHlwZSBpcyBhbGxvd2VkIGFuZCB0eXBlIGFzIGNoaWxkIG9mIGFueU9mIGlzIHBlcm1pdHRlZCBpZiBmb2xsb3dpbmcgb25lIG9mIHRoZSBmb2xsb3dpbmcgcGF0dGVybnM6XG4gICAqXG4gICAqIDEpIGFueU9mOlxuICAgKiAtIHR5cGU6IGludGVnZXJcbiAgICogLSB0eXBlOiBzdHJpbmdcbiAgICogMikgYWxsT2Y6XG4gICAqIC0gYW55T2Y6XG4gICAqIC0gdHlwZTogaW50ZWdlclxuICAgKiAtIHR5cGU6IHN0cmluZ1xuICAgKiAtIC4uLiB6ZXJvIG9yIG1vcmVcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5KU09OU2NoZW1hUHJvcHMjeC1rdWJlcm5ldGVzLWludC1vci1zdHJpbmdcbiAgICovXG4gIHJlYWRvbmx5IHhLdWJlcm5ldGVzSW50T3JTdHJpbmc/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiB4LWt1YmVybmV0ZXMtbGlzdC1tYXAta2V5cyBhbm5vdGF0ZXMgYW4gYXJyYXkgd2l0aCB0aGUgeC1rdWJlcm5ldGVzLWxpc3QtdHlwZSBgbWFwYCBieSBzcGVjaWZ5aW5nIHRoZSBrZXlzIHVzZWQgYXMgdGhlIGluZGV4IG9mIHRoZSBtYXAuXG4gICAqXG4gICAqIFRoaXMgdGFnIE1VU1Qgb25seSBiZSB1c2VkIG9uIGxpc3RzIHRoYXQgaGF2ZSB0aGUgXCJ4LWt1YmVybmV0ZXMtbGlzdC10eXBlXCIgZXh0ZW5zaW9uIHNldCB0byBcIm1hcFwiLiBBbHNvLCB0aGUgdmFsdWVzIHNwZWNpZmllZCBmb3IgdGhpcyBhdHRyaWJ1dGUgbXVzdCBiZSBhIHNjYWxhciB0eXBlZCBmaWVsZCBvZiB0aGUgY2hpbGQgc3RydWN0dXJlIChubyBuZXN0aW5nIGlzIHN1cHBvcnRlZCkuXG4gICAqXG4gICAqIFRoZSBwcm9wZXJ0aWVzIHNwZWNpZmllZCBtdXN0IGVpdGhlciBiZSByZXF1aXJlZCBvciBoYXZlIGEgZGVmYXVsdCB2YWx1ZSwgdG8gZW5zdXJlIHRob3NlIHByb3BlcnRpZXMgYXJlIHByZXNlbnQgZm9yIGFsbCBsaXN0IGl0ZW1zLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkpTT05TY2hlbWFQcm9wcyN4LWt1YmVybmV0ZXMtbGlzdC1tYXAta2V5c1xuICAgKi9cbiAgcmVhZG9ubHkgeEt1YmVybmV0ZXNMaXN0TWFwS2V5cz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiB4LWt1YmVybmV0ZXMtbGlzdC10eXBlIGFubm90YXRlcyBhbiBhcnJheSB0byBmdXJ0aGVyIGRlc2NyaWJlIGl0cyB0b3BvbG9neS4gVGhpcyBleHRlbnNpb24gbXVzdCBvbmx5IGJlIHVzZWQgb24gbGlzdHMgYW5kIG1heSBoYXZlIDMgcG9zc2libGUgdmFsdWVzOlxuICAgKlxuICAgKiAxKSBgYXRvbWljYDogdGhlIGxpc3QgaXMgdHJlYXRlZCBhcyBhIHNpbmdsZSBlbnRpdHksIGxpa2UgYSBzY2FsYXIuXG4gICAqIEF0b21pYyBsaXN0cyB3aWxsIGJlIGVudGlyZWx5IHJlcGxhY2VkIHdoZW4gdXBkYXRlZC4gVGhpcyBleHRlbnNpb25cbiAgICogbWF5IGJlIHVzZWQgb24gYW55IHR5cGUgb2YgbGlzdCAoc3RydWN0LCBzY2FsYXIsIC4uLikuXG4gICAqIDIpIGBzZXRgOlxuICAgKiBTZXRzIGFyZSBsaXN0cyB0aGF0IG11c3Qgbm90IGhhdmUgbXVsdGlwbGUgaXRlbXMgd2l0aCB0aGUgc2FtZSB2YWx1ZS4gRWFjaFxuICAgKiB2YWx1ZSBtdXN0IGJlIGEgc2NhbGFyLCBhbiBvYmplY3Qgd2l0aCB4LWt1YmVybmV0ZXMtbWFwLXR5cGUgYGF0b21pY2Agb3IgYW5cbiAgICogYXJyYXkgd2l0aCB4LWt1YmVybmV0ZXMtbGlzdC10eXBlIGBhdG9taWNgLlxuICAgKiAzKSBgbWFwYDpcbiAgICogVGhlc2UgbGlzdHMgYXJlIGxpa2UgbWFwcyBpbiB0aGF0IHRoZWlyIGVsZW1lbnRzIGhhdmUgYSBub24taW5kZXgga2V5XG4gICAqIHVzZWQgdG8gaWRlbnRpZnkgdGhlbS4gT3JkZXIgaXMgcHJlc2VydmVkIHVwb24gbWVyZ2UuIFRoZSBtYXAgdGFnXG4gICAqIG11c3Qgb25seSBiZSB1c2VkIG9uIGEgbGlzdCB3aXRoIGVsZW1lbnRzIG9mIHR5cGUgb2JqZWN0LlxuICAgKiBEZWZhdWx0cyB0byBhdG9taWMgZm9yIGFycmF5cy5cbiAgICpcbiAgICogQGRlZmF1bHQgYXRvbWljIGZvciBhcnJheXMuXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuSlNPTlNjaGVtYVByb3BzI3gta3ViZXJuZXRlcy1saXN0LXR5cGVcbiAgICovXG4gIHJlYWRvbmx5IHhLdWJlcm5ldGVzTGlzdFR5cGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIHgta3ViZXJuZXRlcy1tYXAtdHlwZSBhbm5vdGF0ZXMgYW4gb2JqZWN0IHRvIGZ1cnRoZXIgZGVzY3JpYmUgaXRzIHRvcG9sb2d5LiBUaGlzIGV4dGVuc2lvbiBtdXN0IG9ubHkgYmUgdXNlZCB3aGVuIHR5cGUgaXMgb2JqZWN0IGFuZCBtYXkgaGF2ZSAyIHBvc3NpYmxlIHZhbHVlczpcbiAgICpcbiAgICogMSkgYGdyYW51bGFyYDpcbiAgICogVGhlc2UgbWFwcyBhcmUgYWN0dWFsIG1hcHMgKGtleS12YWx1ZSBwYWlycykgYW5kIGVhY2ggZmllbGRzIGFyZSBpbmRlcGVuZGVudFxuICAgKiBmcm9tIGVhY2ggb3RoZXIgKHRoZXkgY2FuIGVhY2ggYmUgbWFuaXB1bGF0ZWQgYnkgc2VwYXJhdGUgYWN0b3JzKS4gVGhpcyBpc1xuICAgKiB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgZm9yIGFsbCBtYXBzLlxuICAgKiAyKSBgYXRvbWljYDogdGhlIGxpc3QgaXMgdHJlYXRlZCBhcyBhIHNpbmdsZSBlbnRpdHksIGxpa2UgYSBzY2FsYXIuXG4gICAqIEF0b21pYyBtYXBzIHdpbGwgYmUgZW50aXJlbHkgcmVwbGFjZWQgd2hlbiB1cGRhdGVkLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkpTT05TY2hlbWFQcm9wcyN4LWt1YmVybmV0ZXMtbWFwLXR5cGVcbiAgICovXG4gIHJlYWRvbmx5IHhLdWJlcm5ldGVzTWFwVHlwZT86IHN0cmluZztcblxuICAvKipcbiAgICogeC1rdWJlcm5ldGVzLXByZXNlcnZlLXVua25vd24tZmllbGRzIHN0b3BzIHRoZSBBUEkgc2VydmVyIGRlY29kaW5nIHN0ZXAgZnJvbSBwcnVuaW5nIGZpZWxkcyB3aGljaCBhcmUgbm90IHNwZWNpZmllZCBpbiB0aGUgdmFsaWRhdGlvbiBzY2hlbWEuIFRoaXMgYWZmZWN0cyBmaWVsZHMgcmVjdXJzaXZlbHksIGJ1dCBzd2l0Y2hlcyBiYWNrIHRvIG5vcm1hbCBwcnVuaW5nIGJlaGF2aW91ciBpZiBuZXN0ZWQgcHJvcGVydGllcyBvciBhZGRpdGlvbmFsUHJvcGVydGllcyBhcmUgc3BlY2lmaWVkIGluIHRoZSBzY2hlbWEuIFRoaXMgY2FuIGVpdGhlciBiZSB0cnVlIG9yIHVuZGVmaW5lZC4gRmFsc2UgaXMgZm9yYmlkZGVuLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkpTT05TY2hlbWFQcm9wcyN4LWt1YmVybmV0ZXMtcHJlc2VydmUtdW5rbm93bi1maWVsZHNcbiAgICovXG4gIHJlYWRvbmx5IHhLdWJlcm5ldGVzUHJlc2VydmVVbmtub3duRmllbGRzPzogYm9vbGVhbjtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdKc29uU2NoZW1hUHJvcHMnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0pzb25TY2hlbWFQcm9wcyhvYmo6IEpzb25TY2hlbWFQcm9wcyB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJyRyZWYnOiBvYmoucmVmLFxuICAgICckc2NoZW1hJzogb2JqLnNjaGVtYSxcbiAgICAnYWRkaXRpb25hbEl0ZW1zJzogb2JqLmFkZGl0aW9uYWxJdGVtcyxcbiAgICAnYWRkaXRpb25hbFByb3BlcnRpZXMnOiBvYmouYWRkaXRpb25hbFByb3BlcnRpZXMsXG4gICAgJ2FsbE9mJzogb2JqLmFsbE9mPy5tYXAoeSA9PiB0b0pzb25fSnNvblNjaGVtYVByb3BzKHkpKSxcbiAgICAnYW55T2YnOiBvYmouYW55T2Y/Lm1hcCh5ID0+IHRvSnNvbl9Kc29uU2NoZW1hUHJvcHMoeSkpLFxuICAgICdkZWZhdWx0Jzogb2JqLmRlZmF1bHQsXG4gICAgJ2RlZmluaXRpb25zJzogKChvYmouZGVmaW5pdGlvbnMpID09PSB1bmRlZmluZWQpID8gdW5kZWZpbmVkIDogKE9iamVjdC5lbnRyaWVzKG9iai5kZWZpbml0aW9ucykucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IHRvSnNvbl9Kc29uU2NoZW1hUHJvcHMoaVsxXSkgfSksIHt9KSksXG4gICAgJ2RlcGVuZGVuY2llcyc6ICgob2JqLmRlcGVuZGVuY2llcykgPT09IHVuZGVmaW5lZCkgPyB1bmRlZmluZWQgOiAoT2JqZWN0LmVudHJpZXMob2JqLmRlcGVuZGVuY2llcykucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KSksXG4gICAgJ2Rlc2NyaXB0aW9uJzogb2JqLmRlc2NyaXB0aW9uLFxuICAgICdlbnVtJzogb2JqLmVudW0/Lm1hcCh5ID0+IHkpLFxuICAgICdleGFtcGxlJzogb2JqLmV4YW1wbGUsXG4gICAgJ2V4Y2x1c2l2ZU1heGltdW0nOiBvYmouZXhjbHVzaXZlTWF4aW11bSxcbiAgICAnZXhjbHVzaXZlTWluaW11bSc6IG9iai5leGNsdXNpdmVNaW5pbXVtLFxuICAgICdleHRlcm5hbERvY3MnOiB0b0pzb25fRXh0ZXJuYWxEb2N1bWVudGF0aW9uKG9iai5leHRlcm5hbERvY3MpLFxuICAgICdmb3JtYXQnOiBvYmouZm9ybWF0LFxuICAgICdpZCc6IG9iai5pZCxcbiAgICAnaXRlbXMnOiBvYmouaXRlbXMsXG4gICAgJ21heEl0ZW1zJzogb2JqLm1heEl0ZW1zLFxuICAgICdtYXhMZW5ndGgnOiBvYmoubWF4TGVuZ3RoLFxuICAgICdtYXhQcm9wZXJ0aWVzJzogb2JqLm1heFByb3BlcnRpZXMsXG4gICAgJ21heGltdW0nOiBvYmoubWF4aW11bSxcbiAgICAnbWluSXRlbXMnOiBvYmoubWluSXRlbXMsXG4gICAgJ21pbkxlbmd0aCc6IG9iai5taW5MZW5ndGgsXG4gICAgJ21pblByb3BlcnRpZXMnOiBvYmoubWluUHJvcGVydGllcyxcbiAgICAnbWluaW11bSc6IG9iai5taW5pbXVtLFxuICAgICdtdWx0aXBsZU9mJzogb2JqLm11bHRpcGxlT2YsXG4gICAgJ25vdCc6IHRvSnNvbl9Kc29uU2NoZW1hUHJvcHMob2JqLm5vdCksXG4gICAgJ251bGxhYmxlJzogb2JqLm51bGxhYmxlLFxuICAgICdvbmVPZic6IG9iai5vbmVPZj8ubWFwKHkgPT4gdG9Kc29uX0pzb25TY2hlbWFQcm9wcyh5KSksXG4gICAgJ3BhdHRlcm4nOiBvYmoucGF0dGVybixcbiAgICAncGF0dGVyblByb3BlcnRpZXMnOiAoKG9iai5wYXR0ZXJuUHJvcGVydGllcykgPT09IHVuZGVmaW5lZCkgPyB1bmRlZmluZWQgOiAoT2JqZWN0LmVudHJpZXMob2JqLnBhdHRlcm5Qcm9wZXJ0aWVzKS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogdG9Kc29uX0pzb25TY2hlbWFQcm9wcyhpWzFdKSB9KSwge30pKSxcbiAgICAncHJvcGVydGllcyc6ICgob2JqLnByb3BlcnRpZXMpID09PSB1bmRlZmluZWQpID8gdW5kZWZpbmVkIDogKE9iamVjdC5lbnRyaWVzKG9iai5wcm9wZXJ0aWVzKS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogdG9Kc29uX0pzb25TY2hlbWFQcm9wcyhpWzFdKSB9KSwge30pKSxcbiAgICAncmVxdWlyZWQnOiBvYmoucmVxdWlyZWQ/Lm1hcCh5ID0+IHkpLFxuICAgICd0aXRsZSc6IG9iai50aXRsZSxcbiAgICAndHlwZSc6IG9iai50eXBlLFxuICAgICd1bmlxdWVJdGVtcyc6IG9iai51bmlxdWVJdGVtcyxcbiAgICAneC1rdWJlcm5ldGVzLWVtYmVkZGVkLXJlc291cmNlJzogb2JqLnhLdWJlcm5ldGVzRW1iZWRkZWRSZXNvdXJjZSxcbiAgICAneC1rdWJlcm5ldGVzLWludC1vci1zdHJpbmcnOiBvYmoueEt1YmVybmV0ZXNJbnRPclN0cmluZyxcbiAgICAneC1rdWJlcm5ldGVzLWxpc3QtbWFwLWtleXMnOiBvYmoueEt1YmVybmV0ZXNMaXN0TWFwS2V5cz8ubWFwKHkgPT4geSksXG4gICAgJ3gta3ViZXJuZXRlcy1saXN0LXR5cGUnOiBvYmoueEt1YmVybmV0ZXNMaXN0VHlwZSxcbiAgICAneC1rdWJlcm5ldGVzLW1hcC10eXBlJzogb2JqLnhLdWJlcm5ldGVzTWFwVHlwZSxcbiAgICAneC1rdWJlcm5ldGVzLXByZXNlcnZlLXVua25vd24tZmllbGRzJzogb2JqLnhLdWJlcm5ldGVzUHJlc2VydmVVbmtub3duRmllbGRzLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEN1c3RvbVJlc291cmNlU3VicmVzb3VyY2VTY2FsZSBkZWZpbmVzIGhvdyB0byBzZXJ2ZSB0aGUgc2NhbGUgc3VicmVzb3VyY2UgZm9yIEN1c3RvbVJlc291cmNlcy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkN1c3RvbVJlc291cmNlU3VicmVzb3VyY2VTY2FsZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbVJlc291cmNlU3VicmVzb3VyY2VTY2FsZSB7XG4gIC8qKlxuICAgKiBsYWJlbFNlbGVjdG9yUGF0aCBkZWZpbmVzIHRoZSBKU09OIHBhdGggaW5zaWRlIG9mIGEgY3VzdG9tIHJlc291cmNlIHRoYXQgY29ycmVzcG9uZHMgdG8gU2NhbGUgYHN0YXR1cy5zZWxlY3RvcmAuIE9ubHkgSlNPTiBwYXRocyB3aXRob3V0IHRoZSBhcnJheSBub3RhdGlvbiBhcmUgYWxsb3dlZC4gTXVzdCBiZSBhIEpTT04gUGF0aCB1bmRlciBgLnN0YXR1c2Agb3IgYC5zcGVjYC4gTXVzdCBiZSBzZXQgdG8gd29yayB3aXRoIEhvcml6b250YWxQb2RBdXRvc2NhbGVyLiBUaGUgZmllbGQgcG9pbnRlZCBieSB0aGlzIEpTT04gcGF0aCBtdXN0IGJlIGEgc3RyaW5nIGZpZWxkIChub3QgYSBjb21wbGV4IHNlbGVjdG9yIHN0cnVjdCkgd2hpY2ggY29udGFpbnMgYSBzZXJpYWxpemVkIGxhYmVsIHNlbGVjdG9yIGluIHN0cmluZyBmb3JtLiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL3Rhc2tzL2FjY2Vzcy1rdWJlcm5ldGVzLWFwaS9jdXN0b20tcmVzb3VyY2VzL2N1c3RvbS1yZXNvdXJjZS1kZWZpbml0aW9ucyNzY2FsZS1zdWJyZXNvdXJjZSBJZiB0aGVyZSBpcyBubyB2YWx1ZSB1bmRlciB0aGUgZ2l2ZW4gcGF0aCBpbiB0aGUgY3VzdG9tIHJlc291cmNlLCB0aGUgYHN0YXR1cy5zZWxlY3RvcmAgdmFsdWUgaW4gdGhlIGAvc2NhbGVgIHN1YnJlc291cmNlIHdpbGwgZGVmYXVsdCB0byB0aGUgZW1wdHkgc3RyaW5nLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkN1c3RvbVJlc291cmNlU3VicmVzb3VyY2VTY2FsZSNsYWJlbFNlbGVjdG9yUGF0aFxuICAgKi9cbiAgcmVhZG9ubHkgbGFiZWxTZWxlY3RvclBhdGg/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIHNwZWNSZXBsaWNhc1BhdGggZGVmaW5lcyB0aGUgSlNPTiBwYXRoIGluc2lkZSBvZiBhIGN1c3RvbSByZXNvdXJjZSB0aGF0IGNvcnJlc3BvbmRzIHRvIFNjYWxlIGBzcGVjLnJlcGxpY2FzYC4gT25seSBKU09OIHBhdGhzIHdpdGhvdXQgdGhlIGFycmF5IG5vdGF0aW9uIGFyZSBhbGxvd2VkLiBNdXN0IGJlIGEgSlNPTiBQYXRoIHVuZGVyIGAuc3BlY2AuIElmIHRoZXJlIGlzIG5vIHZhbHVlIHVuZGVyIHRoZSBnaXZlbiBwYXRoIGluIHRoZSBjdXN0b20gcmVzb3VyY2UsIHRoZSBgL3NjYWxlYCBzdWJyZXNvdXJjZSB3aWxsIHJldHVybiBhbiBlcnJvciBvbiBHRVQuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaWV4dGVuc2lvbnMtYXBpc2VydmVyLnBrZy5hcGlzLmFwaWV4dGVuc2lvbnMudjEuQ3VzdG9tUmVzb3VyY2VTdWJyZXNvdXJjZVNjYWxlI3NwZWNSZXBsaWNhc1BhdGhcbiAgICovXG4gIHJlYWRvbmx5IHNwZWNSZXBsaWNhc1BhdGg6IHN0cmluZztcblxuICAvKipcbiAgICogc3RhdHVzUmVwbGljYXNQYXRoIGRlZmluZXMgdGhlIEpTT04gcGF0aCBpbnNpZGUgb2YgYSBjdXN0b20gcmVzb3VyY2UgdGhhdCBjb3JyZXNwb25kcyB0byBTY2FsZSBgc3RhdHVzLnJlcGxpY2FzYC4gT25seSBKU09OIHBhdGhzIHdpdGhvdXQgdGhlIGFycmF5IG5vdGF0aW9uIGFyZSBhbGxvd2VkLiBNdXN0IGJlIGEgSlNPTiBQYXRoIHVuZGVyIGAuc3RhdHVzYC4gSWYgdGhlcmUgaXMgbm8gdmFsdWUgdW5kZXIgdGhlIGdpdmVuIHBhdGggaW4gdGhlIGN1c3RvbSByZXNvdXJjZSwgdGhlIGBzdGF0dXMucmVwbGljYXNgIHZhbHVlIGluIHRoZSBgL3NjYWxlYCBzdWJyZXNvdXJjZSB3aWxsIGRlZmF1bHQgdG8gMC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5DdXN0b21SZXNvdXJjZVN1YnJlc291cmNlU2NhbGUjc3RhdHVzUmVwbGljYXNQYXRoXG4gICAqL1xuICByZWFkb25seSBzdGF0dXNSZXBsaWNhc1BhdGg6IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdDdXN0b21SZXNvdXJjZVN1YnJlc291cmNlU2NhbGUnIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0N1c3RvbVJlc291cmNlU3VicmVzb3VyY2VTY2FsZShvYmo6IEN1c3RvbVJlc291cmNlU3VicmVzb3VyY2VTY2FsZSB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2xhYmVsU2VsZWN0b3JQYXRoJzogb2JqLmxhYmVsU2VsZWN0b3JQYXRoLFxuICAgICdzcGVjUmVwbGljYXNQYXRoJzogb2JqLnNwZWNSZXBsaWNhc1BhdGgsXG4gICAgJ3N0YXR1c1JlcGxpY2FzUGF0aCc6IG9iai5zdGF0dXNSZXBsaWNhc1BhdGgsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQSBub2RlIHNlbGVjdG9yIHJlcXVpcmVtZW50IGlzIGEgc2VsZWN0b3IgdGhhdCBjb250YWlucyB2YWx1ZXMsIGEga2V5LCBhbmQgYW4gb3BlcmF0b3IgdGhhdCByZWxhdGVzIHRoZSBrZXkgYW5kIHZhbHVlcy5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Ob2RlU2VsZWN0b3JSZXF1aXJlbWVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5vZGVTZWxlY3RvclJlcXVpcmVtZW50IHtcbiAgLyoqXG4gICAqIFRoZSBsYWJlbCBrZXkgdGhhdCB0aGUgc2VsZWN0b3IgYXBwbGllcyB0by5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTm9kZVNlbGVjdG9yUmVxdWlyZW1lbnQja2V5XG4gICAqL1xuICByZWFkb25seSBrZXk6IHN0cmluZztcblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIGtleSdzIHJlbGF0aW9uc2hpcCB0byBhIHNldCBvZiB2YWx1ZXMuIFZhbGlkIG9wZXJhdG9ycyBhcmUgSW4sIE5vdEluLCBFeGlzdHMsIERvZXNOb3RFeGlzdC4gR3QsIGFuZCBMdC5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuTm9kZVNlbGVjdG9yUmVxdWlyZW1lbnQjb3BlcmF0b3JcbiAgICovXG4gIHJlYWRvbmx5IG9wZXJhdG9yOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIHN0cmluZyB2YWx1ZXMuIElmIHRoZSBvcGVyYXRvciBpcyBJbiBvciBOb3RJbiwgdGhlIHZhbHVlcyBhcnJheSBtdXN0IGJlIG5vbi1lbXB0eS4gSWYgdGhlIG9wZXJhdG9yIGlzIEV4aXN0cyBvciBEb2VzTm90RXhpc3QsIHRoZSB2YWx1ZXMgYXJyYXkgbXVzdCBiZSBlbXB0eS4gSWYgdGhlIG9wZXJhdG9yIGlzIEd0IG9yIEx0LCB0aGUgdmFsdWVzIGFycmF5IG11c3QgaGF2ZSBhIHNpbmdsZSBlbGVtZW50LCB3aGljaCB3aWxsIGJlIGludGVycHJldGVkIGFzIGFuIGludGVnZXIuIFRoaXMgYXJyYXkgaXMgcmVwbGFjZWQgZHVyaW5nIGEgc3RyYXRlZ2ljIG1lcmdlIHBhdGNoLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Ob2RlU2VsZWN0b3JSZXF1aXJlbWVudCN2YWx1ZXNcbiAgICovXG4gIHJlYWRvbmx5IHZhbHVlcz86IHN0cmluZ1tdO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJ05vZGVTZWxlY3RvclJlcXVpcmVtZW50JyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9Ob2RlU2VsZWN0b3JSZXF1aXJlbWVudChvYmo6IE5vZGVTZWxlY3RvclJlcXVpcmVtZW50IHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAna2V5Jzogb2JqLmtleSxcbiAgICAnb3BlcmF0b3InOiBvYmoub3BlcmF0b3IsXG4gICAgJ3ZhbHVlcyc6IG9iai52YWx1ZXM/Lm1hcCh5ID0+IHkpLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIFNlbGVjdHMgYSBrZXkgZnJvbSBhIENvbmZpZ01hcC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db25maWdNYXBLZXlTZWxlY3RvclxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbmZpZ01hcEtleVNlbGVjdG9yIHtcbiAgLyoqXG4gICAqIFRoZSBrZXkgdG8gc2VsZWN0LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db25maWdNYXBLZXlTZWxlY3RvciNrZXlcbiAgICovXG4gIHJlYWRvbmx5IGtleTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSByZWZlcmVudC4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9vdmVydmlldy93b3JraW5nLXdpdGgtb2JqZWN0cy9uYW1lcy8jbmFtZXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ29uZmlnTWFwS2V5U2VsZWN0b3IjbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogU3BlY2lmeSB3aGV0aGVyIHRoZSBDb25maWdNYXAgb3IgaXRzIGtleSBtdXN0IGJlIGRlZmluZWRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuQ29uZmlnTWFwS2V5U2VsZWN0b3Ijb3B0aW9uYWxcbiAgICovXG4gIHJlYWRvbmx5IG9wdGlvbmFsPzogYm9vbGVhbjtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdDb25maWdNYXBLZXlTZWxlY3RvcicgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fQ29uZmlnTWFwS2V5U2VsZWN0b3Iob2JqOiBDb25maWdNYXBLZXlTZWxlY3RvciB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2tleSc6IG9iai5rZXksXG4gICAgJ25hbWUnOiBvYmoubmFtZSxcbiAgICAnb3B0aW9uYWwnOiBvYmoub3B0aW9uYWwsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogT2JqZWN0RmllbGRTZWxlY3RvciBzZWxlY3RzIGFuIEFQSVZlcnNpb25lZCBmaWVsZCBvZiBhbiBvYmplY3QuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuT2JqZWN0RmllbGRTZWxlY3RvclxuICovXG5leHBvcnQgaW50ZXJmYWNlIE9iamVjdEZpZWxkU2VsZWN0b3Ige1xuICAvKipcbiAgICogVmVyc2lvbiBvZiB0aGUgc2NoZW1hIHRoZSBGaWVsZFBhdGggaXMgd3JpdHRlbiBpbiB0ZXJtcyBvZiwgZGVmYXVsdHMgdG8gXCJ2MVwiLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5PYmplY3RGaWVsZFNlbGVjdG9yI2FwaVZlcnNpb25cbiAgICovXG4gIHJlYWRvbmx5IGFwaVZlcnNpb24/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFBhdGggb2YgdGhlIGZpZWxkIHRvIHNlbGVjdCBpbiB0aGUgc3BlY2lmaWVkIEFQSSB2ZXJzaW9uLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5PYmplY3RGaWVsZFNlbGVjdG9yI2ZpZWxkUGF0aFxuICAgKi9cbiAgcmVhZG9ubHkgZmllbGRQYXRoOiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnT2JqZWN0RmllbGRTZWxlY3RvcicgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fT2JqZWN0RmllbGRTZWxlY3RvcihvYmo6IE9iamVjdEZpZWxkU2VsZWN0b3IgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdhcGlWZXJzaW9uJzogb2JqLmFwaVZlcnNpb24sXG4gICAgJ2ZpZWxkUGF0aCc6IG9iai5maWVsZFBhdGgsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUmVzb3VyY2VGaWVsZFNlbGVjdG9yIHJlcHJlc2VudHMgY29udGFpbmVyIHJlc291cmNlcyAoY3B1LCBtZW1vcnkpIGFuZCB0aGVpciBvdXRwdXQgZm9ybWF0XG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuUmVzb3VyY2VGaWVsZFNlbGVjdG9yXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb3VyY2VGaWVsZFNlbGVjdG9yIHtcbiAgLyoqXG4gICAqIENvbnRhaW5lciBuYW1lOiByZXF1aXJlZCBmb3Igdm9sdW1lcywgb3B0aW9uYWwgZm9yIGVudiB2YXJzXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlJlc291cmNlRmllbGRTZWxlY3RvciNjb250YWluZXJOYW1lXG4gICAqL1xuICByZWFkb25seSBjb250YWluZXJOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIG91dHB1dCBmb3JtYXQgb2YgdGhlIGV4cG9zZWQgcmVzb3VyY2VzLCBkZWZhdWx0cyB0byBcIjFcIlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5SZXNvdXJjZUZpZWxkU2VsZWN0b3IjZGl2aXNvclxuICAgKi9cbiAgcmVhZG9ubHkgZGl2aXNvcj86IFF1YW50aXR5O1xuXG4gIC8qKlxuICAgKiBSZXF1aXJlZDogcmVzb3VyY2UgdG8gc2VsZWN0XG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlJlc291cmNlRmllbGRTZWxlY3RvciNyZXNvdXJjZVxuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2U6IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdSZXNvdXJjZUZpZWxkU2VsZWN0b3InIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX1Jlc291cmNlRmllbGRTZWxlY3RvcihvYmo6IFJlc291cmNlRmllbGRTZWxlY3RvciB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2NvbnRhaW5lck5hbWUnOiBvYmouY29udGFpbmVyTmFtZSxcbiAgICAnZGl2aXNvcic6IG9iai5kaXZpc29yPy52YWx1ZSxcbiAgICAncmVzb3VyY2UnOiBvYmoucmVzb3VyY2UsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogU2VjcmV0S2V5U2VsZWN0b3Igc2VsZWN0cyBhIGtleSBvZiBhIFNlY3JldC5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZWNyZXRLZXlTZWxlY3RvclxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlY3JldEtleVNlbGVjdG9yIHtcbiAgLyoqXG4gICAqIFRoZSBrZXkgb2YgdGhlIHNlY3JldCB0byBzZWxlY3QgZnJvbS4gIE11c3QgYmUgYSB2YWxpZCBzZWNyZXQga2V5LlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZWNyZXRLZXlTZWxlY3RvciNrZXlcbiAgICovXG4gIHJlYWRvbmx5IGtleTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSByZWZlcmVudC4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9vdmVydmlldy93b3JraW5nLXdpdGgtb2JqZWN0cy9uYW1lcy8jbmFtZXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VjcmV0S2V5U2VsZWN0b3IjbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogU3BlY2lmeSB3aGV0aGVyIHRoZSBTZWNyZXQgb3IgaXRzIGtleSBtdXN0IGJlIGRlZmluZWRcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VjcmV0S2V5U2VsZWN0b3Ijb3B0aW9uYWxcbiAgICovXG4gIHJlYWRvbmx5IG9wdGlvbmFsPzogYm9vbGVhbjtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdTZWNyZXRLZXlTZWxlY3RvcicgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fU2VjcmV0S2V5U2VsZWN0b3Iob2JqOiBTZWNyZXRLZXlTZWxlY3RvciB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2tleSc6IG9iai5rZXksXG4gICAgJ25hbWUnOiBvYmoubmFtZSxcbiAgICAnb3B0aW9uYWwnOiBvYmoub3B0aW9uYWwsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogSFRUUEhlYWRlciBkZXNjcmliZXMgYSBjdXN0b20gaGVhZGVyIHRvIGJlIHVzZWQgaW4gSFRUUCBwcm9iZXNcbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5IVFRQSGVhZGVyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSHR0cEhlYWRlciB7XG4gIC8qKlxuICAgKiBUaGUgaGVhZGVyIGZpZWxkIG5hbWVcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuSFRUUEhlYWRlciNuYW1lXG4gICAqL1xuICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBoZWFkZXIgZmllbGQgdmFsdWVcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuSFRUUEhlYWRlciN2YWx1ZVxuICAgKi9cbiAgcmVhZG9ubHkgdmFsdWU6IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdIdHRwSGVhZGVyJyB0byBKU09OIHJlcHJlc2VudGF0aW9uLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbl9IdHRwSGVhZGVyKG9iajogSHR0cEhlYWRlciB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ25hbWUnOiBvYmoubmFtZSxcbiAgICAndmFsdWUnOiBvYmoudmFsdWUsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogQWRhcHRzIGEgQ29uZmlnTWFwIGludG8gYSBwcm9qZWN0ZWQgdm9sdW1lLlxuICpcbiAqIFRoZSBjb250ZW50cyBvZiB0aGUgdGFyZ2V0IENvbmZpZ01hcCdzIERhdGEgZmllbGQgd2lsbCBiZSBwcmVzZW50ZWQgaW4gYSBwcm9qZWN0ZWQgdm9sdW1lIGFzIGZpbGVzIHVzaW5nIHRoZSBrZXlzIGluIHRoZSBEYXRhIGZpZWxkIGFzIHRoZSBmaWxlIG5hbWVzLCB1bmxlc3MgdGhlIGl0ZW1zIGVsZW1lbnQgaXMgcG9wdWxhdGVkIHdpdGggc3BlY2lmaWMgbWFwcGluZ3Mgb2Yga2V5cyB0byBwYXRocy4gTm90ZSB0aGF0IHRoaXMgaXMgaWRlbnRpY2FsIHRvIGEgY29uZmlnbWFwIHZvbHVtZSBzb3VyY2Ugd2l0aG91dCB0aGUgZGVmYXVsdCBtb2RlLlxuICpcbiAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbmZpZ01hcFByb2plY3Rpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb25maWdNYXBQcm9qZWN0aW9uIHtcbiAgLyoqXG4gICAqIElmIHVuc3BlY2lmaWVkLCBlYWNoIGtleS12YWx1ZSBwYWlyIGluIHRoZSBEYXRhIGZpZWxkIG9mIHRoZSByZWZlcmVuY2VkIENvbmZpZ01hcCB3aWxsIGJlIHByb2plY3RlZCBpbnRvIHRoZSB2b2x1bWUgYXMgYSBmaWxlIHdob3NlIG5hbWUgaXMgdGhlIGtleSBhbmQgY29udGVudCBpcyB0aGUgdmFsdWUuIElmIHNwZWNpZmllZCwgdGhlIGxpc3RlZCBrZXlzIHdpbGwgYmUgcHJvamVjdGVkIGludG8gdGhlIHNwZWNpZmllZCBwYXRocywgYW5kIHVubGlzdGVkIGtleXMgd2lsbCBub3QgYmUgcHJlc2VudC4gSWYgYSBrZXkgaXMgc3BlY2lmaWVkIHdoaWNoIGlzIG5vdCBwcmVzZW50IGluIHRoZSBDb25maWdNYXAsIHRoZSB2b2x1bWUgc2V0dXAgd2lsbCBlcnJvciB1bmxlc3MgaXQgaXMgbWFya2VkIG9wdGlvbmFsLiBQYXRocyBtdXN0IGJlIHJlbGF0aXZlIGFuZCBtYXkgbm90IGNvbnRhaW4gdGhlICcuLicgcGF0aCBvciBzdGFydCB3aXRoICcuLicuXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkNvbmZpZ01hcFByb2plY3Rpb24jaXRlbXNcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zPzogS2V5VG9QYXRoW107XG5cbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIHJlZmVyZW50LiBNb3JlIGluZm86IGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL292ZXJ2aWV3L3dvcmtpbmctd2l0aC1vYmplY3RzL25hbWVzLyNuYW1lc1xuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db25maWdNYXBQcm9qZWN0aW9uI25hbWVcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgd2hldGhlciB0aGUgQ29uZmlnTWFwIG9yIGl0cyBrZXlzIG11c3QgYmUgZGVmaW5lZFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Db25maWdNYXBQcm9qZWN0aW9uI29wdGlvbmFsXG4gICAqL1xuICByZWFkb25seSBvcHRpb25hbD86IGJvb2xlYW47XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnQ29uZmlnTWFwUHJvamVjdGlvbicgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fQ29uZmlnTWFwUHJvamVjdGlvbihvYmo6IENvbmZpZ01hcFByb2plY3Rpb24gfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdpdGVtcyc6IG9iai5pdGVtcz8ubWFwKHkgPT4gdG9Kc29uX0tleVRvUGF0aCh5KSksXG4gICAgJ25hbWUnOiBvYmoubmFtZSxcbiAgICAnb3B0aW9uYWwnOiBvYmoub3B0aW9uYWwsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBkb3dud2FyZCBBUEkgaW5mbyBmb3IgcHJvamVjdGluZyBpbnRvIGEgcHJvamVjdGVkIHZvbHVtZS4gTm90ZSB0aGF0IHRoaXMgaXMgaWRlbnRpY2FsIHRvIGEgZG93bndhcmRBUEkgdm9sdW1lIHNvdXJjZSB3aXRob3V0IHRoZSBkZWZhdWx0IG1vZGUuXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuRG93bndhcmRBUElQcm9qZWN0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRG93bndhcmRBcGlQcm9qZWN0aW9uIHtcbiAgLyoqXG4gICAqIEl0ZW1zIGlzIGEgbGlzdCBvZiBEb3dud2FyZEFQSVZvbHVtZSBmaWxlXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLkRvd253YXJkQVBJUHJvamVjdGlvbiNpdGVtc1xuICAgKi9cbiAgcmVhZG9ubHkgaXRlbXM/OiBEb3dud2FyZEFwaVZvbHVtZUZpbGVbXTtcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdEb3dud2FyZEFwaVByb2plY3Rpb24nIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0Rvd253YXJkQXBpUHJvamVjdGlvbihvYmo6IERvd253YXJkQXBpUHJvamVjdGlvbiB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2l0ZW1zJzogb2JqLml0ZW1zPy5tYXAoeSA9PiB0b0pzb25fRG93bndhcmRBcGlWb2x1bWVGaWxlKHkpKSxcbiAgfTtcbiAgLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXNcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3VsdCkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06IGlbMV0gfSksIHt9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cblxuLyoqXG4gKiBBZGFwdHMgYSBzZWNyZXQgaW50byBhIHByb2plY3RlZCB2b2x1bWUuXG4gKlxuICogVGhlIGNvbnRlbnRzIG9mIHRoZSB0YXJnZXQgU2VjcmV0J3MgRGF0YSBmaWVsZCB3aWxsIGJlIHByZXNlbnRlZCBpbiBhIHByb2plY3RlZCB2b2x1bWUgYXMgZmlsZXMgdXNpbmcgdGhlIGtleXMgaW4gdGhlIERhdGEgZmllbGQgYXMgdGhlIGZpbGUgbmFtZXMuIE5vdGUgdGhhdCB0aGlzIGlzIGlkZW50aWNhbCB0byBhIHNlY3JldCB2b2x1bWUgc291cmNlIHdpdGhvdXQgdGhlIGRlZmF1bHQgbW9kZS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZWNyZXRQcm9qZWN0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VjcmV0UHJvamVjdGlvbiB7XG4gIC8qKlxuICAgKiBJZiB1bnNwZWNpZmllZCwgZWFjaCBrZXktdmFsdWUgcGFpciBpbiB0aGUgRGF0YSBmaWVsZCBvZiB0aGUgcmVmZXJlbmNlZCBTZWNyZXQgd2lsbCBiZSBwcm9qZWN0ZWQgaW50byB0aGUgdm9sdW1lIGFzIGEgZmlsZSB3aG9zZSBuYW1lIGlzIHRoZSBrZXkgYW5kIGNvbnRlbnQgaXMgdGhlIHZhbHVlLiBJZiBzcGVjaWZpZWQsIHRoZSBsaXN0ZWQga2V5cyB3aWxsIGJlIHByb2plY3RlZCBpbnRvIHRoZSBzcGVjaWZpZWQgcGF0aHMsIGFuZCB1bmxpc3RlZCBrZXlzIHdpbGwgbm90IGJlIHByZXNlbnQuIElmIGEga2V5IGlzIHNwZWNpZmllZCB3aGljaCBpcyBub3QgcHJlc2VudCBpbiB0aGUgU2VjcmV0LCB0aGUgdm9sdW1lIHNldHVwIHdpbGwgZXJyb3IgdW5sZXNzIGl0IGlzIG1hcmtlZCBvcHRpb25hbC4gUGF0aHMgbXVzdCBiZSByZWxhdGl2ZSBhbmQgbWF5IG5vdCBjb250YWluIHRoZSAnLi4nIHBhdGggb3Igc3RhcnQgd2l0aCAnLi4nLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZWNyZXRQcm9qZWN0aW9uI2l0ZW1zXG4gICAqL1xuICByZWFkb25seSBpdGVtcz86IEtleVRvUGF0aFtdO1xuXG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSByZWZlcmVudC4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9vdmVydmlldy93b3JraW5nLXdpdGgtb2JqZWN0cy9uYW1lcy8jbmFtZXNcbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VjcmV0UHJvamVjdGlvbiNuYW1lXG4gICAqL1xuICByZWFkb25seSBuYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgdGhlIFNlY3JldCBvciBpdHMga2V5IG11c3QgYmUgZGVmaW5lZFxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZWNyZXRQcm9qZWN0aW9uI29wdGlvbmFsXG4gICAqL1xuICByZWFkb25seSBvcHRpb25hbD86IGJvb2xlYW47XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3Qgb2YgdHlwZSAnU2VjcmV0UHJvamVjdGlvbicgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fU2VjcmV0UHJvamVjdGlvbihvYmo6IFNlY3JldFByb2plY3Rpb24gfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgICdpdGVtcyc6IG9iai5pdGVtcz8ubWFwKHkgPT4gdG9Kc29uX0tleVRvUGF0aCh5KSksXG4gICAgJ25hbWUnOiBvYmoubmFtZSxcbiAgICAnb3B0aW9uYWwnOiBvYmoub3B0aW9uYWwsXG4gIH07XG4gIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5cbi8qKlxuICogU2VydmljZUFjY291bnRUb2tlblByb2plY3Rpb24gcmVwcmVzZW50cyBhIHByb2plY3RlZCBzZXJ2aWNlIGFjY291bnQgdG9rZW4gdm9sdW1lLiBUaGlzIHByb2plY3Rpb24gY2FuIGJlIHVzZWQgdG8gaW5zZXJ0IGEgc2VydmljZSBhY2NvdW50IHRva2VuIGludG8gdGhlIHBvZHMgcnVudGltZSBmaWxlc3lzdGVtIGZvciB1c2UgYWdhaW5zdCBBUElzIChLdWJlcm5ldGVzIEFQSSBTZXJ2ZXIgb3Igb3RoZXJ3aXNlKS5cbiAqXG4gKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZXJ2aWNlQWNjb3VudFRva2VuUHJvamVjdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZpY2VBY2NvdW50VG9rZW5Qcm9qZWN0aW9uIHtcbiAgLyoqXG4gICAqIEF1ZGllbmNlIGlzIHRoZSBpbnRlbmRlZCBhdWRpZW5jZSBvZiB0aGUgdG9rZW4uIEEgcmVjaXBpZW50IG9mIGEgdG9rZW4gbXVzdCBpZGVudGlmeSBpdHNlbGYgd2l0aCBhbiBpZGVudGlmaWVyIHNwZWNpZmllZCBpbiB0aGUgYXVkaWVuY2Ugb2YgdGhlIHRva2VuLCBhbmQgb3RoZXJ3aXNlIHNob3VsZCByZWplY3QgdGhlIHRva2VuLiBUaGUgYXVkaWVuY2UgZGVmYXVsdHMgdG8gdGhlIGlkZW50aWZpZXIgb2YgdGhlIGFwaXNlcnZlci5cbiAgICpcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpLmNvcmUudjEuU2VydmljZUFjY291bnRUb2tlblByb2plY3Rpb24jYXVkaWVuY2VcbiAgICovXG4gIHJlYWRvbmx5IGF1ZGllbmNlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBFeHBpcmF0aW9uU2Vjb25kcyBpcyB0aGUgcmVxdWVzdGVkIGR1cmF0aW9uIG9mIHZhbGlkaXR5IG9mIHRoZSBzZXJ2aWNlIGFjY291bnQgdG9rZW4uIEFzIHRoZSB0b2tlbiBhcHByb2FjaGVzIGV4cGlyYXRpb24sIHRoZSBrdWJlbGV0IHZvbHVtZSBwbHVnaW4gd2lsbCBwcm9hY3RpdmVseSByb3RhdGUgdGhlIHNlcnZpY2UgYWNjb3VudCB0b2tlbi4gVGhlIGt1YmVsZXQgd2lsbCBzdGFydCB0cnlpbmcgdG8gcm90YXRlIHRoZSB0b2tlbiBpZiB0aGUgdG9rZW4gaXMgb2xkZXIgdGhhbiA4MCBwZXJjZW50IG9mIGl0cyB0aW1lIHRvIGxpdmUgb3IgaWYgdGhlIHRva2VuIGlzIG9sZGVyIHRoYW4gMjQgaG91cnMuRGVmYXVsdHMgdG8gMSBob3VyIGFuZCBtdXN0IGJlIGF0IGxlYXN0IDEwIG1pbnV0ZXMuXG4gICAqXG4gICAqIEBkZWZhdWx0IDEgaG91ciBhbmQgbXVzdCBiZSBhdCBsZWFzdCAxMCBtaW51dGVzLlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5TZXJ2aWNlQWNjb3VudFRva2VuUHJvamVjdGlvbiNleHBpcmF0aW9uU2Vjb25kc1xuICAgKi9cbiAgcmVhZG9ubHkgZXhwaXJhdGlvblNlY29uZHM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFBhdGggaXMgdGhlIHBhdGggcmVsYXRpdmUgdG8gdGhlIG1vdW50IHBvaW50IG9mIHRoZSBmaWxlIHRvIHByb2plY3QgdGhlIHRva2VuIGludG8uXG4gICAqXG4gICAqIEBzY2hlbWEgaW8uazhzLmFwaS5jb3JlLnYxLlNlcnZpY2VBY2NvdW50VG9rZW5Qcm9qZWN0aW9uI3BhdGhcbiAgICovXG4gIHJlYWRvbmx5IHBhdGg6IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdTZXJ2aWNlQWNjb3VudFRva2VuUHJvamVjdGlvbicgdG8gSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25fU2VydmljZUFjY291bnRUb2tlblByb2plY3Rpb24ob2JqOiBTZXJ2aWNlQWNjb3VudFRva2VuUHJvamVjdGlvbiB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2F1ZGllbmNlJzogb2JqLmF1ZGllbmNlLFxuICAgICdleHBpcmF0aW9uU2Vjb25kcyc6IG9iai5leHBpcmF0aW9uU2Vjb25kcyxcbiAgICAncGF0aCc6IG9iai5wYXRoLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4vKipcbiAqIEV4dGVybmFsRG9jdW1lbnRhdGlvbiBhbGxvd3MgcmVmZXJlbmNpbmcgYW4gZXh0ZXJuYWwgcmVzb3VyY2UgZm9yIGV4dGVuZGVkIGRvY3VtZW50YXRpb24uXG4gKlxuICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5FeHRlcm5hbERvY3VtZW50YXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFeHRlcm5hbERvY3VtZW50YXRpb24ge1xuICAvKipcbiAgICogQHNjaGVtYSBpby5rOHMuYXBpZXh0ZW5zaW9ucy1hcGlzZXJ2ZXIucGtnLmFwaXMuYXBpZXh0ZW5zaW9ucy52MS5FeHRlcm5hbERvY3VtZW50YXRpb24jZGVzY3JpcHRpb25cbiAgICovXG4gIHJlYWRvbmx5IGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGlleHRlbnNpb25zLWFwaXNlcnZlci5wa2cuYXBpcy5hcGlleHRlbnNpb25zLnYxLkV4dGVybmFsRG9jdW1lbnRhdGlvbiN1cmxcbiAgICovXG4gIHJlYWRvbmx5IHVybD86IHN0cmluZztcblxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiB0eXBlICdFeHRlcm5hbERvY3VtZW50YXRpb24nIHRvIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uX0V4dGVybmFsRG9jdW1lbnRhdGlvbihvYmo6IEV4dGVybmFsRG9jdW1lbnRhdGlvbiB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgJ2Rlc2NyaXB0aW9uJzogb2JqLmRlc2NyaXB0aW9uLFxuICAgICd1cmwnOiBvYmoudXJsLFxuICB9O1xuICAvLyBmaWx0ZXIgdW5kZWZpbmVkIHZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzdWx0KS5yZWR1Y2UoKHIsIGkpID0+IChpWzFdID09PSB1bmRlZmluZWQpID8gciA6ICh7IC4uLnIsIFtpWzBdXTogaVsxXSB9KSwge30pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuLCBxdW90ZS1wcm9wcyAqL1xuXG4iXX0=

/***/ }),

/***/ 9107:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__nccwpck_require__(415), exports);
__exportStar(__nccwpck_require__(9998), exports);
__exportStar(__nccwpck_require__(4255), exports);
__exportStar(__nccwpck_require__(4587), exports);
__exportStar(__nccwpck_require__(5702), exports);
__exportStar(__nccwpck_require__(442), exports);
__exportStar(__nccwpck_require__(880), exports);
__exportStar(__nccwpck_require__(9089), exports);
__exportStar(__nccwpck_require__(5445), exports);
__exportStar(__nccwpck_require__(120), exports);
__exportStar(__nccwpck_require__(1680), exports);
__exportStar(__nccwpck_require__(1145), exports);
__exportStar(__nccwpck_require__(6093), exports);
__exportStar(__nccwpck_require__(1967), exports);
__exportStar(__nccwpck_require__(4185), exports);
__exportStar(__nccwpck_require__(5383), exports);
__exportStar(__nccwpck_require__(7967), exports);
__exportStar(__nccwpck_require__(8118), exports);
__exportStar(__nccwpck_require__(1886), exports);
__exportStar(__nccwpck_require__(8131), exports);
__exportStar(__nccwpck_require__(3018), exports);
__exportStar(__nccwpck_require__(7534), exports);
__exportStar(__nccwpck_require__(6419), exports);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEseUNBQXVCO0FBQ3ZCLCtDQUE2QjtBQUM3Qiw4Q0FBNEI7QUFDNUIsK0NBQTZCO0FBQzdCLHdDQUFzQjtBQUN0Qix3Q0FBc0I7QUFDdEIsMkNBQXlCO0FBQ3pCLG9EQUFrQztBQUNsQyw0Q0FBMEI7QUFDMUIsaURBQStCO0FBQy9CLDJDQUF5QjtBQUN6Qiw0Q0FBMEI7QUFDMUIsMENBQXdCO0FBQ3hCLHdDQUFzQjtBQUN0Qix1Q0FBcUI7QUFDckIsNENBQTBCO0FBQzFCLDZDQUEyQjtBQUMzQiwrQ0FBNkI7QUFDN0IseUNBQXVCO0FBQ3ZCLGlEQUErQjtBQUMvQixtREFBaUM7QUFDakMsOENBQTRCO0FBRTVCLDJEQUF5QyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vYmFzZSc7XG5leHBvcnQgKiBmcm9tICcuL2NvbmZpZy1tYXAnO1xuZXhwb3J0ICogZnJvbSAnLi9jb250YWluZXInO1xuZXhwb3J0ICogZnJvbSAnLi9kZXBsb3ltZW50JztcbmV4cG9ydCAqIGZyb20gJy4vam9iJztcbmV4cG9ydCAqIGZyb20gJy4vcG9kJztcbmV4cG9ydCAqIGZyb20gJy4vc2VjcmV0JztcbmV4cG9ydCAqIGZyb20gJy4vc2VydmljZS1hY2NvdW50JztcbmV4cG9ydCAqIGZyb20gJy4vc2VydmljZSc7XG5leHBvcnQgKiBmcm9tICcuL3N0YXRlZnVsLXNldCc7XG5leHBvcnQgKiBmcm9tICcuL3ZvbHVtZSc7XG5leHBvcnQgKiBmcm9tICcuL2luZ3Jlc3MnO1xuZXhwb3J0ICogZnJvbSAnLi9wcm9iZSc7XG5leHBvcnQgKiBmcm9tICcuL3B2Yyc7XG5leHBvcnQgKiBmcm9tICcuL3B2JztcbmV4cG9ydCAqIGZyb20gJy4vaGFuZGxlcic7XG5leHBvcnQgKiBmcm9tICcuL3dvcmtsb2FkJztcbmV4cG9ydCAqIGZyb20gJy4vZGFlbW9uLXNldCc7XG5leHBvcnQgKiBmcm9tICcuL3JvbGUnO1xuZXhwb3J0ICogZnJvbSAnLi9yb2xlLWJpbmRpbmcnO1xuZXhwb3J0ICogZnJvbSAnLi9uZXR3b3JrLXBvbGljeSc7XG5leHBvcnQgKiBmcm9tICcuL25hbWVzcGFjZSc7XG5cbmV4cG9ydCAqIGZyb20gJy4vYXBpLXJlc291cmNlLmdlbmVyYXRlZCc7XG4iXX0=

/***/ }),

/***/ 1145:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IngressBackend = exports.Ingress = exports.HttpIngressPathType = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const cdk8s_1 = __nccwpck_require__(1227);
const base = __nccwpck_require__(415);
const k8s = __nccwpck_require__(4879);
/**
 * Specify how the path is matched against request paths.
 *
 * @see https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types
 */
var HttpIngressPathType;
(function (HttpIngressPathType) {
    /**
     * Matches the URL path exactly.
     */
    HttpIngressPathType["PREFIX"] = "Prefix";
    /**
     * Matches based on a URL path prefix split by '/'.
     */
    HttpIngressPathType["EXACT"] = "Exact";
    /**
     * Matching is specified by the underlying IngressClass.
     */
    HttpIngressPathType["IMPLEMENTATION_SPECIFIC"] = "ImplementationSpecific";
})(HttpIngressPathType = exports.HttpIngressPathType || (exports.HttpIngressPathType = {}));
/**
 * Ingress is a collection of rules that allow inbound connections to reach the
 * endpoints defined by a backend. An Ingress can be configured to give services
 * externally-reachable urls, load balance traffic, terminate SSL, offer name
 * based virtual hosting etc.
 */
class Ingress extends base.Resource {
    constructor(scope, id, props = {}) {
        var _c;
        super(scope, id);
        this.resourceType = 'ingresses';
        this._rulesPerHost = {};
        this._tlsConfig = [];
        this.apiObject = new k8s.KubeIngress(this, 'Resource', {
            metadata: props.metadata,
            spec: {
                defaultBackend: cdk8s_1.Lazy.any({ produce: () => { var _c; return (_c = this._defaultBackend) === null || _c === void 0 ? void 0 : _c._toKube(); } }),
                rules: cdk8s_1.Lazy.any({ produce: () => this.synthRules() }),
                tls: cdk8s_1.Lazy.any({ produce: () => this.tlsConfig() }),
            },
        });
        if (props.defaultBackend) {
            this.addDefaultBackend(props.defaultBackend);
        }
        this.addRules(...(_c = props.rules) !== null && _c !== void 0 ? _c : []);
        if (props.tls) {
            this.addTls(props.tls);
        }
        this.node.addValidation({ validate: () => this._validate() });
    }
    _validate() {
        if (!this._defaultBackend && Object.keys(this._rulesPerHost).length === 0) {
            return ['ingress with no rules or default backend'];
        }
        return [];
    }
    /**
     * Defines the default backend for this ingress. A default backend capable of
     * servicing requests that don't match any rule.
     *
     * @param backend The backend to use for requests that do not match any rule.
     */
    addDefaultBackend(backend) {
        this.addRules({ backend });
    }
    /**
     * Specify a default backend for a specific host name. This backend will be used as a catch-all for requests
     * targeted to this host name (the `Host` header matches this value).
     *
     * @param host The host name to match
     * @param backend The backend to route to
     */
    addHostDefaultBackend(host, backend) {
        if (!host) {
            throw new Error('host must not be an empty string');
        }
        this.addRules({ host, backend });
    }
    /**
     * Adds an ingress rule applied to requests to a specific host and a specific
     * HTTP path (the `Host` header matches this value).
     *
     * @param host The host name
     * @param path The HTTP path
     * @param backend The backend to route requests to
     * @param pathType How the path is matched against request paths
     */
    addHostRule(host, path, backend, pathType) {
        if (!host) {
            throw new Error('host must not be an empty string');
        }
        this.addRules({ host, backend, path, pathType });
    }
    /**
     * Adds an ingress rule applied to requests sent to a specific HTTP path.
     *
     * @param path The HTTP path
     * @param backend The backend to route requests to
     * @param pathType How the path is matched against request paths
     */
    addRule(path, backend, pathType) {
        this.addRules({ backend, path, pathType });
    }
    /**
     * Adds rules to this ingress.
     * @param rules The rules to add
     */
    addRules(...rules) {
        var _c, _d, _e, _f;
        for (const rule of rules) {
            // default backend is not really a rule
            if (!rule.host && !rule.path) {
                if (this._defaultBackend) {
                    throw new Error('a default backend is already defined for this ingress');
                }
                this._defaultBackend = rule.backend;
                continue;
            }
            const host = (_c = rule.host) !== null && _c !== void 0 ? _c : '';
            const backend = rule.backend;
            const path = (_d = rule.path) !== null && _d !== void 0 ? _d : '/';
            const pathType = (_e = rule.pathType) !== null && _e !== void 0 ? _e : HttpIngressPathType.PREFIX;
            if (path && !path.startsWith('/')) {
                throw new Error(`ingress paths must begin with a "/": ${path}`);
            }
            const routes = this._rulesPerHost[host] = (_f = this._rulesPerHost[host]) !== null && _f !== void 0 ? _f : [];
            // check if we already have a rule for this host/path
            if (routes.find(r => r.path === path)) {
                throw new Error(`there is already an ingress rule for ${host}${path}`);
            }
            routes.push({
                backend: backend._toKube(),
                path,
                pathType,
            });
        }
    }
    synthRules() {
        const rules = new Array();
        for (const [host, paths] of Object.entries(this._rulesPerHost)) {
            rules.push({
                host: host ? host : undefined,
                http: { paths: paths.sort(sortByPath) },
            });
        }
        return rules.length > 0 ? rules : undefined;
    }
    addTls(tls) {
        this._tlsConfig.push(...tls);
    }
    tlsConfig() {
        var _c;
        if (this._tlsConfig.length == 0) {
            return undefined;
        }
        const tls = new Array();
        for (const entry of this._tlsConfig) {
            tls.push({
                hosts: entry.hosts,
                secretName: (_c = entry.secret) === null || _c === void 0 ? void 0 : _c.name,
            });
        }
        return tls;
    }
}
exports.Ingress = Ingress;
_a = JSII_RTTI_SYMBOL_1;
Ingress[_a] = { fqn: "cdk8s-plus-22.Ingress", version: "2.0.0-rc.2" };
/**
 * The backend for an ingress path.
 */
class IngressBackend {
    constructor(backend) {
        this.backend = backend;
    }
    /**
     * A Kubernetes `Service` to use as the backend for this path.
     * @param serv The service object.
     */
    static fromService(serv, options = {}) {
        if (serv.ports.length === 0) {
            throw new Error('service does not expose any ports');
        }
        let servicePort;
        if (serv.ports.length === 1) {
            servicePort = serv.ports[0].port;
        }
        else {
            if (options.port !== undefined) {
                const found = serv.ports.find(p => p.port === options.port);
                if (found) {
                    servicePort = found.port;
                }
                else {
                    throw new Error(`service exposes ports ${serv.ports.map(p => p.port).join(',')} but backend is defined to use port ${options.port}`);
                }
            }
            else {
                throw new Error(`unable to determine service port since service exposes multiple ports: ${serv.ports.map(x => x.port).join(',')}`);
            }
        }
        if (options.port !== undefined && servicePort !== options.port) {
            throw new Error(`backend defines port ${options.port} but service exposes port ${servicePort}`);
        }
        return new IngressBackend({
            service: {
                name: serv.name,
                port: { number: servicePort },
            },
        });
    }
    /**
     * A Resource backend is an ObjectRef to another Kubernetes resource
     * within the same namespace as the Ingress object.
     * A common usage for a Resource backend is to ingress data to an object
     * storage backend with static assets.
     */
    static fromResource(resource) {
        return new IngressBackend({
            resource: {
                kind: resource.kind,
                name: resource.name,
                apiGroup: resource.apiGroup,
            },
        });
    }
    /**
     * @internal
     */
    _toKube() { return this.backend; }
}
exports.IngressBackend = IngressBackend;
_b = JSII_RTTI_SYMBOL_1;
IngressBackend[_b] = { fqn: "cdk8s-plus-22.IngressBackend", version: "2.0.0-rc.2" };
function sortByPath(lhs, rhs) {
    var _c, _d;
    const p1 = (_c = lhs.path) !== null && _c !== void 0 ? _c : '';
    const p2 = (_d = rhs.path) !== null && _d !== void 0 ? _d : '';
    return p1.localeCompare(p2);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5ncmVzcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmdyZXNzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsaUNBQXdDO0FBRXhDLCtCQUErQjtBQUMvQixxQ0FBcUM7QUF5Q3JDOzs7O0dBSUc7QUFDSCxJQUFZLG1CQWVYO0FBZkQsV0FBWSxtQkFBbUI7SUFDN0I7O09BRUc7SUFDSCx3Q0FBaUIsQ0FBQTtJQUVqQjs7T0FFRztJQUNILHNDQUFlLENBQUE7SUFFZjs7T0FFRztJQUNILHlFQUFrRCxDQUFBO0FBQ3BELENBQUMsRUFmVyxtQkFBbUIsR0FBbkIsMkJBQW1CLEtBQW5CLDJCQUFtQixRQWU5QjtBQUVEOzs7OztHQUtHO0FBQ0gsTUFBYSxPQUFRLFNBQVEsSUFBSSxDQUFDLFFBQVE7SUFheEMsWUFBWSxLQUFnQixFQUFFLEVBQVUsRUFBRSxRQUFzQixFQUFFOztRQUNoRSxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBUEgsaUJBQVksR0FBRyxXQUFXLENBQUM7UUFFMUIsa0JBQWEsR0FBOEMsRUFBRSxDQUFDO1FBRTlELGVBQVUsR0FBaUIsRUFBRSxDQUFDO1FBSzdDLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxHQUFHLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxVQUFVLEVBQUU7WUFDckQsUUFBUSxFQUFFLEtBQUssQ0FBQyxRQUFRO1lBQ3hCLElBQUksRUFBRTtnQkFDSixjQUFjLEVBQUUsWUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsd0JBQUMsSUFBSSxDQUFDLGVBQWUsMENBQUUsT0FBTyxLQUFFLEVBQUUsQ0FBQztnQkFDNUUsS0FBSyxFQUFFLFlBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUM7Z0JBQ3JELEdBQUcsRUFBRSxZQUFJLENBQUMs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Z0JBQ25CLElBQUksRUFBRSxRQUFRLENBQUMsSUFBSTtnQkFDbkIsUUFBUSxFQUFFLFFBQVEsQ0FBQyxRQUFRO2FBQzVCO1NBQ0YsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQU1EOztPQUVHO0lBQ0ksT0FBTyxLQUFLLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7O0FBN0QzQyx3Q0E4REM7OztBQTRFRCxTQUFTLFVBQVUsQ0FBQyxHQUF3QixFQUFFLEdBQXdCOztJQUNwRSxNQUFNLEVBQUUsU0FBRyxHQUFHLENBQUMsSUFBSSxtQ0FBSSxFQUFFLENBQUM7SUFDMUIsTUFBTSxFQUFFLFNBQUcsR0FBRyxDQUFDLElBQUksbUNBQUksRUFBRSxDQUFDO0lBQzFCLE9BQU8sRUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUM5QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBpT2JqZWN0LCBMYXp5IH0gZnJvbSAnY2RrOHMnO1xuaW1wb3J0IHsgQ29uc3RydWN0IH0gZnJvbSAnY29uc3RydWN0cyc7XG5pbXBvcnQgKiBhcyBiYXNlIGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgKiBhcyBrOHMgZnJvbSAnLi9pbXBvcnRzL2s4cyc7XG5pbXBvcnQgKiBhcyBzZWNyZXQgZnJvbSAnLi9zZWNyZXQnO1xuaW1wb3J0ICogYXMgc2VydmljZSBmcm9tICcuL3NlcnZpY2UnO1xuXG4vKipcbiAqIFByb3BlcnRpZXMgZm9yIGBJbmdyZXNzYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbmdyZXNzUHJvcHMgZXh0ZW5kcyBiYXNlLlJlc291cmNlUHJvcHMge1xuICAvKipcbiAgICogVGhlIGRlZmF1bHQgYmFja2VuZCBzZXJ2aWNlcyByZXF1ZXN0cyB0aGF0IGRvIG5vdCBtYXRjaCBhbnkgcnVsZS5cbiAgICpcbiAgICogVXNpbmcgdGhpcyBvcHRpb24gb3IgdGhlIGBhZGREZWZhdWx0QmFja2VuZCgpYCBtZXRob2QgaXMgZXF1aXZhbGVudCB0b1xuICAgKiBhZGRpbmcgYSBydWxlIHdpdGggYm90aCBgcGF0aGAgYW5kIGBob3N0YCB1bmRlZmluZWQuXG4gICAqL1xuICByZWFkb25seSBkZWZhdWx0QmFja2VuZD86IEluZ3Jlc3NCYWNrZW5kO1xuXG4gIC8qKlxuICAgKiBSb3V0aW5nIHJ1bGVzIGZvciB0aGlzIGluZ3Jlc3MuXG4gICAqXG4gICAqIEVhY2ggcnVsZSBtdXN0IGRlZmluZSBhbiBgSW5ncmVzc0JhY2tlbmRgIHRoYXQgd2lsbCByZWNlaXZlIHRoZSByZXF1ZXN0c1xuICAgKiB0aGF0IG1hdGNoIHRoaXMgcnVsZS4gSWYgYm90aCBgaG9zdGAgYW5kIGBwYXRoYCBhcmUgbm90IHNwZWNpZmllYywgdGhpc1xuICAgKiBiYWNrZW5kIHdpbGwgYmUgdXNlZCBhcyB0aGUgZGVmYXVsdCBiYWNrZW5kIG9mIHRoZSBpbmdyZXNzLlxuICAgKlxuICAgKiBZb3UgY2FuIGFsc28gYWRkIHJ1bGVzIGxhdGVyIHVzaW5nIGBhZGRSdWxlKClgLCBgYWRkSG9zdFJ1bGUoKWAsXG4gICAqIGBhZGREZWZhdWx0QmFja2VuZCgpYCBhbmQgYGFkZEhvc3REZWZhdWx0QmFja2VuZCgpYC5cbiAgICovXG4gIHJlYWRvbmx5IHJ1bGVzPzogSW5ncmVzc1J1bGVbXTtcblxuXG4gIC8qKlxuICAgKiBUTFMgc2V0dGluZ3MgZm9yIHRoaXMgaW5ncmVzcy5cbiAgICpcbiAgICogVXNpbmcgdGhpcyBvcHRpb24gdGVsbHMgdGhlIGluZ3Jlc3MgY29udHJvbGxlciB0byBleHBvc2UgYSBUTFMgZW5kcG9pbnQuXG4gICAqIEN1cnJlbnRseSB0aGUgSW5ncmVzcyBvbmx5IHN1cHBvcnRzIGEgc2luZ2xlIFRMUyBwb3J0LCA0NDMuIElmIG11bHRpcGxlXG4gICAqIG1lbWJlcnMgb2YgdGhpcyBsaXN0IHNwZWNpZnkgZGlmZmVyZW50IGhvc3RzLCB0aGV5IHdpbGwgYmUgbXVsdGlwbGV4ZWQgb25cbiAgICogdGhlIHNhbWUgcG9ydCBhY2NvcmRpbmcgdG8gdGhlIGhvc3RuYW1lIHNwZWNpZmllZCB0aHJvdWdoIHRoZSBTTkkgVExTXG4gICAqIGV4dGVuc2lvbiwgaWYgdGhlIGluZ3Jlc3MgY29udHJvbGxlciBmdWxmaWxsaW5nIHRoZSBpbmdyZXNzIHN1cHBvcnRzIFNOSS5cbiAgICovXG4gIHJlYWRvbmx5IHRscz86IEluZ3Jlc3NUbHNbXTtcbn1cblxuLyoqXG4gKiBTcGVjaWZ5IGhvdyB0aGUgcGF0aCBpcyBtYXRjaGVkIGFnYWluc3QgcmVxdWVzdCBwYXRocy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3NlcnZpY2VzLW5ldHdvcmtpbmcvaW5ncmVzcy8jcGF0aC10eXBlc1xuICovXG5leHBvcnQgZW51bSBIdHRwSW5ncmVzc1BhdGhUeXBlIHtcbiAgLyoqXG4gICAqIE1hdGNoZXMgdGhlIFVSTCBwYXRoIGV4YWN0bHkuXG4gICAqL1xuICBQUkVGSVggPSAnUHJlZml4JyxcblxuICAvKipcbiAgICogTWF0Y2hlcyBiYXNlZCBvbiBhIFVSTCBwYXRoIHByZWZpeCBzcGxpdCBieSAnLycuXG4gICAqL1xuICBFWEFDVCA9ICdFeGFjdCcsXG5cbiAgLyoqXG4gICAqIE1hdGNoaW5nIGlzIHNwZWNpZmllZCBieSB0aGUgdW5kZXJseWluZyBJbmdyZXNzQ2xhc3MuXG4gICAqL1xuICBJTVBMRU1FTlRBVElPTl9TUEVDSUZJQyA9ICdJbXBsZW1lbnRhdGlvblNwZWNpZmljJyxcbn1cblxuLyoqXG4gKiBJbmdyZXNzIGlzIGEgY29sbGVjdGlvbiBvZiBydWxlcyB0aGF0IGFsbG93IGluYm91bmQgY29ubmVjdGlvbnMgdG8gcmVhY2ggdGhlXG4gKiBlbmRwb2ludHMgZGVmaW5lZCBieSBhIGJhY2tlbmQuIEFuIEluZ3Jlc3MgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gZ2l2ZSBzZXJ2aWNlc1xuICogZXh0ZXJuYWxseS1yZWFjaGFibGUgdXJscywgbG9hZCBiYWxhbmNlIHRyYWZmaWMsIHRlcm1pbmF0ZSBTU0wsIG9mZmVyIG5hbWVcbiAqIGJhc2VkIHZpcnR1YWwgaG9zdGluZyBldGMuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbmdyZXNzIGV4dGVuZHMgYmFzZS5SZXNvdXJjZSB7XG5cbiAgLyoqXG4gICAqIEBzZWUgYmFzZS5SZXNvdXJjZS5hcGlPYmplY3RcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBhcGlPYmplY3Q6IEFwaU9iamVjdDtcblxuICBwdWJsaWMgcmVhZG9ubHkgcmVzb3VyY2VUeXBlID0gJ2luZ3Jlc3Nlcyc7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBfcnVsZXNQZXJIb3N0OiB7IFtob3N0OiBzdHJpbmddOiBrOHMuSHR0cEluZ3Jlc3NQYXRoW10gfSA9IHt9O1xuICBwcml2YXRlIF9kZWZhdWx0QmFja2VuZD86IEluZ3Jlc3NCYWNrZW5kO1xuICBwcml2YXRlIHJlYWRvbmx5IF90bHNDb25maWc6IEluZ3Jlc3NUbHNbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBJbmdyZXNzUHJvcHMgPSB7fSkge1xuICAgIHN1cGVyKHNjb3BlLCBpZCk7XG5cbiAgICB0aGlzLmFwaU9iamVjdCA9IG5ldyBrOHMuS3ViZUluZ3Jlc3ModGhpcywgJ1Jlc291cmNlJywge1xuICAgICAgbWV0YWRhdGE6IHByb3BzLm1ldGFkYXRhLFxuICAgICAgc3BlYzoge1xuICAgICAgICBkZWZhdWx0QmFja2VuZDogTGF6eS5hbnkoeyBwcm9kdWNlOiAoKSA9PiB0aGlzLl9kZWZhdWx0QmFja2VuZD8uX3RvS3ViZSgpIH0pLFxuICAgICAgICBydWxlczogTGF6eS5hbnkoeyBwcm9kdWNlOiAoKSA9PiB0aGlzLnN5bnRoUnVsZXMoKSB9KSxcbiAgICAgICAgdGxzOiBMYXp5LmFueSh7IHByb2R1Y2U6ICgpID0+IHRoaXMudGxzQ29uZmlnKCkgfSksXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgaWYgKHByb3BzLmRlZmF1bHRCYWNrZW5kKSB7XG4gICAgICB0aGlzLmFkZERlZmF1bHRCYWNrZW5kKHByb3BzLmRlZmF1bHRCYWNrZW5kKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZFJ1bGVzKC4uLnByb3BzLnJ1bGVzID8/IFtdKTtcblxuICAgIGlmIChwcm9wcy50bHMpIHtcbiAgICAgIHRoaXMuYWRkVGxzKHByb3BzLnRscyk7XG4gICAgfVxuXG4gICAgdGhpcy5ub2RlLmFkZFZhbGlkYXRpb24oeyB2YWxpZGF0ZTogKCkgPT4gdGhpcy5fdmFsaWRhdGUoKSB9KTtcbiAgfVxuXG4gIHByaXZhdGUgX3ZhbGlkYXRlKCkge1xuICAgIGlmICghdGhpcy5fZGVmYXVsdEJhY2tlbmQgJiYgT2JqZWN0LmtleXModGhpcy5fcnVsZXNQZXJIb3N0KS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbJ2luZ3Jlc3Mgd2l0aCBubyBydWxlcyBvciBkZWZhdWx0IGJhY2tlbmQnXTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgdGhlIGRlZmF1bHQgYmFja2VuZCBmb3IgdGhpcyBpbmdyZXNzLiBBIGRlZmF1bHQgYmFja2VuZCBjYXBhYmxlIG9mXG4gICAqIHNlcnZpY2luZyByZXF1ZXN0cyB0aGF0IGRvbid0IG1hdGNoIGFueSBydWxlLlxuICAgKlxuICAgKiBAcGFyYW0gYmFja2VuZCBUaGUgYmFja2VuZCB0byB1c2UgZm9yIHJlcXVlc3RzIHRoYXQgZG8gbm90IG1hdGNoIGFueSBydWxlLlxuICAgKi9cbiAgcHVibGljIGFkZERlZmF1bHRCYWNrZW5kKGJhY2tlbmQ6IEluZ3Jlc3NCYWNrZW5kKSB7XG4gICAgdGhpcy5hZGRSdWxlcyh7IGJhY2tlbmQgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3BlY2lmeSBhIGRlZmF1bHQgYmFja2VuZCBmb3IgYSBzcGVjaWZpYyBob3N0IG5hbWUuIFRoaXMgYmFja2VuZCB3aWxsIGJlIHVzZWQgYXMgYSBjYXRjaC1hbGwgZm9yIHJlcXVlc3RzXG4gICAqIHRhcmdldGVkIHRvIHRoaXMgaG9zdCBuYW1lICh0aGUgYEhvc3RgIGhlYWRlciBtYXRjaGVzIHRoaXMgdmFsdWUpLlxuICAgKlxuICAgKiBAcGFyYW0gaG9zdCBUaGUgaG9zdCBuYW1lIHRvIG1hdGNoXG4gICAqIEBwYXJhbSBiYWNrZW5kIFRoZSBiYWNrZW5kIHRvIHJvdXRlIHRvXG4gICAqL1xuICBwdWJsaWMgYWRkSG9zdERlZmF1bHRCYWNrZW5kKGhvc3Q6IHN0cmluZywgYmFja2VuZDogSW5ncmVzc0JhY2tlbmQpIHtcbiAgICBpZiAoIWhvc3QpIHsgdGhyb3cgbmV3IEVycm9yKCdob3N0IG11c3Qgbm90IGJlIGFuIGVtcHR5IHN0cmluZycpOyB9XG4gICAgdGhpcy5hZGRSdWxlcyh7IGhvc3QsIGJhY2tlbmQgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBpbmdyZXNzIHJ1bGUgYXBwbGllZCB0byByZXF1ZXN0cyB0byBhIHNwZWNpZmljIGhvc3QgYW5kIGEgc3BlY2lmaWNcbiAgICogSFRUUCBwYXRoICh0aGUgYEhvc3RgIGhlYWRlciBtYXRjaGVzIHRoaXMgdmFsdWUpLlxuICAgKlxuICAgKiBAcGFyYW0gaG9zdCBUaGUgaG9zdCBuYW1lXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBIVFRQIHBhdGhcbiAgICogQHBhcmFtIGJhY2tlbmQgVGhlIGJhY2tlbmQgdG8gcm91dGUgcmVxdWVzdHMgdG9cbiAgICogQHBhcmFtIHBhdGhUeXBlIEhvdyB0aGUgcGF0aCBpcyBtYXRjaGVkIGFnYWluc3QgcmVxdWVzdCBwYXRoc1xuICAgKi9cbiAgcHVibGljIGFkZEhvc3RSdWxlKGhvc3Q6IHN0cmluZywgcGF0aDogc3RyaW5nLCBiYWNrZW5kOiBJbmdyZXNzQmFja2VuZCwgcGF0aFR5cGU/OiBIdHRwSW5ncmVzc1BhdGhUeXBlKSB7XG4gICAgaWYgKCFob3N0KSB7IHRocm93IG5ldyBFcnJvcignaG9zdCBtdXN0IG5vdCBiZSBhbiBlbXB0eSBzdHJpbmcnKTsgfVxuICAgIHRoaXMuYWRkUnVsZXMoeyBob3N0LCBiYWNrZW5kLCBwYXRoLCBwYXRoVHlwZSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGluZ3Jlc3MgcnVsZSBhcHBsaWVkIHRvIHJlcXVlc3RzIHNlbnQgdG8gYSBzcGVjaWZpYyBIVFRQIHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBIVFRQIHBhdGhcbiAgICogQHBhcmFtIGJhY2tlbmQgVGhlIGJhY2tlbmQgdG8gcm91dGUgcmVxdWVzdHMgdG9cbiAgICogQHBhcmFtIHBhdGhUeXBlIEhvdyB0aGUgcGF0aCBpcyBtYXRjaGVkIGFnYWluc3QgcmVxdWVzdCBwYXRoc1xuICAgKi9cbiAgcHVibGljIGFkZFJ1bGUocGF0aDogc3RyaW5nLCBiYWNrZW5kOiBJbmdyZXNzQmFja2VuZCwgcGF0aFR5cGU/OiBIdHRwSW5ncmVzc1BhdGhUeXBlKSB7XG4gICAgdGhpcy5hZGRSdWxlcyh7IGJhY2tlbmQsIHBhdGgsIHBhdGhUeXBlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgcnVsZXMgdG8gdGhpcyBpbmdyZXNzLlxuICAgKiBAcGFyYW0gcnVsZXMgVGhlIHJ1bGVzIHRvIGFkZFxuICAgKi9cbiAgcHVibGljIGFkZFJ1bGVzKC4uLnJ1bGVzOiBJbmdyZXNzUnVsZVtdKSB7XG4gICAgZm9yIChjb25zdCBydWxlIG9mIHJ1bGVzKSB7XG5cbiAgICAgIC8vIGRlZmF1bHQgYmFja2VuZCBpcyBub3QgcmVhbGx5IGEgcnVsZVxuICAgICAgaWYgKCFydWxlLmhvc3QgJiYgIXJ1bGUucGF0aCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmYXVsdEJhY2tlbmQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2EgZGVmYXVsdCBiYWNrZW5kIGlzIGFscmVhZHkgZGVmaW5lZCBmb3IgdGhpcyBpbmdyZXNzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGVmYXVsdEJhY2tlbmQgPSBydWxlLmJhY2tlbmQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBob3N0ID0gcnVsZS5ob3N0ID8/ICcnO1xuICAgICAgY29uc3QgYmFja2VuZCA9IHJ1bGUuYmFja2VuZDtcbiAgICAgIGNvbnN0IHBhdGggPSBydWxlLnBhdGggPz8gJy8nO1xuICAgICAgY29uc3QgcGF0aFR5cGUgPSBydWxlLnBhdGhUeXBlID8/IEh0dHBJbmdyZXNzUGF0aFR5cGUuUFJFRklYO1xuXG4gICAgICBpZiAocGF0aCAmJiAhcGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbmdyZXNzIHBhdGhzIG11c3QgYmVnaW4gd2l0aCBhIFwiL1wiOiAke3BhdGh9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJvdXRlcyA9IHRoaXMuX3J1bGVzUGVySG9zdFtob3N0XSA9IHRoaXMuX3J1bGVzUGVySG9zdFtob3N0XSA/PyBbXTtcblxuICAgICAgLy8gY2hlY2sgaWYgd2UgYWxyZWFkeSBoYXZlIGEgcnVsZSBmb3IgdGhpcyBob3N0L3BhdGhcbiAgICAgIGlmIChyb3V0ZXMuZmluZChyID0+IHIucGF0aCA9PT0gcGF0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0aGVyZSBpcyBhbHJlYWR5IGFuIGluZ3Jlc3MgcnVsZSBmb3IgJHtob3N0fSR7cGF0aH1gKTtcbiAgICAgIH1cblxuICAgICAgcm91dGVzLnB1c2goe1xuICAgICAgICBiYWNrZW5kOiBiYWNrZW5kLl90b0t1YmUoKSxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgcGF0aFR5cGUsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN5bnRoUnVsZXMoKTogdW5kZWZpbmVkIHwgazhzLkluZ3Jlc3NSdWxlW10ge1xuICAgIGNvbnN0IHJ1bGVzID0gbmV3IEFycmF5PGs4cy5JbmdyZXNzUnVsZT4oKTtcblxuICAgIGZvciAoY29uc3QgW2hvc3QsIHBhdGhzXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLl9ydWxlc1Blckhvc3QpKSB7XG4gICAgICBydWxlcy5wdXNoKHtcbiAgICAgICAgaG9zdDogaG9zdCA/IGhvc3QgOiB1bmRlZmluZWQsXG4gICAgICAgIGh0dHA6IHsgcGF0aHM6IHBhdGhzLnNvcnQoc29ydEJ5UGF0aCkgfSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBydWxlcy5sZW5ndGggPiAwID8gcnVsZXMgOiB1bmRlZmluZWQ7XG4gIH1cblxuICBwdWJsaWMgYWRkVGxzKHRsczogSW5ncmVzc1Rsc1tdKSB7XG4gICAgdGhpcy5fdGxzQ29uZmlnLnB1c2goLi4udGxzKTtcbiAgfVxuXG4gIHByaXZhdGUgdGxzQ29uZmlnKCk6IHVuZGVmaW5lZCB8IGs4cy5JbmdyZXNzVGxzW10ge1xuICAgIGlmICh0aGlzLl90bHNDb25maWcubGVuZ3RoID09IDApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgdGxzID0gbmV3IEFycmF5PGs4cy5JbmdyZXNzVGxzPigpO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5fdGxzQ29uZmlnKSB7XG4gICAgICB0bHMucHVzaCh7XG4gICAgICAgIGhvc3RzOiBlbnRyeS5ob3N0cyxcbiAgICAgICAgc2VjcmV0TmFtZTogZW50cnkuc2VjcmV0Py5uYW1lLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRscztcbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHNldHRpbmcgdXAgYmFja2VuZHMgZm9yIGluZ3Jlc3MgcnVsZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VydmljZUluZ3Jlc3NCYWNrZW5kT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgcG9ydCB0byB1c2UgdG8gYWNjZXNzIHRoZSBzZXJ2aWNlLlxuICAgKlxuICAgKiAtIFRoaXMgb3B0aW9uIHdpbGwgZmFpbCBpZiB0aGUgc2VydmljZSBkb2VzIG5vdCBleHBvc2UgYW55IHBvcnRzLlxuICAgKiAtIElmIHRoZSBzZXJ2aWNlIGV4cG9zZXMgbXVsdGlwbGUgcG9ydHMsIHRoaXMgb3B0aW9uIG11c3QgYmUgc3BlY2lmaWVkLlxuICAgKiAtIElmIHRoZSBzZXJ2aWNlIGV4cG9zZXMgYSBzaW5nbGUgcG9ydCwgdGhpcyBvcHRpb24gaXMgb3B0aW9uYWwgYW5kIGlmXG4gICAqICAgc3BlY2lmaWVkLCBpdCBtdXN0IGJlIHRoZSBzYW1lIHBvcnQgZXhwb3NlZCBieSB0aGUgc2VydmljZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBpZiB0aGUgc2VydmljZSBleHBvc2VzIGEgc2luZ2xlIHBvcnQsIHRoaXMgcG9ydCB3aWxsIGJlIHVzZWQuXG4gICAqL1xuICByZWFkb25seSBwb3J0PzogbnVtYmVyO1xufVxuXG4vKipcbiAqIFRoZSBiYWNrZW5kIGZvciBhbiBpbmdyZXNzIHBhdGguXG4gKi9cbmV4cG9ydCBjbGFzcyBJbmdyZXNzQmFja2VuZCB7XG4gIC8qKlxuICAgKiBBIEt1YmVybmV0ZXMgYFNlcnZpY2VgIHRvIHVzZSBhcyB0aGUgYmFja2VuZCBmb3IgdGhpcyBwYXRoLlxuICAgKiBAcGFyYW0gc2VydiBUaGUgc2VydmljZSBvYmplY3QuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21TZXJ2aWNlKHNlcnY6IHNlcnZpY2UuU2VydmljZSwgb3B0aW9uczogU2VydmljZUluZ3Jlc3NCYWNrZW5kT3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHNlcnYucG9ydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlcnZpY2UgZG9lcyBub3QgZXhwb3NlIGFueSBwb3J0cycpO1xuICAgIH1cblxuICAgIGxldCBzZXJ2aWNlUG9ydDtcbiAgICBpZiAoc2Vydi5wb3J0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHNlcnZpY2VQb3J0ID0gc2Vydi5wb3J0c1swXS5wb3J0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5wb3J0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZm91bmQgPSBzZXJ2LnBvcnRzLmZpbmQocCA9PiBwLnBvcnQgPT09IG9wdGlvbnMucG9ydCk7XG4gICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgIHNlcnZpY2VQb3J0ID0gZm91bmQucG9ydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNlcnZpY2UgZXhwb3NlcyBwb3J0cyAke3NlcnYucG9ydHMubWFwKHAgPT4gcC5wb3J0KS5qb2luKCcsJyl9IGJ1dCBiYWNrZW5kIGlzIGRlZmluZWQgdG8gdXNlIHBvcnQgJHtvcHRpb25zLnBvcnR9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5hYmxlIHRvIGRldGVybWluZSBzZXJ2aWNlIHBvcnQgc2luY2Ugc2VydmljZSBleHBvc2VzIG11bHRpcGxlIHBvcnRzOiAke3NlcnYucG9ydHMubWFwKHggPT4geC5wb3J0KS5qb2luKCcsJyl9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucG9ydCAhPT0gdW5kZWZpbmVkICYmIHNlcnZpY2VQb3J0ICE9PSBvcHRpb25zLnBvcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgYmFja2VuZCBkZWZpbmVzIHBvcnQgJHtvcHRpb25zLnBvcnR9IGJ1dCBzZXJ2aWNlIGV4cG9zZXMgcG9ydCAke3NlcnZpY2VQb3J0fWApO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSW5ncmVzc0JhY2tlbmQoe1xuICAgICAgc2VydmljZToge1xuICAgICAgICBuYW1lOiBzZXJ2Lm5hbWUsXG4gICAgICAgIHBvcnQ6IHsgbnVtYmVyOiBzZXJ2aWNlUG9ydCB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIFJlc291cmNlIGJhY2tlbmQgaXMgYW4gT2JqZWN0UmVmIHRvIGFub3RoZXIgS3ViZXJuZXRlcyByZXNvdXJjZVxuICAgKiB3aXRoaW4gdGhlIHNhbWUgbmFtZXNwYWNlIGFzIHRoZSBJbmdyZXNzIG9iamVjdC5cbiAgICogQSBjb21tb24gdXNhZ2UgZm9yIGEgUmVzb3VyY2UgYmFja2VuZCBpcyB0byBpbmdyZXNzIGRhdGEgdG8gYW4gb2JqZWN0XG4gICAqIHN0b3JhZ2UgYmFja2VuZCB3aXRoIHN0YXRpYyBhc3NldHMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21SZXNvdXJjZShyZXNvdXJjZTogYmFzZS5JUmVzb3VyY2UpIHtcbiAgICByZXR1cm4gbmV3IEluZ3Jlc3NCYWNrZW5kKHtcbiAgICAgIHJlc291cmNlOiB7XG4gICAgICAgIGtpbmQ6IHJlc291cmNlLmtpbmQsXG4gICAgICAgIG5hbWU6IHJlc291cmNlLm5hbWUsXG4gICAgICAgIGFwaUdyb3VwOiByZXNvdXJjZS5hcGlHcm91cCxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgYmFja2VuZDogazhzLkluZ3Jlc3NCYWNrZW5kKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHB1YmxpYyBfdG9LdWJlKCkgeyByZXR1cm4gdGhpcy5iYWNrZW5kOyB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgcnVsZXMgbWFwcGluZyB0aGUgcGF0aHMgdW5kZXIgYSBzcGVjaWZpZWQgaG9zdCB0byB0aGUgcmVsYXRlZFxuICogYmFja2VuZCBzZXJ2aWNlcy4gSW5jb21pbmcgcmVxdWVzdHMgYXJlIGZpcnN0IGV2YWx1YXRlZCBmb3IgYSBob3N0IG1hdGNoLFxuICogdGhlbiByb3V0ZWQgdG8gdGhlIGJhY2tlbmQgYXNzb2NpYXRlZCB3aXRoIHRoZSBtYXRjaGluZyBwYXRoLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEluZ3Jlc3NSdWxlIHtcbiAgLyoqXG4gICAqIEJhY2tlbmQgZGVmaW5lcyB0aGUgcmVmZXJlbmNlZCBzZXJ2aWNlIGVuZHBvaW50IHRvIHdoaWNoIHRoZSB0cmFmZmljIHdpbGxcbiAgICogYmUgZm9yd2FyZGVkIHRvLlxuICAgKi9cbiAgcmVhZG9ubHkgYmFja2VuZDogSW5ncmVzc0JhY2tlbmQ7XG5cbiAgLyoqXG4gICAqIEhvc3QgaXMgdGhlIGZ1bGx5IHF1YWxpZmllZCBkb21haW4gbmFtZSBvZiBhIG5ldHdvcmsgaG9zdCwgYXMgZGVmaW5lZCBieVxuICAgKiBSRkMgMzk4Ni4gTm90ZSB0aGUgZm9sbG93aW5nIGRldmlhdGlvbnMgZnJvbSB0aGUgXCJob3N0XCIgcGFydCBvZiB0aGUgVVJJIGFzXG4gICAqIGRlZmluZWQgaW4gdGhlIFJGQzogMS4gSVBzIGFyZSBub3QgYWxsb3dlZC4gQ3VycmVudGx5IGFuIEluZ3Jlc3NSdWxlVmFsdWVcbiAgICogY2FuIG9ubHkgYXBwbHkgdG8gdGhlIElQIGluIHRoZSBTcGVjIG9mIHRoZSBwYXJlbnQgSW5ncmVzcy4gMi4gVGhlIGA6YFxuICAgKiBkZWxpbWl0ZXIgaXMgbm90IHJlc3BlY3RlZCBiZWNhdXNlIHBvcnRzIGFyZSBub3QgYWxsb3dlZC4gQ3VycmVudGx5IHRoZVxuICAgKiBwb3J0IG9mIGFuIEluZ3Jlc3MgaXMgaW1wbGljaXRseSA6ODAgZm9yIGh0dHAgYW5kIDo0NDMgZm9yIGh0dHBzLiBCb3RoXG4gICAqIHRoZXNlIG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS4gSW5jb21pbmcgcmVxdWVzdHMgYXJlIG1hdGNoZWQgYWdhaW5zdCB0aGVcbiAgICogaG9zdCBiZWZvcmUgdGhlIEluZ3Jlc3NSdWxlVmFsdWUuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gSWYgdGhlIGhvc3QgaXMgdW5zcGVjaWZpZWQsIHRoZSBJbmdyZXNzIHJvdXRlcyBhbGwgdHJhZmZpYyBiYXNlZFxuICAgKiBvbiB0aGUgc3BlY2lmaWVkIEluZ3Jlc3NSdWxlVmFsdWUuXG4gICAqL1xuICByZWFkb25seSBob3N0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBQYXRoIGlzIGFuIGV4dGVuZGVkIFBPU0lYIHJlZ2V4IGFzIGRlZmluZWQgYnkgSUVFRSBTdGQgMTAwMy4xLCAoaS5lIHRoaXNcbiAgICogZm9sbG93cyB0aGUgZWdyZXAvdW5peCBzeW50YXgsIG5vdCB0aGUgcGVybCBzeW50YXgpIG1hdGNoZWQgYWdhaW5zdCB0aGVcbiAgICogcGF0aCBvZiBhbiBpbmNvbWluZyByZXF1ZXN0LiBDdXJyZW50bHkgaXQgY2FuIGNvbnRhaW4gY2hhcmFjdGVycyBkaXNhbGxvd2VkXG4gICAqIGZyb20gdGhlIGNvbnZlbnRpb25hbCBcInBhdGhcIiBwYXJ0IG9mIGEgVVJMIGFzIGRlZmluZWQgYnkgUkZDIDM5ODYuIFBhdGhzXG4gICAqIG11c3QgYmVnaW4gd2l0aCBhICcvJy5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBJZiB1bnNwZWNpZmllZCwgdGhlIHBhdGggZGVmYXVsdHMgdG8gYSBjYXRjaCBhbGwgc2VuZGluZyB0cmFmZmljXG4gICAqIHRvIHRoZSBiYWNrZW5kLlxuICAgKi9cbiAgcmVhZG9ubHkgcGF0aD86IHN0cmluZztcblxuICAvKipcbiAgICogU3BlY2lmeSBob3cgdGhlIHBhdGggaXMgbWF0Y2hlZCBhZ2FpbnN0IHJlcXVlc3QgcGF0aHMuIEJ5IGRlZmF1bHQsIHBhdGhcbiAgICogdHlwZXMgd2lsbCBiZSBtYXRjaGVkIGJ5IHByZWZpeC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zZXJ2aWNlcy1uZXR3b3JraW5nL2luZ3Jlc3MvI3BhdGgtdHlwZXNcbiAgICovXG4gIHJlYWRvbmx5IHBhdGhUeXBlPzogSHR0cEluZ3Jlc3NQYXRoVHlwZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBUTFMgY29uZmlndXJhdGlvbiBtYXBwaW5nIHRoYXQgaXMgcGFzc2VkIHRvIHRoZSBpbmdyZXNzXG4gKiBjb250cm9sbGVyIGZvciBTU0wgdGVybWluYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5ncmVzc1RscyB7XG5cbiAgLyoqXG4gICAqIEhvc3RzIGFyZSBhIGxpc3Qgb2YgaG9zdHMgaW5jbHVkZWQgaW4gdGhlIFRMUyBjZXJ0aWZpY2F0ZS4gVGhlIHZhbHVlcyBpblxuICAgKiB0aGlzIGxpc3QgbXVzdCBtYXRjaCB0aGUgbmFtZS9zIHVzZWQgaW4gdGhlIFRMUyBTZWNyZXQuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gSWYgdW5zcGVjaWZpZWQsIGl0IGRlZmF1bHRzIHRvIHRoZSB3aWxkY2FyZCBob3N0IHNldHRpbmcgZm9yXG4gICAqIHRoZSBsb2FkYmFsYW5jZXIgY29udHJvbGxlciBmdWxmaWxsaW5nIHRoaXMgSW5ncmVzcy5cbiAgICovXG4gIHJlYWRvbmx5IGhvc3RzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIFNlY3JldCBpcyB0aGUgc2VjcmV0IHRoYXQgY29udGFpbnMgdGhlIGNlcnRpZmljYXRlIGFuZCBrZXkgdXNlZCB0b1xuICAgKiB0ZXJtaW5hdGUgU1NMIHRyYWZmaWMgb24gNDQzLiBJZiB0aGUgU05JIGhvc3QgaW4gYSBsaXN0ZW5lciBjb25mbGljdHMgd2l0aFxuICAgKiB0aGUgXCJIb3N0XCIgaGVhZGVyIGZpZWxkIHVzZWQgYnkgYW4gSW5ncmVzc1J1bGUsIHRoZSBTTkkgaG9zdCBpcyB1c2VkIGZvclxuICAgKiB0ZXJtaW5hdGlvbiBhbmQgdmFsdWUgb2YgdGhlIEhvc3QgaGVhZGVyIGlzIHVzZWQgZm9yIHJvdXRpbmcuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gSWYgdW5zcGVjaWZpZWQsIGl0IGFsbG93cyBTU0wgcm91dGluZyBiYXNlZCBvbiBTTkkgaG9zdG5hbWUuXG4gICAqL1xuICByZWFkb25seSBzZWNyZXQ/OiBzZWNyZXQuSVNlY3JldDtcbn1cblxuZnVuY3Rpb24gc29ydEJ5UGF0aChsaHM6IGs4cy5IdHRwSW5ncmVzc1BhdGgsIHJoczogazhzLkh0dHBJbmdyZXNzUGF0aCkge1xuICBjb25zdCBwMSA9IGxocy5wYXRoID8/ICcnO1xuICBjb25zdCBwMiA9IHJocy5wYXRoID8/ICcnO1xuICByZXR1cm4gcDEubG9jYWxlQ29tcGFyZShwMik7XG59XG4iXX0=

/***/ }),

/***/ 5702:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Job = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const cdk8s_1 = __nccwpck_require__(1227);
const k8s = __nccwpck_require__(4879);
const pod = __nccwpck_require__(442);
const workload = __nccwpck_require__(7967);
/**
 * A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete,
 * the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete.
 * Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion.
 * The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot).
 * You can also use a Job to run multiple Pods in parallel.
 */
class Job extends workload.Workload {
    constructor(scope, id, props = {}) {
        super(scope, id, {
            restartPolicy: pod.RestartPolicy.NEVER,
            select: false,
            ...props,
        });
        this.resourceType = 'jobs';
        this.apiObject = new k8s.KubeJob(this, 'Resource', {
            metadata: props.metadata,
            spec: cdk8s_1.Lazy.any({ produce: () => this._toKube() }),
        });
        this.activeDeadline = props.activeDeadline;
        this.backoffLimit = props.backoffLimit;
        this.ttlAfterFinished = props.ttlAfterFinished;
    }
    /**
     * @internal
     */
    _toKube() {
        var _b;
        return {
            template: {
                metadata: this.podMetadata.toJson(),
                spec: this._toPodSpec(),
            },
            activeDeadlineSeconds: (_b = this.activeDeadline) === null || _b === void 0 ? void 0 : _b.toSeconds(),
            backoffLimit: this.backoffLimit,
            ttlSecondsAfterFinished: this.ttlAfterFinished ? this.ttlAfterFinished.toSeconds() : undefined,
        };
    }
}
exports.Job = Job;
_a = JSII_RTTI_SYMBOL_1;
Job[_a] = { fqn: "cdk8s-plus-22.Job", version: "2.0.0-rc.2" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiam9iLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2pvYi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGlDQUFrRDtBQUVsRCxxQ0FBcUM7QUFDckMsNkJBQTZCO0FBQzdCLHVDQUF1QztBQW9DdkM7Ozs7OztHQU1HO0FBQ0gsTUFBYSxHQUFJLFNBQVEsUUFBUSxDQUFDLFFBQVE7SUF3QnhDLFlBQVksS0FBZ0IsRUFBRSxFQUFVLEVBQUUsUUFBa0IsRUFBRTtRQUM1RCxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRTtZQUNmLGFBQWEsRUFBRSxHQUFHLENBQUMsYUFBYSxDQUFDLEtBQUs7WUFDdEMsTUFBTSxFQUFFLEtBQUs7WUFDYixHQUFHLEtBQUs7U0FDVCxDQUFDLENBQUM7UUFQVyxpQkFBWSxHQUFHLE1BQU0sQ0FBQztRQVNwQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFO1lBQ2pELFFBQVEsRUFBRSxLQUFLLENBQUMsUUFBUTtZQUN4QixJQUFJLEVBQUUsWUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQztTQUNsRCxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsY0FBYyxHQUFHLEtBQUssQ0FBQyxjQUFjLENBQUM7UUFDM0MsSUFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUMsWUFBWSxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxLQUFLLENBQUMsZ0JBQWdCLENBQUM7SUFFakQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksT0FBTzs7UUFDWixPQUFPO1lBQ0wsUUFBUSxFQUFFO2dCQUNSLFFBQVEsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRTtnQkFDbkMsSUFBSSxFQUFFLElBQUksQ0FBQyxVQUFVLEVBQUU7YUFDeEI7WUFDRCxxQkFBcUIsUUFBRSxJQUFJLENBQUMsY0FBYywwQ0FBRSxTQUFTLEVBQUU7WUFDdkQsWUFBWSxFQUFFLElBQUksQ0FBQyxZQUFZO1lBQy9CLHVCQUF1QixFQUFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTO1NBQy9GLENBQUM7SUFDSixDQUFDOztBQXZESCxrQkF5REMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcGlPYmplY3QsIExhenksIER1cmF0aW9uIH0gZnJvbSAnY2RrOHMnO1xuaW1wb3J0IHsgQ29uc3RydWN0IH0gZnJvbSAnY29uc3RydWN0cyc7XG5pbXBvcnQgKiBhcyBrOHMgZnJvbSAnLi9pbXBvcnRzL2s4cyc7XG5pbXBvcnQgKiBhcyBwb2QgZnJvbSAnLi9wb2QnO1xuaW1wb3J0ICogYXMgd29ya2xvYWQgZnJvbSAnLi93b3JrbG9hZCc7XG5cbi8qKlxuICogUHJvcGVydGllcyBmb3IgYEpvYmAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSm9iUHJvcHMgZXh0ZW5kcyB3b3JrbG9hZC5Xb3JrbG9hZFByb3BzIHtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBkdXJhdGlvbiB0aGUgam9iIG1heSBiZSBhY3RpdmUgYmVmb3JlIHRoZSBzeXN0ZW0gdHJpZXMgdG8gdGVybWluYXRlIGl0LlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIElmIHVuc2V0LCB0aGVuIHRoZXJlIGlzIG5vIGRlYWRsaW5lLlxuICAgKi9cbiAgcmVhZG9ubHkgYWN0aXZlRGVhZGxpbmU/OiBEdXJhdGlvbjtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgcmV0cmllcyBiZWZvcmUgbWFya2luZyB0aGlzIGpvYiBmYWlsZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gSWYgbm90IHNldCwgc3lzdGVtIGRlZmF1bHRzIHRvIDYuXG4gICAqL1xuICByZWFkb25seSBiYWNrb2ZmTGltaXQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIExpbWl0cyB0aGUgbGlmZXRpbWUgb2YgYSBKb2IgdGhhdCBoYXMgZmluaXNoZWQgZXhlY3V0aW9uIChlaXRoZXIgQ29tcGxldGVcbiAgICogb3IgRmFpbGVkKS4gSWYgdGhpcyBmaWVsZCBpcyBzZXQsIGFmdGVyIHRoZSBKb2IgZmluaXNoZXMsIGl0IGlzIGVsaWdpYmxlIHRvXG4gICAqIGJlIGF1dG9tYXRpY2FsbHkgZGVsZXRlZC4gV2hlbiB0aGUgSm9iIGlzIGJlaW5nIGRlbGV0ZWQsIGl0cyBsaWZlY3ljbGVcbiAgICogZ3VhcmFudGVlcyAoZS5nLiBmaW5hbGl6ZXJzKSB3aWxsIGJlIGhvbm9yZWQuIElmIHRoaXMgZmllbGQgaXMgc2V0IHRvIHplcm8sXG4gICAqIHRoZSBKb2IgYmVjb21lcyBlbGlnaWJsZSB0byBiZSBkZWxldGVkIGltbWVkaWF0ZWx5IGFmdGVyIGl0IGZpbmlzaGVzLiBUaGlzXG4gICAqIGZpZWxkIGlzIGFscGhhLWxldmVsIGFuZCBpcyBvbmx5IGhvbm9yZWQgYnkgc2VydmVycyB0aGF0IGVuYWJsZSB0aGVcbiAgICogYFRUTEFmdGVyRmluaXNoZWRgIGZlYXR1cmUuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gSWYgdGhpcyBmaWVsZCBpcyB1bnNldCwgdGhlIEpvYiB3b24ndCBiZSBhdXRvbWF0aWNhbGx5IGRlbGV0ZWQuXG4gICAqL1xuICByZWFkb25seSB0dGxBZnRlckZpbmlzaGVkPzogRHVyYXRpb247XG5cbn1cblxuLyoqXG4gKiBBIEpvYiBjcmVhdGVzIG9uZSBvciBtb3JlIFBvZHMgYW5kIGVuc3VyZXMgdGhhdCBhIHNwZWNpZmllZCBudW1iZXIgb2YgdGhlbSBzdWNjZXNzZnVsbHkgdGVybWluYXRlLiBBcyBwb2RzIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZSxcbiAqIHRoZSBKb2IgdHJhY2tzIHRoZSBzdWNjZXNzZnVsIGNvbXBsZXRpb25zLiBXaGVuIGEgc3BlY2lmaWVkIG51bWJlciBvZiBzdWNjZXNzZnVsIGNvbXBsZXRpb25zIGlzIHJlYWNoZWQsIHRoZSB0YXNrIChpZSwgSm9iKSBpcyBjb21wbGV0ZS5cbiAqIERlbGV0aW5nIGEgSm9iIHdpbGwgY2xlYW4gdXAgdGhlIFBvZHMgaXQgY3JlYXRlZC4gQSBzaW1wbGUgY2FzZSBpcyB0byBjcmVhdGUgb25lIEpvYiBvYmplY3QgaW4gb3JkZXIgdG8gcmVsaWFibHkgcnVuIG9uZSBQb2QgdG8gY29tcGxldGlvbi5cbiAqIFRoZSBKb2Igb2JqZWN0IHdpbGwgc3RhcnQgYSBuZXcgUG9kIGlmIHRoZSBmaXJzdCBQb2QgZmFpbHMgb3IgaXMgZGVsZXRlZCAoZm9yIGV4YW1wbGUgZHVlIHRvIGEgbm9kZSBoYXJkd2FyZSBmYWlsdXJlIG9yIGEgbm9kZSByZWJvb3QpLlxuICogWW91IGNhbiBhbHNvIHVzZSBhIEpvYiB0byBydW4gbXVsdGlwbGUgUG9kcyBpbiBwYXJhbGxlbC5cbiAqL1xuZXhwb3J0IGNsYXNzIEpvYiBleHRlbmRzIHdvcmtsb2FkLldvcmtsb2FkIHtcblxuICAvKipcbiAgICogRHVyYXRpb24gYmVmb3JlIGpvYiBpcyB0ZXJtaW5hdGVkLiBJZiB1bmRlZmluZWQsIHRoZXJlIGlzIG5vIGRlYWRsaW5lLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGFjdGl2ZURlYWRsaW5lPzogRHVyYXRpb247XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiByZXRyaWVzIGJlZm9yZSBtYXJraW5nIGZhaWxlZC5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBiYWNrb2ZmTGltaXQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRUTCBiZWZvcmUgdGhlIGpvYiBpcyBkZWxldGVkIGFmdGVyIGl0IGlzIGZpbmlzaGVkLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHR0bEFmdGVyRmluaXNoZWQ/OiBEdXJhdGlvbjtcblxuICAvKipcbiAgICogQHNlZSBiYXNlLlJlc291cmNlLmFwaU9iamVjdFxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGFwaU9iamVjdDogQXBpT2JqZWN0O1xuXG4gIHB1YmxpYyByZWFkb25seSByZXNvdXJjZVR5cGUgPSAnam9icyc7XG5cbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEpvYlByb3BzID0ge30pIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIHJlc3RhcnRQb2xpY3k6IHBvZC5SZXN0YXJ0UG9saWN5Lk5FVkVSLFxuICAgICAgc2VsZWN0OiBmYWxzZSxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuXG4gICAgdGhpcy5hcGlPYmplY3QgPSBuZXcgazhzLkt1YmVKb2IodGhpcywgJ1Jlc291cmNlJywge1xuICAgICAgbWV0YWRhdGE6IHByb3BzLm1ldGFkYXRhLFxuICAgICAgc3BlYzogTGF6eS5hbnkoeyBwcm9kdWNlOiAoKSA9PiB0aGlzLl90b0t1YmUoKSB9KSxcbiAgICB9KTtcblxuICAgIHRoaXMuYWN0aXZlRGVhZGxpbmUgPSBwcm9wcy5hY3RpdmVEZWFkbGluZTtcbiAgICB0aGlzLmJhY2tvZmZMaW1pdCA9IHByb3BzLmJhY2tvZmZMaW1pdDtcbiAgICB0aGlzLnR0bEFmdGVyRmluaXNoZWQgPSBwcm9wcy50dGxBZnRlckZpbmlzaGVkO1xuXG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgX3RvS3ViZSgpOiBrOHMuSm9iU3BlYyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRlbXBsYXRlOiB7XG4gICAgICAgIG1ldGFkYXRhOiB0aGlzLnBvZE1ldGFkYXRhLnRvSnNvbigpLFxuICAgICAgICBzcGVjOiB0aGlzLl90b1BvZFNwZWMoKSxcbiAgICAgIH0sXG4gICAgICBhY3RpdmVEZWFkbGluZVNlY29uZHM6IHRoaXMuYWN0aXZlRGVhZGxpbmU/LnRvU2Vjb25kcygpLFxuICAgICAgYmFja29mZkxpbWl0OiB0aGlzLmJhY2tvZmZMaW1pdCxcbiAgICAgIHR0bFNlY29uZHNBZnRlckZpbmlzaGVkOiB0aGlzLnR0bEFmdGVyRmluaXNoZWQgPyB0aGlzLnR0bEFmdGVyRmluaXNoZWQudG9TZWNvbmRzKCkgOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfVxuXG59XG4iXX0=

/***/ }),

/***/ 7534:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Namespaces = exports.Namespace = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const cdk8s_1 = __nccwpck_require__(1227);
const constructs_1 = __nccwpck_require__(1963);
const base = __nccwpck_require__(415);
const k8s = __nccwpck_require__(4879);
const pod = __nccwpck_require__(442);
/**
 * In Kubernetes, namespaces provides a mechanism for isolating groups of resources within a single cluster.
 * Names of resources need to be unique within a namespace, but not across namespaces.
 * Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc) and
 * not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc).
 */
class Namespace extends base.Resource {
    constructor(scope, id, props = {}) {
        super(scope, id);
        this.resourceType = 'namespaces';
        this.apiObject = new k8s.KubeNamespace(this, 'Resource', {
            metadata: props.metadata,
            spec: cdk8s_1.Lazy.any({ produce: () => this._toKube() }),
        });
        this._pods = pod.Pods.all(this, 'Pods', {
            namespaces: Namespaces.select(this, 'Namespaces', { names: [this.name] }),
        });
    }
    /**
     * @see INamespaceSelector.toNamespaceSelectorConfig()
     */
    toNamespaceSelectorConfig() {
        return { names: [this.name] };
    }
    /**
     * @see INetworkPolicyPeer.toNetworkPolicyPeerConfig()
     */
    toNetworkPolicyPeerConfig() {
        return this._pods.toNetworkPolicyPeerConfig();
    }
    /**
     * @see INetworkPolicyPeer.toPodSelector()
     */
    toPodSelector() {
        return this._pods.toPodSelector();
    }
    /**
     * @internal
     */
    _toKube() {
        return {};
    }
}
exports.Namespace = Namespace;
_a = JSII_RTTI_SYMBOL_1;
Namespace[_a] = { fqn: "cdk8s-plus-22.Namespace", version: "2.0.0-rc.2" };
/**
 * @see https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/#automatic-labelling
 */
Namespace.NAME_LABEL = 'kubernetes.io/metadata.name';
/**
 * Represents a group of namespaces.
 */
class Namespaces extends constructs_1.Construct {
    constructor(scope, id, expressions, names, labels) {
        super(scope, id);
        this.expressions = expressions;
        this.names = names;
        this.labels = labels;
        this._pods = pod.Pods.all(this, 'Pods', { namespaces: this });
    }
    /**
     * Select specific namespaces.
     */
    static select(scope, id, options) {
        return new Namespaces(scope, id, options.expressions, options.names, options.labels);
    }
    /**
     * Select all namespaces.
     */
    static all(scope, id) {
        return Namespaces.select(scope, id, { expressions: [], labels: {} });
    }
    /**
     * @see INamespaceSelector.toNamespaceSelectorConfig()
     */
    toNamespaceSelectorConfig() {
        return {
            labelSelector: pod.LabelSelector.of({ expressions: this.expressions, labels: this.labels }),
            names: this.names,
        };
    }
    /**
     * @see INetworkPolicyPeer.toNetworkPolicyPeerConfig()
     */
    toNetworkPolicyPeerConfig() {
        return this._pods.toNetworkPolicyPeerConfig();
    }
    /**
     * @see INetworkPolicyPeer.toPodSelector()
     */
    toPodSelector() {
        return this._pods.toPodSelector();
    }
}
exports.Namespaces = Namespaces;
_b = JSII_RTTI_SYMBOL_1;
Namespaces[_b] = { fqn: "cdk8s-plus-22.Namespaces", version: "2.0.0-rc.2" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmFtZXNwYWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL25hbWVzcGFjZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGlDQUF3QztBQUN4QywyQ0FBbUQ7QUFDbkQsK0JBQStCO0FBQy9CLHFDQUFxQztBQUVyQyw2QkFBNkI7QUFpQzdCOzs7OztHQUtHO0FBQ0gsTUFBYSxTQUFVLFNBQVEsSUFBSSxDQUFDLFFBQVE7SUFnQjFDLFlBQW1CLEtBQWdCLEVBQUUsRUFBVSxFQUFFLFFBQXdCLEVBQUU7UUFDekUsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUxILGlCQUFZLEdBQVcsWUFBWSxDQUFDO1FBT2xELElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxHQUFHLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxVQUFVLEVBQUU7WUFDdkQsUUFBUSxFQUFFLEtBQUssQ0FBQyxRQUFRO1lBQ3hCLElBQUksRUFBRSxZQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDO1NBQ2xELENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRTtZQUN0QyxVQUFVLEVBQUUsVUFBVSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsWUFBWSxFQUFFLEVBQUUsS0FBSyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7U0FDMUUsQ0FBQyxDQUFDO0lBRUwsQ0FBQztJQUVEOztPQUVHO0lBQ0kseUJBQXlCO1FBQzlCLE9BQU8sRUFBRSxLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztJQUNoQyxDQUFDO0lBRUQ7O09BRUc7SUFDSSx5QkFBeUI7UUFDOUIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLHlCQUF5QixFQUFFLENBQUM7SUFDaEQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksYUFBYTtRQUNsQixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDcEMsQ0FBQztJQUVEOztPQUVHO0lBQ0ksT0FBTztRQUNaLE9BQU8sRUFBRSxDQUFDO0lBQ1osQ0FBQzs7QUF4REgsOEJBMERDOzs7QUF4REM7O0dBRUc7QUFDb0Isb0JBQVUsR0FBRyw2QkFBNkIsQ0FBQztBQXNGcEU7O0dBRUc7QUFDSCxNQUFhLFVBQVcsU0FBUSxzQkFBUztJQWtCdkMsWUFBWSxLQUFnQixFQUFFLEVBQVUsRUFDckIsV0FBbUMsRUFDbkMsS0FBZ0IsRUFDaEIsTUFBa0M7UUFDbkQsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUhBLGdCQUFXLEdBQVgsV0FBVyxDQUF3QjtRQUNuQyxVQUFLLEdBQUwsS0FBSyxDQUFXO1FBQ2hCLFdBQU0sR0FBTixNQUFNLENBQTRCO1FBR25ELElBQUksQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ2hFLENBQUM7SUF2QkQ7O09BRUc7SUFDSSxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQWdCLEVBQUUsRUFBVSxFQUFFLE9BQWdDO1FBQ2pGLE9BQU8sSUFBSSxVQUFVLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRSxPQUFPLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3ZGLENBQUM7SUFFRDs7T0FFRztJQUNJLE1BQU0sQ0FBQyxHQUFHLENBQUMsS0FBZ0IsRUFBRSxFQUFVO1FBQzVDLE9BQU8sVUFBVSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsRUFBRSxFQUFFLEVBQUUsV0FBVyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUN2RSxDQUFDO0lBYUQ7O09BRUc7SUFDSSx5QkFBeUI7UUFDOUIsT0FBTztZQUNMLGFBQWEsRUFBRSxHQUFHLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxFQUFFLFdBQVcsRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUU7WUFDNUYsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLO1NBQ2xCLENBQUM7SUFDSixDQUFDO0lBRUQ7O09BRUc7SUFDSSx5QkFBeUI7UUFDOUIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLHlCQUF5QixFQUFFLENBQUM7SUFDaEQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksYUFBYTtRQUNsQixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDcEMsQ0FBQzs7QUFqREgsZ0NBbURDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBpT2JqZWN0LCBMYXp5IH0gZnJvbSAnY2RrOHMnO1xuaW1wb3J0IHsgQ29uc3RydWN0LCBJQ29uc3RydWN0IH0gZnJvbSAnY29uc3RydWN0cyc7XG5pbXBvcnQgKiBhcyBiYXNlIGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgKiBhcyBrOHMgZnJvbSAnLi9pbXBvcnRzL2s4cyc7XG5pbXBvcnQgKiBhcyBuZXR3b3JrcG9saWN5IGZyb20gJy4vbmV0d29yay1wb2xpY3knO1xuaW1wb3J0ICogYXMgcG9kIGZyb20gJy4vcG9kJztcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGZvciBzZWxlY3RpbmcgbmFtZXNwYWNlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOYW1lc3BhY2VTZWxlY3RvckNvbmZpZyB7XG5cbiAgLyoqXG4gICAqIEEgc2VsZWN0b3IgdG8gc2VsZWN0IG5hbWVzcGFjZXMgYnkgbGFiZWxzLlxuICAgKi9cbiAgcmVhZG9ubHkgbGFiZWxTZWxlY3Rvcj86IHBvZC5MYWJlbFNlbGVjdG9yO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgbmFtZXMgdG8gc2VsZWN0IG5hbWVzcGFjZXMgYnkgbmFtZXMuXG4gICAqL1xuICByZWFkb25seSBuYW1lcz86IHN0cmluZ1tdO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gb2JqZWN0IHRoYXQgY2FuIHNlbGVjdCBuYW1lc3BhY2VzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElOYW1lc3BhY2VTZWxlY3RvciBleHRlbmRzIElDb25zdHJ1Y3Qge1xuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb25maWd1cmF0aW9uIG9mIHRoaXMgc2VsZWN0b3IuXG4gICAqL1xuICB0b05hbWVzcGFjZVNlbGVjdG9yQ29uZmlnKCk6IE5hbWVzcGFjZVNlbGVjdG9yQ29uZmlnO1xufVxuXG4vKipcbiAqIFByb3BlcnRpZXMgZm9yIGBOYW1lc3BhY2VgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5hbWVzcGFjZVByb3BzIGV4dGVuZHMgYmFzZS5SZXNvdXJjZVByb3BzIHt9XG5cbi8qKlxuICogSW4gS3ViZXJuZXRlcywgbmFtZXNwYWNlcyBwcm92aWRlcyBhIG1lY2hhbmlzbSBmb3IgaXNvbGF0aW5nIGdyb3VwcyBvZiByZXNvdXJjZXMgd2l0aGluIGEgc2luZ2xlIGNsdXN0ZXIuXG4gKiBOYW1lcyBvZiByZXNvdXJjZXMgbmVlZCB0byBiZSB1bmlxdWUgd2l0aGluIGEgbmFtZXNwYWNlLCBidXQgbm90IGFjcm9zcyBuYW1lc3BhY2VzLlxuICogTmFtZXNwYWNlLWJhc2VkIHNjb3BpbmcgaXMgYXBwbGljYWJsZSBvbmx5IGZvciBuYW1lc3BhY2VkIG9iamVjdHMgKGUuZy4gRGVwbG95bWVudHMsIFNlcnZpY2VzLCBldGMpIGFuZFxuICogbm90IGZvciBjbHVzdGVyLXdpZGUgb2JqZWN0cyAoZS5nLiBTdG9yYWdlQ2xhc3MsIE5vZGVzLCBQZXJzaXN0ZW50Vm9sdW1lcywgZXRjKS5cbiAqL1xuZXhwb3J0IGNsYXNzIE5hbWVzcGFjZSBleHRlbmRzIGJhc2UuUmVzb3VyY2UgaW1wbGVtZW50cyBJTmFtZXNwYWNlU2VsZWN0b3IsIG5ldHdvcmtwb2xpY3kuSU5ldHdvcmtQb2xpY3lQZWVyIHtcblxuICAvKipcbiAgICogQHNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9vdmVydmlldy93b3JraW5nLXdpdGgtb2JqZWN0cy9uYW1lc3BhY2VzLyNhdXRvbWF0aWMtbGFiZWxsaW5nXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IE5BTUVfTEFCRUwgPSAna3ViZXJuZXRlcy5pby9tZXRhZGF0YS5uYW1lJztcblxuICAvKipcbiAgICogQHNlZSBiYXNlLlJlc291cmNlLmFwaU9iamVjdFxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGFwaU9iamVjdDogQXBpT2JqZWN0O1xuXG4gIHB1YmxpYyByZWFkb25seSByZXNvdXJjZVR5cGU6IHN0cmluZyA9ICduYW1lc3BhY2VzJztcblxuICBwcml2YXRlIHJlYWRvbmx5IF9wb2RzOiBwb2QuUG9kcztcblxuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IE5hbWVzcGFjZVByb3BzID0ge30pIHtcbiAgICBzdXBlcihzY29wZSwgaWQpO1xuXG4gICAgdGhpcy5hcGlPYmplY3QgPSBuZXcgazhzLkt1YmVOYW1lc3BhY2UodGhpcywgJ1Jlc291cmNlJywge1xuICAgICAgbWV0YWRhdGE6IHByb3BzLm1ldGFkYXRhLFxuICAgICAgc3BlYzogTGF6eS5hbnkoeyBwcm9kdWNlOiAoKSA9PiB0aGlzLl90b0t1YmUoKSB9KSxcbiAgICB9KTtcblxuICAgIHRoaXMuX3BvZHMgPSBwb2QuUG9kcy5hbGwodGhpcywgJ1BvZHMnLCB7XG4gICAgICBuYW1lc3BhY2VzOiBOYW1lc3BhY2VzLnNlbGVjdCh0aGlzLCAnTmFtZXNwYWNlcycsIHsgbmFtZXM6IFt0aGlzLm5hbWVdIH0pLFxuICAgIH0pO1xuXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBJTmFtZXNwYWNlU2VsZWN0b3IudG9OYW1lc3BhY2VTZWxlY3RvckNvbmZpZygpXG4gICAqL1xuICBwdWJsaWMgdG9OYW1lc3BhY2VTZWxlY3RvckNvbmZpZygpOiBOYW1lc3BhY2VTZWxlY3RvckNvbmZpZyB7XG4gICAgcmV0dXJuIHsgbmFtZXM6IFt0aGlzLm5hbWVdIH07XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBJTmV0d29ya1BvbGljeVBlZXIudG9OZXR3b3JrUG9saWN5UGVlckNvbmZpZygpXG4gICAqL1xuICBwdWJsaWMgdG9OZXR3b3JrUG9saWN5UGVlckNvbmZpZygpOiBuZXR3b3JrcG9saWN5Lk5ldHdvcmtQb2xpY3lQZWVyQ29uZmlnIHtcbiAgICByZXR1cm4gdGhpcy5fcG9kcy50b05ldHdvcmtQb2xpY3lQZWVyQ29uZmlnKCk7XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBJTmV0d29ya1BvbGljeVBlZXIudG9Qb2RTZWxlY3RvcigpXG4gICAqL1xuICBwdWJsaWMgdG9Qb2RTZWxlY3RvcigpOiBwb2QuSVBvZFNlbGVjdG9yIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fcG9kcy50b1BvZFNlbGVjdG9yKCk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgX3RvS3ViZSgpOiBrOHMuTmFtZXNwYWNlU3BlYyB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBgTmFtZXNwYWNlcy5zZWxlY3RgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5hbWVzcGFjZXNTZWxlY3RPcHRpb25zIHtcblxuICAvKipcbiAgICogTGFiZWxzIHRoZSBuYW1lc3BhY2VzIG11c3QgaGF2ZS5cbiAgICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIHVzaW5nIGFuICdJcycgc2VsZWN0b3IuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gbm8gc3RyaWN0IGxhYmVscyByZXF1aXJlbWVudHMuXG4gICAqL1xuICByZWFkb25seSBsYWJlbHM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXG4gIC8qKlxuICAgKiBOYW1lc3BhY2VzIG11c3Qgc2F0aXNmeSB0aGVzZSBzZWxlY3RvcnMuXG4gICAqIFRoZSBzZWxlY3RvcnMgcXVlcnkgbGFiZWxzLCBqdXN0IGxpa2UgdGhlIGBsYWJlbHNgIHByb3BlcnR5LCBidXQgdGhleVxuICAgKiBwcm92aWRlIGEgbW9yZSBhZHZhbmNlZCBtYXRjaGluZyBtZWNoYW5pc20uXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gbm8gc2VsZWN0b3IgcmVxdWlyZW1lbnRzLlxuICAgKi9cbiAgcmVhZG9ubHkgZXhwcmVzc2lvbnM/OiBwb2QuTGFiZWxFeHByZXNzaW9uW107XG5cbiAgLyoqXG4gICAqIE5hbWVzcGFjZXMgbmFtZXMgbXVzdCBiZSBvbmUgb2YgdGhlc2UuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gbm8gbmFtZSByZXF1aXJlbWVudHMuXG4gICAqL1xuICByZWFkb25seSBuYW1lcz86IHN0cmluZ1tdO1xuXG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGdyb3VwIG9mIG5hbWVzcGFjZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBOYW1lc3BhY2VzIGV4dGVuZHMgQ29uc3RydWN0IGltcGxlbWVudHMgSU5hbWVzcGFjZVNlbGVjdG9yLCBuZXR3b3JrcG9saWN5LklOZXR3b3JrUG9saWN5UGVlciB7XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBzcGVjaWZpYyBuYW1lc3BhY2VzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBzZWxlY3Qoc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgb3B0aW9uczogTmFtZXNwYWNlc1NlbGVjdE9wdGlvbnMpOiBOYW1lc3BhY2VzIHtcbiAgICByZXR1cm4gbmV3IE5hbWVzcGFjZXMoc2NvcGUsIGlkLCBvcHRpb25zLmV4cHJlc3Npb25zLCBvcHRpb25zLm5hbWVzLCBvcHRpb25zLmxhYmVscyk7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IGFsbCBuYW1lc3BhY2VzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhbGwoc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZyk6IE5hbWVzcGFjZXMge1xuICAgIHJldHVybiBOYW1lc3BhY2VzLnNlbGVjdChzY29wZSwgaWQsIHsgZXhwcmVzc2lvbnM6IFtdLCBsYWJlbHM6IHt9IH0pO1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkb25seSBfcG9kczogcG9kLlBvZHM7XG5cbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGV4cHJlc3Npb25zPzogcG9kLkxhYmVsRXhwcmVzc2lvbltdLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbmFtZXM/OiBzdHJpbmdbXSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGxhYmVscz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0pIHtcbiAgICBzdXBlcihzY29wZSwgaWQpO1xuXG4gICAgdGhpcy5fcG9kcyA9IHBvZC5Qb2RzLmFsbCh0aGlzLCAnUG9kcycsIHsgbmFtZXNwYWNlczogdGhpcyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIElOYW1lc3BhY2VTZWxlY3Rvci50b05hbWVzcGFjZVNlbGVjdG9yQ29uZmlnKClcbiAgICovXG4gIHB1YmxpYyB0b05hbWVzcGFjZVNlbGVjdG9yQ29uZmlnKCk6IE5hbWVzcGFjZVNlbGVjdG9yQ29uZmlnIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWxTZWxlY3RvcjogcG9kLkxhYmVsU2VsZWN0b3Iub2YoeyBleHByZXNzaW9uczogdGhpcy5leHByZXNzaW9ucywgbGFiZWxzOiB0aGlzLmxhYmVscyB9ICksXG4gICAgICBuYW1lczogdGhpcy5uYW1lcyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgSU5ldHdvcmtQb2xpY3lQZWVyLnRvTmV0d29ya1BvbGljeVBlZXJDb25maWcoKVxuICAgKi9cbiAgcHVibGljIHRvTmV0d29ya1BvbGljeVBlZXJDb25maWcoKTogbmV0d29ya3BvbGljeS5OZXR3b3JrUG9saWN5UGVlckNvbmZpZyB7XG4gICAgcmV0dXJuIHRoaXMuX3BvZHMudG9OZXR3b3JrUG9saWN5UGVlckNvbmZpZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgSU5ldHdvcmtQb2xpY3lQZWVyLnRvUG9kU2VsZWN0b3IoKVxuICAgKi9cbiAgcHVibGljIHRvUG9kU2VsZWN0b3IoKTogcG9kLklQb2RTZWxlY3RvciB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX3BvZHMudG9Qb2RTZWxlY3RvcigpO1xuICB9XG5cbn1cbiJdfQ==

/***/ }),

/***/ 3018:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validatePeerConfig = exports.NetworkPolicy = exports.NetworkPolicyTrafficDefault = exports.NetworkProtocol = exports.NetworkPolicyIpBlock = exports.NetworkPolicyPort = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const cdk8s_1 = __nccwpck_require__(1227);
const constructs_1 = __nccwpck_require__(1963);
const base = __nccwpck_require__(415);
const k8s = __nccwpck_require__(4879);
const namespace = __nccwpck_require__(7534);
const pod = __nccwpck_require__(442);
const utils_1 = __nccwpck_require__(6594);
/**
 * Describes a port to allow traffic on.
 */
class NetworkPolicyPort {
    constructor(port, endPort, protocol) {
        this.port = port;
        this.endPort = endPort;
        this.protocol = protocol;
    }
    /**
     * Distinct TCP ports
     */
    static tcp(port) {
        return new NetworkPolicyPort(k8s.IntOrString.fromNumber(port), undefined, NetworkProtocol.TCP);
    }
    /**
     * A TCP port range
     */
    static tcpRange(startPort, endPort) {
        return new NetworkPolicyPort(k8s.IntOrString.fromNumber(startPort), endPort, NetworkProtocol.TCP);
    }
    /**
     * Any TCP traffic
     */
    static allTcp() {
        return new NetworkPolicyPort(k8s.IntOrString.fromNumber(0), 65535, NetworkProtocol.TCP);
    }
    /**
     * Distinct UDP ports
     */
    static udp(port) {
        return new NetworkPolicyPort(k8s.IntOrString.fromNumber(port), undefined, NetworkProtocol.UDP);
    }
    /**
     * A UDP port range
     */
    static udpRange(startPort, endPort) {
        return new NetworkPolicyPort(k8s.IntOrString.fromNumber(startPort), endPort, NetworkProtocol.UDP);
    }
    /**
     * Any UDP traffic
     */
    static allUdp() {
        return new NetworkPolicyPort(k8s.IntOrString.fromNumber(0), 65535, NetworkProtocol.UDP);
    }
    /**
     * Custom port configuration.
     */
    static of(props) {
        return new NetworkPolicyPort(props.port ? k8s.IntOrString.fromNumber(props.port) : undefined, props.endPort, props.protocol);
    }
    /**
     * @internal
     */
    _toKube() {
        return { port: this.port, endPort: this.endPort, protocol: this.protocol };
    }
}
exports.NetworkPolicyPort = NetworkPolicyPort;
_a = JSII_RTTI_SYMBOL_1;
NetworkPolicyPort[_a] = { fqn: "cdk8s-plus-22.NetworkPolicyPort", version: "2.0.0-rc.2" };
/**
 * Describes a particular CIDR (Ex. "192.168.1.1/24","2001:db9::/64") that is
 * allowed to the pods matched by a network policy selector.
 * The except entry describes CIDRs that should not be included within this rule.
 */
class NetworkPolicyIpBlock extends constructs_1.Construct {
    constructor(scope, id, 
    /**
     * A string representing the IP Block Valid examples are "192.168.1.1/24" or "2001:db9::/64".
     */
    cidr, 
    /**
     * A slice of CIDRs that should not be included within an IP Block Valid examples are "192.168.1.1/24" or "2001:db9::/64".
     * Except values will be rejected if they are outside the CIDR range.
     */
    except) {
        super(scope, id);
        this.cidr = cidr;
        this.except = except;
    }
    /**
     * Create an IPv4 peer from a CIDR
     */
    static ipv4(scope, id, cidrIp, except) {
        const cidrMatch = cidrIp.match(/^(\d{1,3}\.){3}\d{1,3}(\/\d+)?$/);
        if (!cidrMatch) {
            throw new Error(`Invalid IPv4 CIDR: "${cidrIp}"`);
        }
        if (!cidrMatch[2]) {
            throw new Error(`CIDR mask is missing in IPv4: "${cidrIp}". Did you mean "${cidrIp}/32"?`);
        }
        return new NetworkPolicyIpBlock(scope, id, cidrIp, except);
    }
    /**
     * Any IPv4 address
     */
    static anyIpv4(scope, id) {
        return new NetworkPolicyIpBlock(scope, id, '0.0.0.0/0');
    }
    /**
     * Create an IPv6 peer from a CIDR
     */
    static ipv6(scope, id, cidrIp, except) {
        const cidrMatch = cidrIp.match(/^([\da-f]{0,4}:){2,7}([\da-f]{0,4})?(\/\d+)?$/);
        if (!cidrMatch) {
            throw new Error(`Invalid IPv6 CIDR: "${cidrIp}"`);
        }
        if (!cidrMatch[3]) {
            throw new Error(`CIDR mask is missing in IPv6: "${cidrIp}". Did you mean "${cidrIp}/128"?`);
        }
        return new NetworkPolicyIpBlock(scope, id, cidrIp, except);
    }
    /**
     * Any IPv6 address
     */
    static anyIpv6(scope, id) {
        return new NetworkPolicyIpBlock(scope, id, '::/0');
    }
    /**
     * @see INetworkPolicyPeer.toNetworkPolicyPeerConfig()
     */
    toNetworkPolicyPeerConfig() {
        return { ipBlock: this };
    }
    /**
     * @see INetworkPolicyPeer.toPodSelector()
     */
    toPodSelector() {
        return undefined;
    }
    /**
     * @internal
     */
    _toKube() {
        return { cidr: this.cidr, except: this.except };
    }
}
exports.NetworkPolicyIpBlock = NetworkPolicyIpBlock;
_b = JSII_RTTI_SYMBOL_1;
NetworkPolicyIpBlock[_b] = { fqn: "cdk8s-plus-22.NetworkPolicyIpBlock", version: "2.0.0-rc.2" };
/**
 * Network protocols.
 */
var NetworkProtocol;
(function (NetworkProtocol) {
    /**
     * TCP.
     */
    NetworkProtocol["TCP"] = "TCP";
    /**
     * UDP.
     */
    NetworkProtocol["UDP"] = "UDP";
    /**
     * SCTP.
     */
    NetworkProtocol["SCTP"] = "SCTP";
})(NetworkProtocol = exports.NetworkProtocol || (exports.NetworkProtocol = {}));
/**
 * Default behaviors of network traffic in policies.
 */
var NetworkPolicyTrafficDefault;
(function (NetworkPolicyTrafficDefault) {
    /**
     * The policy denies all traffic.
     * Since rules are additive, additional rules or policies can allow
     * specific traffic.
     */
    NetworkPolicyTrafficDefault["DENY"] = "DENY";
    /**
     * The policy allows all traffic (either ingress or egress).
     * Since rules are additive, no additional rule or policies can
     * subsequently deny the traffic.
     */
    NetworkPolicyTrafficDefault["ALLOW"] = "ALLOW";
})(NetworkPolicyTrafficDefault = exports.NetworkPolicyTrafficDefault || (exports.NetworkPolicyTrafficDefault = {}));
/**
 * Control traffic flow at the IP address or port level (OSI layer 3 or 4),
 * network policies are an application-centric construct which allow you
 * to specify how a pod is allowed to communicate with various network peers.
 *
 * - Outgoing traffic is allowed if there are no network policies selecting
 *   the pod (and cluster policy otherwise allows the traffic),
 *   OR if the traffic matches at least one egress rule across all of the
 *   network policies that select the pod.
 *
 * - Incoming traffic is allowed to a pod if there are no network policies
 *   selecting the pod (and cluster policy otherwise allows the traffic),
 *   OR if the traffic source is the pod's local node,
 *   OR if the traffic matches at least one ingress rule across all of
 *   the network policies that select the pod.
 *
 * Network policies do not conflict; they are additive.
 * If any policy or policies apply to a given pod for a given
 * direction, the connections allowed in that direction from
 * that pod is the union of what the applicable policies allow.
 * Thus, order of evaluation does not affect the policy result.
 *
 * For a connection from a source pod to a destination pod to be allowed,
 * both the egress policy on the source pod and the ingress policy on the
 * destination pod need to allow the connection.
 * If either side does not allow the connection, it will not happen.
 *
 * @see https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource
 */
class NetworkPolicy extends base.Resource {
    constructor(scope, id, props = {}) {
        var _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        super(scope, id);
        this.resourceType = 'networkpolicies';
        this._egressRules = [];
        this._ingressRules = [];
        this._policyTypes = new Set();
        const podSelector = (_d = props.selector) !== null && _d !== void 0 ? _d : pod.Pods.all(this, 'AllPods');
        this._podSelectorConfig = podSelector.toPodSelectorConfig();
        let ns;
        if (!((_e = props.metadata) === null || _e === void 0 ? void 0 : _e.namespace)) {
            if (((_f = this._podSelectorConfig.namespaces) === null || _f === void 0 ? void 0 : _f.labelSelector) && !((_g = this._podSelectorConfig.namespaces) === null || _g === void 0 ? void 0 : _g.labelSelector.isEmpty())) {
                throw new Error(`Unable to create a network policy for a selector (${podSelector.node.path}) that selects pods in namespaces based on labels`);
            }
            if (((_h = this._podSelectorConfig.namespaces) === null || _h === void 0 ? void 0 : _h.names) && this._podSelectorConfig.namespaces.names.length > 1) {
                throw new Error(`Unable to create a network policy for a selector (${podSelector.node.path}) that selects pods in multiple namespaces`);
            }
            ns = ((_j = this._podSelectorConfig.namespaces) === null || _j === void 0 ? void 0 : _j.names) ? (_k = this._podSelectorConfig.namespaces) === null || _k === void 0 ? void 0 : _k.names[0] : undefined;
        }
        else {
            ns = props.metadata.namespace;
        }
        this.apiObject = new k8s.KubeNetworkPolicy(this, 'Resource', {
            metadata: { ...props.metadata, namespace: ns },
            spec: cdk8s_1.Lazy.any({ produce: () => this._toKube() }),
        });
        this.configureDefaultBehavior('Egress', (_l = props.egress) === null || _l === void 0 ? void 0 : _l.default);
        this.configureDefaultBehavior('Ingress', (_m = props.ingress) === null || _m === void 0 ? void 0 : _m.default);
        for (const rule of (_p = (_o = props.egress) === null || _o === void 0 ? void 0 : _o.rules) !== null && _p !== void 0 ? _p : []) {
            this.addEgressRule(rule.peer, rule.ports);
        }
        for (const rule of (_r = (_q = props.ingress) === null || _q === void 0 ? void 0 : _q.rules) !== null && _r !== void 0 ? _r : []) {
            this.addIngressRule(rule.peer, rule.ports);
        }
    }
    /**
     * Allow outgoing traffic to the peer.
     *
     * If ports are not passed, traffic will be allowed on all ports.
     */
    addEgressRule(peer, ports) {
        this._policyTypes.add('Egress');
        this._egressRules.push({ ports: (ports !== null && ports !== void 0 ? ports : []).map(p => p._toKube()), to: this.createNetworkPolicyPeers(peer) });
    }
    /**
     * Allow incoming traffic from the peer.
     *
     * If ports are not passed, traffic will be allowed on all ports.
     */
    addIngressRule(peer, ports) {
        this._policyTypes.add('Ingress');
        this._ingressRules.push({ ports: (ports !== null && ports !== void 0 ? ports : []).map(p => p._toKube()), from: this.createNetworkPolicyPeers(peer) });
    }
    createNetworkPolicyPeers(peer) {
        var _d, _e, _f, _g, _h, _j, _k;
        const config = peer.toNetworkPolicyPeerConfig();
        validatePeerConfig(config);
        if (config.ipBlock) {
            // ip block is a single peer.
            return [{ ipBlock: config.ipBlock._toKube() }];
        }
        if (!((_d = config.podSelector.namespaces) === null || _d === void 0 ? void 0 : _d.names)) {
            // when no explicit namespaces are defined we can just use
            // the selector as is
            return [{
                    namespaceSelector: (_f = (_e = config.podSelector.namespaces) === null || _e === void 0 ? void 0 : _e.labelSelector) === null || _f === void 0 ? void 0 : _f._toKube(),
                    podSelector: config.podSelector.labelSelector._toKube(),
                }];
        }
        // when explicit namespaces are defined, we need to create a separate
        // peer for each, since a label selector cannot have multiple name labels. (they will conflict)
        const namespaceSelector = (_k = (_j = (_h = (_g = config.podSelector) === null || _g === void 0 ? void 0 : _g.namespaces) === null || _h === void 0 ? void 0 : _h.labelSelector) === null || _j === void 0 ? void 0 : _j._toKube()) !== null && _k !== void 0 ? _k : {};
        return config.podSelector.namespaces.names.map(n => ({
            podSelector: config.podSelector.labelSelector._toKube(),
            namespaceSelector: {
                matchExpressions: namespaceSelector.matchExpressions,
                matchLabels: {
                    ...namespaceSelector.matchLabels,
                    [namespace.Namespace.NAME_LABEL]: n,
                },
            },
        }));
    }
    configureDefaultBehavior(direction, _default) {
        if (!_default) {
            return;
        }
        if (_default === NetworkPolicyTrafficDefault.DENY) {
            // https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-deny-all-egress-traffic
            this._policyTypes.add(direction);
        }
        if (_default === NetworkPolicyTrafficDefault.ALLOW) {
            // https://kubernetes.io/docs/concepts/services-networking/network-policies/#allow-all-egress-traffic
            this._policyTypes.add(direction);
            if (direction === 'Egress') {
                this._egressRules.push({});
            }
            else {
                this._ingressRules.push({});
            }
        }
    }
    /**
     * @internal
     */
    _toKube() {
        return {
            podSelector: this._podSelectorConfig.labelSelector._toKube(),
            egress: utils_1.undefinedIfEmpty(this._egressRules),
            ingress: utils_1.undefinedIfEmpty(this._ingressRules),
            policyTypes: utils_1.undefinedIfEmpty(Array.from(this._policyTypes)),
        };
    }
}
exports.NetworkPolicy = NetworkPolicy;
_c = JSII_RTTI_SYMBOL_1;
NetworkPolicy[_c] = { fqn: "cdk8s-plus-22.NetworkPolicy", version: "2.0.0-rc.2" };
function validatePeerConfig(peerConfig) {
    if (!peerConfig.ipBlock && !peerConfig.podSelector) {
        throw new Error('Inavlid peer: either \'ipBlock\' or \'podSelector\' must be defined');
    }
    if (peerConfig.ipBlock && peerConfig.podSelector) {
        throw new Error('Inavlid peer: only one of \'ipBlock\' and \'podSelector\' must be defined');
    }
}
exports.validatePeerConfig = validatePeerConfig;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmV0d29yay1wb2xpY3kuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvbmV0d29yay1wb2xpY3kudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxpQ0FBd0M7QUFDeEMsMkNBQW1EO0FBQ25ELCtCQUErQjtBQUMvQixxQ0FBcUM7QUFDckMseUNBQXlDO0FBQ3pDLDZCQUE2QjtBQUM3QixtQ0FBMkM7QUE4QjNDOztHQUVHO0FBQ0gsTUFBYSxpQkFBaUI7SUFtRDVCLFlBQ21CLElBQXNCLEVBQ3RCLE9BQWdCLEVBQ2hCLFFBQTBCO1FBRjFCLFNBQUksR0FBSixJQUFJLENBQWtCO1FBQ3RCLFlBQU8sR0FBUCxPQUFPLENBQVM7UUFDaEIsYUFBUSxHQUFSLFFBQVEsQ0FBa0I7SUFBRyxDQUFDO0lBcERqRDs7T0FFRztJQUNJLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBWTtRQUM1QixPQUFPLElBQUksaUJBQWlCLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUUsU0FBUyxFQUFFLGVBQWUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqRyxDQUFDO0lBRUQ7O09BRUc7SUFDSSxNQUFNLENBQUMsUUFBUSxDQUFDLFNBQWlCLEVBQUUsT0FBZTtRQUN2RCxPQUFPLElBQUksaUJBQWlCLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLEVBQUUsT0FBTyxFQUFFLGVBQWUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNwRyxDQUFDO0lBRUQ7O09BRUc7SUFDSSxNQUFNLENBQUMsTUFBTTtRQUNsQixPQUFPLElBQUksaUJBQWlCLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLGVBQWUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUMxRixDQUFDO0lBRUQ7O09BRUc7SUFDSSxNQUFNLENBQUMsR0FBRyxDQUFDLElBQVk7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QUksUUFBUSxLQUFLLDJCQUEyQixDQUFDLEtBQUssRUFBRTtZQUNsRCxxR0FBcUc7WUFDckcsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDakMsSUFBSSxTQUFTLEtBQUssUUFBUSxFQUFFO2dCQUMxQixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQzthQUM1QjtpQkFBTTtnQkFDTCxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQzthQUM3QjtTQUNGO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0ksT0FBTztRQUNaLE9BQU87WUFDTCxXQUFXLEVBQUUsSUFBSSxDQUFDLGtCQUFrQixDQUFDLGFBQWEsQ0FBQyxPQUFPLEVBQUU7WUFDNUQsTUFBTSxFQUFFLHdCQUFnQixDQUFDLElBQUksQ0FBQyxZQUFZLENBQUM7WUFDM0MsT0FBTyxFQUFFLHdCQUFnQixDQUFDLElBQUksQ0FBQyxhQUFhLENBQUM7WUFDN0MsV0FBVyxFQUFFLHdCQUFnQixDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1NBQzdELENBQUM7SUFDSixDQUFDOztBQTVJSCxzQ0E4SUM7OztBQUVELFNBQWdCLGtCQUFrQixDQUFDLFVBQW1DO0lBQ3BFLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRTtRQUNsRCxNQUFNLElBQUksS0FBSyxDQUFDLHFFQUFxRSxDQUFDLENBQUM7S0FDeEY7SUFDRCxJQUFJLFVBQVUsQ0FBQyxPQUFPLElBQUksVUFBVSxDQUFDLFdBQVcsRUFBRTtRQUNoRCxNQUFNLElBQUksS0FBSyxDQUFDLDJFQUEyRSxDQUFDLENBQUM7S0FDOUY7QUFDSCxDQUFDO0FBUEQsZ0RBT0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcGlPYmplY3QsIExhenkgfSBmcm9tICdjZGs4cyc7XG5pbXBvcnQgeyBDb25zdHJ1Y3QsIElDb25zdHJ1Y3QgfSBmcm9tICdjb25zdHJ1Y3RzJztcbmltcG9ydCAqIGFzIGJhc2UgZnJvbSAnLi9iYXNlJztcbmltcG9ydCAqIGFzIGs4cyBmcm9tICcuL2ltcG9ydHMvazhzJztcbmltcG9ydCAqIGFzIG5hbWVzcGFjZSBmcm9tICcuL25hbWVzcGFjZSc7XG5pbXBvcnQgKiBhcyBwb2QgZnJvbSAnLi9wb2QnO1xuaW1wb3J0IHsgdW5kZWZpbmVkSWZFbXB0eSB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIFByb3BlcnRpZXMgZm9yIGBOZXR3b3JrUG9saWN5UG9ydGAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV0d29ya1BvbGljeVBvcnRQcm9wcyB7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmljIHBvcnQgbnVtYmVyLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGFsbCBwb3J0cyBhcmUgYWxsb3dlZC5cbiAgICovXG4gIHJlYWRvbmx5IHBvcnQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEVuZCBwb3J0IChyZWxhdGl2ZSB0byBgcG9ydGApLiBPbmx5IGFwcGxpZXMgaWYgYHBvcnRgIGlzIGRlZmluZWQuXG4gICAqIFVzZSB0aGlzIHRvIHNwZWNpZnkgYSBwb3J0IHJhbmdlLCByYXRoZXIgdGhhdCBhIHNwZWNpZmljIG9uZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBub3QgYSBwb3J0IHJhbmdlLlxuICAgKi9cbiAgcmVhZG9ubHkgZW5kUG9ydD86IG51bWJlcjtcblxuICAvKipcbiAgICogUHJvdG9jb2wuXG4gICAqXG4gICAqIEBkZWZhdWx0IE5ldHdvcmtQcm90b2NvbC5UQ1BcbiAgICovXG4gIHJlYWRvbmx5IHByb3RvY29sPzogTmV0d29ya1Byb3RvY29sO1xufVxuXG4vKipcbiAqIERlc2NyaWJlcyBhIHBvcnQgdG8gYWxsb3cgdHJhZmZpYyBvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIE5ldHdvcmtQb2xpY3lQb3J0IHtcblxuICAvKipcbiAgICogRGlzdGluY3QgVENQIHBvcnRzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHRjcChwb3J0OiBudW1iZXIpOiBOZXR3b3JrUG9saWN5UG9ydCB7XG4gICAgcmV0dXJuIG5ldyBOZXR3b3JrUG9saWN5UG9ydChrOHMuSW50T3JTdHJpbmcuZnJvbU51bWJlcihwb3J0KSwgdW5kZWZpbmVkLCBOZXR3b3JrUHJvdG9jb2wuVENQKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIFRDUCBwb3J0IHJhbmdlXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHRjcFJhbmdlKHN0YXJ0UG9ydDogbnVtYmVyLCBlbmRQb3J0OiBudW1iZXIpIHtcbiAgICByZXR1cm4gbmV3IE5ldHdvcmtQb2xpY3lQb3J0KGs4cy5JbnRPclN0cmluZy5mcm9tTnVtYmVyKHN0YXJ0UG9ydCksIGVuZFBvcnQsIE5ldHdvcmtQcm90b2NvbC5UQ1ApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFueSBUQ1AgdHJhZmZpY1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhbGxUY3AoKSB7XG4gICAgcmV0dXJuIG5ldyBOZXR3b3JrUG9saWN5UG9ydChrOHMuSW50T3JTdHJpbmcuZnJvbU51bWJlcigwKSwgNjU1MzUsIE5ldHdvcmtQcm90b2NvbC5UQ1ApO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3RpbmN0IFVEUCBwb3J0c1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyB1ZHAocG9ydDogbnVtYmVyKTogTmV0d29ya1BvbGljeVBvcnQge1xuICAgIHJldHVybiBuZXcgTmV0d29ya1BvbGljeVBvcnQoazhzLkludE9yU3RyaW5nLmZyb21OdW1iZXIocG9ydCksIHVuZGVmaW5lZCwgTmV0d29ya1Byb3RvY29sLlVEUCk7XG4gIH1cblxuICAvKipcbiAgICogQSBVRFAgcG9ydCByYW5nZVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyB1ZHBSYW5nZShzdGFydFBvcnQ6IG51bWJlciwgZW5kUG9ydDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIG5ldyBOZXR3b3JrUG9saWN5UG9ydChrOHMuSW50T3JTdHJpbmcuZnJvbU51bWJlcihzdGFydFBvcnQpLCBlbmRQb3J0LCBOZXR3b3JrUHJvdG9jb2wuVURQKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbnkgVURQIHRyYWZmaWNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYWxsVWRwKCkge1xuICAgIHJldHVybiBuZXcgTmV0d29ya1BvbGljeVBvcnQoazhzLkludE9yU3RyaW5nLmZyb21OdW1iZXIoMCksIDY1NTM1LCBOZXR3b3JrUHJvdG9jb2wuVURQKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXN0b20gcG9ydCBjb25maWd1cmF0aW9uLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBvZihwcm9wczogTmV0d29ya1BvbGljeVBvcnRQcm9wcyk6IE5ldHdvcmtQb2xpY3lQb3J0IHtcbiAgICByZXR1cm4gbmV3IE5ldHdvcmtQb2xpY3lQb3J0KHByb3BzLnBvcnQgPyBrOHMuSW50T3JTdHJpbmcuZnJvbU51bWJlcihwcm9wcy5wb3J0KSA6IHVuZGVmaW5lZCwgcHJvcHMuZW5kUG9ydCwgcHJvcHMucHJvdG9jb2wpO1xuICB9XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBvcnQ/OiBrOHMuSW50T3JTdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBlbmRQb3J0PzogbnVtYmVyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcHJvdG9jb2w/OiBOZXR3b3JrUHJvdG9jb2wpIHt9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHVibGljIF90b0t1YmUoKTogazhzLk5ldHdvcmtQb2xpY3lQb3J0IHtcbiAgICByZXR1cm4geyBwb3J0OiB0aGlzLnBvcnQsIGVuZFBvcnQ6IHRoaXMuZW5kUG9ydCwgcHJvdG9jb2w6IHRoaXMucHJvdG9jb2wgfTtcbiAgfVxuXG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgbmV0d29yayBwZWVycy5cbiAqIEEgcGVlciBjYW4gZWl0aGVyIGJ5IGFuIGlwIGJsb2NrLCBvciBhIHNlbGVjdGlvbiBvZiBwb2RzLCBub3QgYm90aC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXR3b3JrUG9saWN5UGVlckNvbmZpZyB7XG5cbiAgLyoqXG4gICAqIFRoZSBpcCBibG9jayB0aGlzIHBlZXIgcmVwcmVzZW50cy5cbiAgICovXG4gIHJlYWRvbmx5IGlwQmxvY2s/OiBOZXR3b3JrUG9saWN5SXBCbG9jaztcblxuICAvKipcbiAgICogVGhlIHBvZCBzZWxlY3RvciB0aGlzIHBlZXIgcmVwcmVzZW50cy5cbiAgICovXG4gIHJlYWRvbmx5IHBvZFNlbGVjdG9yPzogcG9kLlBvZFNlbGVjdG9yQ29uZmlnO1xuXG59XG5cbi8qKlxuICogRGVzY3JpYmVzIGEgcGVlciB0byBhbGxvdyB0cmFmZmljIHRvL2Zyb20uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSU5ldHdvcmtQb2xpY3lQZWVyIGV4dGVuZHMgSUNvbnN0cnVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhpcyBwZWVyLlxuICAgKi9cbiAgdG9OZXR3b3JrUG9saWN5UGVlckNvbmZpZygpOiBOZXR3b3JrUG9saWN5UGVlckNvbmZpZztcblxuICAvKipcbiAgICogQ29udmVydCB0aGUgcGVlciBpbnRvIGEgcG9kIHNlbGVjdG9yLCBpZiBwb3NzaWJsZS5cbiAgICovXG4gIHRvUG9kU2VsZWN0b3IoKTogcG9kLklQb2RTZWxlY3RvciB8IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBEZXNjcmliZXMgYSBydWxlIGFsbG93aW5nIHRyYWZmaWMgZnJvbSAvIHRvIHBvZHMgbWF0Y2hlZCBieSBhIG5ldHdvcmsgcG9saWN5IHNlbGVjdG9yLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5ldHdvcmtQb2xpY3lSdWxlIHtcblxuICAvKipcbiAgICogVGhlIHBvcnRzIG9mIHRoZSBydWxlLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIHRyYWZmaWMgaXMgYWxsb3dlZCBvbiBhbGwgcG9ydHMuXG4gICAqL1xuICByZWFkb25seSBwb3J0cz86IE5ldHdvcmtQb2xpY3lQb3J0W107XG5cbiAgLyoqXG4gICAqIFBlZXIgdGhpcyBydWxlIGludGVyYWN0cyB3aXRoLlxuICAgKi9cbiAgcmVhZG9ubHkgcGVlcjogSU5ldHdvcmtQb2xpY3lQZWVyO1xuXG59XG5cbi8qKlxuICogRGVzY3JpYmVzIGEgcGFydGljdWxhciBDSURSIChFeC4gXCIxOTIuMTY4LjEuMS8yNFwiLFwiMjAwMTpkYjk6Oi82NFwiKSB0aGF0IGlzXG4gKiBhbGxvd2VkIHRvIHRoZSBwb2RzIG1hdGNoZWQgYnkgYSBuZXR3b3JrIHBvbGljeSBzZWxlY3Rvci5cbiAqIFRoZSBleGNlcHQgZW50cnkgZGVzY3JpYmVzIENJRFJzIHRoYXQgc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCB3aXRoaW4gdGhpcyBydWxlLlxuICovXG5leHBvcnQgY2xhc3MgTmV0d29ya1BvbGljeUlwQmxvY2sgZXh0ZW5kcyBDb25zdHJ1Y3QgaW1wbGVtZW50cyBJTmV0d29ya1BvbGljeVBlZXIge1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSVB2NCBwZWVyIGZyb20gYSBDSURSXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGlwdjQoc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgY2lkcklwOiBzdHJpbmcsIGV4Y2VwdD86IHN0cmluZ1tdKTogTmV0d29ya1BvbGljeUlwQmxvY2sge1xuICAgIGNvbnN0IGNpZHJNYXRjaCA9IGNpZHJJcC5tYXRjaCgvXihcXGR7MSwzfVxcLil7M31cXGR7MSwzfShcXC9cXGQrKT8kLyk7XG5cbiAgICBpZiAoIWNpZHJNYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIElQdjQgQ0lEUjogXCIke2NpZHJJcH1cImApO1xuICAgIH1cblxuICAgIGlmICghY2lkck1hdGNoWzJdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENJRFIgbWFzayBpcyBtaXNzaW5nIGluIElQdjQ6IFwiJHtjaWRySXB9XCIuIERpZCB5b3UgbWVhbiBcIiR7Y2lkcklwfS8zMlwiP2ApO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgTmV0d29ya1BvbGljeUlwQmxvY2soc2NvcGUsIGlkLCBjaWRySXAsIGV4Y2VwdCk7XG4gIH1cblxuICAvKipcbiAgICogQW55IElQdjQgYWRkcmVzc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhbnlJcHY0KHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcpOiBOZXR3b3JrUG9saWN5SXBCbG9jayB7XG4gICAgcmV0dXJuIG5ldyBOZXR3b3JrUG9saWN5SXBCbG9jayhzY29wZSwgaWQsICcwLjAuMC4wLzAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSVB2NiBwZWVyIGZyb20gYSBDSURSXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGlwdjYoc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgY2lkcklwOiBzdHJpbmcsIGV4Y2VwdD86IHN0cmluZ1tdKTogTmV0d29ya1BvbGljeUlwQmxvY2sge1xuXG4gICAgY29uc3QgY2lkck1hdGNoID0gY2lkcklwLm1hdGNoKC9eKFtcXGRhLWZdezAsNH06KXsyLDd9KFtcXGRhLWZdezAsNH0pPyhcXC9cXGQrKT8kLyk7XG5cbiAgICBpZiAoIWNpZHJNYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIElQdjYgQ0lEUjogXCIke2NpZHJJcH1cImApO1xuICAgIH1cblxuICAgIGlmICghY2lkck1hdGNoWzNdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENJRFIgbWFzayBpcyBtaXNzaW5nIGluIElQdjY6IFwiJHtjaWRySXB9XCIuIERpZCB5b3UgbWVhbiBcIiR7Y2lkcklwfS8xMjhcIj9gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE5ldHdvcmtQb2xpY3lJcEJsb2NrKHNjb3BlLCBpZCwgY2lkcklwLCBleGNlcHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFueSBJUHY2IGFkZHJlc3NcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYW55SXB2NihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nKTogTmV0d29ya1BvbGljeUlwQmxvY2sge1xuICAgIHJldHVybiBuZXcgTmV0d29ya1BvbGljeUlwQmxvY2soc2NvcGUsIGlkLCAnOjovMCcpO1xuICB9XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLFxuICAgIC8qKlxuICAgICAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgSVAgQmxvY2sgVmFsaWQgZXhhbXBsZXMgYXJlIFwiMTkyLjE2OC4xLjEvMjRcIiBvciBcIjIwMDE6ZGI5OjovNjRcIi5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgY2lkcjogc3RyaW5nLFxuICAgIC8qKlxuICAgICAqIEEgc2xpY2Ugb2YgQ0lEUnMgdGhhdCBzaG91bGQgbm90IGJlIGluY2x1ZGVkIHdpdGhpbiBhbiBJUCBCbG9jayBWYWxpZCBleGFtcGxlcyBhcmUgXCIxOTIuMTY4LjEuMS8yNFwiIG9yIFwiMjAwMTpkYjk6Oi82NFwiLlxuICAgICAqIEV4Y2VwdCB2YWx1ZXMgd2lsbCBiZSByZWplY3RlZCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZSBDSURSIHJhbmdlLlxuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBleGNlcHQ/OiBzdHJpbmdbXSkge1xuICAgIHN1cGVyKHNjb3BlLCBpZCk7XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBJTmV0d29ya1BvbGljeVBlZXIudG9OZXR3b3JrUG9saWN5UGVlckNvbmZpZygpXG4gICAqL1xuICBwdWJsaWMgdG9OZXR3b3JrUG9saWN5UGVlckNvbmZpZygpOiBOZXR3b3JrUG9saWN5UGVlckNvbmZpZyB7XG4gICAgcmV0dXJuIHsgaXBCbG9jazogdGhpcyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgSU5ldHdvcmtQb2xpY3lQZWVyLnRvUG9kU2VsZWN0b3IoKVxuICAgKi9cbiAgcHVibGljIHRvUG9kU2VsZWN0b3IoKTogcG9kLklQb2RTZWxlY3RvciB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHB1YmxpYyBfdG9LdWJlKCk6IGs4cy5JcEJsb2NrIHtcbiAgICByZXR1cm4geyBjaWRyOiB0aGlzLmNpZHIsIGV4Y2VwdDogdGhpcy5leGNlcHQgfTtcbiAgfVxuXG59XG5cbi8qKlxuICogTmV0d29yayBwcm90b2NvbHMuXG4gKi9cbmV4cG9ydCBlbnVtIE5ldHdvcmtQcm90b2NvbCB7XG4gIC8qKlxuICAgKiBUQ1AuXG4gICAqL1xuICBUQ1AgPSAnVENQJyxcbiAgLyoqXG4gICAqIFVEUC5cbiAgICovXG4gIFVEUCA9ICdVRFAnLFxuICAvKipcbiAgICogU0NUUC5cbiAgICovXG4gIFNDVFAgPSAnU0NUUCcsXG59XG5cbi8qKlxuICogRGVmYXVsdCBiZWhhdmlvcnMgb2YgbmV0d29yayB0cmFmZmljIGluIHBvbGljaWVzLlxuICovXG5leHBvcnQgZW51bSBOZXR3b3JrUG9saWN5VHJhZmZpY0RlZmF1bHQge1xuICAvKipcbiAgICogVGhlIHBvbGljeSBkZW5pZXMgYWxsIHRyYWZmaWMuXG4gICAqIFNpbmNlIHJ1bGVzIGFyZSBhZGRpdGl2ZSwgYWRkaXRpb25hbCBydWxlcyBvciBwb2xpY2llcyBjYW4gYWxsb3dcbiAgICogc3BlY2lmaWMgdHJhZmZpYy5cbiAgICovXG4gIERFTlkgPSAnREVOWScsXG4gIC8qKlxuICAgKiBUaGUgcG9saWN5IGFsbG93cyBhbGwgdHJhZmZpYyAoZWl0aGVyIGluZ3Jlc3Mgb3IgZWdyZXNzKS5cbiAgICogU2luY2UgcnVsZXMgYXJlIGFkZGl0aXZlLCBubyBhZGRpdGlvbmFsIHJ1bGUgb3IgcG9saWNpZXMgY2FuXG4gICAqIHN1YnNlcXVlbnRseSBkZW55IHRoZSB0cmFmZmljLlxuICAgKi9cbiAgQUxMT1cgPSAnQUxMT1cnLFxufVxuXG4vKipcbiAqIERlc2NyaWJlcyBob3cgdGhlIG5ldHdvcmsgcG9saWN5IHNob3VsZCBjb25maWd1cmUgZWdyZXNzIC8gaW5ncmVzcyB0cmFmZmljLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5ldHdvcmtQb2xpY3lUcmFmZmljIHtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIHRoZSBwb2xpY3kgd2hlblxuICAgKiBubyBydWxlcyBhcmUgZGVmaW5lZC5cbiAgICpcbiAgICogQGRlZmF1bHQgLSB1bnNldCwgdGhlIHBvbGljeSBkb2VzIG5vdCBjaGFuZ2UgdGhlIGJlaGF2aW9yLlxuICAgKi9cbiAgcmVhZG9ubHkgZGVmYXVsdD86IE5ldHdvcmtQb2xpY3lUcmFmZmljRGVmYXVsdDtcblxuICAvKipcbiAgICogTGlzdCBvZiBydWxlcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBzZWxlY3RlZCBwb2RzLlxuICAgKiBJZiBlbXB0eSwgdGhlIGJlaGF2aW9yIG9mIHRoZSBwb2xpY3kgaXMgZGljdGF0ZWQgYnkgdGhlIGBkZWZhdWx0YCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBubyBydWxlc1xuICAgKi9cbiAgcmVhZG9ubHkgcnVsZXM/OiBOZXR3b3JrUG9saWN5UnVsZVtdO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGBOZXR3b3JrUG9saWN5LmFkZEVncmVzc1J1bGVgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5ldHdvcmtQb2xpY3lBZGRFZ3Jlc3NSdWxlT3B0aW9ucyB7XG5cbiAgLyoqXG4gICAqIFBvcnRzIHRoZSBydWxlIHNob3VsZCBhbGxvdyBvdXRnb2luZyB0cmFmZmljIHRvLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIElmIHRoZSBwZWVyIGlzIGEgbWFuYWdlZCBwb2QsIHRha2UgaXRzIHBvcnRzLiBPdGhlcndpc2UsIGFsbCBwb3J0cyBhcmUgYWxsb3dlZC5cbiAgICovXG4gIHJlYWRvbmx5IHBvcnRzPzogTmV0d29ya1BvbGljeVBvcnRbXTtcblxufVxuXG5cbi8qKlxuICogUHJvcGVydGllcyBmb3IgYE5ldHdvcmtQb2xpY3lgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5ldHdvcmtQb2xpY3lQcm9wcyBleHRlbmRzIGJhc2UuUmVzb3VyY2VQcm9wcyB7XG5cbiAgLyoqXG4gICAqIFdoaWNoIHBvZHMgZG9lcyB0aGlzIHBvbGljeSBvYmplY3QgYXBwbGllcyB0by5cbiAgICpcbiAgICogVGhpcyBjYW4gZWl0aGVyIGJlIGEgc2luZ2xlIHBvZCAvIHdvcmtsb2FkLCBvciBhIGdyb3VwaW5nIG9mIHBvZHMgc2VsZWN0ZWRcbiAgICogdmlhIHRoZSBgUG9kcy5zZWxlY3RgIGZ1bmN0aW9uLiBSdWxlcyBpcyBhcHBsaWVkIHRvIGFueSBwb2RzIHNlbGVjdGVkIGJ5IHRoaXMgcHJvcGVydHkuXG4gICAqIE11bHRpcGxlIG5ldHdvcmsgcG9saWNpZXMgY2FuIHNlbGVjdCB0aGUgc2FtZSBzZXQgb2YgcG9kcy5cbiAgICogSW4gdGhpcyBjYXNlLCB0aGUgcnVsZXMgZm9yIGVhY2ggYXJlIGNvbWJpbmVkIGFkZGl0aXZlbHkuXG4gICAqXG4gICAqIE5vdGUgdGhhdFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIHdpbGwgc2VsZWN0IGFsbCBwb2RzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlIHBvbGljeS5cbiAgICovXG4gIHJlYWRvbmx5IHNlbGVjdG9yPzogcG9kLklQb2RTZWxlY3RvcjtcblxuICAvKipcbiAgICogRWdyZXNzIHRyYWZmaWMgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQGRlZmF1bHQgLSB0aGUgcG9saWN5IGRvZXNuJ3QgY2hhbmdlIGVncmVzcyBiZWhhdmlvciBvZiB0aGUgcG9kcyBpdCBzZWxlY3RzLlxuICAgKi9cbiAgcmVhZG9ubHkgZWdyZXNzPzogTmV0d29ya1BvbGljeVRyYWZmaWM7XG5cbiAgLyoqXG4gICAqIEluZ3Jlc3MgdHJhZmZpYyBjb25maWd1cmF0aW9uLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIHRoZSBwb2xpY3kgZG9lc24ndCBjaGFuZ2UgaW5ncmVzcyBiZWhhdmlvciBvZiB0aGUgcG9kcyBpdCBzZWxlY3RzLlxuICAgKi9cbiAgcmVhZG9ubHkgaW5ncmVzcz86IE5ldHdvcmtQb2xpY3lUcmFmZmljO1xufVxuXG4vKipcbiAqIENvbnRyb2wgdHJhZmZpYyBmbG93IGF0IHRoZSBJUCBhZGRyZXNzIG9yIHBvcnQgbGV2ZWwgKE9TSSBsYXllciAzIG9yIDQpLFxuICogbmV0d29yayBwb2xpY2llcyBhcmUgYW4gYXBwbGljYXRpb24tY2VudHJpYyBjb25zdHJ1Y3Qgd2hpY2ggYWxsb3cgeW91XG4gKiB0byBzcGVjaWZ5IGhvdyBhIHBvZCBpcyBhbGxvd2VkIHRvIGNvbW11bmljYXRlIHdpdGggdmFyaW91cyBuZXR3b3JrIHBlZXJzLlxuICpcbiAqIC0gT3V0Z29pbmcgdHJhZmZpYyBpcyBhbGxvd2VkIGlmIHRoZXJlIGFyZSBubyBuZXR3b3JrIHBvbGljaWVzIHNlbGVjdGluZ1xuICogICB0aGUgcG9kIChhbmQgY2x1c3RlciBwb2xpY3kgb3RoZXJ3aXNlIGFsbG93cyB0aGUgdHJhZmZpYyksXG4gKiAgIE9SIGlmIHRoZSB0cmFmZmljIG1hdGNoZXMgYXQgbGVhc3Qgb25lIGVncmVzcyBydWxlIGFjcm9zcyBhbGwgb2YgdGhlXG4gKiAgIG5ldHdvcmsgcG9saWNpZXMgdGhhdCBzZWxlY3QgdGhlIHBvZC5cbiAqXG4gKiAtIEluY29taW5nIHRyYWZmaWMgaXMgYWxsb3dlZCB0byBhIHBvZCBpZiB0aGVyZSBhcmUgbm8gbmV0d29yayBwb2xpY2llc1xuICogICBzZWxlY3RpbmcgdGhlIHBvZCAoYW5kIGNsdXN0ZXIgcG9saWN5IG90aGVyd2lzZSBhbGxvd3MgdGhlIHRyYWZmaWMpLFxuICogICBPUiBpZiB0aGUgdHJhZmZpYyBzb3VyY2UgaXMgdGhlIHBvZCdzIGxvY2FsIG5vZGUsXG4gKiAgIE9SIGlmIHRoZSB0cmFmZmljIG1hdGNoZXMgYXQgbGVhc3Qgb25lIGluZ3Jlc3MgcnVsZSBhY3Jvc3MgYWxsIG9mXG4gKiAgIHRoZSBuZXR3b3JrIHBvbGljaWVzIHRoYXQgc2VsZWN0IHRoZSBwb2QuXG4gKlxuICogTmV0d29yayBwb2xpY2llcyBkbyBub3QgY29uZmxpY3Q7IHRoZXkgYXJlIGFkZGl0aXZlLlxuICogSWYgYW55IHBvbGljeSBvciBwb2xpY2llcyBhcHBseSB0byBhIGdpdmVuIHBvZCBmb3IgYSBnaXZlblxuICogZGlyZWN0aW9uLCB0aGUgY29ubmVjdGlvbnMgYWxsb3dlZCBpbiB0aGF0IGRpcmVjdGlvbiBmcm9tXG4gKiB0aGF0IHBvZCBpcyB0aGUgdW5pb24gb2Ygd2hhdCB0aGUgYXBwbGljYWJsZSBwb2xpY2llcyBhbGxvdy5cbiAqIFRodXMsIG9yZGVyIG9mIGV2YWx1YXRpb24gZG9lcyBub3QgYWZmZWN0IHRoZSBwb2xpY3kgcmVzdWx0LlxuICpcbiAqIEZvciBhIGNvbm5lY3Rpb24gZnJvbSBhIHNvdXJjZSBwb2QgdG8gYSBkZXN0aW5hdGlvbiBwb2QgdG8gYmUgYWxsb3dlZCxcbiAqIGJvdGggdGhlIGVncmVzcyBwb2xpY3kgb24gdGhlIHNvdXJjZSBwb2QgYW5kIHRoZSBpbmdyZXNzIHBvbGljeSBvbiB0aGVcbiAqIGRlc3RpbmF0aW9uIHBvZCBuZWVkIHRvIGFsbG93IHRoZSBjb25uZWN0aW9uLlxuICogSWYgZWl0aGVyIHNpZGUgZG9lcyBub3QgYWxsb3cgdGhlIGNvbm5lY3Rpb24sIGl0IHdpbGwgbm90IGhhcHBlbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3NlcnZpY2VzLW5ldHdvcmtpbmcvbmV0d29yay1wb2xpY2llcy8jbmV0d29ya3BvbGljeS1yZXNvdXJjZVxuICovXG5leHBvcnQgY2xhc3MgTmV0d29ya1BvbGljeSBleHRlbmRzIGJhc2UuUmVzb3VyY2Uge1xuXG4gIC8qKlxuICAgKiBAc2VlIGJhc2UuUmVzb3VyY2UuYXBpT2JqZWN0XG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgYXBpT2JqZWN0OiBBcGlPYmplY3Q7XG5cbiAgcHVibGljIHJlYWRvbmx5IHJlc291cmNlVHlwZTogc3RyaW5nID0gJ25ldHdvcmtwb2xpY2llcyc7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBfcG9kU2VsZWN0b3JDb25maWc6IHBvZC5Qb2RTZWxlY3RvckNvbmZpZztcbiAgcHJpdmF0ZSByZWFkb25seSBfZWdyZXNzUnVsZXM6IGs4cy5OZXR3b3JrUG9saWN5RWdyZXNzUnVsZVtdID0gW107XG4gIHByaXZhdGUgcmVhZG9ubHkgX2luZ3Jlc3NSdWxlczogazhzLk5ldHdvcmtQb2xpY3lJbmdyZXNzUnVsZVtdID0gW107XG4gIHByaXZhdGUgcmVhZG9ubHkgX3BvbGljeVR5cGVzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKTtcblxuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IE5ldHdvcmtQb2xpY3lQcm9wcyA9IHt9KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkKTtcblxuICAgIGNvbnN0IHBvZFNlbGVjdG9yID0gcHJvcHMuc2VsZWN0b3IgPz8gcG9kLlBvZHMuYWxsKHRoaXMsICdBbGxQb2RzJyk7XG4gICAgdGhpcy5fcG9kU2VsZWN0b3JDb25maWcgPSBwb2RTZWxlY3Rvci50b1BvZFNlbGVjdG9yQ29uZmlnKCk7XG5cbiAgICBsZXQgbnM7XG5cbiAgICBpZiAoIXByb3BzLm1ldGFkYXRhPy5uYW1lc3BhY2UpIHtcblxuICAgICAgaWYgKHRoaXMuX3BvZFNlbGVjdG9yQ29uZmlnLm5hbWVzcGFjZXM/LmxhYmVsU2VsZWN0b3IgJiYgIXRoaXMuX3BvZFNlbGVjdG9yQ29uZmlnLm5hbWVzcGFjZXM/LmxhYmVsU2VsZWN0b3IuaXNFbXB0eSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGNyZWF0ZSBhIG5ldHdvcmsgcG9saWN5IGZvciBhIHNlbGVjdG9yICgke3BvZFNlbGVjdG9yLm5vZGUucGF0aH0pIHRoYXQgc2VsZWN0cyBwb2RzIGluIG5hbWVzcGFjZXMgYmFzZWQgb24gbGFiZWxzYCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9wb2RTZWxlY3RvckNvbmZpZy5uYW1lc3BhY2VzPy5uYW1lcyAmJiB0aGlzLl9wb2RTZWxlY3RvckNvbmZpZy5uYW1lc3BhY2VzLm5hbWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gY3JlYXRlIGEgbmV0d29yayBwb2xpY3kgZm9yIGEgc2VsZWN0b3IgKCR7cG9kU2VsZWN0b3Iubm9kZS5wYXRofSkgdGhhdCBzZWxlY3RzIHBvZHMgaW4gbXVsdGlwbGUgbmFtZXNwYWNlc2ApO1xuICAgICAgfVxuXG4gICAgICBucyA9IHRoaXMuX3BvZFNlbGVjdG9yQ29uZmlnLm5hbWVzcGFjZXM/Lm5hbWVzID8gdGhpcy5fcG9kU2VsZWN0b3JDb25maWcubmFtZXNwYWNlcz8ubmFtZXNbMF0gOiB1bmRlZmluZWQ7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbnMgPSBwcm9wcy5tZXRhZGF0YS5uYW1lc3BhY2U7XG4gICAgfVxuXG4gICAgdGhpcy5hcGlPYmplY3QgPSBuZXcgazhzLkt1YmVOZXR3b3JrUG9saWN5KHRoaXMsICdSZXNvdXJjZScsIHtcbiAgICAgIG1ldGFkYXRhOiB7IC4uLnByb3BzLm1ldGFkYXRhLCBuYW1lc3BhY2U6IG5zIH0sXG4gICAgICBzcGVjOiBMYXp5LmFueSh7IHByb2R1Y2U6ICgpID0+IHRoaXMuX3RvS3ViZSgpIH0pLFxuICAgIH0pO1xuXG4gICAgdGhpcy5jb25maWd1cmVEZWZhdWx0QmVoYXZpb3IoJ0VncmVzcycsIHByb3BzLmVncmVzcz8uZGVmYXVsdCk7XG4gICAgdGhpcy5jb25maWd1cmVEZWZhdWx0QmVoYXZpb3IoJ0luZ3Jlc3MnLCBwcm9wcy5pbmdyZXNzPy5kZWZhdWx0KTtcblxuICAgIGZvciAoY29uc3QgcnVsZSBvZiBwcm9wcy5lZ3Jlc3M/LnJ1bGVzID8/IFtdKSB7XG4gICAgICB0aGlzLmFkZEVncmVzc1J1bGUocnVsZS5wZWVyLCBydWxlLnBvcnRzKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgcHJvcHMuaW5ncmVzcz8ucnVsZXMgPz8gW10pIHtcbiAgICAgIHRoaXMuYWRkSW5ncmVzc1J1bGUocnVsZS5wZWVyLCBydWxlLnBvcnRzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWxsb3cgb3V0Z29pbmcgdHJhZmZpYyB0byB0aGUgcGVlci5cbiAgICpcbiAgICogSWYgcG9ydHMgYXJlIG5vdCBwYXNzZWQsIHRyYWZmaWMgd2lsbCBiZSBhbGxvd2VkIG9uIGFsbCBwb3J0cy5cbiAgICovXG4gIHB1YmxpYyBhZGRFZ3Jlc3NSdWxlKHBlZXI6IElOZXR3b3JrUG9saWN5UGVlciwgcG9ydHM/OiBOZXR3b3JrUG9saWN5UG9ydFtdKSB7XG4gICAgdGhpcy5fcG9saWN5VHlwZXMuYWRkKCdFZ3Jlc3MnKTtcbiAgICB0aGlzLl9lZ3Jlc3NSdWxlcy5wdXNoKHsgcG9ydHM6IChwb3J0cyA/PyBbXSkubWFwKHAgPT4gcC5fdG9LdWJlKCkpLCB0bzogdGhpcy5jcmVhdGVOZXR3b3JrUG9saWN5UGVlcnMocGVlcikgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3cgaW5jb21pbmcgdHJhZmZpYyBmcm9tIHRoZSBwZWVyLlxuICAgKlxuICAgKiBJZiBwb3J0cyBhcmUgbm90IHBhc3NlZCwgdHJhZmZpYyB3aWxsIGJlIGFsbG93ZWQgb24gYWxsIHBvcnRzLlxuICAgKi9cbiAgcHVibGljIGFkZEluZ3Jlc3NSdWxlKHBlZXI6IElOZXR3b3JrUG9saWN5UGVlciwgcG9ydHM/OiBOZXR3b3JrUG9saWN5UG9ydFtdKSB7XG4gICAgdGhpcy5fcG9saWN5VHlwZXMuYWRkKCdJbmdyZXNzJyk7XG4gICAgdGhpcy5faW5ncmVzc1J1bGVzLnB1c2goeyBwb3J0czogKHBvcnRzID8/IFtdKS5tYXAocCA9PiBwLl90b0t1YmUoKSksIGZyb206IHRoaXMuY3JlYXRlTmV0d29ya1BvbGljeVBlZXJzKHBlZXIpIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVOZXR3b3JrUG9saWN5UGVlcnMocGVlcjogSU5ldHdvcmtQb2xpY3lQZWVyKTogazhzLk5ldHdvcmtQb2xpY3lQZWVyW10ge1xuXG4gICAgY29uc3QgY29uZmlnID0gcGVlci50b05ldHdvcmtQb2xpY3lQZWVyQ29uZmlnKCk7XG5cbiAgICB2YWxpZGF0ZVBlZXJDb25maWcoY29uZmlnKTtcblxuICAgIGlmIChjb25maWcuaXBCbG9jaykge1xuICAgICAgLy8gaXAgYmxvY2sgaXMgYSBzaW5nbGUgcGVlci5cbiAgICAgIHJldHVybiBbeyBpcEJsb2NrOiBjb25maWcuaXBCbG9jay5fdG9LdWJlKCkgfV07XG4gICAgfVxuXG4gICAgaWYgKCFjb25maWcucG9kU2VsZWN0b3IhLm5hbWVzcGFjZXM/Lm5hbWVzKSB7XG4gICAgICAvLyB3aGVuIG5vIGV4cGxpY2l0IG5hbWVzcGFjZXMgYXJlIGRlZmluZWQgd2UgY2FuIGp1c3QgdXNlXG4gICAgICAvLyB0aGUgc2VsZWN0b3IgYXMgaXNcbiAgICAgIHJldHVybiBbe1xuICAgICAgICBuYW1lc3BhY2VTZWxlY3RvcjogY29uZmlnLnBvZFNlbGVjdG9yIS5uYW1lc3BhY2VzPy5sYWJlbFNlbGVjdG9yPy5fdG9LdWJlKCksXG4gICAgICAgIHBvZFNlbGVjdG9yOiBjb25maWcucG9kU2VsZWN0b3IhLmxhYmVsU2VsZWN0b3IuX3RvS3ViZSgpLFxuICAgICAgfV07XG4gICAgfVxuXG4gICAgLy8gd2hlbiBleHBsaWNpdCBuYW1lc3BhY2VzIGFyZSBkZWZpbmVkLCB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHNlcGFyYXRlXG4gICAgLy8gcGVlciBmb3IgZWFjaCwgc2luY2UgYSBsYWJlbCBzZWxlY3RvciBjYW5ub3QgaGF2ZSBtdWx0aXBsZSBuYW1lIGxhYmVscy4gKHRoZXkgd2lsbCBjb25mbGljdClcbiAgICBjb25zdCBuYW1lc3BhY2VTZWxlY3RvciA9IGNvbmZpZy5wb2RTZWxlY3Rvcj8ubmFtZXNwYWNlcz8ubGFiZWxTZWxlY3Rvcj8uX3RvS3ViZSgpID8/IHt9O1xuICAgIHJldHVybiBjb25maWcucG9kU2VsZWN0b3IhLm5hbWVzcGFjZXMubmFtZXMhLm1hcChuID0+ICh7XG4gICAgICBwb2RTZWxlY3RvcjogY29uZmlnLnBvZFNlbGVjdG9yIS5sYWJlbFNlbGVjdG9yLl90b0t1YmUoKSxcbiAgICAgIG5hbWVzcGFjZVNlbGVjdG9yOiB7XG4gICAgICAgIG1hdGNoRXhwcmVzc2lvbnM6IG5hbWVzcGFjZVNlbGVjdG9yLm1hdGNoRXhwcmVzc2lvbnMsXG4gICAgICAgIG1hdGNoTGFiZWxzOiB7XG4gICAgICAgICAgLi4ubmFtZXNwYWNlU2VsZWN0b3IubWF0Y2hMYWJlbHMsXG4gICAgICAgICAgW25hbWVzcGFjZS5OYW1lc3BhY2UuTkFNRV9MQUJFTF06IG4sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pKTtcbiAgfVxuXG4gIHByaXZhdGUgY29uZmlndXJlRGVmYXVsdEJlaGF2aW9yKGRpcmVjdGlvbjogJ0luZ3Jlc3MnIHwgJ0VncmVzcycsIF9kZWZhdWx0PzogTmV0d29ya1BvbGljeVRyYWZmaWNEZWZhdWx0KSB7XG5cbiAgICBpZiAoIV9kZWZhdWx0KSB7IHJldHVybjt9XG5cbiAgICBpZiAoX2RlZmF1bHQgPT09IE5ldHdvcmtQb2xpY3lUcmFmZmljRGVmYXVsdC5ERU5ZKSB7XG4gICAgICAvLyBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zZXJ2aWNlcy1uZXR3b3JraW5nL25ldHdvcmstcG9saWNpZXMvI2RlZmF1bHQtZGVueS1hbGwtZWdyZXNzLXRyYWZmaWNcbiAgICAgIHRoaXMuX3BvbGljeVR5cGVzLmFkZChkaXJlY3Rpb24pO1xuICAgIH1cblxuICAgIGlmIChfZGVmYXVsdCA9PT0gTmV0d29ya1BvbGljeVRyYWZmaWNEZWZhdWx0LkFMTE9XKSB7XG4gICAgICAvLyBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zZXJ2aWNlcy1uZXR3b3JraW5nL25ldHdvcmstcG9saWNpZXMvI2FsbG93LWFsbC1lZ3Jlc3MtdHJhZmZpY1xuICAgICAgdGhpcy5fcG9saWN5VHlwZXMuYWRkKGRpcmVjdGlvbik7XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAnRWdyZXNzJykge1xuICAgICAgICB0aGlzLl9lZ3Jlc3NSdWxlcy5wdXNoKHt9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2luZ3Jlc3NSdWxlcy5wdXNoKHt9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgX3RvS3ViZSgpOiBrOHMuTmV0d29ya1BvbGljeVNwZWMge1xuICAgIHJldHVybiB7XG4gICAgICBwb2RTZWxlY3RvcjogdGhpcy5fcG9kU2VsZWN0b3JDb25maWcubGFiZWxTZWxlY3Rvci5fdG9LdWJlKCksXG4gICAgICBlZ3Jlc3M6IHVuZGVmaW5lZElmRW1wdHkodGhpcy5fZWdyZXNzUnVsZXMpLFxuICAgICAgaW5ncmVzczogdW5kZWZpbmVkSWZFbXB0eSh0aGlzLl9pbmdyZXNzUnVsZXMpLFxuICAgICAgcG9saWN5VHlwZXM6IHVuZGVmaW5lZElmRW1wdHkoQXJyYXkuZnJvbSh0aGlzLl9wb2xpY3lUeXBlcykpLFxuICAgIH07XG4gIH1cblxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVQZWVyQ29uZmlnKHBlZXJDb25maWc6IE5ldHdvcmtQb2xpY3lQZWVyQ29uZmlnKSB7XG4gIGlmICghcGVlckNvbmZpZy5pcEJsb2NrICYmICFwZWVyQ29uZmlnLnBvZFNlbGVjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbmF2bGlkIHBlZXI6IGVpdGhlciBcXCdpcEJsb2NrXFwnIG9yIFxcJ3BvZFNlbGVjdG9yXFwnIG11c3QgYmUgZGVmaW5lZCcpO1xuICB9XG4gIGlmIChwZWVyQ29uZmlnLmlwQmxvY2sgJiYgcGVlckNvbmZpZy5wb2RTZWxlY3Rvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5hdmxpZCBwZWVyOiBvbmx5IG9uZSBvZiBcXCdpcEJsb2NrXFwnIGFuZCBcXCdwb2RTZWxlY3RvclxcJyBtdXN0IGJlIGRlZmluZWQnKTtcbiAgfVxufVxuIl19

/***/ }),

/***/ 442:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PodConnections = exports.PodConnectionsIsolation = exports.PodScheduling = exports.Topology = exports.Node = exports.NamedNode = exports.TaintedNode = exports.LabeledNode = exports.Pods = exports.NodeTaintQuery = exports.TaintEffect = exports.LabelExpression = exports.NodeLabelQuery = exports.DnsPolicy = exports.FsGroupChangePolicy = exports.RestartPolicy = exports.PodSecurityContext = exports.PodDns = exports.Pod = exports.LabelSelector = exports.LabelSelectorOptions = exports.AbstractPod = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const cdk8s_1 = __nccwpck_require__(1227);
const constructs_1 = __nccwpck_require__(1963);
const base = __nccwpck_require__(415);
const container = __nccwpck_require__(4255);
const k8s = __nccwpck_require__(4879);
const networkpolicy = __nccwpck_require__(3018);
const utils_1 = __nccwpck_require__(6594);
class AbstractPod extends base.Resource {
    constructor(scope, id, props = {}) {
        var _t;
        super(scope, id);
        this._containers = [];
        this._initContainers = [];
        this._hostAliases = [];
        this._volumes = new Map();
        this.restartPolicy = props.restartPolicy;
        this.serviceAccount = props.serviceAccount;
        this.securityContext = new PodSecurityContext(props.securityContext);
        this.dns = new PodDns(props.dns);
        this.dockerRegistryAuth = props.dockerRegistryAuth;
        this.automountServiceAccountToken = (_t = props.automountServiceAccountToken) !== null && _t !== void 0 ? _t : true;
        if (props.containers) {
            props.containers.forEach(c => this.addContainer(c));
        }
        if (props.volumes) {
            props.volumes.forEach(v => this.addVolume(v));
        }
        if (props.initContainers) {
            props.initContainers.forEach(c => this.addInitContainer(c));
        }
        if (props.hostAliases) {
            props.hostAliases.forEach(c => this.addHostAlias(c));
        }
    }
    get containers() {
        return [...this._containers];
    }
    get initContainers() {
        return [...this._initContainers];
    }
    get volumes() {
        return Array.from(this._volumes.values());
    }
    get hostAliases() {
        return [...this._hostAliases];
    }
    /**
     * @see IPodSelector.toPodSelectorConfig()
     */
    toPodSelectorConfig() {
        const podAddress = this.podMetadata.getLabel(Pod.ADDRESS_LABEL);
        if (!podAddress) {
            // shouldn't happen because we add this label automatically in both pods and workloads.
            throw new Error(`Unable to create a label selector since ${Pod.ADDRESS_LABEL} label is missing`);
        }
        return {
            labelSelector: LabelSelector.of({ labels: { [Pod.ADDRESS_LABEL]: podAddress } }),
            namespaces: this.metadata.namespace ? {
                names: [this.metadata.namespace],
            } : undefined,
        };
    }
    /**
     * @see INetworkPolicyPeer.toNetworkPolicyPeerConfig()
     */
    toNetworkPolicyPeerConfig() {
        return { podSelector: this.toPodSelectorConfig() };
    }
    /**
     * @see INetworkPolicyPeer.toPodSelector()
     */
    toPodSelector() {
        return this;
    }
    addContainer(cont) {
        const impl = new container.Container(cont);
        this._containers.push(impl);
        return impl;
    }
    addInitContainer(cont) {
        var _t;
        // https://kubernetes.io/docs/concepts/workloads/pods/init-containers/#differences-from-regular-containers
        if (cont.readiness) {
            throw new Error('Init containers must not have a readiness probe');
        }
        if (cont.liveness) {
            throw new Error('Init containers must not have a liveness probe');
        }
        if (cont.startup) {
            throw new Error('Init containers must not have a startup probe');
        }
        const impl = new container.Container({
            ...cont,
            name: (_t = cont.name) !== null && _t !== void 0 ? _t : `init-${this._initContainers.length}`,
        });
        this._initContainers.push(impl);
        return impl;
    }
    addHostAlias(hostAlias) {
        this._hostAliases.push(hostAlias);
    }
    addVolume(vol) {
        const existingVolume = this._volumes.get(vol.name);
        if (existingVolume) {
            throw new Error(`Volume with name ${vol.name} already exists`);
        }
        this._volumes.set(vol.name, vol);
    }
    /**
     * @see ISubect.toSubjectConfiguration()
     */
    toSubjectConfiguration() {
        var _t, _u;
        if (!this.serviceAccount && !this.automountServiceAccountToken) {
            throw new Error(`${this.name} cannot be converted to a role binding subject:`
                + ' You must either assign a service account to it, or use \'automountServiceAccountToken: true\'');
        }
        // 'default' is assumed to be the name of the default service account
        // in the cluster.
        const serviceAccountName = (_u = (_t = this.serviceAccount) === null || _t === void 0 ? void 0 : _t.name) !== null && _u !== void 0 ? _u : 'default';
        return {
            kind: 'ServiceAccount',
            name: serviceAccountName,
            apiGroup: '',
        };
    }
    /**
     * @internal
     */
    _toPodSpec() {
        var _t;
        if (this.containers.length === 0) {
            throw new Error('PodSpec must have at least 1 container');
        }
        const volumes = new Map();
        const containers = [];
        const initContainers = [];
        for (const cont of this.containers) {
            // automatically add volume from the container mount
            // to this pod so thats its available to the container.
            for (const mount of cont.mounts) {
                addVolume(mount.volume);
            }
            containers.push(cont._toKube());
        }
        for (const cont of this.initContainers) {
            // automatically add volume from the container mount
            // to this pod so thats its available to the container.
            for (const mount of cont.mounts) {
                addVolume(mount.volume);
            }
            initContainers.push(cont._toKube());
        }
        for (const vol of this.volumes) {
            addVolume(vol);
        }
        function addVolume(vol) {
            const existingVolume = volumes.get(vol.name);
            // its ok to call this function twice on the same volume, but its not ok to
            // call it twice on a different volume with the same name.
            if (existingVolume && existingVolume !== vol) {
                throw new Error(`Invalid mount configuration. At least two different volumes have the same name: ${vol.name}`);
            }
            volumes.set(vol.name, vol);
        }
        const dns = this.dns._toKube();
        return {
            restartPolicy: this.restartPolicy,
            serviceAccountName: (_t = this.serviceAccount) === null || _t === void 0 ? void 0 : _t.name,
            containers: containers,
            securityContext: utils_1.undefinedIfEmpty(this.securityContext._toKube()),
            initContainers: utils_1.undefinedIfEmpty(initContainers),
            hostAliases: utils_1.undefinedIfEmpty(this.hostAliases),
            volumes: utils_1.undefinedIfEmpty(Array.from(volumes.values()).map(v => v._toKube())),
            dnsPolicy: dns.policy,
            dnsConfig: utils_1.undefinedIfEmpty(dns.config),
            hostname: dns.hostname,
            subdomain: dns.subdomain,
            setHostnameAsFqdn: dns.hostnameAsFQDN,
            imagePullSecrets: this.dockerRegistryAuth ? [{ name: this.dockerRegistryAuth.name }] : undefined,
            automountServiceAccountToken: this.automountServiceAccountToken,
        };
    }
}
exports.AbstractPod = AbstractPod;
_a = JSII_RTTI_SYMBOL_1;
AbstractPod[_a] = { fqn: "cdk8s-plus-22.AbstractPod", version: "2.0.0-rc.2" };
/**
 * Options for `LabelSelector.of`.
 */
class LabelSelectorOptions {
}
exports.LabelSelectorOptions = LabelSelectorOptions;
_b = JSII_RTTI_SYMBOL_1;
LabelSelectorOptions[_b] = { fqn: "cdk8s-plus-22.LabelSelectorOptions", version: "2.0.0-rc.2" };
/**
 * Match a resource by labels.
 */
class LabelSelector {
    constructor(expressions, labels) {
        this.expressions = expressions;
        this.labels = labels;
    }
    static of(options = {}) {
        var _t, _u;
        return new LabelSelector((_t = options.expressions) !== null && _t !== void 0 ? _t : [], (_u = options.labels) !== null && _u !== void 0 ? _u : {});
    }
    isEmpty() {
        return this.expressions.length === 0 && Object.keys(this.labels).length === 0;
    }
    /**
     * @internal
     */
    _toKube() {
        if (this.isEmpty()) {
            return {};
        }
        return {
            matchExpressions: utils_1.undefinedIfEmpty(this.expressions.map(q => ({ key: q.key, operator: q.operator, values: q.values }))),
            matchLabels: utils_1.undefinedIfEmpty(this.labels),
        };
    }
}
exports.LabelSelector = LabelSelector;
_c = JSII_RTTI_SYMBOL_1;
LabelSelector[_c] = { fqn: "cdk8s-plus-22.LabelSelector", version: "2.0.0-rc.2" };
/**
 * Pod is a collection of containers that can run on a host. This resource is
 * created by clients and scheduled onto hosts.
 */
class Pod extends AbstractPod {
    constructor(scope, id, props = {}) {
        super(scope, id, props);
        this.resourceType = 'pods';
        this.apiObject = new k8s.KubePod(this, 'Resource', {
            metadata: props.metadata,
            spec: cdk8s_1.Lazy.any({ produce: () => this._toKube() }),
        });
        this.metadata.addLabel(Pod.ADDRESS_LABEL, cdk8s_1.Names.toLabelValue(this));
        this.scheduling = new PodScheduling(this);
        this.connections = new PodConnections(this);
    }
    get podMetadata() {
        return this.metadata;
    }
    /**
     * @internal
     */
    _toKube() {
        const scheduling = this.scheduling._toKube();
        return {
            ...this._toPodSpec(),
            affinity: scheduling.affinity,
            nodeName: scheduling.nodeName,
            tolerations: scheduling.tolerations,
        };
    }
}
exports.Pod = Pod;
_d = JSII_RTTI_SYMBOL_1;
Pod[_d] = { fqn: "cdk8s-plus-22.Pod", version: "2.0.0-rc.2" };
/**
 * This label is autoamtically added by cdk8s to any pod. It provides
 * a unique and stable identifier for the pod.
 */
Pod.ADDRESS_LABEL = 'cdk8s.io/metadata.addr';
/**
 * Holds dns settings of the pod.
 */
class PodDns {
    constructor(props = {}) {
        var _t, _u, _v, _w, _x;
        this.hostname = props.hostname;
        this.subdomain = props.subdomain;
        this.policy = (_t = props.policy) !== null && _t !== void 0 ? _t : DnsPolicy.CLUSTER_FIRST;
        this.hostnameAsFQDN = (_u = props.hostnameAsFQDN) !== null && _u !== void 0 ? _u : false;
        this._nameservers = (_v = props.nameservers) !== null && _v !== void 0 ? _v : [];
        this._searches = (_w = props.searches) !== null && _w !== void 0 ? _w : [];
        this._options = (_x = props.options) !== null && _x !== void 0 ? _x : [];
    }
    /**
     * Nameservers defined for this pod.
     */
    get nameservers() {
        return [...this._nameservers];
    }
    /**
     * Search domains defined for this pod.
     */
    get searches() {
        return [...this._searches];
    }
    /**
     * Custom dns options defined for this pod.
     */
    get options() {
        return [...this._options];
    }
    /**
     * Add a nameserver.
     */
    addNameserver(...nameservers) {
        this._nameservers.push(...nameservers);
    }
    /**
     * Add a search domain.
     */
    addSearch(...searches) {
        this._searches.push(...searches);
    }
    /**
     * Add a custom option.
     */
    addOption(...options) {
        this._options.push(...options);
    }
    /**
     * @internal
     */
    _toKube() {
        if (this.policy === DnsPolicy.NONE && this.nameservers.length === 0) {
            throw new Error('When dns policy is set to NONE, at least one nameserver is required');
        }
        if (this.nameservers.length > 3) {
            throw new Error('There can be at most 3 nameservers specified');
        }
        if (this.searches.length > 6) {
            throw new Error('There can be at most 6 search domains specified');
        }
        return {
            hostname: this.hostname,
            subdomain: this.subdomain,
            hostnameAsFQDN: this.hostnameAsFQDN,
            policy: this.policy,
            config: {
                nameservers: utils_1.undefinedIfEmpty(this.nameservers),
                searches: utils_1.undefinedIfEmpty(this.searches),
                options: utils_1.undefinedIfEmpty(this.options),
            },
        };
    }
}
exports.PodDns = PodDns;
_e = JSII_RTTI_SYMBOL_1;
PodDns[_e] = { fqn: "cdk8s-plus-22.PodDns", version: "2.0.0-rc.2" };
/**
 * Holds pod-level security attributes and common container settings.
 */
class PodSecurityContext {
    constructor(props = {}) {
        var _t, _u, _v;
        this._sysctls = [];
        this.ensureNonRoot = (_t = props.ensureNonRoot) !== null && _t !== void 0 ? _t : false;
        this.fsGroupChangePolicy = (_u = props.fsGroupChangePolicy) !== null && _u !== void 0 ? _u : FsGroupChangePolicy.ALWAYS;
        this.user = props.user;
        this.group = props.group;
        this.fsGroup = props.fsGroup;
        for (const sysctl of (_v = props.sysctls) !== null && _v !== void 0 ? _v : []) {
            this._sysctls.push(sysctl);
        }
    }
    get sysctls() {
        return [...this._sysctls];
    }
    /**
     * @internal
     */
    _toKube() {
        return {
            runAsGroup: this.group,
            runAsUser: this.user,
            fsGroup: this.fsGroup,
            runAsNonRoot: this.ensureNonRoot,
            fsGroupChangePolicy: this.fsGroupChangePolicy,
            sysctls: utils_1.undefinedIfEmpty(this._sysctls),
        };
    }
}
exports.PodSecurityContext = PodSecurityContext;
_f = JSII_RTTI_SYMBOL_1;
PodSecurityContext[_f] = { fqn: "cdk8s-plus-22.PodSecurityContext", version: "2.0.0-rc.2" };
/**
 * Restart policy for all containers within the pod.
 */
var RestartPolicy;
(function (RestartPolicy) {
    /**
     * Always restart the pod after it exits.
     */
    RestartPolicy["ALWAYS"] = "Always";
    /**
     * Only restart if the pod exits with a non-zero exit code.
     */
    RestartPolicy["ON_FAILURE"] = "OnFailure";
    /**
     * Never restart the pod.
     */
    RestartPolicy["NEVER"] = "Never";
})(RestartPolicy = exports.RestartPolicy || (exports.RestartPolicy = {}));
var FsGroupChangePolicy;
(function (FsGroupChangePolicy) {
    /**
     * Only change permissions and ownership if permission and ownership of root directory does
     * not match with expected permissions of the volume.
     * This could help shorten the time it takes to change ownership and permission of a volume
     */
    FsGroupChangePolicy["ON_ROOT_MISMATCH"] = "OnRootMismatch";
    /**
     * Always change permission and ownership of the volume when volume is mounted.
     */
    FsGroupChangePolicy["ALWAYS"] = "Always";
})(FsGroupChangePolicy = exports.FsGroupChangePolicy || (exports.FsGroupChangePolicy = {}));
/**
 * Pod DNS policies.
 */
var DnsPolicy;
(function (DnsPolicy) {
    /**
     * Any DNS query that does not match the configured cluster domain suffix,
     * such as "www.kubernetes.io", is forwarded to the
     * upstream nameserver inherited from the node.
     * Cluster administrators may have extra stub-domain and upstream DNS servers configured.
     */
    DnsPolicy["CLUSTER_FIRST"] = "ClusterFirst";
    /**
     * For Pods running with hostNetwork, you should
     * explicitly set its DNS policy "ClusterFirstWithHostNet".
     */
    DnsPolicy["CLUSTER_FIRST_WITH_HOST_NET"] = "ClusterFirstWithHostNet";
    /**
     * The Pod inherits the name resolution configuration
     * from the node that the pods run on.
     */
    DnsPolicy["DEFAULT"] = "Default";
    /**
     * It allows a Pod to ignore DNS settings from the Kubernetes environment.
     * All DNS settings are supposed to be provided using the dnsConfig
     * field in the Pod Spec.
     */
    DnsPolicy["NONE"] = "None";
})(DnsPolicy = exports.DnsPolicy || (exports.DnsPolicy = {}));
/**
 * Represents a query that can be performed against nodes with labels.
 */
class NodeLabelQuery {
    constructor(key, operator, values) {
        this.key = key;
        this.operator = operator;
        this.values = values;
    }
    /**
     * Requires value of label `key` to equal `value`.
     */
    static is(key, value) {
        return NodeLabelQuery.in(key, [value]);
    }
    /**
     * Requires value of label `key` to be one of `values`.
     */
    static in(key, values) {
        return new NodeLabelQuery(key, 'In', values);
    }
    /**
     * Requires value of label `key` to be none of `values`.
     */
    static notIn(key, values) {
        return new NodeLabelQuery(key, 'NotIn', values);
    }
    /**
     * Requires label `key` to exist.
     */
    static exists(key) {
        return new NodeLabelQuery(key, 'Exists', undefined);
    }
    /**
     * Requires label `key` to not exist.
     */
    static doesNotExist(key) {
        return new NodeLabelQuery(key, 'DoesNotExist', undefined);
    }
    /**
     * Requires value of label `key` to greater than all elements in `values`.
     */
    static gt(key, values) {
        return new NodeLabelQuery(key, 'Gt', values);
    }
    /**
     * Requires value of label `key` to less than all elements in `values`.
     */
    static lt(key, values) {
        return new NodeLabelQuery(key, 'Lt', values);
    }
}
exports.NodeLabelQuery = NodeLabelQuery;
_g = JSII_RTTI_SYMBOL_1;
NodeLabelQuery[_g] = { fqn: "cdk8s-plus-22.NodeLabelQuery", version: "2.0.0-rc.2" };
/**
 * Represents a query that can be performed against resources with labels.
 */
class LabelExpression {
    constructor(key, operator, values) {
        this.key = key;
        this.operator = operator;
        this.values = values;
    }
    /**
     * Requires value of label `key` to be one of `values`.
     */
    static in(key, values) {
        return new LabelExpression(key, 'In', values);
    }
    /**
     * Requires value of label `key` to be none of `values`.
     */
    static notIn(key, values) {
        return new LabelExpression(key, 'NotIn', values);
    }
    /**
     * Requires label `key` to exist.
     */
    static exists(key) {
        return new LabelExpression(key, 'Exists', undefined);
    }
    /**
     * Requires label `key` to not exist.
     */
    static doesNotExist(key) {
        return new LabelExpression(key, 'DoesNotExist', undefined);
    }
}
exports.LabelExpression = LabelExpression;
_h = JSII_RTTI_SYMBOL_1;
LabelExpression[_h] = { fqn: "cdk8s-plus-22.LabelExpression", version: "2.0.0-rc.2" };
/**
 * Taint effects.
 */
var TaintEffect;
(function (TaintEffect) {
    /**
     * This means that no pod will be able to schedule
     * onto the node unless it has a matching toleration.
     */
    TaintEffect["NO_SCHEDULE"] = "NoSchedule";
    /**
     * This is a "preference" or "soft" version of `NO_SCHEDULE` -- the system
     * will try to avoid placing a pod that does not tolerate the taint on the node,
     * but it is not required
     */
    TaintEffect["PREFER_NO_SCHEDULE"] = "PreferNoSchedule";
    /**
     * This affects pods that are already running on the node as follows:
     *
     * - Pods that do not tolerate the taint are evicted immediately.
     * - Pods that tolerate the taint without specifying `duration` remain bound forever.
     * - Pods that tolerate the taint with a specified `duration` remain bound for
     *   the specified amount of time.
     */
    TaintEffect["NO_EXECUTE"] = "NoExecute";
})(TaintEffect = exports.TaintEffect || (exports.TaintEffect = {}));
/**
 * Taint queries that can be perfomed against nodes.
 */
class NodeTaintQuery {
    constructor(operator, key, value, effect, evictAfter) {
        this.operator = operator;
        this.key = key;
        this.value = value;
        this.effect = effect;
        this.evictAfter = evictAfter;
        if (evictAfter && effect !== TaintEffect.NO_EXECUTE) {
            throw new Error('Only \'NO_EXECUTE\' effects can specify \'evictAfter\'');
        }
    }
    /**
     * Matches a taint with a specific key and value.
     */
    static is(key, value, options = {}) {
        return new NodeTaintQuery('Equal', key, value, options.effect, options.evictAfter);
    }
    /**
     * Matches a tain with any value of a specific key.
     */
    static exists(key, options = {}) {
        return new NodeTaintQuery('Exists', key, undefined, options.effect, options.evictAfter);
    }
    /**
     * Matches any taint.
     */
    static any() {
        return new NodeTaintQuery('Exists');
    }
}
exports.NodeTaintQuery = NodeTaintQuery;
_j = JSII_RTTI_SYMBOL_1;
NodeTaintQuery[_j] = { fqn: "cdk8s-plus-22.NodeTaintQuery", version: "2.0.0-rc.2" };
/**
 * Represents a group of pods.
 */
class Pods extends constructs_1.Construct {
    constructor(scope, id, expressions, labels, namespaces) {
        super(scope, id);
        this.expressions = expressions;
        this.labels = labels;
        this.namespaces = namespaces;
    }
    /**
     * Select pods in the cluster with various selectors.
     */
    static select(scope, id, options) {
        return new Pods(scope, id, options.expressions, options.labels, options.namespaces);
    }
    /**
     * Select all pods.
     */
    static all(scope, id, options = {}) {
        return Pods.select(scope, id, { namespaces: options.namespaces });
    }
    /**
     * @see IPodSelector.toPodSelectorConfig()
     */
    toPodSelectorConfig() {
        var _t;
        return {
            labelSelector: LabelSelector.of({ expressions: this.expressions, labels: this.labels }),
            namespaces: (_t = this.namespaces) === null || _t === void 0 ? void 0 : _t.toNamespaceSelectorConfig(),
        };
    }
    /**
     * @see INetworkPolicyPeer.toNetworkPolicyPeerConfig()
     */
    toNetworkPolicyPeerConfig() {
        return { podSelector: this.toPodSelectorConfig() };
    }
    /**
     * @see INetworkPolicyPeer.toPodSelector()
     */
    toPodSelector() {
        return this;
    }
}
exports.Pods = Pods;
_k = JSII_RTTI_SYMBOL_1;
Pods[_k] = { fqn: "cdk8s-plus-22.Pods", version: "2.0.0-rc.2" };
/**
 * A node that is matched by label selectors.
 */
class LabeledNode {
    constructor(labelSelector) {
        this.labelSelector = labelSelector;
    }
    ;
}
exports.LabeledNode = LabeledNode;
_l = JSII_RTTI_SYMBOL_1;
LabeledNode[_l] = { fqn: "cdk8s-plus-22.LabeledNode", version: "2.0.0-rc.2" };
/**
 * A node that is matched by taint selectors.
 */
class TaintedNode {
    constructor(taintSelector) {
        this.taintSelector = taintSelector;
    }
    ;
}
exports.TaintedNode = TaintedNode;
_m = JSII_RTTI_SYMBOL_1;
TaintedNode[_m] = { fqn: "cdk8s-plus-22.TaintedNode", version: "2.0.0-rc.2" };
/**
 * A node that is matched by its name.
 */
class NamedNode {
    constructor(name) {
        this.name = name;
    }
    ;
}
exports.NamedNode = NamedNode;
_o = JSII_RTTI_SYMBOL_1;
NamedNode[_o] = { fqn: "cdk8s-plus-22.NamedNode", version: "2.0.0-rc.2" };
/**
 * Represents a node in the cluster.
 */
class Node {
    /**
     * Match a node by its labels.
     */
    static labeled(...labelSelector) {
        return new LabeledNode(labelSelector);
    }
    /**
     * Match a node by its name.
     */
    static named(nodeName) {
        return new NamedNode(nodeName);
    }
    /**
     * Match a node by its taints.
     */
    static tainted(...taintSelector) {
        return new TaintedNode(taintSelector);
    }
}
exports.Node = Node;
_p = JSII_RTTI_SYMBOL_1;
Node[_p] = { fqn: "cdk8s-plus-22.Node", version: "2.0.0-rc.2" };
/**
 * Available topology domains.
 */
class Topology {
    constructor(key) {
        this.key = key;
    }
    /**
     * Custom key for the node label that the system uses to denote the topology domain.
     */
    static custom(key) {
        return new Topology(key);
    }
    ;
}
exports.Topology = Topology;
_q = JSII_RTTI_SYMBOL_1;
Topology[_q] = { fqn: "cdk8s-plus-22.Topology", version: "2.0.0-rc.2" };
/**
 * A hostname represents a single node in the cluster.
 *
 * @see https://kubernetes.io/docs/reference/labels-annotations-taints/#kubernetesiohostname
 */
Topology.HOSTNAME = new Topology('kubernetes.io/hostname');
/**
 * A zone represents a logical failure domain. It is common for Kubernetes clusters to
 * span multiple zones for increased availability. While the exact definition of a zone is
 * left to infrastructure implementations, common properties of a zone include very low
 * network latency within a zone, no-cost network traffic within a zone, and failure
 * independence from other zones. For example, nodes within a zone might share a network
 * switch, but nodes in different zones should not.
 *
 * @see https://kubernetes.io/docs/reference/labels-annotations-taints/#topologykubernetesiozone
 */
Topology.ZONE = new Topology('topology.kubernetes.io/zone');
/**
 * A region represents a larger domain, made up of one or more zones. It is uncommon
 * for Kubernetes clusters to span multiple regions. While the exact definition of a
 * zone or region is left to infrastructure implementations, common properties of a region
 * include higher network latency between them than within them, non-zero cost for network
 * traffic between them, and failure independence from other zones or regions.
 *
 * For example, nodes within a region might share power infrastructure (e.g. a UPS or generator), but
 * nodes in different regions typically would not.
 *
 * @see https://kubernetes.io/docs/reference/labels-annotations-taints/#topologykubernetesioregion
 */
Topology.REGION = new Topology('topology.kubernetes.io/region');
/**
 * Controls the pod scheduling strategy.
 */
class PodScheduling {
    constructor(instance) {
        this.instance = instance;
        this._nodeAffinityPreferred = [];
        this._nodeAffinityRequired = [];
        this._podAffinityPreferred = [];
        this._podAffinityRequired = [];
        this._podAntiAffinityPreferred = [];
        this._podAntiAffinityRequired = [];
        this._tolerations = [];
    }
    /**
     * Assign this pod a specific node by name.
     *
     * The scheduler ignores the Pod, and the kubelet on the named node
     * tries to place the Pod on that node. Overrules any affinity rules of the pod.
     *
     * Some limitations of static assignment are:
     *
     * - If the named node does not exist, the Pod will not run, and in some
     *   cases may be automatically deleted.
     * - If the named node does not have the resources to accommodate the Pod,
     *   the Pod will fail and its reason will indicate why, for example OutOfmemory or OutOfcpu.
     * - Node names in cloud environments are not always predictable or stable.
     *
     * Will throw is the pod is already assigned to named node.
     *
     * Under the hood, this method utilizes the `nodeName` property.
     */
    assign(node) {
        if (this._nodeName) {
            // disallow overriding an static node assignment
            throw new Error(`Cannot assign ${this.instance.podMetadata.name} to node ${node.name}. It is already assigned to node ${this._nodeName}`);
        }
        else {
            this._nodeName = node.name;
        }
    }
    /**
     * Allow this pod to tolerate taints matching these tolerations.
     *
     * You can put multiple taints on the same node and multiple tolerations on the same pod.
     * The way Kubernetes processes multiple taints and tolerations is like a filter: start with
     * all of a node's taints, then ignore the ones for which the pod has a matching toleration;
     * the remaining un-ignored taints have the indicated effects on the pod. In particular:
     *
     * - if there is at least one un-ignored taint with effect NoSchedule then Kubernetes will
     *   not schedule the pod onto that node
     * - if there is no un-ignored taint with effect NoSchedule but there is at least one un-ignored
     *   taint with effect PreferNoSchedule then Kubernetes will try to not schedule the pod onto the node
     * - if there is at least one un-ignored taint with effect NoExecute then the pod will be evicted from
     *   the node (if it is already running on the node), and will not be scheduled onto the node (if it is
     *   not yet running on the node).
     *
     * Under the hood, this method utilizes the `tolerations` property.
     *
     * @see https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
     */
    tolerate(node) {
        var _t;
        for (const query of node.taintSelector) {
            this._tolerations.push({
                key: query.key,
                value: query.value,
                effect: query.effect,
                operator: query.operator,
                tolerationSeconds: (_t = query.evictAfter) === null || _t === void 0 ? void 0 : _t.toSeconds(),
            });
        }
    }
    /**
     * Attract this pod to a node matched by selectors.
     * You can select a node by using `Node.labeled()`.
     *
     * Attracting to multiple nodes (i.e invoking this method multiple times) acts as
     * an OR condition, meaning the pod will be assigned to either one of the nodes.
     *
     * Under the hood, this method utilizes the `nodeAffinity` property.
     *
     * @see https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity
     */
    attract(node, options = {}) {
        const term = this.createNodeAffinityTerm(node);
        if (options.weight) {
            this.validateWeight(options.weight);
            this._nodeAffinityPreferred.push({ weight: options.weight, preference: term });
        }
        else {
            this._nodeAffinityRequired.push(term);
        }
    }
    /**
     * Co-locate this pod with a scheduling selection.
     *
     * A selection can be one of:
     *
     * - An instance of a `Pod`.
     * - An instance of a `Workload` (e.g `Deployment`, `StatefulSet`).
     * - An un-managed pod that can be selected via `Pods.select()`.
     *
     * Co-locating with multiple selections ((i.e invoking this method multiple times)) acts as
     * an AND condition. meaning the pod will be assigned to a node that satisfies all
     * selections (i.e runs at least one pod that satisifies each selection).
     *
     * Under the hood, this method utilizes the `podAffinity` property.
     *
     * @see https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
     */
    colocate(selector, options = {}) {
        var _t;
        const topology = (_t = options.topology) !== null && _t !== void 0 ? _t : Topology.HOSTNAME;
        const term = this.createPodAffinityTerm(topology, selector);
        if (options.weight) {
            this.validateWeight(options.weight);
            this._podAffinityPreferred.push({ weight: options.weight, podAffinityTerm: term });
        }
        else {
            this._podAffinityRequired.push(term);
        }
    }
    /**
     * Seperate this pod from a scheduling selection.
     *
     * A selection can be one of:
     *
     * - An instance of a `Pod`.
     * - An instance of a `Workload` (e.g `Deployment`, `StatefulSet`).
     * - An un-managed pod that can be selected via `Pods.select()`.
     *
     * Seperating from multiple selections acts as an AND condition. meaning the pod
     * will not be assigned to a node that satisfies all selections (i.e runs at least one pod that satisifies each selection).
     *
     * Under the hood, this method utilizes the `podAntiAffinity` property.
     *
     * @see https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
     */
    separate(selector, options = {}) {
        var _t;
        const topology = (_t = options.topology) !== null && _t !== void 0 ? _t : Topology.HOSTNAME;
        const term = this.createPodAffinityTerm(topology, selector);
        if (options.weight) {
            this.validateWeight(options.weight);
            this._podAntiAffinityPreferred.push({ weight: options.weight, podAffinityTerm: term });
        }
        else {
            this._podAntiAffinityRequired.push(term);
        }
    }
    createPodAffinityTerm(topology, selector) {
        var _t, _u, _v;
        const config = selector.toPodSelectorConfig();
        return {
            topologyKey: topology.key,
            labelSelector: config.labelSelector._toKube(),
            namespaceSelector: (_u = (_t = config.namespaces) === null || _t === void 0 ? void 0 : _t.labelSelector) === null || _u === void 0 ? void 0 : _u._toKube(),
            namespaces: (_v = config.namespaces) === null || _v === void 0 ? void 0 : _v.names,
        };
    }
    createNodeAffinityTerm(node) {
        return { matchExpressions: node.labelSelector.map(s => ({ key: s.key, operator: s.operator, values: s.values })) };
    }
    validateWeight(weight) {
        if (weight < 1 || weight > 100) {
            // https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity-weight
            throw new Error(`Invalid affinity weight: ${weight}. Must be in range 1-100`);
        }
    }
    /**
     * @internal
     */
    _toKube() {
        const atLeastOne = (...arrays) => {
            return arrays.flat().length > 0;
        };
        const hasNodeAffinity = atLeastOne(this._nodeAffinityPreferred, this._nodeAffinityRequired);
        const hasPodAffinity = atLeastOne(this._podAffinityPreferred, this._podAffinityRequired);
        const hasPodAntiAffinty = atLeastOne(this._podAntiAffinityPreferred, this._podAntiAffinityRequired);
        const hasAffinity = hasNodeAffinity || hasPodAffinity || hasPodAntiAffinty;
        return {
            affinity: hasAffinity ? {
                nodeAffinity: hasNodeAffinity ? {
                    preferredDuringSchedulingIgnoredDuringExecution: utils_1.undefinedIfEmpty(this._nodeAffinityPreferred),
                    requiredDuringSchedulingIgnoredDuringExecution: this._nodeAffinityRequired.length > 0 ? {
                        nodeSelectorTerms: this._nodeAffinityRequired,
                    } : undefined,
                } : undefined,
                podAffinity: hasPodAffinity ? {
                    preferredDuringSchedulingIgnoredDuringExecution: utils_1.undefinedIfEmpty(this._podAffinityPreferred),
                    requiredDuringSchedulingIgnoredDuringExecution: utils_1.undefinedIfEmpty(this._podAffinityRequired),
                } : undefined,
                podAntiAffinity: hasPodAntiAffinty ? {
                    preferredDuringSchedulingIgnoredDuringExecution: utils_1.undefinedIfEmpty(this._podAntiAffinityPreferred),
                    requiredDuringSchedulingIgnoredDuringExecution: utils_1.undefinedIfEmpty(this._podAntiAffinityRequired),
                } : undefined,
            } : undefined,
            nodeName: this._nodeName,
            tolerations: utils_1.undefinedIfEmpty(this._tolerations),
        };
    }
}
exports.PodScheduling = PodScheduling;
_r = JSII_RTTI_SYMBOL_1;
PodScheduling[_r] = { fqn: "cdk8s-plus-22.PodScheduling", version: "2.0.0-rc.2" };
/**
 * Isolation determines which policies are created
 * when allowing connections from a a pod / workload to peers.
 */
var PodConnectionsIsolation;
(function (PodConnectionsIsolation) {
    /**
     * Only creates network policies that select the pod.
     */
    PodConnectionsIsolation["POD"] = "POD";
    /**
     * Only creates network policies that select the peer.
     */
    PodConnectionsIsolation["PEER"] = "PEER";
})(PodConnectionsIsolation = exports.PodConnectionsIsolation || (exports.PodConnectionsIsolation = {}));
/**
 * Controls network isolation rules for inter-pod communication.
 */
class PodConnections {
    constructor(instance) {
        this.instance = instance;
    }
    /**
     * Allow network traffic from this pod to the peer.
     *
     * By default, this will create an egress network policy for this pod, and an ingress
     * network policy for the peer. This is required if both sides are already isolated.
     * Use `options.isolation` to control this behavior.
     *
     * @example
     *
     * // create only an egress policy that selects the 'web' pod to allow outgoing traffic
     * // to the 'redis' pod. this requires the 'redis' pod to not be isolated for ingress.
     * web.connections.allowTo(redis, { isolation: Isolation.POD })
     *
     * // create only an ingress policy that selects the 'redis' peer to allow incoming traffic
     * // from the 'web' pod. this requires the 'web' pod to not be isolated for egress.
     * web.connections.allowTo(redis, { isolation: Isolation.PEER })
     *
     */
    allowTo(peer, options = {}) {
        return this.allow('Egress', peer, { ports: this.extractPorts(peer), ...options });
    }
    /**
     * Allow network traffic from the peer to this pod.
     *
     * By default, this will create an ingress network policy for this pod, and an egress
     * network policy for the peer. This is required if both sides are already isolated.
     * Use `options.isolation` to control this behavior.
     *
     * @example
     *
     * // create only an egress policy that selects the 'web' pod to allow outgoing traffic
     * // to the 'redis' pod. this requires the 'redis' pod to not be isolated for ingress.
     * redis.connections.allowFrom(web, { isolation: Isolation.PEER })
     *
     * // create only an ingress policy that selects the 'redis' peer to allow incoming traffic
     * // from the 'web' pod. this requires the 'web' pod to not be isolated for egress.
     * redis.connections.allowFrom(web, { isolation: Isolation.POD })
     *
     */
    allowFrom(peer, options = {}) {
        return this.allow('Ingress', peer, { ports: this.extractPorts(this.instance), ...options });
    }
    allow(direction, peer, options = {}) {
        const config = peer.toNetworkPolicyPeerConfig();
        networkpolicy.validatePeerConfig(config);
        const peerAddress = utils_1.address(peer);
        if (!options.isolation || options.isolation === PodConnectionsIsolation.POD) {
            const src = new networkpolicy.NetworkPolicy(this.instance, `Allow${direction}${peerAddress}`, {
                selector: this.instance,
                // the policy must be defined in the namespace of the pod
                // so it can select it.
                metadata: { namespace: this.instance.metadata.namespace },
            });
            switch (direction) {
                case 'Egress':
                    src.addEgressRule(peer, options.ports);
                    break;
                case 'Ingress':
                    src.addIngressRule(peer, options.ports);
            }
        }
        if (!options.isolation || options.isolation === PodConnectionsIsolation.PEER) {
            if (config.ipBlock) {
                // for an ip block we don't need to create the opposite policies
                return;
            }
            const podSelector = peer.toPodSelector();
            if (!podSelector) {
                throw new Error(`Unable to create policies for peer '${peer.node.addr}' since its not a pod selector`);
            }
            const oppositeDirection = direction === 'Egress' ? 'Ingress' : 'Egress';
            const podSelectorConfig = podSelector.toPodSelectorConfig();
            let namespaces;
            if (!podSelectorConfig.namespaces) {
                // if the peer doesn't specify namespaces, we assume the same namespace.
                namespaces = [this.instance.metadata.namespace];
            }
            else {
                // a peer cannot specify namespaces by labels because
                // we won't be able to extract the names of those namespaces.
                if (podSelectorConfig.namespaces.labelSelector && !podSelectorConfig.namespaces.labelSelector.isEmpty()) {
                    throw new Error(`Unable to create an ${oppositeDirection} policy for peer '${peer.node.path}' (pod=${this.instance.name}). Peer must specify namespaces only by name`);
                }
                // a peer must specify namespaces by name.
                if (!podSelectorConfig.namespaces.names) {
                    throw new Error(`Unable to create an ${oppositeDirection} policy for peer '${peer.node.path}' (pod=${this.instance.name}). Peer must specify namespace names`);
                }
                namespaces = podSelectorConfig.namespaces.names;
            }
            for (const name of namespaces) {
                switch (direction) {
                    case 'Egress':
                        new networkpolicy.NetworkPolicy(this.instance, `AllowIngress${name}${peerAddress}`, {
                            selector: podSelector,
                            metadata: { namespace: name },
                            ingress: { rules: [{ peer: this.instance, ports: options.ports }] },
                        });
                        break;
                    case 'Ingress':
                        new networkpolicy.NetworkPolicy(this.instance, `AllowEgress${name}${peerAddress}`, {
                            selector: podSelector,
                            metadata: { namespace: name },
                            egress: { rules: [{ peer: this.instance, ports: options.ports }] },
                        });
                        break;
                    default:
                        throw new Error(`Unsupported direction: ${direction}`);
                }
            }
        }
    }
    extractPorts(selector) {
        return container.extractContainerPorts(selector).map(n => networkpolicy.NetworkPolicyPort.tcp(n));
    }
}
exports.PodConnections = PodConnections;
_s = JSII_RTTI_SYMBOL_1;
PodConnections[_s] = { fqn: "cdk8s-plus-22.PodConnections", version: "2.0.0-rc.2" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9kLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3BvZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGlDQUFzRjtBQUN0RiwyQ0FBbUQ7QUFDbkQsK0JBQStCO0FBQy9CLHlDQUF5QztBQUN6QyxxQ0FBcUM7QUFFckMsa0RBQWtEO0FBSWxELG1DQUFvRDtBQUdwRCxNQUFzQixXQUFZLFNBQVEsSUFBSSxDQUFDLFFBQVE7SUFnQnJELFlBQVksS0FBZ0IsRUFBRSxFQUFVLEVBQUUsUUFBMEIsRUFBRTs7UUFDcEUsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQVJGLGdCQUFXLEdBQTBCLEVBQUUsQ0FBQztRQUN4QyxvQkFBZSxHQUEwQixFQUFFLENBQUM7UUFDNUMsaUJBQVksR0FBZ0IsRUFBRSxDQUFDO1FBQy9CLGFBQVEsR0FBK0IsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQU9oRSxJQUFJLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQyxhQUFhLENBQUM7UUFDekMsSUFBSSxDQUFDLGNBQWMsR0FBRyxLQUFLLENBQUMsY0FBYyxDQUFDO1FBQzNDLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDckUsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDakMsSUFBSSxDQUFDLGtCQUFrQixHQUFHLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQztRQUNuRCxJQUFJLENBQUMsNEJBQTRCLFNBQUcsS0FBSyxDQUFDLDRCQUE0QixtQ0FBSSxJQUFJLENBQUM7UUFFL0UsSUFBSSxLQUFLLENBQUMsVUFBVSxFQUFFO1lBQ3BCLEtBQUssQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NB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QVEsRUFBRSxlQUFlLElBQUksR0FBRyxXQUFXLEVBQUUsRUFBRTs0QkFDbEYsUUFBUSxFQUFFLFdBQVc7NEJBQ3JCLFFBQVEsRUFBRSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUU7NEJBQzdCLE9BQU8sRUFBRSxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsS0FBSyxFQUFFLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFO3lCQUNwRSxDQUFDLENBQUM7d0JBQ0gsTUFBTTtvQkFDUixLQUFLLFNBQVM7d0JBQ1osSUFBSSxhQUFhLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsY0FBYyxJQUFJLEdBQUcsV0FBVyxFQUFFLEVBQUU7NEJBQ2pGLFFBQVEsRUFBRSxXQUFXOzRCQUNyQixRQUFRLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFOzRCQUM3QixNQUFNLEVBQUUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLEtBQUssRUFBRSxPQUFPLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRTt5QkFDbkUsQ0FBQyxDQUFDO3dCQUNILE1BQU07b0JBQ1I7d0JBQ0UsTUFBTSxJQUFJLEtBQUssQ0FBQywwQkFBMEIsU0FBUyxFQUFFLENBQUMsQ0FBQztpQkFDMUQ7YUFDRjtTQUVGO0lBQ0gsQ0FBQztJQUVPLFlBQVksQ0FBQyxRQUEyQztRQUM5RCxPQUFPLFNBQVMsQ0FBQyxxQkFBcUIsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDcEcsQ0FBQzs7QUExSUgsd0NBMklDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBpT2JqZWN0LCBBcGlPYmplY3RNZXRhZGF0YURlZmluaXRpb24sIER1cmF0aW9uLCBMYXp5LCBOYW1lcyB9IGZyb20gJ2NkazhzJztcbmltcG9ydCB7IENvbnN0cnVjdCwgSUNvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xuaW1wb3J0ICogYXMgYmFzZSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0ICogYXMgY29udGFpbmVyIGZyb20gJy4vY29udGFpbmVyJztcbmltcG9ydCAqIGFzIGs4cyBmcm9tICcuL2ltcG9ydHMvazhzJztcbmltcG9ydCAqIGFzIG5hbWVzcGFjZSBmcm9tICcuL25hbWVzcGFjZSc7XG5pbXBvcnQgKiBhcyBuZXR3b3JrcG9saWN5IGZyb20gJy4vbmV0d29yay1wb2xpY3knO1xuaW1wb3J0ICogYXMgcmIgZnJvbSAnLi9yb2xlLWJpbmRpbmcnO1xuaW1wb3J0ICogYXMgc2VjcmV0IGZyb20gJy4vc2VjcmV0JztcbmltcG9ydCAqIGFzIHNlcnZpY2VhY2NvdW50IGZyb20gJy4vc2VydmljZS1hY2NvdW50JztcbmltcG9ydCB7IHVuZGVmaW5lZElmRW1wdHksIGFkZHJlc3MgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCAqIGFzIHZvbHVtZSBmcm9tICcuL3ZvbHVtZSc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdFBvZCBleHRlbmRzIGJhc2UuUmVzb3VyY2UgaW1wbGVtZW50cyBJUG9kU2VsZWN0b3IsIG5ldHdvcmtwb2xpY3kuSU5ldHdvcmtQb2xpY3lQZWVyLCByYi5JU3ViamVjdCB7XG5cbiAgcHVibGljIHJlYWRvbmx5IHJlc3RhcnRQb2xpY3k/OiBSZXN0YXJ0UG9saWN5O1xuICBwdWJsaWMgcmVhZG9ubHkgc2VydmljZUFjY291bnQ/OiBzZXJ2aWNlYWNjb3VudC5JU2VydmljZUFjY291bnQ7XG4gIHB1YmxpYyByZWFkb25seSBzZWN1cml0eUNvbnRleHQ6IFBvZFNlY3VyaXR5Q29udGV4dDtcbiAgcHVibGljIHJlYWRvbmx5IGRuczogUG9kRG5zO1xuICBwdWJsaWMgcmVhZG9ubHkgZG9ja2VyUmVnaXN0cnlBdXRoPzogc2VjcmV0LkRvY2tlckNvbmZpZ1NlY3JldDtcbiAgcHVibGljIHJlYWRvbmx5IGF1dG9tb3VudFNlcnZpY2VBY2NvdW50VG9rZW46IGJvb2xlYW47XG5cbiAgcHJpdmF0ZSByZWFkb25seSBfY29udGFpbmVyczogY29udGFpbmVyLkNvbnRhaW5lcltdID0gW107XG4gIHByaXZhdGUgcmVhZG9ubHkgX2luaXRDb250YWluZXJzOiBjb250YWluZXIuQ29udGFpbmVyW10gPSBbXTtcbiAgcHJpdmF0ZSByZWFkb25seSBfaG9zdEFsaWFzZXM6IEhvc3RBbGlhc1tdID0gW107XG4gIHByaXZhdGUgcmVhZG9ubHkgX3ZvbHVtZXM6IE1hcDxzdHJpbmcsIHZvbHVtZS5Wb2x1bWU+ID0gbmV3IE1hcCgpO1xuXG4gIHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBwb2RNZXRhZGF0YTogQXBpT2JqZWN0TWV0YWRhdGFEZWZpbml0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBBYnN0cmFjdFBvZFByb3BzID0ge30pIHtcbiAgICBzdXBlcihzY29wZSwgaWQpO1xuXG4gICAgdGhpcy5yZXN0YXJ0UG9saWN5ID0gcHJvcHMucmVzdGFydFBvbGljeTtcbiAgICB0aGlzLnNlcnZpY2VBY2NvdW50ID0gcHJvcHMuc2VydmljZUFjY291bnQ7XG4gICAgdGhpcy5zZWN1cml0eUNvbnRleHQgPSBuZXcgUG9kU2VjdXJpdHlDb250ZXh0KHByb3BzLnNlY3VyaXR5Q29udGV4dCk7XG4gICAgdGhpcy5kbnMgPSBuZXcgUG9kRG5zKHByb3BzLmRucyk7XG4gICAgdGhpcy5kb2NrZXJSZWdpc3RyeUF1dGggPSBwcm9wcy5kb2NrZXJSZWdpc3RyeUF1dGg7XG4gICAgdGhpcy5hdXRvbW91bnRTZXJ2aWNlQWNjb3VudFRva2VuID0gcHJvcHMuYXV0b21vdW50U2VydmljZUFjY291bnRUb2tlbiA/PyB0cnVlO1xuXG4gICAgaWYgKHByb3BzLmNvbnRhaW5lcnMpIHtcbiAgICAgIHByb3BzLmNvbnRhaW5lcnMuZm9yRWFjaChjID0+IHRoaXMuYWRkQ29udGFpbmVyKGMpKTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMudm9sdW1lcykge1xuICAgICAgcHJvcHMudm9sdW1lcy5mb3JFYWNoKHYgPT4gdGhpcy5hZGRWb2x1bWUodikpO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy5pbml0Q29udGFpbmVycykge1xuICAgICAgcHJvcHMuaW5pdENvbnRhaW5lcnMuZm9yRWFjaChjID0+IHRoaXMuYWRkSW5pdENvbnRhaW5lcihjKSk7XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLmhvc3RBbGlhc2VzKSB7XG4gICAgICBwcm9wcy5ob3N0QWxpYXNlcy5mb3JFYWNoKGMgPT4gdGhpcy5hZGRIb3N0QWxpYXMoYykpO1xuICAgIH1cblxuICB9XG5cbiAgcHVibGljIGdldCBjb250YWluZXJzKCk6IGNvbnRhaW5lci5Db250YWluZXJbXSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLl9jb250YWluZXJzXTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgaW5pdENvbnRhaW5lcnMoKTogY29udGFpbmVyLkNvbnRhaW5lcltdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuX2luaXRDb250YWluZXJzXTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgdm9sdW1lcygpOiB2b2x1bWUuVm9sdW1lW10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3ZvbHVtZXMudmFsdWVzKCkpO1xuICB9XG5cbiAgcHVibGljIGdldCBob3N0QWxpYXNlcygpOiBIb3N0QWxpYXNbXSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLl9ob3N0QWxpYXNlc107XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBJUG9kU2VsZWN0b3IudG9Qb2RTZWxlY3RvckNvbmZpZygpXG4gICAqL1xuICBwdWJsaWMgdG9Qb2RTZWxlY3RvckNvbmZpZygpOiBQb2RTZWxlY3RvckNvbmZpZyB7XG4gICAgY29uc3QgcG9kQWRkcmVzcyA9IHRoaXMucG9kTWV0YWRhdGEuZ2V0TGFiZWwoUG9kLkFERFJFU1NfTEFCRUwpO1xuICAgIGlmICghcG9kQWRkcmVzcykge1xuICAgICAgLy8gc2hvdWxkbid0IGhhcHBlbiBiZWNhdXNlIHdlIGFkZCB0aGlzIGxhYmVsIGF1dG9tYXRpY2FsbHkgaW4gYm90aCBwb2RzIGFuZCB3b3JrbG9hZHMuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBjcmVhdGUgYSBsYWJlbCBzZWxlY3RvciBzaW5jZSAke1BvZC5BRERSRVNTX0xBQkVMfSBsYWJlbCBpcyBtaXNzaW5nYCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbFNlbGVjdG9yOiBMYWJlbFNlbGVjdG9yLm9mKHsgbGFiZWxzOiB7IFtQb2QuQUREUkVTU19MQUJFTF06IHBvZEFkZHJlc3MgfSB9KSxcbiAgICAgIG5hbWVzcGFjZXM6IHRoaXMubWV0YWRhdGEubmFtZXNwYWNlID8ge1xuICAgICAgICBuYW1lczogW3RoaXMubWV0YWRhdGEubmFtZXNwYWNlXSxcbiAgICAgIH0gOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIElOZXR3b3JrUG9saWN5UGVlci50b05ldHdvcmtQb2xpY3lQZWVyQ29uZmlnKClcbiAgICovXG4gIHB1YmxpYyB0b05ldHdvcmtQb2xpY3lQZWVyQ29uZmlnKCk6IG5ldHdvcmtwb2xpY3kuTmV0d29ya1BvbGljeVBlZXJDb25maWcge1xuICAgIHJldHVybiB7IHBvZFNlbGVjdG9yOiB0aGlzLnRvUG9kU2VsZWN0b3JDb25maWcoKSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgSU5ldHdvcmtQb2xpY3lQZWVyLnRvUG9kU2VsZWN0b3IoKVxuICAgKi9cbiAgcHVibGljIHRvUG9kU2VsZWN0b3IoKTogSVBvZFNlbGVjdG9yIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHB1YmxpYyBhZGRDb250YWluZXIoY29udDogY29udGFpbmVyLkNvbnRhaW5lclByb3BzKTogY29udGFpbmVyLkNvbnRhaW5lciB7XG4gICAgY29uc3QgaW1wbCA9IG5ldyBjb250YWluZXIuQ29udGFpbmVyKGNvbnQpO1xuICAgIHRoaXMuX2NvbnRhaW5lcnMucHVzaChpbXBsKTtcbiAgICByZXR1cm4gaW1wbDtcbiAgfVxuXG4gIHB1YmxpYyBhZGRJbml0Q29udGFpbmVyKGNvbnQ6IGNvbnRhaW5lci5Db250YWluZXJQcm9wcyk6IGNvbnRhaW5lci5Db250YWluZXIge1xuXG4gICAgLy8gaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL3BvZHMvaW5pdC1jb250YWluZXJzLyNkaWZmZXJlbmNlcy1mcm9tLXJlZ3VsYXItY29udGFpbmVyc1xuICAgIGlmIChjb250LnJlYWRpbmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbml0IGNvbnRhaW5lcnMgbXVzdCBub3QgaGF2ZSBhIHJlYWRpbmVzcyBwcm9iZScpO1xuICAgIH1cblxuICAgIGlmIChjb250LmxpdmVuZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luaXQgY29udGFpbmVycyBtdXN0IG5vdCBoYXZlIGEgbGl2ZW5lc3MgcHJvYmUnKTtcbiAgICB9XG5cbiAgICBpZiAoY29udC5zdGFydHVwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luaXQgY29udGFpbmVycyBtdXN0IG5vdCBoYXZlIGEgc3RhcnR1cCBwcm9iZScpO1xuICAgIH1cblxuICAgIGNvbnN0IGltcGwgPSBuZXcgY29udGFpbmVyLkNvbnRhaW5lcih7XG4gICAgICAuLi5jb250LFxuICAgICAgbmFtZTogY29udC5uYW1lID8/IGBpbml0LSR7dGhpcy5faW5pdENvbnRhaW5lcnMubGVuZ3RofWAsXG4gICAgfSk7XG5cbiAgICB0aGlzLl9pbml0Q29udGFpbmVycy5wdXNoKGltcGwpO1xuICAgIHJldHVybiBpbXBsO1xuICB9XG5cbiAgcHVibGljIGFkZEhvc3RBbGlhcyhob3N0QWxpYXM6IEhvc3RBbGlhcyk6IHZvaWQge1xuICAgIHRoaXMuX2hvc3RBbGlhc2VzLnB1c2goaG9zdEFsaWFzKTtcbiAgfVxuXG4gIHB1YmxpYyBhZGRWb2x1bWUodm9sOiB2b2x1bWUuVm9sdW1lKTogdm9pZCB7XG4gICAgY29uc3QgZXhpc3RpbmdWb2x1bWUgPSB0aGlzLl92b2x1bWVzLmdldCh2b2wubmFtZSk7XG4gICAgaWYgKGV4aXN0aW5nVm9sdW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFZvbHVtZSB3aXRoIG5hbWUgJHt2b2wubmFtZX0gYWxyZWFkeSBleGlzdHNgKTtcbiAgICB9XG4gICAgdGhpcy5fdm9sdW1lcy5zZXQodm9sLm5hbWUsIHZvbCk7XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBJU3ViZWN0LnRvU3ViamVjdENvbmZpZ3VyYXRpb24oKVxuICAgKi9cbiAgcHVibGljIHRvU3ViamVjdENvbmZpZ3VyYXRpb24oKTogcmIuU3ViamVjdENvbmZpZ3VyYXRpb24ge1xuXG4gICAgaWYgKCF0aGlzLnNlcnZpY2VBY2NvdW50ICYmICF0aGlzLmF1dG9tb3VudFNlcnZpY2VBY2NvdW50VG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLm5hbWV9IGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYSByb2xlIGJpbmRpbmcgc3ViamVjdDpgXG4gICAgICAgICsgJyBZb3UgbXVzdCBlaXRoZXIgYXNzaWduIGEgc2VydmljZSBhY2NvdW50IHRvIGl0LCBvciB1c2UgXFwnYXV0b21vdW50U2VydmljZUFjY291bnRUb2tlbjogdHJ1ZVxcJycpO1xuICAgIH1cblxuICAgIC8vICdkZWZhdWx0JyBpcyBhc3N1bWVkIHRvIGJlIHRoZSBuYW1lIG9mIHRoZSBkZWZhdWx0IHNlcnZpY2UgYWNjb3VudFxuICAgIC8vIGluIHRoZSBjbHVzdGVyLlxuICAgIGNvbnN0IHNlcnZpY2VBY2NvdW50TmFtZSA9IHRoaXMuc2VydmljZUFjY291bnQ/Lm5hbWUgPz8gJ2RlZmF1bHQnO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6ICdTZXJ2aWNlQWNjb3VudCcsXG4gICAgICBuYW1lOiBzZXJ2aWNlQWNjb3VudE5hbWUsXG4gICAgICBhcGlHcm91cDogJycsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHB1YmxpYyBfdG9Qb2RTcGVjKCk6IGs4cy5Qb2RTcGVjIHtcblxuICAgIGlmICh0aGlzLmNvbnRhaW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvZFNwZWMgbXVzdCBoYXZlIGF0IGxlYXN0IDEgY29udGFpbmVyJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgdm9sdW1lczogTWFwPHN0cmluZywgdm9sdW1lLlZvbHVtZT4gPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgY29udGFpbmVyczogazhzLkNvbnRhaW5lcltdID0gW107XG4gICAgY29uc3QgaW5pdENvbnRhaW5lcnM6IGs4cy5Db250YWluZXJbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBjb250IG9mIHRoaXMuY29udGFpbmVycykge1xuICAgICAgLy8gYXV0b21hdGljYWxseSBhZGQgdm9sdW1lIGZyb20gdGhlIGNvbnRhaW5lciBtb3VudFxuICAgICAgLy8gdG8gdGhpcyBwb2Qgc28gdGhhdHMgaXRzIGF2YWlsYWJsZSB0byB0aGUgY29udGFpbmVyLlxuICAgICAgZm9yIChjb25zdCBtb3VudCBvZiBjb250Lm1vdW50cykge1xuICAgICAgICBhZGRWb2x1bWUobW91bnQudm9sdW1lKTtcbiAgICAgIH1cbiAgICAgIGNvbnRhaW5lcnMucHVzaChjb250Ll90b0t1YmUoKSk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBjb250IG9mIHRoaXMuaW5pdENvbnRhaW5lcnMpIHtcbiAgICAgIC8vIGF1dG9tYXRpY2FsbHkgYWRkIHZvbHVtZSBmcm9tIHRoZSBjb250YWluZXIgbW91bnRcbiAgICAgIC8vIHRvIHRoaXMgcG9kIHNvIHRoYXRzIGl0cyBhdmFpbGFibGUgdG8gdGhlIGNvbnRhaW5lci5cbiAgICAgIGZvciAoY29uc3QgbW91bnQgb2YgY29udC5tb3VudHMpIHtcbiAgICAgICAgYWRkVm9sdW1lKG1vdW50LnZvbHVtZSk7XG4gICAgICB9XG4gICAgICBpbml0Q29udGFpbmVycy5wdXNoKGNvbnQuX3RvS3ViZSgpKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHZvbCBvZiB0aGlzLnZvbHVtZXMpIHtcbiAgICAgIGFkZFZvbHVtZSh2b2wpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFZvbHVtZSh2b2w6IHZvbHVtZS5Wb2x1bWUpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nVm9sdW1lID0gdm9sdW1lcy5nZXQodm9sLm5hbWUpO1xuICAgICAgLy8gaXRzIG9rIHRvIGNhbGwgdGhpcyBmdW5jdGlvbiB0d2ljZSBvbiB0aGUgc2FtZSB2b2x1bWUsIGJ1dCBpdHMgbm90IG9rIHRvXG4gICAgICAvLyBjYWxsIGl0IHR3aWNlIG9uIGEgZGlmZmVyZW50IHZvbHVtZSB3aXRoIHRoZSBzYW1lIG5hbWUuXG4gICAgICBpZiAoZXhpc3RpbmdWb2x1bWUgJiYgZXhpc3RpbmdWb2x1bWUgIT09IHZvbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbW91bnQgY29uZmlndXJhdGlvbi4gQXQgbGVhc3QgdHdvIGRpZmZlcmVudCB2b2x1bWVzIGhhdmUgdGhlIHNhbWUgbmFtZTogJHt2b2wubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIHZvbHVtZXMuc2V0KHZvbC5uYW1lLCB2b2wpO1xuICAgIH1cblxuICAgIGNvbnN0IGRucyA9IHRoaXMuZG5zLl90b0t1YmUoKTtcblxuICAgIHJldHVybiB7XG4gICAgICByZXN0YXJ0UG9saWN5OiB0aGlzLnJlc3RhcnRQb2xpY3ksXG4gICAgICBzZXJ2aWNlQWNjb3VudE5hbWU6IHRoaXMuc2VydmljZUFjY291bnQ/Lm5hbWUsXG4gICAgICBjb250YWluZXJzOiBjb250YWluZXJzLFxuICAgICAgc2VjdXJpdHlDb250ZXh0OiB1bmRlZmluZWRJZkVtcHR5KHRoaXMuc2VjdXJpdHlDb250ZXh0Ll90b0t1YmUoKSksXG4gICAgICBpbml0Q29udGFpbmVyczogdW5kZWZpbmVkSWZFbXB0eShpbml0Q29udGFpbmVycyksXG4gICAgICBob3N0QWxpYXNlczogdW5kZWZpbmVkSWZFbXB0eSh0aGlzLmhvc3RBbGlhc2VzKSxcbiAgICAgIHZvbHVtZXM6IHVuZGVmaW5lZElmRW1wdHkoQXJyYXkuZnJvbSh2b2x1bWVzLnZhbHVlcygpKS5tYXAodiA9PiB2Ll90b0t1YmUoKSkpLFxuICAgICAgZG5zUG9saWN5OiBkbnMucG9saWN5LFxuICAgICAgZG5zQ29uZmlnOiB1bmRlZmluZWRJZkVtcHR5KGRucy5jb25maWcpLFxuICAgICAgaG9zdG5hbWU6IGRucy5ob3N0bmFtZSxcbiAgICAgIHN1YmRvbWFpbjogZG5zLnN1YmRvbWFpbixcbiAgICAgIHNldEhvc3RuYW1lQXNGcWRuOiBkbnMuaG9zdG5hbWVBc0ZRRE4sXG4gICAgICBpbWFnZVB1bGxTZWNyZXRzOiB0aGlzLmRvY2tlclJlZ2lzdHJ5QXV0aCA/IFt7IG5hbWU6IHRoaXMuZG9ja2VyUmVnaXN0cnlBdXRoLm5hbWUgfV0gOiB1bmRlZmluZWQsXG4gICAgICBhdXRvbW91bnRTZXJ2aWNlQWNjb3VudFRva2VuOiB0aGlzLmF1dG9tb3VudFNlcnZpY2VBY2NvdW50VG9rZW4sXG4gICAgfTtcblxuICB9XG5cbn1cblxuLyoqXG4gKiBTeXNjdGwgZGVmaW5lcyBhIGtlcm5lbCBwYXJhbWV0ZXIgdG8gYmUgc2V0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3lzY3RsIHtcbiAgLyoqXG4gICAqIE5hbWUgb2YgYSBwcm9wZXJ0eSB0byBzZXRcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogVmFsdWUgb2YgYSBwcm9wZXJ0eSB0byBzZXRcbiAgICovXG4gIHJlYWRvbmx5IHZhbHVlOiBzdHJpbmc7XG59XG5cbi8qKlxuICogUHJvcGVydGllcyBmb3IgYFBvZFNlY3VyaXR5Q29udGV4dGBcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQb2RTZWN1cml0eUNvbnRleHRQcm9wcyB7XG5cbiAgLyoqXG4gICAqIE1vZGlmeSB0aGUgb3duZXJzaGlwIGFuZCBwZXJtaXNzaW9ucyBvZiBwb2Qgdm9sdW1lcyB0byB0aGlzIEdJRC5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBWb2x1bWUgb3duZXJzaGlwIGlzIG5vdCBjaGFuZ2VkLlxuICAgKi9cbiAgcmVhZG9ubHkgZnNHcm91cD86IG51bWJlcjtcblxuICAvKipcbiAgICogRGVmaW5lcyBiZWhhdmlvciBvZiBjaGFuZ2luZyBvd25lcnNoaXAgYW5kIHBlcm1pc3Npb24gb2YgdGhlIHZvbHVtZSBiZWZvcmUgYmVpbmcgZXhwb3NlZCBpbnNpZGUgUG9kLlxuICAgKiBUaGlzIGZpZWxkIHdpbGwgb25seSBhcHBseSB0byB2b2x1bWUgdHlwZXMgd2hpY2ggc3VwcG9ydCBmc0dyb3VwIGJhc2VkIG93bmVyc2hpcChhbmQgcGVybWlzc2lvbnMpLlxuICAgKiBJdCB3aWxsIGhhdmUgbm8gZWZmZWN0IG9uIGVwaGVtZXJhbCB2b2x1bWUgdHlwZXMgc3VjaCBhczogc2VjcmV0LCBjb25maWdtYXBzIGFuZCBlbXB0eWRpci5cbiAgICpcbiAgICogQGRlZmF1bHQgRnNHcm91cENoYW5nZVBvbGljeS5BTFdBWVNcbiAgICovXG4gIHJlYWRvbmx5IGZzR3JvdXBDaGFuZ2VQb2xpY3k/OiBGc0dyb3VwQ2hhbmdlUG9saWN5O1xuXG4gIC8qKlxuICAgKiBUaGUgVUlEIHRvIHJ1biB0aGUgZW50cnlwb2ludCBvZiB0aGUgY29udGFpbmVyIHByb2Nlc3MuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gVXNlciBzcGVjaWZpZWQgaW4gaW1hZ2UgbWV0YWRhdGFcbiAgICovXG4gIHJlYWRvbmx5IHVzZXI/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBHSUQgdG8gcnVuIHRoZSBlbnRyeXBvaW50IG9mIHRoZSBjb250YWluZXIgcHJvY2Vzcy5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBHcm91cCBjb25maWd1cmVkIGJ5IGNvbnRhaW5lciBydW50aW1lXG4gICAqL1xuICByZWFkb25seSBncm91cD86IG51bWJlcjtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIHRoYXQgdGhlIGNvbnRhaW5lciBtdXN0IHJ1biBhcyBhIG5vbi1yb290IHVzZXIuXG4gICAqIElmIHRydWUsIHRoZSBLdWJlbGV0IHdpbGwgdmFsaWRhdGUgdGhlIGltYWdlIGF0IHJ1bnRpbWUgdG8gZW5zdXJlIHRoYXQgaXQgZG9lc1xuICAgKiBub3QgcnVuIGFzIFVJRCAwIChyb290KSBhbmQgZmFpbCB0byBzdGFydCB0aGUgY29udGFpbmVyIGlmIGl0IGRvZXMuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBlbnN1cmVOb25Sb290PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogU3lzY3RscyBob2xkIGEgbGlzdCBvZiBuYW1lc3BhY2VkIHN5c2N0bHMgdXNlZCBmb3IgdGhlIHBvZC5cbiAgICogUG9kcyB3aXRoIHVuc3VwcG9ydGVkIHN5c2N0bHMgKGJ5IHRoZSBjb250YWluZXIgcnVudGltZSkgbWlnaHQgZmFpbCB0byBsYXVuY2guXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gc3lzY3Rsc1xuICAgKi9cbiAgcmVhZG9ubHkgc3lzY3Rscz86IFN5c2N0bFtdO1xufVxuXG4vKipcbiAqIFByb3BlcnRpZXMgZm9yIGBBYnN0cmFjdFBvZGAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWJzdHJhY3RQb2RQcm9wcyBleHRlbmRzIGJhc2UuUmVzb3VyY2VQcm9wcyB7XG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgY29udGFpbmVycyBiZWxvbmdpbmcgdG8gdGhlIHBvZC4gQ29udGFpbmVycyBjYW5ub3QgY3VycmVudGx5IGJlXG4gICAqIGFkZGVkIG9yIHJlbW92ZWQuIFRoZXJlIG11c3QgYmUgYXQgbGVhc3Qgb25lIGNvbnRhaW5lciBpbiBhIFBvZC5cbiAgICpcbiAgICogWW91IGNhbiBhZGQgYWRkaXRpb25uYWwgY29udGFpbmVycyB1c2luZyBgcG9kU3BlYy5hZGRDb250YWluZXIoKWBcbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyBjb250YWluZXJzLiBOb3RlIHRoYXQgYSBwb2Qgc3BlYyBtdXN0IGluY2x1ZGUgYXQgbGVhc3Qgb25lIGNvbnRhaW5lci5cbiAgICovXG4gIHJlYWRvbmx5IGNvbnRhaW5lcnM/OiBjb250YWluZXIuQ29udGFpbmVyUHJvcHNbXTtcblxuICAvKipcbiAgICogTGlzdCBvZiBpbml0aWFsaXphdGlvbiBjb250YWluZXJzIGJlbG9uZ2luZyB0byB0aGUgcG9kLlxuICAgKiBJbml0IGNvbnRhaW5lcnMgYXJlIGV4ZWN1dGVkIGluIG9yZGVyIHByaW9yIHRvIGNvbnRhaW5lcnMgYmVpbmcgc3RhcnRlZC5cbiAgICogSWYgYW55IGluaXQgY29udGFpbmVyIGZhaWxzLCB0aGUgcG9kIGlzIGNvbnNpZGVyZWQgdG8gaGF2ZSBmYWlsZWQgYW5kIGlzIGhhbmRsZWQgYWNjb3JkaW5nIHRvIGl0cyByZXN0YXJ0UG9saWN5LlxuICAgKiBUaGUgbmFtZSBmb3IgYW4gaW5pdCBjb250YWluZXIgb3Igbm9ybWFsIGNvbnRhaW5lciBtdXN0IGJlIHVuaXF1ZSBhbW9uZyBhbGwgY29udGFpbmVycy5cbiAgICogSW5pdCBjb250YWluZXJzIG1heSBub3QgaGF2ZSBMaWZlY3ljbGUgYWN0aW9ucywgUmVhZGluZXNzIHByb2JlcywgTGl2ZW5lc3MgcHJvYmVzLCBvciBTdGFydHVwIHByb2Jlcy5cbiAgICogVGhlIHJlc291cmNlUmVxdWlyZW1lbnRzIG9mIGFuIGluaXQgY29udGFpbmVyIGFyZSB0YWtlbiBpbnRvIGFjY291bnQgZHVyaW5nIHNjaGVkdWxpbmcgYnkgZmluZGluZyB0aGUgaGlnaGVzdCByZXF1ZXN0L2xpbWl0XG4gICAqIGZvciBlYWNoIHJlc291cmNlIHR5cGUsIGFuZCB0aGVuIHVzaW5nIHRoZSBtYXggb2Ygb2YgdGhhdCB2YWx1ZSBvciB0aGUgc3VtIG9mIHRoZSBub3JtYWwgY29udGFpbmVycy5cbiAgICogTGltaXRzIGFyZSBhcHBsaWVkIHRvIGluaXQgY29udGFpbmVycyBpbiBhIHNpbWlsYXIgZmFzaGlvbi5cbiAgICpcbiAgICogSW5pdCBjb250YWluZXJzIGNhbm5vdCBjdXJyZW50bHkgYmUgYWRkZWQgLHJlbW92ZWQgb3IgdXBkYXRlZC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy93b3JrbG9hZHMvcG9kcy9pbml0LWNvbnRhaW5lcnMvXG4gICAqIEBkZWZhdWx0IC0gTm8gaW5pdCBjb250YWluZXJzLlxuICAgKi9cbiAgcmVhZG9ubHkgaW5pdENvbnRhaW5lcnM/OiBjb250YWluZXIuQ29udGFpbmVyUHJvcHNbXTtcblxuICAvKipcbiAgICogTGlzdCBvZiB2b2x1bWVzIHRoYXQgY2FuIGJlIG1vdW50ZWQgYnkgY29udGFpbmVycyBiZWxvbmdpbmcgdG8gdGhlIHBvZC5cbiAgICpcbiAgICogWW91IGNhbiBhbHNvIGFkZCB2b2x1bWVzIGxhdGVyIHVzaW5nIGBwb2RTcGVjLmFkZFZvbHVtZSgpYFxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2Uvdm9sdW1lc1xuICAgKlxuICAgKiBAZGVmYXVsdCAtIE5vIHZvbHVtZXMuXG4gICAqL1xuICByZWFkb25seSB2b2x1bWVzPzogdm9sdW1lLlZvbHVtZVtdO1xuXG4gIC8qKlxuICAgKiBSZXN0YXJ0IHBvbGljeSBmb3IgYWxsIGNvbnRhaW5lcnMgd2l0aGluIHRoZSBwb2QuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL3BvZHMvcG9kLWxpZmVjeWNsZS8jcmVzdGFydC1wb2xpY3lcbiAgICpcbiAgICogQGRlZmF1bHQgUmVzdGFydFBvbGljeS5BTFdBWVNcbiAgICovXG4gIHJlYWRvbmx5IHJlc3RhcnRQb2xpY3k/OiBSZXN0YXJ0UG9saWN5O1xuXG4gIC8qKlxuICAgKiBBIHNlcnZpY2UgYWNjb3VudCBwcm92aWRlcyBhbiBpZGVudGl0eSBmb3IgcHJvY2Vzc2VzIHRoYXQgcnVuIGluIGEgUG9kLlxuICAgKlxuICAgKiBXaGVuIHlvdSAoYSBodW1hbikgYWNjZXNzIHRoZSBjbHVzdGVyIChmb3IgZXhhbXBsZSwgdXNpbmcga3ViZWN0bCksIHlvdSBhcmVcbiAgICogYXV0aGVudGljYXRlZCBieSB0aGUgYXBpc2VydmVyIGFzIGEgcGFydGljdWxhciBVc2VyIEFjY291bnQgKGN1cnJlbnRseSB0aGlzXG4gICAqIGlzIHVzdWFsbHkgYWRtaW4sIHVubGVzcyB5b3VyIGNsdXN0ZXIgYWRtaW5pc3RyYXRvciBoYXMgY3VzdG9taXplZCB5b3VyXG4gICAqIGNsdXN0ZXIpLiBQcm9jZXNzZXMgaW4gY29udGFpbmVycyBpbnNpZGUgcG9kcyBjYW4gYWxzbyBjb250YWN0IHRoZVxuICAgKiBhcGlzZXJ2ZXIuIFdoZW4gdGhleSBkbywgdGhleSBhcmUgYXV0aGVudGljYXRlZCBhcyBhIHBhcnRpY3VsYXIgU2VydmljZVxuICAgKiBBY2NvdW50IChmb3IgZXhhbXBsZSwgZGVmYXVsdCkuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvdGFza3MvY29uZmlndXJlLXBvZC1jb250YWluZXIvY29uZmlndXJlLXNlcnZpY2UtYWNjb3VudC9cbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyBzZXJ2aWNlIGFjY291bnQuXG4gICAqL1xuICByZWFkb25seSBzZXJ2aWNlQWNjb3VudD86IHNlcnZpY2VhY2NvdW50LklTZXJ2aWNlQWNjb3VudDtcblxuICAvKipcbiAgICogU2VjdXJpdHlDb250ZXh0IGhvbGRzIHBvZC1sZXZlbCBzZWN1cml0eSBhdHRyaWJ1dGVzIGFuZCBjb21tb24gY29udGFpbmVyIHNldHRpbmdzLlxuICAgKlxuICAgKiBAZGVmYXVsdFxuICAgKlxuICAgKiAgIGZzR3JvdXBDaGFuZ2VQb2xpY3k6IEZzR3JvdXBDaGFuZ2VQb2xpY3kuRnNHcm91cENoYW5nZVBvbGljeS5BTFdBWVNcbiAgICogICBlbnN1cmVOb25Sb290OiBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgc2VjdXJpdHlDb250ZXh0PzogUG9kU2VjdXJpdHlDb250ZXh0UHJvcHM7XG5cbiAgLyoqXG4gICAqIEhvc3RBbGlhcyBob2xkcyB0aGUgbWFwcGluZyBiZXR3ZWVuIElQIGFuZCBob3N0bmFtZXMgdGhhdCB3aWxsIGJlIGluamVjdGVkIGFzIGFuIGVudHJ5IGluIHRoZSBwb2QncyBob3N0cyBmaWxlLlxuICAgKlxuICAgKiBAc2NoZW1hIGlvLms4cy5hcGkuY29yZS52MS5Ib3N0QWxpYXNcbiAgICovXG4gIHJlYWRvbmx5IGhvc3RBbGlhc2VzPzogSG9zdEFsaWFzW107XG5cbiAgLyoqXG4gICAqIEROUyBzZXR0aW5ncyBmb3IgdGhlIHBvZC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zZXJ2aWNlcy1uZXR3b3JraW5nL2Rucy1wb2Qtc2VydmljZS9cbiAgICpcbiAgICogQGRlZmF1bHRcbiAgICpcbiAgICogIHBvbGljeTogRG5zUG9saWN5LkNMVVNURVJfRklSU1RcbiAgICogIGhvc3RuYW1lQXNGUUROOiBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgZG5zPzogUG9kRG5zUHJvcHM7XG5cbiAgLyoqXG4gICAqIEEgc2VjcmV0IGNvbnRhaW5pbmcgZG9ja2VyIGNyZWRlbnRpYWxzIGZvciBhdXRoZW50aWNhdGluZyB0byBhIHJlZ2lzdHJ5LlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIE5vIGF1dGguIEltYWdlcyBhcmUgYXNzdW1lZCB0byBiZSBwdWJsaWNseSBhdmFpbGFibGUuXG4gICAqL1xuICByZWFkb25seSBkb2NrZXJSZWdpc3RyeUF1dGg/OiBzZWNyZXQuRG9ja2VyQ29uZmlnU2VjcmV0O1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBhIHNlcnZpY2UgYWNjb3VudCB0b2tlbiBzaG91bGQgYmUgYXV0b21hdGljYWxseSBtb3VudGVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvdGFza3MvY29uZmlndXJlLXBvZC1jb250YWluZXIvY29uZmlndXJlLXNlcnZpY2UtYWNjb3VudC8jdXNlLXRoZS1kZWZhdWx0LXNlcnZpY2UtYWNjb3VudC10by1hY2Nlc3MtdGhlLWFwaS1zZXJ2ZXJcbiAgICovXG4gIHJlYWRvbmx5IGF1dG9tb3VudFNlcnZpY2VBY2NvdW50VG9rZW4/OiBib29sZWFuO1xuXG59XG5cbi8qKlxuICogUHJvcGVydGllcyBmb3IgYFBvZGAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUG9kUHJvcHMgZXh0ZW5kcyBBYnN0cmFjdFBvZFByb3BzIHt9XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYExhYmVsU2VsZWN0b3Iub2ZgLlxuICovXG5leHBvcnQgY2xhc3MgTGFiZWxTZWxlY3Rvck9wdGlvbnMge1xuXG4gIC8qKlxuICAgKiBTdHJpY3QgbGFiZWwgbWF0Y2hlcnMuXG4gICAqL1xuICByZWFkb25seSBsYWJlbHM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXG4gIC8qKlxuICAgKiBFeHByZXNzaW9uIGJhc2VkIGxhYmVsIG1hdGNoZXJzLlxuICAgKi9cbiAgcmVhZG9ubHkgZXhwcmVzc2lvbnM/OiBMYWJlbEV4cHJlc3Npb25bXTtcbn1cblxuLyoqXG4gKiBNYXRjaCBhIHJlc291cmNlIGJ5IGxhYmVscy5cbiAqL1xuZXhwb3J0IGNsYXNzIExhYmVsU2VsZWN0b3Ige1xuXG4gIHB1YmxpYyBzdGF0aWMgb2Yob3B0aW9uczogTGFiZWxTZWxlY3Rvck9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgTGFiZWxTZWxlY3RvcihvcHRpb25zLmV4cHJlc3Npb25zID8/IFtdLCBvcHRpb25zLmxhYmVscyA/PyB7fSk7XG4gIH1cblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZXhwcmVzc2lvbnM6IExhYmVsRXhwcmVzc2lvbltdLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbGFiZWxzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9KSB7fVxuXG4gIHB1YmxpYyBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMCAmJiBPYmplY3Qua2V5cyh0aGlzLmxhYmVscykubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHVibGljIF90b0t1YmUoKTogazhzLkxhYmVsU2VsZWN0b3Ige1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbWF0Y2hFeHByZXNzaW9uczogdW5kZWZpbmVkSWZFbXB0eSh0aGlzLmV4cHJlc3Npb25zLm1hcChxID0+ICh7IGtleTogcS5rZXksIG9wZXJhdG9yOiBxLm9wZXJhdG9yLCB2YWx1ZXM6IHEudmFsdWVzIH0pKSksXG4gICAgICBtYXRjaExhYmVsczogdW5kZWZpbmVkSWZFbXB0eSh0aGlzLmxhYmVscyksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIHNlbGVjdGluZyBwb2RzLCBvcHRpb25hbGx5IGluIHBhcnRpY3VsYXIgbmFtZXNwYWNlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQb2RTZWxlY3RvckNvbmZpZyB7XG5cbiAgLyoqXG4gICAqIEEgc2VsZWN0b3IgdG8gc2VsZWN0IHBvZHMgYnkgbGFiZWxzLlxuICAgKi9cbiAgcmVhZG9ubHkgbGFiZWxTZWxlY3RvcjogTGFiZWxTZWxlY3RvcjtcblxuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBmb3Igc2VsZWN0aW5nIHdoaWNoIG5hbWVwc2FjZXMgYXJlIHRoZSBwb2RzIGFsbG93ZWQgdG8gYmUgaW4uXG4gICAqL1xuICByZWFkb25seSBuYW1lc3BhY2VzPzogbmFtZXNwYWNlLk5hbWVzcGFjZVNlbGVjdG9yQ29uZmlnO1xuXG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBvYmplY3QgdGhhdCBjYW4gc2VsZWN0IHBvZHMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSVBvZFNlbGVjdG9yIGV4dGVuZHMgSUNvbnN0cnVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhpcyBzZWxlY3Rvci5cbiAgICovXG4gIHRvUG9kU2VsZWN0b3JDb25maWcoKTogUG9kU2VsZWN0b3JDb25maWc7XG59XG5cbi8qKlxuICogUG9kIGlzIGEgY29sbGVjdGlvbiBvZiBjb250YWluZXJzIHRoYXQgY2FuIHJ1biBvbiBhIGhvc3QuIFRoaXMgcmVzb3VyY2UgaXNcbiAqIGNyZWF0ZWQgYnkgY2xpZW50cyBhbmQgc2NoZWR1bGVkIG9udG8gaG9zdHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2QgZXh0ZW5kcyBBYnN0cmFjdFBvZCB7XG5cbiAgLyoqXG4gICAqIFRoaXMgbGFiZWwgaXMgYXV0b2FtdGljYWxseSBhZGRlZCBieSBjZGs4cyB0byBhbnkgcG9kLiBJdCBwcm92aWRlc1xuICAgKiBhIHVuaXF1ZSBhbmQgc3RhYmxlIGlkZW50aWZpZXIgZm9yIHRoZSBwb2QuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEFERFJFU1NfTEFCRUwgPSAnY2RrOHMuaW8vbWV0YWRhdGEuYWRkcic7XG5cbiAgLyoqXG4gICAqIEBzZWUgYmFzZS5SZXNvdXJjZS5hcGlPYmplY3RcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBhcGlPYmplY3Q6IEFwaU9iamVjdDtcblxuICBwdWJsaWMgcmVhZG9ubHkgcmVzb3VyY2VUeXBlID0gJ3BvZHMnO1xuXG4gIHB1YmxpYyByZWFkb25seSBzY2hlZHVsaW5nOiBQb2RTY2hlZHVsaW5nO1xuICBwdWJsaWMgcmVhZG9ubHkgY29ubmVjdGlvbnM6IFBvZENvbm5lY3Rpb25zO1xuXG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBQb2RQcm9wcyA9IHt9KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCBwcm9wcyk7XG5cbiAgICB0aGlzLmFwaU9iamVjdCA9IG5ldyBrOHMuS3ViZVBvZCh0aGlzLCAnUmVzb3VyY2UnLCB7XG4gICAgICBtZXRhZGF0YTogcHJvcHMubWV0YWRhdGEsXG4gICAgICBzcGVjOiBMYXp5LmFueSh7IHByb2R1Y2U6ICgpID0+IHRoaXMuX3RvS3ViZSgpIH0pLFxuICAgIH0pO1xuXG4gICAgdGhpcy5tZXRhZGF0YS5hZGRMYWJlbChQb2QuQUREUkVTU19MQUJFTCwgTmFtZXMudG9MYWJlbFZhbHVlKHRoaXMpKTtcblxuICAgIHRoaXMuc2NoZWR1bGluZyA9IG5ldyBQb2RTY2hlZHVsaW5nKHRoaXMpO1xuICAgIHRoaXMuY29ubmVjdGlvbnMgPSBuZXcgUG9kQ29ubmVjdGlvbnModGhpcyk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHBvZE1ldGFkYXRhKCk6IEFwaU9iamVjdE1ldGFkYXRhRGVmaW5pdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGE7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgX3RvS3ViZSgpOiBrOHMuUG9kU3BlYyB7XG4gICAgY29uc3Qgc2NoZWR1bGluZyA9IHRoaXMuc2NoZWR1bGluZy5fdG9LdWJlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMuX3RvUG9kU3BlYygpLFxuICAgICAgYWZmaW5pdHk6IHNjaGVkdWxpbmcuYWZmaW5pdHksXG4gICAgICBub2RlTmFtZTogc2NoZWR1bGluZy5ub2RlTmFtZSxcbiAgICAgIHRvbGVyYXRpb25zOiBzY2hlZHVsaW5nLnRvbGVyYXRpb25zLFxuICAgIH07XG4gIH1cblxufVxuXG4vKipcbiAqIFByb3BlcnRpZXMgZm9yIGBQb2REbnNgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBvZERuc1Byb3BzIHtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBob3N0bmFtZSBvZiB0aGUgUG9kLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIFNldCB0byBhIHN5c3RlbS1kZWZpbmVkIHZhbHVlLlxuICAgKi9cbiAgcmVhZG9ubHkgaG9zdG5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIElmIHNwZWNpZmllZCwgdGhlIGZ1bGx5IHF1YWxpZmllZCBQb2QgaG9zdG5hbWUgd2lsbCBiZSBcIjxob3N0bmFtZT4uPHN1YmRvbWFpbj4uPHBvZCBuYW1lc3BhY2U+LnN2Yy48Y2x1c3RlciBkb21haW4+XCIuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gc3ViZG9tYWluLlxuICAgKi9cbiAgcmVhZG9ubHkgc3ViZG9tYWluPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBJZiB0cnVlIHRoZSBwb2QncyBob3N0bmFtZSB3aWxsIGJlIGNvbmZpZ3VyZWQgYXMgdGhlIHBvZCdzIEZRRE4sIHJhdGhlciB0aGFuIHRoZSBsZWFmIG5hbWUgKHRoZSBkZWZhdWx0KS5cbiAgICogSW4gTGludXggY29udGFpbmVycywgdGhpcyBtZWFucyBzZXR0aW5nIHRoZSBGUUROIGluIHRoZSBob3N0bmFtZSBmaWVsZCBvZiB0aGUga2VybmVsICh0aGUgbm9kZW5hbWUgZmllbGQgb2Ygc3RydWN0IHV0c25hbWUpLlxuICAgKiBJbiBXaW5kb3dzIGNvbnRhaW5lcnMsIHRoaXMgbWVhbnMgc2V0dGluZyB0aGUgcmVnaXN0cnkgdmFsdWUgb2YgaG9zdG5hbWUgZm9yIHRoZSByZWdpc3RyeVxuICAgKiBrZXkgSEtFWV9MT0NBTF9NQUNISU5FXFxTWVNURU1cXEN1cnJlbnRDb250cm9sU2V0XFxTZXJ2aWNlc1xcVGNwaXBcXFBhcmFtZXRlcnMgdG8gRlFETi5cbiAgICogSWYgYSBwb2QgZG9lcyBub3QgaGF2ZSBGUUROLCB0aGlzIGhhcyBubyBlZmZlY3QuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBob3N0bmFtZUFzRlFETj86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFNldCBETlMgcG9saWN5IGZvciB0aGUgcG9kLlxuICAgKlxuICAgKiBJZiBwb2xpY3kgaXMgc2V0IHRvIGBOb25lYCwgb3RoZXIgY29uZmlndXJhdGlvbiBtdXN0IGJlIHN1cHBsaWVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCBEbnNQb2xpY3kuQ0xVU1RFUl9GSVJTVFxuICAgKi9cbiAgcmVhZG9ubHkgcG9saWN5PzogRG5zUG9saWN5O1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgSVAgYWRkcmVzc2VzIHRoYXQgd2lsbCBiZSB1c2VkIGFzIEROUyBzZXJ2ZXJzIGZvciB0aGUgUG9kLiBUaGVyZSBjYW4gYmUgYXQgbW9zdCAzIElQIGFkZHJlc3NlcyBzcGVjaWZpZWQuXG4gICAqIFdoZW4gdGhlIHBvbGljeSBpcyBzZXQgdG8gXCJOT05FXCIsIHRoZSBsaXN0IG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgSVAgYWRkcmVzcyxcbiAgICogb3RoZXJ3aXNlIHRoaXMgcHJvcGVydHkgaXMgb3B0aW9uYWwuXG4gICAqIFRoZSBzZXJ2ZXJzIGxpc3RlZCB3aWxsIGJlIGNvbWJpbmVkIHRvIHRoZSBiYXNlIG5hbWVzZXJ2ZXJzIGdlbmVyYXRlZCBmcm9tXG4gICAqIHRoZSBzcGVjaWZpZWQgRE5TIHBvbGljeSB3aXRoIGR1cGxpY2F0ZSBhZGRyZXNzZXMgcmVtb3ZlZC5cbiAgICovXG4gIHJlYWRvbmx5IG5hbWVzZXJ2ZXJzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBETlMgc2VhcmNoIGRvbWFpbnMgZm9yIGhvc3RuYW1lIGxvb2t1cCBpbiB0aGUgUG9kLlxuICAgKiBXaGVuIHNwZWNpZmllZCwgdGhlIHByb3ZpZGVkIGxpc3Qgd2lsbCBiZSBtZXJnZWQgaW50byB0aGUgYmFzZVxuICAgKiBzZWFyY2ggZG9tYWluIG5hbWVzIGdlbmVyYXRlZCBmcm9tIHRoZSBjaG9zZW4gRE5TIHBvbGljeS5cbiAgICogRHVwbGljYXRlIGRvbWFpbiBuYW1lcyBhcmUgcmVtb3ZlZC5cbiAgICpcbiAgICogS3ViZXJuZXRlcyBhbGxvd3MgZm9yIGF0IG1vc3QgNiBzZWFyY2ggZG9tYWlucy5cbiAgICovXG4gIHJlYWRvbmx5IHNlYXJjaGVzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIExpc3Qgb2Ygb2JqZWN0cyB3aGVyZSBlYWNoIG9iamVjdCBtYXkgaGF2ZSBhIG5hbWUgcHJvcGVydHkgKHJlcXVpcmVkKVxuICAgKiBhbmQgYSB2YWx1ZSBwcm9wZXJ0eSAob3B0aW9uYWwpLiBUaGUgY29udGVudHMgaW4gdGhpcyBwcm9wZXJ0eVxuICAgKiB3aWxsIGJlIG1lcmdlZCB0byB0aGUgb3B0aW9ucyBnZW5lcmF0ZWQgZnJvbSB0aGUgc3BlY2lmaWVkIEROUyBwb2xpY3kuXG4gICAqIER1cGxpY2F0ZSBlbnRyaWVzIGFyZSByZW1vdmVkLlxuICAgKi9cbiAgcmVhZG9ubHkgb3B0aW9ucz86IERuc09wdGlvbltdO1xufVxuXG4vKipcbiAqIEhvbGRzIGRucyBzZXR0aW5ncyBvZiB0aGUgcG9kLlxuICovXG5leHBvcnQgY2xhc3MgUG9kRG5zIHtcblxuICAvKipcbiAgICogVGhlIEROUyBwb2xpY3kgb2YgdGhpcyBwb2QuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgcG9saWN5OiBEbnNQb2xpY3k7XG5cbiAgLyoqXG4gICAqIFRoZSBjb25maWd1cmVkIGhvc3RuYW1lIG9mIHRoZSBwb2QuIFVuZGVmaW5lZCBtZWFucyBpdHMgc2V0IHRvIGEgc3lzdGVtLWRlZmluZWQgdmFsdWUuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgaG9zdG5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBjb25maWd1cmVkIHN1YmRvbWFpbiBvZiB0aGUgcG9kLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHN1YmRvbWFpbj86IHN0cmluZztcblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdGhlIHBvZHMgaG9zdG5hbWUgaXMgc2V0IHRvIGl0cyBGUUROLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGhvc3RuYW1lQXNGUUROOiBib29sZWFuO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgX25hbWVzZXJ2ZXJzOiBzdHJpbmdbXTtcbiAgcHJpdmF0ZSByZWFkb25seSBfc2VhcmNoZXM6IHN0cmluZ1tdO1xuICBwcml2YXRlIHJlYWRvbmx5IF9vcHRpb25zOiBEbnNPcHRpb25bXTtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogUG9kRG5zUHJvcHMgPSB7fSkge1xuICAgIHRoaXMuaG9zdG5hbWUgPSBwcm9wcy5ob3N0bmFtZTtcbiAgICB0aGlzLnN1YmRvbWFpbiA9IHByb3BzLnN1YmRvbWFpbjtcbiAgICB0aGlzLnBvbGljeSA9IHByb3BzLnBvbGljeSA/PyBEbnNQb2xpY3kuQ0xVU1RFUl9GSVJTVDtcbiAgICB0aGlzLmhvc3RuYW1lQXNGUUROID0gcHJvcHMuaG9zdG5hbWVBc0ZRRE4gPz8gZmFsc2U7XG4gICAgdGhpcy5fbmFtZXNlcnZlcnMgPSBwcm9wcy5uYW1lc2VydmVycyA/PyBbXTtcbiAgICB0aGlzLl9zZWFyY2hlcyA9IHByb3BzLnNlYXJjaGVzID8/IFtdO1xuICAgIHRoaXMuX29wdGlvbnMgPSBwcm9wcy5vcHRpb25zID8/IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIE5hbWVzZXJ2ZXJzIGRlZmluZWQgZm9yIHRoaXMgcG9kLlxuICAgKi9cbiAgcHVibGljIGdldCBuYW1lc2VydmVycygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLl9uYW1lc2VydmVyc107XG4gIH1cblxuICAvKipcbiAgICogU2VhcmNoIGRvbWFpbnMgZGVmaW5lZCBmb3IgdGhpcyBwb2QuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHNlYXJjaGVzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuX3NlYXJjaGVzXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXN0b20gZG5zIG9wdGlvbnMgZGVmaW5lZCBmb3IgdGhpcyBwb2QuXG4gICAqL1xuICBwdWJsaWMgZ2V0IG9wdGlvbnMoKTogRG5zT3B0aW9uW10ge1xuICAgIHJldHVybiBbLi4udGhpcy5fb3B0aW9uc107XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbmFtZXNlcnZlci5cbiAgICovXG4gIHB1YmxpYyBhZGROYW1lc2VydmVyKC4uLm5hbWVzZXJ2ZXJzOiBzdHJpbmdbXSkge1xuICAgIHRoaXMuX25hbWVzZXJ2ZXJzLnB1c2goLi4ubmFtZXNlcnZlcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHNlYXJjaCBkb21haW4uXG4gICAqL1xuICBwdWJsaWMgYWRkU2VhcmNoKC4uLnNlYXJjaGVzOiBzdHJpbmdbXSkge1xuICAgIHRoaXMuX3NlYXJjaGVzLnB1c2goLi4uc2VhcmNoZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGN1c3RvbSBvcHRpb24uXG4gICAqL1xuICBwdWJsaWMgYWRkT3B0aW9uKC4uLm9wdGlvbnM6IERuc09wdGlvbltdKSB7XG4gICAgdGhpcy5fb3B0aW9ucy5wdXNoKC4uLm9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHVibGljIF90b0t1YmUoKTogeyBob3N0bmFtZT86IHN0cmluZzsgc3ViZG9tYWluPzogc3RyaW5nOyBob3N0bmFtZUFzRlFETjogYm9vbGVhbjsgcG9saWN5OiBzdHJpbmc7IGNvbmZpZzogazhzLlBvZERuc0NvbmZpZyB9IHtcblxuICAgIGlmICh0aGlzLnBvbGljeSA9PT0gRG5zUG9saWN5Lk5PTkUgJiYgdGhpcy5uYW1lc2VydmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2hlbiBkbnMgcG9saWN5IGlzIHNldCB0byBOT05FLCBhdCBsZWFzdCBvbmUgbmFtZXNlcnZlciBpcyByZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5hbWVzZXJ2ZXJzLmxlbmd0aCA+IDMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgY2FuIGJlIGF0IG1vc3QgMyBuYW1lc2VydmVycyBzcGVjaWZpZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zZWFyY2hlcy5sZW5ndGggPiA2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGNhbiBiZSBhdCBtb3N0IDYgc2VhcmNoIGRvbWFpbnMgc3BlY2lmaWVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGhvc3RuYW1lOiB0aGlzLmhvc3RuYW1lLFxuICAgICAgc3ViZG9tYWluOiB0aGlzLnN1YmRvbWFpbixcbiAgICAgIGhvc3RuYW1lQXNGUUROOiB0aGlzLmhvc3RuYW1lQXNGUUROLFxuICAgICAgcG9saWN5OiB0aGlzLnBvbGljeSxcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICBuYW1lc2VydmVyczogdW5kZWZpbmVkSWZFbXB0eSh0aGlzLm5hbWVzZXJ2ZXJzKSxcbiAgICAgICAgc2VhcmNoZXM6IHVuZGVmaW5lZElmRW1wdHkodGhpcy5zZWFyY2hlcyksXG4gICAgICAgIG9wdGlvbnM6IHVuZGVmaW5lZElmRW1wdHkodGhpcy5vcHRpb25zKSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG59XG5cbi8qKlxuICogSG9sZHMgcG9kLWxldmVsIHNlY3VyaXR5IGF0dHJpYnV0ZXMgYW5kIGNvbW1vbiBjb250YWluZXIgc2V0dGluZ3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2RTZWN1cml0eUNvbnRleHQge1xuXG4gIHB1YmxpYyByZWFkb25seSBlbnN1cmVOb25Sb290OiBib29sZWFuO1xuICBwdWJsaWMgcmVhZG9ubHkgdXNlcj86IG51bWJlcjtcbiAgcHVibGljIHJlYWRvbmx5IGdyb3VwPzogbnVtYmVyO1xuICBwdWJsaWMgcmVhZG9ubHkgZnNHcm91cD86IG51bWJlcjtcbiAgcHVibGljIHJlYWRvbmx5IGZzR3JvdXBDaGFuZ2VQb2xpY3k6IEZzR3JvdXBDaGFuZ2VQb2xpY3k7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBfc3lzY3RsczogU3lzY3RsW10gPSBbXTtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogUG9kU2VjdXJpdHlDb250ZXh0UHJvcHMgPSB7fSkge1xuICAgIHRoaXMuZW5zdXJlTm9uUm9vdCA9IHByb3BzLmVuc3VyZU5vblJvb3QgPz8gZmFsc2U7XG4gICAgdGhpcy5mc0dyb3VwQ2hhbmdlUG9saWN5ID0gcHJvcHMuZnNHcm91cENoYW5nZVBvbGljeSA/PyBGc0dyb3VwQ2hhbmdlUG9saWN5LkFMV0FZUztcbiAgICB0aGlzLnVzZXIgPSBwcm9wcy51c2VyO1xuICAgIHRoaXMuZ3JvdXAgPSBwcm9wcy5ncm91cDtcbiAgICB0aGlzLmZzR3JvdXAgPSBwcm9wcy5mc0dyb3VwO1xuXG4gICAgZm9yIChjb25zdCBzeXNjdGwgb2YgcHJvcHMuc3lzY3RscyA/PyBbXSkge1xuICAgICAgdGhpcy5fc3lzY3Rscy5wdXNoKHN5c2N0bCk7XG4gICAgfVxuXG4gIH1cblxuICBwdWJsaWMgZ2V0IHN5c2N0bHMoKTogU3lzY3RsW10ge1xuICAgIHJldHVybiBbLi4udGhpcy5fc3lzY3Rsc107XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgX3RvS3ViZSgpOiBrOHMuUG9kU2VjdXJpdHlDb250ZXh0IHtcbiAgICByZXR1cm4ge1xuICAgICAgcnVuQXNHcm91cDogdGhpcy5ncm91cCxcbiAgICAgIHJ1bkFzVXNlcjogdGhpcy51c2VyLFxuICAgICAgZnNHcm91cDogdGhpcy5mc0dyb3VwLFxuICAgICAgcnVuQXNOb25Sb290OiB0aGlzLmVuc3VyZU5vblJvb3QsXG4gICAgICBmc0dyb3VwQ2hhbmdlUG9saWN5OiB0aGlzLmZzR3JvdXBDaGFuZ2VQb2xpY3ksXG4gICAgICBzeXNjdGxzOiB1bmRlZmluZWRJZkVtcHR5KHRoaXMuX3N5c2N0bHMpLFxuICAgIH07XG4gIH1cblxufVxuXG4vKipcbiAqIFJlc3RhcnQgcG9saWN5IGZvciBhbGwgY29udGFpbmVycyB3aXRoaW4gdGhlIHBvZC5cbiAqL1xuZXhwb3J0IGVudW0gUmVzdGFydFBvbGljeSB7XG4gIC8qKlxuICAgKiBBbHdheXMgcmVzdGFydCB0aGUgcG9kIGFmdGVyIGl0IGV4aXRzLlxuICAgKi9cbiAgQUxXQVlTID0gJ0Fsd2F5cycsXG5cbiAgLyoqXG4gICAqIE9ubHkgcmVzdGFydCBpZiB0aGUgcG9kIGV4aXRzIHdpdGggYSBub24temVybyBleGl0IGNvZGUuXG4gICAqL1xuICBPTl9GQUlMVVJFID0gJ09uRmFpbHVyZScsXG5cbiAgLyoqXG4gICAqIE5ldmVyIHJlc3RhcnQgdGhlIHBvZC5cbiAgICovXG4gIE5FVkVSID0gJ05ldmVyJ1xufVxuXG5leHBvcnQgZW51bSBGc0dyb3VwQ2hhbmdlUG9saWN5IHtcblxuICAvKipcbiAgICogT25seSBjaGFuZ2UgcGVybWlzc2lvbnMgYW5kIG93bmVyc2hpcCBpZiBwZXJtaXNzaW9uIGFuZCBvd25lcnNoaXAgb2Ygcm9vdCBkaXJlY3RvcnkgZG9lc1xuICAgKiBub3QgbWF0Y2ggd2l0aCBleHBlY3RlZCBwZXJtaXNzaW9ucyBvZiB0aGUgdm9sdW1lLlxuICAgKiBUaGlzIGNvdWxkIGhlbHAgc2hvcnRlbiB0aGUgdGltZSBpdCB0YWtlcyB0byBjaGFuZ2Ugb3duZXJzaGlwIGFuZCBwZXJtaXNzaW9uIG9mIGEgdm9sdW1lXG4gICAqL1xuICBPTl9ST09UX01JU01BVENIID0gJ09uUm9vdE1pc21hdGNoJyxcblxuICAvKipcbiAgICogQWx3YXlzIGNoYW5nZSBwZXJtaXNzaW9uIGFuZCBvd25lcnNoaXAgb2YgdGhlIHZvbHVtZSB3aGVuIHZvbHVtZSBpcyBtb3VudGVkLlxuICAgKi9cbiAgQUxXQVlTID0gJ0Fsd2F5cydcbn1cblxuLyoqXG4gKiBDdXN0b20gRE5TIG9wdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEbnNPcHRpb24ge1xuXG4gIC8qKlxuICAgKiBPcHRpb24gbmFtZS5cbiAgICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogT3B0aW9uIHZhbHVlLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIE5vIHZhbHVlLlxuICAgKi9cbiAgcmVhZG9ubHkgdmFsdWU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUG9kIEROUyBwb2xpY2llcy5cbiAqL1xuZXhwb3J0IGVudW0gRG5zUG9saWN5IHtcblxuICAvKipcbiAgICogQW55IEROUyBxdWVyeSB0aGF0IGRvZXMgbm90IG1hdGNoIHRoZSBjb25maWd1cmVkIGNsdXN0ZXIgZG9tYWluIHN1ZmZpeCxcbiAgICogc3VjaCBhcyBcInd3dy5rdWJlcm5ldGVzLmlvXCIsIGlzIGZvcndhcmRlZCB0byB0aGVcbiAgICogdXBzdHJlYW0gbmFtZXNlcnZlciBpbmhlcml0ZWQgZnJvbSB0aGUgbm9kZS5cbiAgICogQ2x1c3RlciBhZG1pbmlzdHJhdG9ycyBtYXkgaGF2ZSBleHRyYSBzdHViLWRvbWFpbiBhbmQgdXBzdHJlYW0gRE5TIHNlcnZlcnMgY29uZmlndXJlZC5cbiAgICovXG4gIENMVVNURVJfRklSU1QgPSAnQ2x1c3RlckZpcnN0JyxcblxuICAvKipcbiAgICogRm9yIFBvZHMgcnVubmluZyB3aXRoIGhvc3ROZXR3b3JrLCB5b3Ugc2hvdWxkXG4gICAqIGV4cGxpY2l0bHkgc2V0IGl0cyBETlMgcG9saWN5IFwiQ2x1c3RlckZpcnN0V2l0aEhvc3ROZXRcIi5cbiAgICovXG4gIENMVVNURVJfRklSU1RfV0lUSF9IT1NUX05FVCA9ICdDbHVzdGVyRmlyc3RXaXRoSG9zdE5ldCcsXG5cbiAgLyoqXG4gICAqIFRoZSBQb2QgaW5oZXJpdHMgdGhlIG5hbWUgcmVzb2x1dGlvbiBjb25maWd1cmF0aW9uXG4gICAqIGZyb20gdGhlIG5vZGUgdGhhdCB0aGUgcG9kcyBydW4gb24uXG4gICAqL1xuICBERUZBVUxUID0gJ0RlZmF1bHQnLFxuXG4gIC8qKlxuICAgKiBJdCBhbGxvd3MgYSBQb2QgdG8gaWdub3JlIEROUyBzZXR0aW5ncyBmcm9tIHRoZSBLdWJlcm5ldGVzIGVudmlyb25tZW50LlxuICAgKiBBbGwgRE5TIHNldHRpbmdzIGFyZSBzdXBwb3NlZCB0byBiZSBwcm92aWRlZCB1c2luZyB0aGUgZG5zQ29uZmlnXG4gICAqIGZpZWxkIGluIHRoZSBQb2QgU3BlYy5cbiAgICovXG4gIE5PTkUgPSAnTm9uZScsXG5cbn1cblxuLyoqXG4gKiBIb3N0QWxpYXMgaG9sZHMgdGhlIG1hcHBpbmcgYmV0d2VlbiBJUCBhbmQgaG9zdG5hbWVzIHRoYXQgd2lsbCBiZSBpbmplY3RlZCBhc1xuICogYW4gZW50cnkgaW4gdGhlIHBvZCdzIC9ldGMvaG9zdHMgZmlsZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIb3N0QWxpYXMge1xuICAvKipcbiAgICogSG9zdG5hbWVzIGZvciB0aGUgY2hvc2VuIElQIGFkZHJlc3MuXG4gICAqL1xuICByZWFkb25seSBob3N0bmFtZXM6IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBJUCBhZGRyZXNzIG9mIHRoZSBob3N0IGZpbGUgZW50cnkuXG4gICAqL1xuICByZWFkb25seSBpcDogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBxdWVyeSB0aGF0IGNhbiBiZSBwZXJmb3JtZWQgYWdhaW5zdCBub2RlcyB3aXRoIGxhYmVscy5cbiAqL1xuZXhwb3J0IGNsYXNzIE5vZGVMYWJlbFF1ZXJ5IHtcblxuICAvKipcbiAgICogUmVxdWlyZXMgdmFsdWUgb2YgbGFiZWwgYGtleWAgdG8gZXF1YWwgYHZhbHVlYC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgaXMoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gTm9kZUxhYmVsUXVlcnkuaW4oa2V5LCBbdmFsdWVdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1aXJlcyB2YWx1ZSBvZiBsYWJlbCBga2V5YCB0byBiZSBvbmUgb2YgYHZhbHVlc2AuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGluKGtleTogc3RyaW5nLCB2YWx1ZXM6IHN0cmluZ1tdKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlTGFiZWxRdWVyeShrZXksICdJbicsIHZhbHVlcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWlyZXMgdmFsdWUgb2YgbGFiZWwgYGtleWAgdG8gYmUgbm9uZSBvZiBgdmFsdWVzYC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbm90SW4oa2V5OiBzdHJpbmcsIHZhbHVlczogc3RyaW5nW10pIHtcbiAgICByZXR1cm4gbmV3IE5vZGVMYWJlbFF1ZXJ5KGtleSwgJ05vdEluJywgdmFsdWVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1aXJlcyBsYWJlbCBga2V5YCB0byBleGlzdC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZXhpc3RzKGtleTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlTGFiZWxRdWVyeShrZXksICdFeGlzdHMnLCB1bmRlZmluZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVpcmVzIGxhYmVsIGBrZXlgIHRvIG5vdCBleGlzdC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZG9lc05vdEV4aXN0KGtleTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlTGFiZWxRdWVyeShrZXksICdEb2VzTm90RXhpc3QnLCB1bmRlZmluZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVpcmVzIHZhbHVlIG9mIGxhYmVsIGBrZXlgIHRvIGdyZWF0ZXIgdGhhbiBhbGwgZWxlbWVudHMgaW4gYHZhbHVlc2AuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGd0KGtleTogc3RyaW5nLCB2YWx1ZXM6IHN0cmluZ1tdKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlTGFiZWxRdWVyeShrZXksICdHdCcsIHZhbHVlcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWlyZXMgdmFsdWUgb2YgbGFiZWwgYGtleWAgdG8gbGVzcyB0aGFuIGFsbCBlbGVtZW50cyBpbiBgdmFsdWVzYC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbHQoa2V5OiBzdHJpbmcsIHZhbHVlczogc3RyaW5nW10pIHtcbiAgICByZXR1cm4gbmV3IE5vZGVMYWJlbFF1ZXJ5KGtleSwgJ0x0JywgdmFsdWVzKTtcbiAgfVxuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHJlYWRvbmx5IGtleTogc3RyaW5nLFxuICAgIHB1YmxpYyByZWFkb25seSBvcGVyYXRvcjogc3RyaW5nLFxuICAgIHB1YmxpYyByZWFkb25seSB2YWx1ZXM/OiBzdHJpbmdbXSkge1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHF1ZXJ5IHRoYXQgY2FuIGJlIHBlcmZvcm1lZCBhZ2FpbnN0IHJlc291cmNlcyB3aXRoIGxhYmVscy5cbiAqL1xuZXhwb3J0IGNsYXNzIExhYmVsRXhwcmVzc2lvbiB7XG5cbiAgLyoqXG4gICAqIFJlcXVpcmVzIHZhbHVlIG9mIGxhYmVsIGBrZXlgIHRvIGJlIG9uZSBvZiBgdmFsdWVzYC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgaW4oa2V5OiBzdHJpbmcsIHZhbHVlczogc3RyaW5nW10pIHtcbiAgICByZXR1cm4gbmV3IExhYmVsRXhwcmVzc2lvbihrZXksICdJbicsIHZhbHVlcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWlyZXMgdmFsdWUgb2YgbGFiZWwgYGtleWAgdG8gYmUgbm9uZSBvZiBgdmFsdWVzYC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbm90SW4oa2V5OiBzdHJpbmcsIHZhbHVlczogc3RyaW5nW10pIHtcbiAgICByZXR1cm4gbmV3IExhYmVsRXhwcmVzc2lvbihrZXksICdOb3RJbicsIHZhbHVlcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWlyZXMgbGFiZWwgYGtleWAgdG8gZXhpc3QuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGV4aXN0cyhrZXk6IHN0cmluZykge1xuICAgIHJldHVybiBuZXcgTGFiZWxFeHByZXNzaW9uKGtleSwgJ0V4aXN0cycsIHVuZGVmaW5lZCk7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWlyZXMgbGFiZWwgYGtleWAgdG8gbm90IGV4aXN0LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBkb2VzTm90RXhpc3Qoa2V5OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IExhYmVsRXhwcmVzc2lvbihrZXksICdEb2VzTm90RXhpc3QnLCB1bmRlZmluZWQpO1xuICB9XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcmVhZG9ubHkga2V5OiBzdHJpbmcsXG4gICAgcHVibGljIHJlYWRvbmx5IG9wZXJhdG9yOiBzdHJpbmcsXG4gICAgcHVibGljIHJlYWRvbmx5IHZhbHVlcz86IHN0cmluZ1tdKSB7XG4gIH1cblxufVxuXG4vKipcbiAqIFRhaW50IGVmZmVjdHMuXG4gKi9cbmV4cG9ydCBlbnVtIFRhaW50RWZmZWN0IHtcbiAgLyoqXG4gICAqIFRoaXMgbWVhbnMgdGhhdCBubyBwb2Qgd2lsbCBiZSBhYmxlIHRvIHNjaGVkdWxlXG4gICAqIG9udG8gdGhlIG5vZGUgdW5sZXNzIGl0IGhhcyBhIG1hdGNoaW5nIHRvbGVyYXRpb24uXG4gICAqL1xuICBOT19TQ0hFRFVMRSA9ICdOb1NjaGVkdWxlJyxcblxuICAvKipcbiAgICogVGhpcyBpcyBhIFwicHJlZmVyZW5jZVwiIG9yIFwic29mdFwiIHZlcnNpb24gb2YgYE5PX1NDSEVEVUxFYCAtLSB0aGUgc3lzdGVtXG4gICAqIHdpbGwgdHJ5IHRvIGF2b2lkIHBsYWNpbmcgYSBwb2QgdGhhdCBkb2VzIG5vdCB0b2xlcmF0ZSB0aGUgdGFpbnQgb24gdGhlIG5vZGUsXG4gICAqIGJ1dCBpdCBpcyBub3QgcmVxdWlyZWRcbiAgICovXG4gIFBSRUZFUl9OT19TQ0hFRFVMRSA9ICdQcmVmZXJOb1NjaGVkdWxlJyxcblxuICAvKipcbiAgICogVGhpcyBhZmZlY3RzIHBvZHMgdGhhdCBhcmUgYWxyZWFkeSBydW5uaW5nIG9uIHRoZSBub2RlIGFzIGZvbGxvd3M6XG4gICAqXG4gICAqIC0gUG9kcyB0aGF0IGRvIG5vdCB0b2xlcmF0ZSB0aGUgdGFpbnQgYXJlIGV2aWN0ZWQgaW1tZWRpYXRlbHkuXG4gICAqIC0gUG9kcyB0aGF0IHRvbGVyYXRlIHRoZSB0YWludCB3aXRob3V0IHNwZWNpZnlpbmcgYGR1cmF0aW9uYCByZW1haW4gYm91bmQgZm9yZXZlci5cbiAgICogLSBQb2RzIHRoYXQgdG9sZXJhdGUgdGhlIHRhaW50IHdpdGggYSBzcGVjaWZpZWQgYGR1cmF0aW9uYCByZW1haW4gYm91bmQgZm9yXG4gICAqICAgdGhlIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZS5cbiAgICovXG4gIE5PX0VYRUNVVEUgPSAnTm9FeGVjdXRlJyxcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBgTm9kZVRhaW50UXVlcnlgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5vZGVUYWludFF1ZXJ5T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgdGFpbnQgZWZmZWN0IHRvIG1hdGNoLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGFsbCBlZmZlY3RzIGFyZSBtYXRjaGVkLlxuICAgKi9cbiAgcmVhZG9ubHkgZWZmZWN0PzogVGFpbnRFZmZlY3Q7XG5cbiAgLyoqXG4gICAqIEhvdyBtdWNoIHRpbWUgc2hvdWxkIGEgcG9kIHRoYXQgdG9sZXJhdGVzIHRoZSBgTk9fRVhFQ1VURWAgZWZmZWN0XG4gICAqIGJlIGJvdW5kIHRvIHRoZSBub2RlLiBPbmx5IGFwcGxpZXMgZm9yIHRoZSBgTk9fRVhFQ1VURWAgZWZmZWN0LlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGJvdW5kIGZvcmV2ZXIuXG4gICAqL1xuICByZWFkb25seSBldmljdEFmdGVyPzogRHVyYXRpb247XG59XG5cbi8qKlxuICogVGFpbnQgcXVlcmllcyB0aGF0IGNhbiBiZSBwZXJmb21lZCBhZ2FpbnN0IG5vZGVzLlxuICovXG5leHBvcnQgY2xhc3MgTm9kZVRhaW50UXVlcnkge1xuXG4gIC8qKlxuICAgKiBNYXRjaGVzIGEgdGFpbnQgd2l0aCBhIHNwZWNpZmljIGtleSBhbmQgdmFsdWUuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGlzKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nLCBvcHRpb25zOiBOb2RlVGFpbnRRdWVyeU9wdGlvbnMgPSB7fSk6IE5vZGVUYWludFF1ZXJ5IHtcbiAgICByZXR1cm4gbmV3IE5vZGVUYWludFF1ZXJ5KCdFcXVhbCcsIGtleSwgdmFsdWUsIG9wdGlvbnMuZWZmZWN0LCBvcHRpb25zLmV2aWN0QWZ0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoZXMgYSB0YWluIHdpdGggYW55IHZhbHVlIG9mIGEgc3BlY2lmaWMga2V5LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBleGlzdHMoa2V5OiBzdHJpbmcsIG9wdGlvbnM6IE5vZGVUYWludFF1ZXJ5T3B0aW9ucyA9IHt9KTogTm9kZVRhaW50UXVlcnkge1xuICAgIHJldHVybiBuZXcgTm9kZVRhaW50UXVlcnkoJ0V4aXN0cycsIGtleSwgdW5kZWZpbmVkLCBvcHRpb25zLmVmZmVjdCwgb3B0aW9ucy5ldmljdEFmdGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXRjaGVzIGFueSB0YWludC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYW55KCk6IE5vZGVUYWludFF1ZXJ5IHtcbiAgICByZXR1cm4gbmV3IE5vZGVUYWludFF1ZXJ5KCdFeGlzdHMnKTtcbiAgfVxuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHJlYWRvbmx5IG9wZXJhdG9yOiBzdHJpbmcsXG4gICAgcHVibGljIHJlYWRvbmx5IGtleT86IHN0cmluZyxcbiAgICBwdWJsaWMgcmVhZG9ubHkgdmFsdWU/OiBzdHJpbmcsXG4gICAgcHVibGljIHJlYWRvbmx5IGVmZmVjdD86IHN0cmluZyxcbiAgICBwdWJsaWMgcmVhZG9ubHkgZXZpY3RBZnRlcj86IER1cmF0aW9uLFxuICApIHtcbiAgICBpZiAoZXZpY3RBZnRlciAmJiBlZmZlY3QgIT09IFRhaW50RWZmZWN0Lk5PX0VYRUNVVEUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBcXCdOT19FWEVDVVRFXFwnIGVmZmVjdHMgY2FuIHNwZWNpZnkgXFwnZXZpY3RBZnRlclxcJycpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGBQb2RzLmFsbGAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUG9kc0FsbE9wdGlvbnMge1xuXG4gIC8qKlxuICAgKiBOYW1lc3BhY2VzIHRoZSBwb2RzIGFyZSBhbGxvd2VkIHRvIGJlIGluLlxuICAgKiBVc2UgYE5hbWVzcGFjZXMuYWxsKClgIHRvIGFsbG93IGFsbCBuYW1lc3BhY2VzLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIHVuc2V0LCBpbXBsaWVzIHRoZSBuYW1lc3BhY2Ugb2YgdGhlIHJlc291cmNlIHRoaXMgc2VsZWN0aW9uIGlzIHVzZWQgaW4uXG4gICAqL1xuICByZWFkb25seSBuYW1lc3BhY2VzPzogbmFtZXNwYWNlLk5hbWVzcGFjZXM7XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYFBvZHMuc2VsZWN0YC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQb2RzU2VsZWN0T3B0aW9ucyB7XG5cbiAgLyoqXG4gICAqIExhYmVscyB0aGUgcG9kcyBtdXN0IGhhdmUuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gbm8gc3RyaWN0IGxhYmVscyByZXF1aXJlbWVudHMuXG4gICAqL1xuICByZWFkb25seSBsYWJlbHM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXG4gIC8qKlxuICAgICogRXhwcmVzc2lvbnMgdGhlIHBvZHMgbXVzdCBzYXRpc2lmeS5cbiAgICAqXG4gICAgKiBAZGVmYXVsdCAtIG5vIGV4cHJlc3Npb25zIHJlcXVpcmVtZW50cy5cbiAgICAqL1xuICByZWFkb25seSBleHByZXNzaW9ucz86IExhYmVsRXhwcmVzc2lvbltdO1xuXG4gIC8qKlxuICAgKiBOYW1lc3BhY2VzIHRoZSBwb2RzIGFyZSBhbGxvd2VkIHRvIGJlIGluLlxuICAgKiBVc2UgYE5hbWVzcGFjZXMuYWxsKClgIHRvIGFsbG93IGFsbCBuYW1lc3BhY2VzLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIHVuc2V0LCBpbXBsaWVzIHRoZSBuYW1lc3BhY2Ugb2YgdGhlIHJlc291cmNlIHRoaXMgc2VsZWN0aW9uIGlzIHVzZWQgaW4uXG4gICAqL1xuICByZWFkb25seSBuYW1lc3BhY2VzPzogbmFtZXNwYWNlLk5hbWVzcGFjZXM7XG5cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgZ3JvdXAgb2YgcG9kcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFBvZHMgZXh0ZW5kcyBDb25zdHJ1Y3QgaW1wbGVtZW50cyBJUG9kU2VsZWN0b3Ige1xuXG4gIC8qKlxuICAgKiBTZWxlY3QgcG9kcyBpbiB0aGUgY2x1c3RlciB3aXRoIHZhcmlvdXMgc2VsZWN0b3JzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBzZWxlY3Qoc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgb3B0aW9uczogUG9kc1NlbGVjdE9wdGlvbnMpOiBQb2RzIHtcbiAgICByZXR1cm4gbmV3IFBvZHMoc2NvcGUsIGlkLCBvcHRpb25zLmV4cHJlc3Npb25zLCBvcHRpb25zLmxhYmVscywgb3B0aW9ucy5uYW1lc3BhY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3QgYWxsIHBvZHMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFsbChzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBvcHRpb25zOiBQb2RzQWxsT3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIFBvZHMuc2VsZWN0KHNjb3BlLCBpZCwgeyBuYW1lc3BhY2VzOiBvcHRpb25zLm5hbWVzcGFjZXMgfSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZXhwcmVzc2lvbnM/OiBMYWJlbEV4cHJlc3Npb25bXSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGxhYmVscz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0sXG4gICAgcHJpdmF0ZSByZWFkb25seSBuYW1lc3BhY2VzPzogbmFtZXNwYWNlLklOYW1lc3BhY2VTZWxlY3Rvcikge1xuICAgIHN1cGVyKHNjb3BlLCBpZCk7XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBJUG9kU2VsZWN0b3IudG9Qb2RTZWxlY3RvckNvbmZpZygpXG4gICAqL1xuICBwdWJsaWMgdG9Qb2RTZWxlY3RvckNvbmZpZygpOiBQb2RTZWxlY3RvckNvbmZpZyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsU2VsZWN0b3I6IExhYmVsU2VsZWN0b3Iub2YoeyBleHByZXNzaW9uczogdGhpcy5leHByZXNzaW9ucywgbGFiZWxzOiB0aGlzLmxhYmVscyB9KSxcbiAgICAgIG5hbWVzcGFjZXM6IHRoaXMubmFtZXNwYWNlcz8udG9OYW1lc3BhY2VTZWxlY3RvckNvbmZpZygpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBJTmV0d29ya1BvbGljeVBlZXIudG9OZXR3b3JrUG9saWN5UGVlckNvbmZpZygpXG4gICAqL1xuICBwdWJsaWMgdG9OZXR3b3JrUG9saWN5UGVlckNvbmZpZygpOiBuZXR3b3JrcG9saWN5Lk5ldHdvcmtQb2xpY3lQZWVyQ29uZmlnIHtcbiAgICByZXR1cm4geyBwb2RTZWxlY3RvcjogdGhpcy50b1BvZFNlbGVjdG9yQ29uZmlnKCkgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIElOZXR3b3JrUG9saWN5UGVlci50b1BvZFNlbGVjdG9yKClcbiAgICovXG4gIHB1YmxpYyB0b1BvZFNlbGVjdG9yKCk6IElQb2RTZWxlY3RvciB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufVxuXG4vKipcbiAqIEEgbm9kZSB0aGF0IGlzIG1hdGNoZWQgYnkgbGFiZWwgc2VsZWN0b3JzLlxuICovXG5leHBvcnQgY2xhc3MgTGFiZWxlZE5vZGUge1xuICBwdWJsaWMgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGxhYmVsU2VsZWN0b3I6IE5vZGVMYWJlbFF1ZXJ5W10pIHt9O1xufVxuXG4vKipcbiAqIEEgbm9kZSB0aGF0IGlzIG1hdGNoZWQgYnkgdGFpbnQgc2VsZWN0b3JzLlxuICovXG5leHBvcnQgY2xhc3MgVGFpbnRlZE5vZGUge1xuICBwdWJsaWMgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IHRhaW50U2VsZWN0b3I6IE5vZGVUYWludFF1ZXJ5W10pIHt9O1xufVxuXG4vKipcbiAqIEEgbm9kZSB0aGF0IGlzIG1hdGNoZWQgYnkgaXRzIG5hbWUuXG4gKi9cbmV4cG9ydCBjbGFzcyBOYW1lZE5vZGUge1xuICBwdWJsaWMgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IG5hbWU6IHN0cmluZykge307XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIG5vZGUgaW4gdGhlIGNsdXN0ZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBOb2RlIHtcblxuICAvKipcbiAgICogTWF0Y2ggYSBub2RlIGJ5IGl0cyBsYWJlbHMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGxhYmVsZWQoLi4ubGFiZWxTZWxlY3RvcjogTm9kZUxhYmVsUXVlcnlbXSk6IExhYmVsZWROb2RlIHtcbiAgICByZXR1cm4gbmV3IExhYmVsZWROb2RlKGxhYmVsU2VsZWN0b3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoIGEgbm9kZSBieSBpdHMgbmFtZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbmFtZWQobm9kZU5hbWU6IHN0cmluZyk6IE5hbWVkTm9kZSB7XG4gICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUobm9kZU5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoIGEgbm9kZSBieSBpdHMgdGFpbnRzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyB0YWludGVkKC4uLnRhaW50U2VsZWN0b3I6IE5vZGVUYWludFF1ZXJ5W10pOiBUYWludGVkTm9kZSB7XG4gICAgcmV0dXJuIG5ldyBUYWludGVkTm9kZSh0YWludFNlbGVjdG9yKTtcbiAgfVxuXG59XG5cbi8qKlxuICogQXZhaWxhYmxlIHRvcG9sb2d5IGRvbWFpbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBUb3BvbG9neSB7XG5cbiAgLyoqXG4gICAqIEEgaG9zdG5hbWUgcmVwcmVzZW50cyBhIHNpbmdsZSBub2RlIGluIHRoZSBjbHVzdGVyLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL3JlZmVyZW5jZS9sYWJlbHMtYW5ub3RhdGlvbnMtdGFpbnRzLyNrdWJlcm5ldGVzaW9ob3N0bmFtZVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBIT1NUTkFNRSA9IG5ldyBUb3BvbG9neSgna3ViZXJuZXRlcy5pby9ob3N0bmFtZScpO1xuXG4gIC8qKlxuICAgKiBBIHpvbmUgcmVwcmVzZW50cyBhIGxvZ2ljYWwgZmFpbHVyZSBkb21haW4uIEl0IGlzIGNvbW1vbiBmb3IgS3ViZXJuZXRlcyBjbHVzdGVycyB0b1xuICAgKiBzcGFuIG11bHRpcGxlIHpvbmVzIGZvciBpbmNyZWFzZWQgYXZhaWxhYmlsaXR5LiBXaGlsZSB0aGUgZXhhY3QgZGVmaW5pdGlvbiBvZiBhIHpvbmUgaXNcbiAgICogbGVmdCB0byBpbmZyYXN0cnVjdHVyZSBpbXBsZW1lbnRhdGlvbnMsIGNvbW1vbiBwcm9wZXJ0aWVzIG9mIGEgem9uZSBpbmNsdWRlIHZlcnkgbG93XG4gICAqIG5ldHdvcmsgbGF0ZW5jeSB3aXRoaW4gYSB6b25lLCBuby1jb3N0IG5ldHdvcmsgdHJhZmZpYyB3aXRoaW4gYSB6b25lLCBhbmQgZmFpbHVyZVxuICAgKiBpbmRlcGVuZGVuY2UgZnJvbSBvdGhlciB6b25lcy4gRm9yIGV4YW1wbGUsIG5vZGVzIHdpdGhpbiBhIHpvbmUgbWlnaHQgc2hhcmUgYSBuZXR3b3JrXG4gICAqIHN3aXRjaCwgYnV0IG5vZGVzIGluIGRpZmZlcmVudCB6b25lcyBzaG91bGQgbm90LlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL3JlZmVyZW5jZS9sYWJlbHMtYW5ub3RhdGlvbnMtdGFpbnRzLyN0b3BvbG9neWt1YmVybmV0ZXNpb3pvbmVcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgWk9ORSA9IG5ldyBUb3BvbG9neSgndG9wb2xvZ3kua3ViZXJuZXRlcy5pby96b25lJyk7XG5cbiAgLyoqXG4gICAqIEEgcmVnaW9uIHJlcHJlc2VudHMgYSBsYXJnZXIgZG9tYWluLCBtYWRlIHVwIG9mIG9uZSBvciBtb3JlIHpvbmVzLiBJdCBpcyB1bmNvbW1vblxuICAgKiBmb3IgS3ViZXJuZXRlcyBjbHVzdGVycyB0byBzcGFuIG11bHRpcGxlIHJlZ2lvbnMuIFdoaWxlIHRoZSBleGFjdCBkZWZpbml0aW9uIG9mIGFcbiAgICogem9uZSBvciByZWdpb24gaXMgbGVmdCB0byBpbmZyYXN0cnVjdHVyZSBpbXBsZW1lbnRhdGlvbnMsIGNvbW1vbiBwcm9wZXJ0aWVzIG9mIGEgcmVnaW9uXG4gICAqIGluY2x1ZGUgaGlnaGVyIG5ldHdvcmsgbGF0ZW5jeSBiZXR3ZWVuIHRoZW0gdGhhbiB3aXRoaW4gdGhlbSwgbm9uLXplcm8gY29zdCBmb3IgbmV0d29ya1xuICAgKiB0cmFmZmljIGJldHdlZW4gdGhlbSwgYW5kIGZhaWx1cmUgaW5kZXBlbmRlbmNlIGZyb20gb3RoZXIgem9uZXMgb3IgcmVnaW9ucy5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIG5vZGVzIHdpdGhpbiBhIHJlZ2lvbiBtaWdodCBzaGFyZSBwb3dlciBpbmZyYXN0cnVjdHVyZSAoZS5nLiBhIFVQUyBvciBnZW5lcmF0b3IpLCBidXRcbiAgICogbm9kZXMgaW4gZGlmZmVyZW50IHJlZ2lvbnMgdHlwaWNhbGx5IHdvdWxkIG5vdC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9yZWZlcmVuY2UvbGFiZWxzLWFubm90YXRpb25zLXRhaW50cy8jdG9wb2xvZ3lrdWJlcm5ldGVzaW9yZWdpb25cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUkVHSU9OID0gbmV3IFRvcG9sb2d5KCd0b3BvbG9neS5rdWJlcm5ldGVzLmlvL3JlZ2lvbicpO1xuXG4gIC8qKlxuICAgKiBDdXN0b20ga2V5IGZvciB0aGUgbm9kZSBsYWJlbCB0aGF0IHRoZSBzeXN0ZW0gdXNlcyB0byBkZW5vdGUgdGhlIHRvcG9sb2d5IGRvbWFpbi5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgY3VzdG9tKGtleTogc3RyaW5nKTogVG9wb2xvZ3kge1xuICAgIHJldHVybiBuZXcgVG9wb2xvZ3koa2V5KTtcbiAgfVxuXG4gIHByaXZhdGUgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGtleTogc3RyaW5nKSB7fTtcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBgUG9kU2NoZWR1bGluZy5jb2xvY2F0ZWAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUG9kU2NoZWR1bGluZ0NvbG9jYXRlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBXaGljaCB0b3BvbG9neSB0byBjb2xvYXRlIG9uLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIFRvcG9sb2d5LkhPU1ROQU1FXG4gICAqL1xuICByZWFkb25seSB0b3BvbG9neT86IFRvcG9sb2d5O1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhlIGNvLWxvY2F0aW9uIGlzIG9wdGlvbmFsIChzb2Z0KSwgd2l0aCB0aGlzIHdlaWdodCBzY29yZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBubyB3ZWlnaHQuIGNvLWxvY2F0aW9uIGlzIGFzc3VtZWQgdG8gYmUgcmVxdWlyZWQgKGhhcmQpLlxuICAgKi9cbiAgcmVhZG9ubHkgd2VpZ2h0PzogbnVtYmVyO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGBQb2RTY2hlZHVsaW5nLnNlcGFyYXRlYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQb2RTY2hlZHVsaW5nU2VwYXJhdGVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFdoaWNoIHRvcG9sb2d5IHRvIHNlcGFyYXRlIG9uLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIFRvcG9sb2d5LkhPU1ROQU1FXG4gICAqL1xuICByZWFkb25seSB0b3BvbG9neT86IFRvcG9sb2d5O1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhlIHNlcGFyYXRpb24gaXMgb3B0aW9uYWwgKHNvZnQpLCB3aXRoIHRoaXMgd2VpZ2h0IHNjb3JlLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIG5vIHdlaWdodC4gc2VwYXJhdGlvbiBpcyBhc3N1bWVkIHRvIGJlIHJlcXVpcmVkIChoYXJkKS5cbiAgICovXG4gIHJlYWRvbmx5IHdlaWdodD86IG51bWJlcjtcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBgUG9kU2NoZWR1bGluZy5hdHRyYWN0YC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQb2RTY2hlZHVsaW5nQXR0cmFjdE9wdGlvbnMge1xuICAvKipcbiAgICogSW5kaWNhdGVzIHRoZSBhdHRyYWN0aW9uIGlzIG9wdGlvbmFsIChzb2Z0KSwgd2l0aCB0aGlzIHdlaWdodCBzY29yZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBubyB3ZWlnaHQuIGFzc2lnbm1lbnQgaXMgYXNzdW1lZCB0byBiZSByZXF1aXJlZCAoaGFyZCkuXG4gICAqL1xuICByZWFkb25seSB3ZWlnaHQ/OiBudW1iZXI7XG59XG5cbi8qKlxuICogQ29udHJvbHMgdGhlIHBvZCBzY2hlZHVsaW5nIHN0cmF0ZWd5LlxuICovXG5leHBvcnQgY2xhc3MgUG9kU2NoZWR1bGluZyB7XG5cbiAgcHJpdmF0ZSBfbm9kZUFmZmluaXR5UHJlZmVycmVkOiBrOHMuUHJlZmVycmVkU2NoZWR1bGluZ1Rlcm1bXSA9IFtdO1xuICBwcml2YXRlIF9ub2RlQWZmaW5pdHlSZXF1aXJlZDogazhzLk5vZGVTZWxlY3RvclRlcm1bXSA9IFtdO1xuICBwcml2YXRlIF9wb2RBZmZpbml0eVByZWZlcnJlZDogazhzLldlaWdodGVkUG9kQWZmaW5pdHlUZXJtW10gPSBbXTtcbiAgcHJpdmF0ZSBfcG9kQWZmaW5pdHlSZXF1aXJlZDogazhzLlBvZEFmZmluaXR5VGVybVtdID0gW107XG4gIHByaXZhdGUgX3BvZEFudGlBZmZpbml0eVByZWZlcnJlZDogazhzLldlaWdodGVkUG9kQWZmaW5pdHlUZXJtW10gPSBbXTtcbiAgcHJpdmF0ZSBfcG9kQW50aUFmZmluaXR5UmVxdWlyZWQ6IGs4cy5Qb2RBZmZpbml0eVRlcm1bXSA9IFtdO1xuICBwcml2YXRlIF90b2xlcmF0aW9uczogazhzLlRvbGVyYXRpb25bXSA9IFtdO1xuICBwcml2YXRlIF9ub2RlTmFtZT86IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgcmVhZG9ubHkgaW5zdGFuY2U6IEFic3RyYWN0UG9kKSB7fVxuXG4gIC8qKlxuICAgKiBBc3NpZ24gdGhpcyBwb2QgYSBzcGVjaWZpYyBub2RlIGJ5IG5hbWUuXG4gICAqXG4gICAqIFRoZSBzY2hlZHVsZXIgaWdub3JlcyB0aGUgUG9kLCBhbmQgdGhlIGt1YmVsZXQgb24gdGhlIG5hbWVkIG5vZGVcbiAgICogdHJpZXMgdG8gcGxhY2UgdGhlIFBvZCBvbiB0aGF0IG5vZGUuIE92ZXJydWxlcyBhbnkgYWZmaW5pdHkgcnVsZXMgb2YgdGhlIHBvZC5cbiAgICpcbiAgICogU29tZSBsaW1pdGF0aW9ucyBvZiBzdGF0aWMgYXNzaWdubWVudCBhcmU6XG4gICAqXG4gICAqIC0gSWYgdGhlIG5hbWVkIG5vZGUgZG9lcyBub3QgZXhpc3QsIHRoZSBQb2Qgd2lsbCBub3QgcnVuLCBhbmQgaW4gc29tZVxuICAgKiAgIGNhc2VzIG1heSBiZSBhdXRvbWF0aWNhbGx5IGRlbGV0ZWQuXG4gICAqIC0gSWYgdGhlIG5hbWVkIG5vZGUgZG9lcyBub3QgaGF2ZSB0aGUgcmVzb3VyY2VzIHRvIGFjY29tbW9kYXRlIHRoZSBQb2QsXG4gICAqICAgdGhlIFBvZCB3aWxsIGZhaWwgYW5kIGl0cyByZWFzb24gd2lsbCBpbmRpY2F0ZSB3aHksIGZvciBleGFtcGxlIE91dE9mbWVtb3J5IG9yIE91dE9mY3B1LlxuICAgKiAtIE5vZGUgbmFtZXMgaW4gY2xvdWQgZW52aXJvbm1lbnRzIGFyZSBub3QgYWx3YXlzIHByZWRpY3RhYmxlIG9yIHN0YWJsZS5cbiAgICpcbiAgICogV2lsbCB0aHJvdyBpcyB0aGUgcG9kIGlzIGFscmVhZHkgYXNzaWduZWQgdG8gbmFtZWQgbm9kZS5cbiAgICpcbiAgICogVW5kZXIgdGhlIGhvb2QsIHRoaXMgbWV0aG9kIHV0aWxpemVzIHRoZSBgbm9kZU5hbWVgIHByb3BlcnR5LlxuICAgKi9cbiAgcHVibGljIGFzc2lnbihub2RlOiBOYW1lZE5vZGUpIHtcblxuICAgIGlmICh0aGlzLl9ub2RlTmFtZSkge1xuICAgICAgLy8gZGlzYWxsb3cgb3ZlcnJpZGluZyBhbiBzdGF0aWMgbm9kZSBhc3NpZ25tZW50XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBhc3NpZ24gJHt0aGlzLmluc3RhbmNlLnBvZE1ldGFkYXRhLm5hbWV9IHRvIG5vZGUgJHtub2RlLm5hbWV9LiBJdCBpcyBhbHJlYWR5IGFzc2lnbmVkIHRvIG5vZGUgJHt0aGlzLl9ub2RlTmFtZX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbm9kZU5hbWUgPSBub2RlLm5hbWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93IHRoaXMgcG9kIHRvIHRvbGVyYXRlIHRhaW50cyBtYXRjaGluZyB0aGVzZSB0b2xlcmF0aW9ucy5cbiAgICpcbiAgICogWW91IGNhbiBwdXQgbXVsdGlwbGUgdGFpbnRzIG9uIHRoZSBzYW1lIG5vZGUgYW5kIG11bHRpcGxlIHRvbGVyYXRpb25zIG9uIHRoZSBzYW1lIHBvZC5cbiAgICogVGhlIHdheSBLdWJlcm5ldGVzIHByb2Nlc3NlcyBtdWx0aXBsZSB0YWludHMgYW5kIHRvbGVyYXRpb25zIGlzIGxpa2UgYSBmaWx0ZXI6IHN0YXJ0IHdpdGhcbiAgICogYWxsIG9mIGEgbm9kZSdzIHRhaW50cywgdGhlbiBpZ25vcmUgdGhlIG9uZXMgZm9yIHdoaWNoIHRoZSBwb2QgaGFzIGEgbWF0Y2hpbmcgdG9sZXJhdGlvbjtcbiAgICogdGhlIHJlbWFpbmluZyB1bi1pZ25vcmVkIHRhaW50cyBoYXZlIHRoZSBpbmRpY2F0ZWQgZWZmZWN0cyBvbiB0aGUgcG9kLiBJbiBwYXJ0aWN1bGFyOlxuICAgKlxuICAgKiAtIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSB1bi1pZ25vcmVkIHRhaW50IHdpdGggZWZmZWN0IE5vU2NoZWR1bGUgdGhlbiBLdWJlcm5ldGVzIHdpbGxcbiAgICogICBub3Qgc2NoZWR1bGUgdGhlIHBvZCBvbnRvIHRoYXQgbm9kZVxuICAgKiAtIGlmIHRoZXJlIGlzIG5vIHVuLWlnbm9yZWQgdGFpbnQgd2l0aCBlZmZlY3QgTm9TY2hlZHVsZSBidXQgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIHVuLWlnbm9yZWRcbiAgICogICB0YWludCB3aXRoIGVmZmVjdCBQcmVmZXJOb1NjaGVkdWxlIHRoZW4gS3ViZXJuZXRlcyB3aWxsIHRyeSB0byBub3Qgc2NoZWR1bGUgdGhlIHBvZCBvbnRvIHRoZSBub2RlXG4gICAqIC0gaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIHVuLWlnbm9yZWQgdGFpbnQgd2l0aCBlZmZlY3QgTm9FeGVjdXRlIHRoZW4gdGhlIHBvZCB3aWxsIGJlIGV2aWN0ZWQgZnJvbVxuICAgKiAgIHRoZSBub2RlIChpZiBpdCBpcyBhbHJlYWR5IHJ1bm5pbmcgb24gdGhlIG5vZGUpLCBhbmQgd2lsbCBub3QgYmUgc2NoZWR1bGVkIG9udG8gdGhlIG5vZGUgKGlmIGl0IGlzXG4gICAqICAgbm90IHlldCBydW5uaW5nIG9uIHRoZSBub2RlKS5cbiAgICpcbiAgICogVW5kZXIgdGhlIGhvb2QsIHRoaXMgbWV0aG9kIHV0aWxpemVzIHRoZSBgdG9sZXJhdGlvbnNgIHByb3BlcnR5LlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3NjaGVkdWxpbmctZXZpY3Rpb24vdGFpbnQtYW5kLXRvbGVyYXRpb24vXG4gICAqL1xuICBwdWJsaWMgdG9sZXJhdGUobm9kZTogVGFpbnRlZE5vZGUpIHtcbiAgICBmb3IgKGNvbnN0IHF1ZXJ5IG9mIG5vZGUudGFpbnRTZWxlY3Rvcikge1xuXG4gICAgICB0aGlzLl90b2xlcmF0aW9ucy5wdXNoKHtcbiAgICAgICAga2V5OiBxdWVyeS5rZXksXG4gICAgICAgIHZhbHVlOiBxdWVyeS52YWx1ZSxcbiAgICAgICAgZWZmZWN0OiBxdWVyeS5lZmZlY3QsXG4gICAgICAgIG9wZXJhdG9yOiBxdWVyeS5vcGVyYXRvcixcbiAgICAgICAgdG9sZXJhdGlvblNlY29uZHM6IHF1ZXJ5LmV2aWN0QWZ0ZXI/LnRvU2Vjb25kcygpLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEF0dHJhY3QgdGhpcyBwb2QgdG8gYSBub2RlIG1hdGNoZWQgYnkgc2VsZWN0b3JzLlxuICAgKiBZb3UgY2FuIHNlbGVjdCBhIG5vZGUgYnkgdXNpbmcgYE5vZGUubGFiZWxlZCgpYC5cbiAgICpcbiAgICogQXR0cmFjdGluZyB0byBtdWx0aXBsZSBub2RlcyAoaS5lIGludm9raW5nIHRoaXMgbWV0aG9kIG11bHRpcGxlIHRpbWVzKSBhY3RzIGFzXG4gICAqIGFuIE9SIGNvbmRpdGlvbiwgbWVhbmluZyB0aGUgcG9kIHdpbGwgYmUgYXNzaWduZWQgdG8gZWl0aGVyIG9uZSBvZiB0aGUgbm9kZXMuXG4gICAqXG4gICAqIFVuZGVyIHRoZSBob29kLCB0aGlzIG1ldGhvZCB1dGlsaXplcyB0aGUgYG5vZGVBZmZpbml0eWAgcHJvcGVydHkuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvc2NoZWR1bGluZy1ldmljdGlvbi9hc3NpZ24tcG9kLW5vZGUvI25vZGUtYWZmaW5pdHlcbiAgICovXG4gIHB1YmxpYyBhdHRyYWN0KG5vZGU6IExhYmVsZWROb2RlLCBvcHRpb25zOiBQb2RTY2hlZHVsaW5nQXR0cmFjdE9wdGlvbnMgPSB7fSkge1xuXG4gICAgY29uc3QgdGVybSA9IHRoaXMuY3JlYXRlTm9kZUFmZmluaXR5VGVybShub2RlKTtcblxuICAgIGlmIChvcHRpb25zLndlaWdodCkge1xuICAgICAgdGhpcy52YWxpZGF0ZVdlaWdodChvcHRpb25zLndlaWdodCk7XG4gICAgICB0aGlzLl9ub2RlQWZmaW5pdHlQcmVmZXJyZWQucHVzaCh7IHdlaWdodDogb3B0aW9ucy53ZWlnaHQsIHByZWZlcmVuY2U6IHRlcm0gfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX25vZGVBZmZpbml0eVJlcXVpcmVkLnB1c2godGVybSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvLWxvY2F0ZSB0aGlzIHBvZCB3aXRoIGEgc2NoZWR1bGluZyBzZWxlY3Rpb24uXG4gICAqXG4gICAqIEEgc2VsZWN0aW9uIGNhbiBiZSBvbmUgb2Y6XG4gICAqXG4gICAqIC0gQW4gaW5zdGFuY2Ugb2YgYSBgUG9kYC5cbiAgICogLSBBbiBpbnN0YW5jZSBvZiBhIGBXb3JrbG9hZGAgKGUuZyBgRGVwbG95bWVudGAsIGBTdGF0ZWZ1bFNldGApLlxuICAgKiAtIEFuIHVuLW1hbmFnZWQgcG9kIHRoYXQgY2FuIGJlIHNlbGVjdGVkIHZpYSBgUG9kcy5zZWxlY3QoKWAuXG4gICAqXG4gICAqIENvLWxvY2F0aW5nIHdpdGggbXVsdGlwbGUgc2VsZWN0aW9ucyAoKGkuZSBpbnZva2luZyB0aGlzIG1ldGhvZCBtdWx0aXBsZSB0aW1lcykpIGFjdHMgYXNcbiAgICogYW4gQU5EIGNvbmRpdGlvbi4gbWVhbmluZyB0aGUgcG9kIHdpbGwgYmUgYXNzaWduZWQgdG8gYSBub2RlIHRoYXQgc2F0aXNmaWVzIGFsbFxuICAgKiBzZWxlY3Rpb25zIChpLmUgcnVucyBhdCBsZWFzdCBvbmUgcG9kIHRoYXQgc2F0aXNpZmllcyBlYWNoIHNlbGVjdGlvbikuXG4gICAqXG4gICAqIFVuZGVyIHRoZSBob29kLCB0aGlzIG1ldGhvZCB1dGlsaXplcyB0aGUgYHBvZEFmZmluaXR5YCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zY2hlZHVsaW5nLWV2aWN0aW9uL2Fzc2lnbi1wb2Qtbm9kZS8jaW50ZXItcG9kLWFmZmluaXR5LWFuZC1hbnRpLWFmZmluaXR5XG4gICAqL1xuICBwdWJsaWMgY29sb2NhdGUoc2VsZWN0b3I6IElQb2RTZWxlY3Rvciwgb3B0aW9uczogUG9kU2NoZWR1bGluZ0NvbG9jYXRlT3B0aW9ucyA9IHt9KSB7XG5cbiAgICBjb25zdCB0b3BvbG9neSA9IG9wdGlvbnMudG9wb2xvZ3kgPz8gVG9wb2xvZ3kuSE9TVE5BTUU7XG4gICAgY29uc3QgdGVybSA9IHRoaXMuY3JlYXRlUG9kQWZmaW5pdHlUZXJtKHRvcG9sb2d5LCBzZWxlY3Rvcik7XG5cbiAgICBpZiAob3B0aW9ucy53ZWlnaHQpIHtcbiAgICAgIHRoaXMudmFsaWRhdGVXZWlnaHQob3B0aW9ucy53ZWlnaHQpO1xuICAgICAgdGhpcy5fcG9kQWZmaW5pdHlQcmVmZXJyZWQucHVzaCh7IHdlaWdodDogb3B0aW9ucy53ZWlnaHQsIHBvZEFmZmluaXR5VGVybTogdGVybSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcG9kQWZmaW5pdHlSZXF1aXJlZC5wdXNoKHRlcm0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXBlcmF0ZSB0aGlzIHBvZCBmcm9tIGEgc2NoZWR1bGluZyBzZWxlY3Rpb24uXG4gICAqXG4gICAqIEEgc2VsZWN0aW9uIGNhbiBiZSBvbmUgb2Y6XG4gICAqXG4gICAqIC0gQW4gaW5zdGFuY2Ugb2YgYSBgUG9kYC5cbiAgICogLSBBbiBpbnN0YW5jZSBvZiBhIGBXb3JrbG9hZGAgKGUuZyBgRGVwbG95bWVudGAsIGBTdGF0ZWZ1bFNldGApLlxuICAgKiAtIEFuIHVuLW1hbmFnZWQgcG9kIHRoYXQgY2FuIGJlIHNlbGVjdGVkIHZpYSBgUG9kcy5zZWxlY3QoKWAuXG4gICAqXG4gICAqIFNlcGVyYXRpbmcgZnJvbSBtdWx0aXBsZSBzZWxlY3Rpb25zIGFjdHMgYXMgYW4gQU5EIGNvbmRpdGlvbi4gbWVhbmluZyB0aGUgcG9kXG4gICAqIHdpbGwgbm90IGJlIGFzc2lnbmVkIHRvIGEgbm9kZSB0aGF0IHNhdGlzZmllcyBhbGwgc2VsZWN0aW9ucyAoaS5lIHJ1bnMgYXQgbGVhc3Qgb25lIHBvZCB0aGF0IHNhdGlzaWZpZXMgZWFjaCBzZWxlY3Rpb24pLlxuICAgKlxuICAgKiBVbmRlciB0aGUgaG9vZCwgdGhpcyBtZXRob2QgdXRpbGl6ZXMgdGhlIGBwb2RBbnRpQWZmaW5pdHlgIHByb3BlcnR5LlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3NjaGVkdWxpbmctZXZpY3Rpb24vYXNzaWduLXBvZC1ub2RlLyNpbnRlci1wb2QtYWZmaW5pdHktYW5kLWFudGktYWZmaW5pdHlcbiAgICovXG4gIHB1YmxpYyBzZXBhcmF0ZShzZWxlY3RvcjogSVBvZFNlbGVjdG9yLCBvcHRpb25zOiBQb2RTY2hlZHVsaW5nU2VwYXJhdGVPcHRpb25zID0ge30pIHtcblxuICAgIGNvbnN0IHRvcG9sb2d5ID0gb3B0aW9ucy50b3BvbG9neSA/PyBUb3BvbG9neS5IT1NUTkFNRTtcbiAgICBjb25zdCB0ZXJtID0gdGhpcy5jcmVhdGVQb2RBZmZpbml0eVRlcm0odG9wb2xvZ3ksIHNlbGVjdG9yKTtcblxuICAgIGlmIChvcHRpb25zLndlaWdodCkge1xuICAgICAgdGhpcy52YWxpZGF0ZVdlaWdodChvcHRpb25zLndlaWdodCk7XG4gICAgICB0aGlzLl9wb2RBbnRpQWZmaW5pdHlQcmVmZXJyZWQucHVzaCh7IHdlaWdodDogb3B0aW9ucy53ZWlnaHQsIHBvZEFmZmluaXR5VGVybTogdGVybSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcG9kQW50aUFmZmluaXR5UmVxdWlyZWQucHVzaCh0ZXJtKTtcbiAgICB9XG5cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlUG9kQWZmaW5pdHlUZXJtKHRvcG9sb2d5OiBUb3BvbG9neSwgc2VsZWN0b3I6IElQb2RTZWxlY3Rvcik6IGs4cy5Qb2RBZmZpbml0eVRlcm0ge1xuICAgIGNvbnN0IGNvbmZpZyA9IHNlbGVjdG9yLnRvUG9kU2VsZWN0b3JDb25maWcoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wb2xvZ3lLZXk6IHRvcG9sb2d5LmtleSxcbiAgICAgIGxhYmVsU2VsZWN0b3I6IGNvbmZpZy5sYWJlbFNlbGVjdG9yLl90b0t1YmUoKSxcbiAgICAgIG5hbWVzcGFjZVNlbGVjdG9yOiBjb25maWcubmFtZXNwYWNlcz8ubGFiZWxTZWxlY3Rvcj8uX3RvS3ViZSgpLFxuICAgICAgbmFtZXNwYWNlczogY29uZmlnLm5hbWVzcGFjZXM/Lm5hbWVzLFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZU5vZGVBZmZpbml0eVRlcm0obm9kZTogTGFiZWxlZE5vZGUpOiBrOHMuTm9kZVNlbGVjdG9yVGVybSB7XG4gICAgcmV0dXJuIHsgbWF0Y2hFeHByZXNzaW9uczogbm9kZS5sYWJlbFNlbGVjdG9yLm1hcChzID0+ICh7IGtleTogcy5rZXksIG9wZXJhdG9yOiBzLm9wZXJhdG9yISwgdmFsdWVzOiBzLnZhbHVlcyB9KSkgfTtcbiAgfVxuXG4gIHByaXZhdGUgdmFsaWRhdGVXZWlnaHQod2VpZ2h0OiBudW1iZXIpIHtcbiAgICBpZiAod2VpZ2h0IDwgMSB8fCB3ZWlnaHQgPiAxMDApIHtcbiAgICAgIC8vIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3NjaGVkdWxpbmctZXZpY3Rpb24vYXNzaWduLXBvZC1ub2RlLyNub2RlLWFmZmluaXR5LXdlaWdodFxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFmZmluaXR5IHdlaWdodDogJHt3ZWlnaHR9LiBNdXN0IGJlIGluIHJhbmdlIDEtMTAwYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHVibGljIF90b0t1YmUoKTogeyBhZmZpbml0eT86IGs4cy5BZmZpbml0eTsgbm9kZU5hbWU/OiBzdHJpbmc7IHRvbGVyYXRpb25zPzogazhzLlRvbGVyYXRpb25bXSB9IHtcblxuICAgIGNvbnN0IGF0TGVhc3RPbmUgPSAoLi4uYXJyYXlzOiBBcnJheTxhbnk+W10pID0+IHtcbiAgICAgIHJldHVybiBhcnJheXMuZmxhdCgpLmxlbmd0aCA+IDA7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhc05vZGVBZmZpbml0eSA9IGF0TGVhc3RPbmUodGhpcy5fbm9kZUFmZmluaXR5UHJlZmVycmVkLCB0aGlzLl9ub2RlQWZmaW5pdHlSZXF1aXJlZCk7XG4gICAgY29uc3QgaGFzUG9kQWZmaW5pdHkgPSBhdExlYXN0T25lKHRoaXMuX3BvZEFmZmluaXR5UHJlZmVycmVkLCB0aGlzLl9wb2RBZmZpbml0eVJlcXVpcmVkKTtcbiAgICBjb25zdCBoYXNQb2RBbnRpQWZmaW50eSA9IGF0TGVhc3RPbmUodGhpcy5fcG9kQW50aUFmZmluaXR5UHJlZmVycmVkLCB0aGlzLl9wb2RBbnRpQWZmaW5pdHlSZXF1aXJlZCk7XG4gICAgY29uc3QgaGFzQWZmaW5pdHkgPSBoYXNOb2RlQWZmaW5pdHkgfHwgaGFzUG9kQWZmaW5pdHkgfHwgaGFzUG9kQW50aUFmZmludHk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWZmaW5pdHk6IGhhc0FmZmluaXR5ID8ge1xuICAgICAgICBub2RlQWZmaW5pdHk6IGhhc05vZGVBZmZpbml0eSA/IHtcbiAgICAgICAgICBwcmVmZXJyZWREdXJpbmdTY2hlZHVsaW5nSWdub3JlZER1cmluZ0V4ZWN1dGlvbjogdW5kZWZpbmVkSWZFbXB0eSh0aGlzLl9ub2RlQWZmaW5pdHlQcmVmZXJyZWQpLFxuICAgICAgICAgIHJlcXVpcmVkRHVyaW5nU2NoZWR1bGluZ0lnbm9yZWREdXJpbmdFeGVjdXRpb246IHRoaXMuX25vZGVBZmZpbml0eVJlcXVpcmVkLmxlbmd0aCA+IDAgPyB7XG4gICAgICAgICAgICBub2RlU2VsZWN0b3JUZXJtczogdGhpcy5fbm9kZUFmZmluaXR5UmVxdWlyZWQsXG4gICAgICAgICAgfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgcG9kQWZmaW5pdHk6IGhhc1BvZEFmZmluaXR5ID8ge1xuICAgICAgICAgIHByZWZlcnJlZER1cmluZ1NjaGVkdWxpbmdJZ25vcmVkRHVyaW5nRXhlY3V0aW9uOiB1bmRlZmluZWRJZkVtcHR5KHRoaXMuX3BvZEFmZmluaXR5UHJlZmVycmVkKSxcbiAgICAgICAgICByZXF1aXJlZER1cmluZ1NjaGVkdWxpbmdJZ25vcmVkRHVyaW5nRXhlY3V0aW9uOiB1bmRlZmluZWRJZkVtcHR5KHRoaXMuX3BvZEFmZmluaXR5UmVxdWlyZWQpLFxuICAgICAgICB9IDogdW5kZWZpbmVkLFxuICAgICAgICBwb2RBbnRpQWZmaW5pdHk6IGhhc1BvZEFudGlBZmZpbnR5ID8ge1xuICAgICAgICAgIHByZWZlcnJlZER1cmluZ1NjaGVkdWxpbmdJZ25vcmVkRHVyaW5nRXhlY3V0aW9uOiB1bmRlZmluZWRJZkVtcHR5KHRoaXMuX3BvZEFudGlBZmZpbml0eVByZWZlcnJlZCksXG4gICAgICAgICAgcmVxdWlyZWREdXJpbmdTY2hlZHVsaW5nSWdub3JlZER1cmluZ0V4ZWN1dGlvbjogdW5kZWZpbmVkSWZFbXB0eSh0aGlzLl9wb2RBbnRpQWZmaW5pdHlSZXF1aXJlZCksXG4gICAgICAgIH0gOiB1bmRlZmluZWQsXG4gICAgICB9IDogdW5kZWZpbmVkLFxuICAgICAgbm9kZU5hbWU6IHRoaXMuX25vZGVOYW1lLFxuICAgICAgdG9sZXJhdGlvbnM6IHVuZGVmaW5lZElmRW1wdHkodGhpcy5fdG9sZXJhdGlvbnMpLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBJc29sYXRpb24gZGV0ZXJtaW5lcyB3aGljaCBwb2xpY2llcyBhcmUgY3JlYXRlZFxuICogd2hlbiBhbGxvd2luZyBjb25uZWN0aW9ucyBmcm9tIGEgYSBwb2QgLyB3b3JrbG9hZCB0byBwZWVycy5cbiAqL1xuZXhwb3J0IGVudW0gUG9kQ29ubmVjdGlvbnNJc29sYXRpb24ge1xuXG4gIC8qKlxuICAgKiBPbmx5IGNyZWF0ZXMgbmV0d29yayBwb2xpY2llcyB0aGF0IHNlbGVjdCB0aGUgcG9kLlxuICAgKi9cbiAgUE9EID0gJ1BPRCcsXG5cbiAgLyoqXG4gICAqIE9ubHkgY3JlYXRlcyBuZXR3b3JrIHBvbGljaWVzIHRoYXQgc2VsZWN0IHRoZSBwZWVyLlxuICAgKi9cbiAgUEVFUiA9ICdQRUVSJyxcblxufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGBQb2RDb25uZWN0aW9ucy5hbGxvd1RvYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQb2RDb25uZWN0aW9uc0FsbG93VG9PcHRpb25zIHtcblxuICAvKipcbiAgICogV2hpY2ggaXNvbGF0aW9uIHNob3VsZCBiZSBhcHBsaWVkIHRvIGVzdGFibGlzaCB0aGUgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQGRlZmF1bHQgLSB1bnNldCwgaXNvbGF0ZXMgYm90aCB0aGUgcG9kIGFuZCB0aGUgcGVlci5cbiAgICovXG4gIHJlYWRvbmx5IGlzb2xhdGlvbj86IFBvZENvbm5lY3Rpb25zSXNvbGF0aW9uO1xuXG4gIC8qKlxuICAgKiBQb3J0cyB0byBhbGxvdyBvdXRnb2luZyB0cmFmZmljIHRvLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIElmIHRoZSBwZWVyIGlzIGEgbWFuYWdlZCBwb2QsIHRha2UgaXRzIHBvcnRzLiBPdGhlcndpc2UsIGFsbCBwb3J0cyBhcmUgYWxsb3dlZC5cbiAgICovXG4gIHJlYWRvbmx5IHBvcnRzPzogbmV0d29ya3BvbGljeS5OZXR3b3JrUG9saWN5UG9ydFtdO1xuXG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYFBvZENvbm5lY3Rpb25zLmFsbG93RnJvbWAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUG9kQ29ubmVjdGlvbnNBbGxvd0Zyb21PcHRpb25zIHtcblxuICAvKipcbiAgICogV2hpY2ggaXNvbGF0aW9uIHNob3VsZCBiZSBhcHBsaWVkIHRvIGVzdGFibGlzaCB0aGUgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQGRlZmF1bHQgLSB1bnNldCwgaXNvbGF0ZXMgYm90aCB0aGUgcG9kIGFuZCB0aGUgcGVlci5cbiAgICovXG4gIHJlYWRvbmx5IGlzb2xhdGlvbj86IFBvZENvbm5lY3Rpb25zSXNvbGF0aW9uO1xuXG4gIC8qKlxuICAgKiBQb3J0cyB0byBhbGxvdyBpbmNvbWluZyB0cmFmZmljIHRvLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIFRoZSBwb2QgcG9ydHMuXG4gICAqL1xuICByZWFkb25seSBwb3J0cz86IG5ldHdvcmtwb2xpY3kuTmV0d29ya1BvbGljeVBvcnRbXTtcblxufVxuXG4vKipcbiAqIENvbnRyb2xzIG5ldHdvcmsgaXNvbGF0aW9uIHJ1bGVzIGZvciBpbnRlci1wb2QgY29tbXVuaWNhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFBvZENvbm5lY3Rpb25zIHtcblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgcmVhZG9ubHkgaW5zdGFuY2U6IEFic3RyYWN0UG9kKSB7fVxuXG4gIC8qKlxuICAgKiBBbGxvdyBuZXR3b3JrIHRyYWZmaWMgZnJvbSB0aGlzIHBvZCB0byB0aGUgcGVlci5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhpcyB3aWxsIGNyZWF0ZSBhbiBlZ3Jlc3MgbmV0d29yayBwb2xpY3kgZm9yIHRoaXMgcG9kLCBhbmQgYW4gaW5ncmVzc1xuICAgKiBuZXR3b3JrIHBvbGljeSBmb3IgdGhlIHBlZXIuIFRoaXMgaXMgcmVxdWlyZWQgaWYgYm90aCBzaWRlcyBhcmUgYWxyZWFkeSBpc29sYXRlZC5cbiAgICogVXNlIGBvcHRpb25zLmlzb2xhdGlvbmAgdG8gY29udHJvbCB0aGlzIGJlaGF2aW9yLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAvLyBjcmVhdGUgb25seSBhbiBlZ3Jlc3MgcG9saWN5IHRoYXQgc2VsZWN0cyB0aGUgJ3dlYicgcG9kIHRvIGFsbG93IG91dGdvaW5nIHRyYWZmaWNcbiAgICogLy8gdG8gdGhlICdyZWRpcycgcG9kLiB0aGlzIHJlcXVpcmVzIHRoZSAncmVkaXMnIHBvZCB0byBub3QgYmUgaXNvbGF0ZWQgZm9yIGluZ3Jlc3MuXG4gICAqIHdlYi5jb25uZWN0aW9ucy5hbGxvd1RvKHJlZGlzLCB7IGlzb2xhdGlvbjogSXNvbGF0aW9uLlBPRCB9KVxuICAgKlxuICAgKiAvLyBjcmVhdGUgb25seSBhbiBpbmdyZXNzIHBvbGljeSB0aGF0IHNlbGVjdHMgdGhlICdyZWRpcycgcGVlciB0byBhbGxvdyBpbmNvbWluZyB0cmFmZmljXG4gICAqIC8vIGZyb20gdGhlICd3ZWInIHBvZC4gdGhpcyByZXF1aXJlcyB0aGUgJ3dlYicgcG9kIHRvIG5vdCBiZSBpc29sYXRlZCBmb3IgZWdyZXNzLlxuICAgKiB3ZWIuY29ubmVjdGlvbnMuYWxsb3dUbyhyZWRpcywgeyBpc29sYXRpb246IElzb2xhdGlvbi5QRUVSIH0pXG4gICAqXG4gICAqL1xuICBwdWJsaWMgYWxsb3dUbyhwZWVyOiBuZXR3b3JrcG9saWN5LklOZXR3b3JrUG9saWN5UGVlciwgb3B0aW9uczogUG9kQ29ubmVjdGlvbnNBbGxvd1RvT3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsb3coJ0VncmVzcycsIHBlZXIsIHsgcG9ydHM6IHRoaXMuZXh0cmFjdFBvcnRzKHBlZXIpLCAuLi5vcHRpb25zIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93IG5ldHdvcmsgdHJhZmZpYyBmcm9tIHRoZSBwZWVyIHRvIHRoaXMgcG9kLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIHdpbGwgY3JlYXRlIGFuIGluZ3Jlc3MgbmV0d29yayBwb2xpY3kgZm9yIHRoaXMgcG9kLCBhbmQgYW4gZWdyZXNzXG4gICAqIG5ldHdvcmsgcG9saWN5IGZvciB0aGUgcGVlci4gVGhpcyBpcyByZXF1aXJlZCBpZiBib3RoIHNpZGVzIGFyZSBhbHJlYWR5IGlzb2xhdGVkLlxuICAgKiBVc2UgYG9wdGlvbnMuaXNvbGF0aW9uYCB0byBjb250cm9sIHRoaXMgYmVoYXZpb3IuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIC8vIGNyZWF0ZSBvbmx5IGFuIGVncmVzcyBwb2xpY3kgdGhhdCBzZWxlY3RzIHRoZSAnd2ViJyBwb2QgdG8gYWxsb3cgb3V0Z29pbmcgdHJhZmZpY1xuICAgKiAvLyB0byB0aGUgJ3JlZGlzJyBwb2QuIHRoaXMgcmVxdWlyZXMgdGhlICdyZWRpcycgcG9kIHRvIG5vdCBiZSBpc29sYXRlZCBmb3IgaW5ncmVzcy5cbiAgICogcmVkaXMuY29ubmVjdGlvbnMuYWxsb3dGcm9tKHdlYiwgeyBpc29sYXRpb246IElzb2xhdGlvbi5QRUVSIH0pXG4gICAqXG4gICAqIC8vIGNyZWF0ZSBvbmx5IGFuIGluZ3Jlc3MgcG9saWN5IHRoYXQgc2VsZWN0cyB0aGUgJ3JlZGlzJyBwZWVyIHRvIGFsbG93IGluY29taW5nIHRyYWZmaWNcbiAgICogLy8gZnJvbSB0aGUgJ3dlYicgcG9kLiB0aGlzIHJlcXVpcmVzIHRoZSAnd2ViJyBwb2QgdG8gbm90IGJlIGlzb2xhdGVkIGZvciBlZ3Jlc3MuXG4gICAqIHJlZGlzLmNvbm5lY3Rpb25zLmFsbG93RnJvbSh3ZWIsIHsgaXNvbGF0aW9uOiBJc29sYXRpb24uUE9EIH0pXG4gICAqXG4gICAqL1xuICBwdWJsaWMgYWxsb3dGcm9tKHBlZXI6IG5ldHdvcmtwb2xpY3kuSU5ldHdvcmtQb2xpY3lQZWVyLCBvcHRpb25zOiBQb2RDb25uZWN0aW9uc0FsbG93RnJvbU9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmFsbG93KCdJbmdyZXNzJywgcGVlciwgeyBwb3J0czogdGhpcy5leHRyYWN0UG9ydHModGhpcy5pbnN0YW5jZSksIC4uLm9wdGlvbnMgfSk7XG4gIH1cblxuICBwcml2YXRlIGFsbG93KGRpcmVjdGlvbjogJ0luZ3Jlc3MnIHwgJ0VncmVzcycsIHBlZXI6IG5ldHdvcmtwb2xpY3kuSU5ldHdvcmtQb2xpY3lQZWVyLCBvcHRpb25zOiBQb2RDb25uZWN0aW9uc0FsbG93VG9PcHRpb25zIHwgUG9kQ29ubmVjdGlvbnNBbGxvd0Zyb21PcHRpb25zID0ge30pIHtcblxuICAgIGNvbnN0IGNvbmZpZyA9IHBlZXIudG9OZXR3b3JrUG9saWN5UGVlckNvbmZpZygpO1xuICAgIG5ldHdvcmtwb2xpY3kudmFsaWRhdGVQZWVyQ29uZmlnKGNvbmZpZyk7XG5cbiAgICBjb25zdCBwZWVyQWRkcmVzcyA9IGFkZHJlc3MocGVlcik7XG5cbiAgICBpZiAoIW9wdGlvbnMuaXNvbGF0aW9uIHx8IG9wdGlvbnMuaXNvbGF0aW9uID09PSBQb2RDb25uZWN0aW9uc0lzb2xhdGlvbi5QT0QpIHtcblxuICAgICAgY29uc3Qgc3JjID0gbmV3IG5ldHdvcmtwb2xpY3kuTmV0d29ya1BvbGljeSh0aGlzLmluc3RhbmNlLCBgQWxsb3cke2RpcmVjdGlvbn0ke3BlZXJBZGRyZXNzfWAsIHtcbiAgICAgICAgc2VsZWN0b3I6IHRoaXMuaW5zdGFuY2UsXG4gICAgICAgIC8vIHRoZSBwb2xpY3kgbXVzdCBiZSBkZWZpbmVkIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlIHBvZFxuICAgICAgICAvLyBzbyBpdCBjYW4gc2VsZWN0IGl0LlxuICAgICAgICBtZXRhZGF0YTogeyBuYW1lc3BhY2U6IHRoaXMuaW5zdGFuY2UubWV0YWRhdGEubmFtZXNwYWNlIH0sXG4gICAgICB9KTtcblxuICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgY2FzZSAnRWdyZXNzJzpcbiAgICAgICAgICBzcmMuYWRkRWdyZXNzUnVsZShwZWVyLCBvcHRpb25zLnBvcnRzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnSW5ncmVzcyc6XG4gICAgICAgICAgc3JjLmFkZEluZ3Jlc3NSdWxlKHBlZXIsIG9wdGlvbnMucG9ydHMpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLmlzb2xhdGlvbiB8fCBvcHRpb25zLmlzb2xhdGlvbiA9PT0gUG9kQ29ubmVjdGlvbnNJc29sYXRpb24uUEVFUikge1xuXG4gICAgICBpZiAoY29uZmlnLmlwQmxvY2spIHtcbiAgICAgICAgLy8gZm9yIGFuIGlwIGJsb2NrIHdlIGRvbid0IG5lZWQgdG8gY3JlYXRlIHRoZSBvcHBvc2l0ZSBwb2xpY2llc1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBvZFNlbGVjdG9yID0gcGVlci50b1BvZFNlbGVjdG9yKCk7XG4gICAgICBpZiAoIXBvZFNlbGVjdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGNyZWF0ZSBwb2xpY2llcyBmb3IgcGVlciAnJHtwZWVyLm5vZGUuYWRkcn0nIHNpbmNlIGl0cyBub3QgYSBwb2Qgc2VsZWN0b3JgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3Bwb3NpdGVEaXJlY3Rpb24gPSBkaXJlY3Rpb24gPT09ICdFZ3Jlc3MnID8gJ0luZ3Jlc3MnIDogJ0VncmVzcyc7XG5cbiAgICAgIGNvbnN0IHBvZFNlbGVjdG9yQ29uZmlnID0gcG9kU2VsZWN0b3IudG9Qb2RTZWxlY3RvckNvbmZpZygpO1xuICAgICAgbGV0IG5hbWVzcGFjZXM6IChzdHJpbmcgfCB1bmRlZmluZWQpW107XG5cbiAgICAgIGlmICghcG9kU2VsZWN0b3JDb25maWcubmFtZXNwYWNlcykge1xuXG4gICAgICAgIC8vIGlmIHRoZSBwZWVyIGRvZXNuJ3Qgc3BlY2lmeSBuYW1lc3BhY2VzLCB3ZSBhc3N1bWUgdGhlIHNhbWUgbmFtZXNwYWNlLlxuICAgICAgICBuYW1lc3BhY2VzID0gW3RoaXMuaW5zdGFuY2UubWV0YWRhdGEubmFtZXNwYWNlXTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBhIHBlZXIgY2Fubm90IHNwZWNpZnkgbmFtZXNwYWNlcyBieSBsYWJlbHMgYmVjYXVzZVxuICAgICAgICAvLyB3ZSB3b24ndCBiZSBhYmxlIHRvIGV4dHJhY3QgdGhlIG5hbWVzIG9mIHRob3NlIG5hbWVzcGFjZXMuXG4gICAgICAgIGlmIChwb2RTZWxlY3RvckNvbmZpZy5uYW1lc3BhY2VzLmxhYmVsU2VsZWN0b3IgJiYgIXBvZFNlbGVjdG9yQ29uZmlnLm5hbWVzcGFjZXMubGFiZWxTZWxlY3Rvci5pc0VtcHR5KCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBjcmVhdGUgYW4gJHtvcHBvc2l0ZURpcmVjdGlvbn0gcG9saWN5IGZvciBwZWVyICcke3BlZXIubm9kZS5wYXRofScgKHBvZD0ke3RoaXMuaW5zdGFuY2UubmFtZX0pLiBQZWVyIG11c3Qgc3BlY2lmeSBuYW1lc3BhY2VzIG9ubHkgYnkgbmFtZWApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYSBwZWVyIG11c3Qgc3BlY2lmeSBuYW1lc3BhY2VzIGJ5IG5hbWUuXG4gICAgICAgIGlmICghcG9kU2VsZWN0b3JDb25maWcubmFtZXNwYWNlcy5uYW1lcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGNyZWF0ZSBhbiAke29wcG9zaXRlRGlyZWN0aW9ufSBwb2xpY3kgZm9yIHBlZXIgJyR7cGVlci5ub2RlLnBhdGh9JyAocG9kPSR7dGhpcy5pbnN0YW5jZS5uYW1lfSkuIFBlZXIgbXVzdCBzcGVjaWZ5IG5hbWVzcGFjZSBuYW1lc2ApO1xuICAgICAgICB9XG5cbiAgICAgICAgbmFtZXNwYWNlcyA9IHBvZFNlbGVjdG9yQ29uZmlnLm5hbWVzcGFjZXMubmFtZXM7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lc3BhY2VzKSB7XG4gICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgY2FzZSAnRWdyZXNzJzpcbiAgICAgICAgICAgIG5ldyBuZXR3b3JrcG9saWN5Lk5ldHdvcmtQb2xpY3kodGhpcy5pbnN0YW5jZSwgYEFsbG93SW5ncmVzcyR7bmFtZX0ke3BlZXJBZGRyZXNzfWAsIHtcbiAgICAgICAgICAgICAgc2VsZWN0b3I6IHBvZFNlbGVjdG9yLFxuICAgICAgICAgICAgICBtZXRhZGF0YTogeyBuYW1lc3BhY2U6IG5hbWUgfSxcbiAgICAgICAgICAgICAgaW5ncmVzczogeyBydWxlczogW3sgcGVlcjogdGhpcy5pbnN0YW5jZSwgcG9ydHM6IG9wdGlvbnMucG9ydHMgfV0gfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnSW5ncmVzcyc6XG4gICAgICAgICAgICBuZXcgbmV0d29ya3BvbGljeS5OZXR3b3JrUG9saWN5KHRoaXMuaW5zdGFuY2UsIGBBbGxvd0VncmVzcyR7bmFtZX0ke3BlZXJBZGRyZXNzfWAsIHtcbiAgICAgICAgICAgICAgc2VsZWN0b3I6IHBvZFNlbGVjdG9yLFxuICAgICAgICAgICAgICBtZXRhZGF0YTogeyBuYW1lc3BhY2U6IG5hbWUgfSxcbiAgICAgICAgICAgICAgZWdyZXNzOiB7IHJ1bGVzOiBbeyBwZWVyOiB0aGlzLmluc3RhbmNlLCBwb3J0czogb3B0aW9ucy5wb3J0cyB9XSB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkaXJlY3Rpb246ICR7ZGlyZWN0aW9ufWApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGV4dHJhY3RQb3J0cyhzZWxlY3Rvcj86IG5ldHdvcmtwb2xpY3kuSU5ldHdvcmtQb2xpY3lQZWVyKTogbmV0d29ya3BvbGljeS5OZXR3b3JrUG9saWN5UG9ydFtdIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmV4dHJhY3RDb250YWluZXJQb3J0cyhzZWxlY3RvcikubWFwKG4gPT4gbmV0d29ya3BvbGljeS5OZXR3b3JrUG9saWN5UG9ydC50Y3AobikpO1xuICB9XG59XG4iXX0=

/***/ }),

/***/ 6093:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Probe = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const _action = __nccwpck_require__(4778);
/**
 * Probe describes a health check to be performed against a container to
 * determine whether it is alive or ready to receive traffic.
 */
class Probe {
    constructor(probeOptions, tcpSocketOptions, commandOptions, httpGetOptions) {
        this.probeOptions = probeOptions;
        this.tcpSocketOptions = tcpSocketOptions;
        this.commandOptions = commandOptions;
        this.httpGetOptions = httpGetOptions;
    }
    /**
     * Defines a probe based on an HTTP GET request to the IP address of the container.
     *
     * @param path The URL path to hit
     * @param options Options
     */
    static fromHttpGet(path, options = {}) {
        return new Probe(options, undefined, undefined, { path, ...options });
    }
    /**
     * Defines a probe based on a command which is executed within the container.
     *
     * @param command The command to execute
     * @param options Options
     */
    static fromCommand(command, options = {}) {
        return new Probe(options, undefined, { command, ...options }, undefined);
    }
    /**
     * Defines a probe based opening a connection to a TCP socket on the container.
     *
     * @param options Options
     */
    static fromTcpSocket(options = {}) {
        return new Probe(options, options, undefined, undefined);
    }
    /**
     * @internal
     */
    _toKube(cont) {
        var _b;
        const exec = this.commandOptions ? _action.Action.fromCommand(this.commandOptions.command) : undefined;
        const httpGet = this.httpGetOptions ? _action.Action.fromHttpGet(cont, this.httpGetOptions.path, this.httpGetOptions) : undefined;
        const tcpSocket = this.tcpSocketOptions ? _action.Action.fromTcpSocket(cont, this.tcpSocketOptions) : undefined;
        return {
            failureThreshold: (_b = this.probeOptions.failureThreshold) !== null && _b !== void 0 ? _b : 3,
            initialDelaySeconds: this.probeOptions.initialDelaySeconds ? this.probeOptions.initialDelaySeconds.toSeconds() : undefined,
            periodSeconds: this.probeOptions.periodSeconds ? this.probeOptions.periodSeconds.toSeconds() : undefined,
            successThreshold: this.probeOptions.successThreshold,
            timeoutSeconds: this.probeOptions.timeoutSeconds ? this.probeOptions.timeoutSeconds.toSeconds() : undefined,
            exec: exec,
            httpGet,
            tcpSocket,
        };
    }
}
exports.Probe = Probe;
_a = JSII_RTTI_SYMBOL_1;
Probe[_a] = { fqn: "cdk8s-plus-22.Probe", version: "2.0.0-rc.2" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvYmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvcHJvYmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDQSxxQ0FBcUM7QUErRnJDOzs7R0FHRztBQUNILE1BQWEsS0FBSztJQStCaEIsWUFDbUIsWUFBMEIsRUFDMUIsZ0JBQXdDLEVBQ3hDLGNBQXFELEVBQ3JELGNBQXVEO1FBSHZELGlCQUFZLEdBQVosWUFBWSxDQUFjO1FBQzFCLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBd0I7UUFDeEMsbUJBQWMsR0FBZCxjQUFjLENBQXVDO1FBQ3JELG1CQUFjLEdBQWQsY0FBYyxDQUF5QztJQUFHLENBQUM7SUFqQzlFOzs7OztPQUtHO0lBQ0ksTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFZLEVBQUUsVUFBK0IsRUFBRTtRQUN2RSxPQUFPLElBQUksS0FBSyxDQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLEVBQUUsSUFBSSxFQUFFLEdBQUcsT0FBTyxFQUFFLENBQUMsQ0FBQztJQUN4RSxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxNQUFNLENBQUMsV0FBVyxDQUFDLE9BQWlCLEVBQUUsVUFBK0IsRUFBRTtRQUM1RSxPQUFPLElBQUksS0FBSyxDQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsRUFBRSxPQUFPLEVBQUUsR0FBRyxPQUFPLEVBQUUsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUMzRSxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLE1BQU0sQ0FBQyxhQUFhLENBQUMsVUFBaUMsRUFBRTtRQUM3RCxPQUFPLElBQUksS0FBSyxDQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQzNELENBQUM7SUFRRDs7T0FFRztJQUNJLE9BQU8sQ0FBQyxJQUF5Qjs7UUFFdEMsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO1FBQ3ZHLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztRQUNsSSxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO1FBRWhILE9BQU87WUFDTCxnQkFBZ0IsUUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLGdCQUFnQixtQ0FBSSxDQUFDO1lBQ3pELG1CQUFtQixFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsbUJBQW1CLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFDLFNBQVM7WUFDMUgsYUFBYSxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUztZQUN4RyxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLGdCQUFnQjtZQUNwRCxjQUFjLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsY0FBYyxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTO1lBQzNHLElBQUksRUFBRSxJQUFJO1lBQ1YsT0FBTztZQUNQLFNBQVM7U0FDVixDQUFDO0lBQ0osQ0FBQzs7QUF4REgsc0JBeURDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRHVyYXRpb24gfSBmcm9tICdjZGs4cyc7XG5pbXBvcnQgKiBhcyBfYWN0aW9uIGZyb20gJy4vX2FjdGlvbic7XG5pbXBvcnQgKiBhcyBjb250YWluZXIgZnJvbSAnLi9jb250YWluZXInO1xuaW1wb3J0ICogYXMgazhzIGZyb20gJy4vaW1wb3J0cy9rOHMnO1xuXG4vKipcbiAqIFByb2JlIG9wdGlvbnMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJvYmVPcHRpb25zIHtcbiAgLyoqXG4gICAqIE1pbmltdW0gY29uc2VjdXRpdmUgZmFpbHVyZXMgZm9yIHRoZSBwcm9iZSB0byBiZSBjb25zaWRlcmVkIGZhaWxlZCBhZnRlclxuICAgKiBoYXZpbmcgc3VjY2VlZGVkLlxuICAgKlxuICAgKiBEZWZhdWx0cyB0byAzLiBNaW5pbXVtIHZhbHVlIGlzIDEuXG4gICAqXG4gICAqIEBkZWZhdWx0IDNcbiAgICovXG4gIHJlYWRvbmx5IGZhaWx1cmVUaHJlc2hvbGQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBzZWNvbmRzIGFmdGVyIHRoZSBjb250YWluZXIgaGFzIHN0YXJ0ZWQgYmVmb3JlIGxpdmVuZXNzIHByb2Jlc1xuICAgKiBhcmUgaW5pdGlhdGVkLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3dvcmtsb2Fkcy9wb2RzL3BvZC1saWZlY3ljbGUjY29udGFpbmVyLXByb2Jlc1xuICAgKiBAZGVmYXVsdCAtIGltbWVkaWF0ZVxuICAgKi9cbiAgcmVhZG9ubHkgaW5pdGlhbERlbGF5U2Vjb25kcz86IER1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBIb3cgb2Z0ZW4gKGluIHNlY29uZHMpIHRvIHBlcmZvcm0gdGhlIHByb2JlLlxuICAgKlxuICAgKiBEZWZhdWx0IHRvIDEwIHNlY29uZHMuIE1pbmltdW0gdmFsdWUgaXMgMS5cbiAgICpcbiAgICogQGRlZmF1bHQgRHVyYXRpb24uc2Vjb25kcygxMCkgTWluaW11bSB2YWx1ZSBpcyAxLlxuICAgKi9cbiAgcmVhZG9ubHkgcGVyaW9kU2Vjb25kcz86IER1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBNaW5pbXVtIGNvbnNlY3V0aXZlIHN1Y2Nlc3NlcyBmb3IgdGhlIHByb2JlIHRvIGJlIGNvbnNpZGVyZWQgc3VjY2Vzc2Z1bFxuICAgKiBhZnRlciBoYXZpbmcgZmFpbGVkLiBEZWZhdWx0cyB0byAxLlxuICAgKlxuICAgKiBNdXN0IGJlIDEgZm9yIGxpdmVuZXNzIGFuZCBzdGFydHVwLiBNaW5pbXVtIHZhbHVlIGlzIDEuXG4gICAqXG4gICAqIEBkZWZhdWx0IDEgTXVzdCBiZSAxIGZvciBsaXZlbmVzcyBhbmQgc3RhcnR1cC4gTWluaW11bSB2YWx1ZSBpcyAxLlxuICAgKi9cbiAgcmVhZG9ubHkgc3VjY2Vzc1RocmVzaG9sZD86IG51bWJlcjtcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHNlY29uZHMgYWZ0ZXIgd2hpY2ggdGhlIHByb2JlIHRpbWVzIG91dC5cbiAgICpcbiAgICogRGVmYXVsdHMgdG8gMSBzZWNvbmQuIE1pbmltdW0gdmFsdWUgaXMgMS5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy93b3JrbG9hZHMvcG9kcy9wb2QtbGlmZWN5Y2xlI2NvbnRhaW5lci1wcm9iZXNcbiAgICogQGRlZmF1bHQgRHVyYXRpb24uc2Vjb25kcygxKVxuICAgKi9cbiAgcmVhZG9ubHkgdGltZW91dFNlY29uZHM/OiBEdXJhdGlvbjtcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBgUHJvYmUuZnJvbUh0dHBHZXQoKWAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSHR0cEdldFByb2JlT3B0aW9ucyBleHRlbmRzIFByb2JlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgVENQIHBvcnQgdG8gdXNlIHdoZW4gc2VuZGluZyB0aGUgR0VUIHJlcXVlc3QuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gZGVmYXVsdHMgdG8gYGNvbnRhaW5lci5wb3J0YC5cbiAgICovXG4gIHJlYWRvbmx5IHBvcnQ/OiBudW1iZXI7XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYFByb2JlLmZyb21Db21tYW5kKClgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbW1hbmRQcm9iZU9wdGlvbnMgZXh0ZW5kcyBQcm9iZU9wdGlvbnMge1xuXG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYFByb2JlLmZyb21UY3BTb2NrZXQoKWAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGNwU29ja2V0UHJvYmVPcHRpb25zIGV4dGVuZHMgUHJvYmVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBUQ1AgcG9ydCB0byBjb25uZWN0IHRvIG9uIHRoZSBjb250YWluZXIuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gZGVmYXVsdHMgdG8gYGNvbnRhaW5lci5wb3J0YC5cbiAgICovXG4gIHJlYWRvbmx5IHBvcnQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBob3N0IG5hbWUgdG8gY29ubmVjdCB0byBvbiB0aGUgY29udGFpbmVyLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGRlZmF1bHRzIHRvIHRoZSBwb2QgSVBcbiAgICovXG4gIHJlYWRvbmx5IGhvc3Q/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUHJvYmUgZGVzY3JpYmVzIGEgaGVhbHRoIGNoZWNrIHRvIGJlIHBlcmZvcm1lZCBhZ2FpbnN0IGEgY29udGFpbmVyIHRvXG4gKiBkZXRlcm1pbmUgd2hldGhlciBpdCBpcyBhbGl2ZSBvciByZWFkeSB0byByZWNlaXZlIHRyYWZmaWMuXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9iZSB7XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBwcm9iZSBiYXNlZCBvbiBhbiBIVFRQIEdFVCByZXF1ZXN0IHRvIHRoZSBJUCBhZGRyZXNzIG9mIHRoZSBjb250YWluZXIuXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBVUkwgcGF0aCB0byBoaXRcbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tSHR0cEdldChwYXRoOiBzdHJpbmcsIG9wdGlvbnM6IEh0dHBHZXRQcm9iZU9wdGlvbnMgPSB7fSk6IFByb2JlIHtcbiAgICByZXR1cm4gbmV3IFByb2JlKG9wdGlvbnMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IHBhdGgsIC4uLm9wdGlvbnMgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhIHByb2JlIGJhc2VkIG9uIGEgY29tbWFuZCB3aGljaCBpcyBleGVjdXRlZCB3aXRoaW4gdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtIGNvbW1hbmQgVGhlIGNvbW1hbmQgdG8gZXhlY3V0ZVxuICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21Db21tYW5kKGNvbW1hbmQ6IHN0cmluZ1tdLCBvcHRpb25zOiBDb21tYW5kUHJvYmVPcHRpb25zID0ge30pOiBQcm9iZSB7XG4gICAgcmV0dXJuIG5ldyBQcm9iZShvcHRpb25zLCB1bmRlZmluZWQsIHsgY29tbWFuZCwgLi4ub3B0aW9ucyB9LCB1bmRlZmluZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBwcm9iZSBiYXNlZCBvcGVuaW5nIGEgY29ubmVjdGlvbiB0byBhIFRDUCBzb2NrZXQgb24gdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tVGNwU29ja2V0KG9wdGlvbnM6IFRjcFNvY2tldFByb2JlT3B0aW9ucyA9IHt9KTogUHJvYmUge1xuICAgIHJldHVybiBuZXcgUHJvYmUob3B0aW9ucywgb3B0aW9ucywgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICB9XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHByb2JlT3B0aW9uczogUHJvYmVPcHRpb25zLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdGNwU29ja2V0T3B0aW9ucz86IFRjcFNvY2tldFByb2JlT3B0aW9ucyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNvbW1hbmRPcHRpb25zPzogeyBjb21tYW5kOiBzdHJpbmdbXSB9ICYgUHJvYmVPcHRpb25zLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgaHR0cEdldE9wdGlvbnM/OiB7IHBhdGg6IHN0cmluZyB9ICYgSHR0cEdldFByb2JlT3B0aW9ucykge31cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgX3RvS3ViZShjb250OiBjb250YWluZXIuQ29udGFpbmVyKTogazhzLlByb2JlIHtcblxuICAgIGNvbnN0IGV4ZWMgPSB0aGlzLmNvbW1hbmRPcHRpb25zID8gX2FjdGlvbi5BY3Rpb24uZnJvbUNvbW1hbmQodGhpcy5jb21tYW5kT3B0aW9ucy5jb21tYW5kKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBodHRwR2V0ID0gdGhpcy5odHRwR2V0T3B0aW9ucyA/IF9hY3Rpb24uQWN0aW9uLmZyb21IdHRwR2V0KGNvbnQsIHRoaXMuaHR0cEdldE9wdGlvbnMucGF0aCwgdGhpcy5odHRwR2V0T3B0aW9ucykgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgdGNwU29ja2V0ID0gdGhpcy50Y3BTb2NrZXRPcHRpb25zID8gX2FjdGlvbi5BY3Rpb24uZnJvbVRjcFNvY2tldChjb250LCB0aGlzLnRjcFNvY2tldE9wdGlvbnMpIDogdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZhaWx1cmVUaHJlc2hvbGQ6IHRoaXMucHJvYmVPcHRpb25zLmZhaWx1cmVUaHJlc2hvbGQgPz8gMyxcbiAgICAgIGluaXRpYWxEZWxheVNlY29uZHM6IHRoaXMucHJvYmVPcHRpb25zLmluaXRpYWxEZWxheVNlY29uZHMgPyB0aGlzLnByb2JlT3B0aW9ucy5pbml0aWFsRGVsYXlTZWNvbmRzLnRvU2Vjb25kcygpIDogdW5kZWZpbmVkLFxuICAgICAgcGVyaW9kU2Vjb25kczogdGhpcy5wcm9iZU9wdGlvbnMucGVyaW9kU2Vjb25kcyA/IHRoaXMucHJvYmVPcHRpb25zLnBlcmlvZFNlY29uZHMudG9TZWNvbmRzKCkgOiB1bmRlZmluZWQsXG4gICAgICBzdWNjZXNzVGhyZXNob2xkOiB0aGlzLnByb2JlT3B0aW9ucy5zdWNjZXNzVGhyZXNob2xkLFxuICAgICAgdGltZW91dFNlY29uZHM6IHRoaXMucHJvYmVPcHRpb25zLnRpbWVvdXRTZWNvbmRzID8gdGhpcy5wcm9iZU9wdGlvbnMudGltZW91dFNlY29uZHMudG9TZWNvbmRzKCkgOiB1bmRlZmluZWQsXG4gICAgICBleGVjOiBleGVjLFxuICAgICAgaHR0cEdldCxcbiAgICAgIHRjcFNvY2tldCxcbiAgICB9O1xuICB9XG59XG4iXX0=

/***/ }),

/***/ 4185:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GCEPersistentDiskPersistentVolume = exports.AzureDiskPersistentVolume = exports.AwsElasticBlockStorePersistentVolume = exports.PersistentVolumeReclaimPolicy = exports.PersistentVolume = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const cdk8s_1 = __nccwpck_require__(1227);
const constructs_1 = __nccwpck_require__(1963);
const base = __nccwpck_require__(415);
const k8s = __nccwpck_require__(4879);
const pvc = __nccwpck_require__(1967);
const volume = __nccwpck_require__(1680);
class ImportedPersistentVolume extends constructs_1.Construct {
    constructor(scope, id, name) {
        super(scope, id);
        this._name = name;
    }
    get name() {
        return this._name;
    }
    get apiVersion() {
        return k8s.KubePersistentVolume.GVK.apiVersion;
    }
    get apiGroup() {
        return '';
    }
    get kind() {
        return k8s.KubePersistentVolume.GVK.kind;
    }
}
/**
 * A PersistentVolume (PV) is a piece of storage in the cluster that has been
 * provisioned by an administrator or dynamically provisioned using Storage Classes.
 * It is a resource in the cluster just like a node is a cluster resource.
 * PVs are volume plugins like Volumes, but have a lifecycle independent of any
 * individual Pod that uses the PV. This API object captures the details of the
 * implementation of the storage, be that NFS, iSCSI, or a
 * cloud-provider-specific storage system.
 */
class PersistentVolume extends base.Resource {
    constructor(scope, id, props = {}) {
        var _e, _f;
        super(scope, id);
        this.resourceType = 'persistentvolumes';
        this.storage = props.storage;
        this.mode = (_e = props.volumeMode) !== null && _e !== void 0 ? _e : pvc.PersistentVolumeMode.FILE_SYSTEM;
        this.storageClassName = props.storageClassName;
        this._accessModes = props.accessModes;
        this.mountOptions = props.mountOptions;
        this.reclaimPolicy = (_f = props.reclaimPolicy) !== null && _f !== void 0 ? _f : PersistentVolumeReclaimPolicy.RETAIN;
        if (props.claim) {
            this.bind(props.claim);
        }
        this.apiObject = new k8s.KubePersistentVolume(this, 'Resource', {
            metadata: props.metadata,
            spec: cdk8s_1.Lazy.any({ produce: () => this._toKube() }),
        });
    }
    /**
     * Imports a pv from the cluster as a reference.
     */
    static fromPersistentVolumeName(scope, id, volumeName) {
        return new ImportedPersistentVolume(scope, id, volumeName);
    }
    /**
     * Access modes requirement of this claim.
     */
    get accessModes() {
        return this._accessModes ? [...this._accessModes] : undefined;
    }
    /**
     * PVC this volume is bound to. Undefined means this volume is not yet
     * claimed by any PVC.
     */
    get claim() {
        return this._claim;
    }
    /**
     * Reserve a `PersistentVolume` by creating a `PersistentVolumeClaim`
     * that is wired to claim this volume.
     *
     * Note that this method will throw in case the volume is already claimed.
     *
     * @see https://kubernetes.io/docs/concepts/storage/persistent-volumes/#reserving-a-persistentvolume
     */
    reserve() {
        const claim = new pvc.PersistentVolumeClaim(this, `${this.name}PVC`, {
            metadata: { name: `pvc-${this.name}`, namespace: this.metadata.namespace },
            // the storage classes must match, otherwise the claim
            // will use the default class (or no class at all), which may be different than the class
            // of this volume. note that other requirements are not needed since
            // when they are not defined, any volume satisifies them.
            storageClassName: this.storageClassName,
        });
        this.bind(claim);
        claim.bind(this);
        return claim;
    }
    /**
     * Bind a volume to a specific claim.
     * Note that you must also bind the claim to the volume.
     *
     * @see https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding
     *
     * @param claim The PVC to bind to.
     */
    bind(claim) {
        if (this._claim && this._claim.name !== claim.name) {
            throw new Error(`Cannot bind volume '${this.name}' to claim '${claim.name}' since it is already bound to claim '${this._claim.name}'`);
        }
        this._claim = claim;
    }
    asVolume() {
        const claim = this.reserve();
        return volume.Volume.fromPersistentVolumeClaim(this, 'Volume', claim);
    }
    /**
     * @internal
     */
    _toKube() {
        var _e, _f, _g;
        const storage = this.storage ? k8s.Quantity.fromString(this.storage.toGibibytes() + 'Gi') : undefined;
        return {
            claimRef: this._claim ? { name: (_e = this._claim) === null || _e === void 0 ? void 0 : _e.name } : undefined,
            accessModes: (_f = this.accessModes) === null || _f === void 0 ? void 0 : _f.map(a => a.toString()),
            capacity: storage ? { storage } : undefined,
            mountOptions: (_g = this.mountOptions) === null || _g === void 0 ? void 0 : _g.map(o => o),
            storageClassName: this.storageClassName,
            persistentVolumeReclaimPolicy: this.reclaimPolicy,
            volumeMode: this.mode,
        };
    }
}
exports.PersistentVolume = PersistentVolume;
_a = JSII_RTTI_SYMBOL_1;
PersistentVolume[_a] = { fqn: "cdk8s-plus-22.PersistentVolume", version: "2.0.0-rc.2" };
/**
 * Reclaim Policies.
 */
var PersistentVolumeReclaimPolicy;
(function (PersistentVolumeReclaimPolicy) {
    /**
     * The Retain reclaim policy allows for manual reclamation of the resource.
     * When the PersistentVolumeClaim is deleted, the PersistentVolume still exists and the
     * volume is considered "released". But it is not yet available for another claim
     * because the previous claimant's data remains on the volume.
     * An administrator can manually reclaim the volume with the following steps:
     *
     * 1. Delete the PersistentVolume. The associated storage asset in external
     *    infrastructure (such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume) still exists after the PV is deleted.
     * 2. Manually clean up the data on the associated storage asset accordingly.
     * 3. Manually delete the associated storage asset.
     *
     * If you want to reuse the same storage asset, create a new PersistentVolume
     * with the same storage asset definition.
     */
    PersistentVolumeReclaimPolicy["RETAIN"] = "Retain";
    /**
     * For volume plugins that support the Delete reclaim policy, deletion removes both the
     * PersistentVolume object from Kubernetes, as well as the associated storage asset in
     * the external infrastructure, such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume.
     * Volumes that were dynamically provisioned inherit the reclaim policy of their StorageClass, which defaults to Delete.
     * The administrator should configure the StorageClass according to users' expectations; otherwise,
     * the PV must be edited or patched after it is created
     */
    PersistentVolumeReclaimPolicy["DELETE"] = "Delete";
})(PersistentVolumeReclaimPolicy = exports.PersistentVolumeReclaimPolicy || (exports.PersistentVolumeReclaimPolicy = {}));
/**
 * Represents an AWS Disk resource that is attached to a kubelet's host machine and
 * then exposed to the pod.
 *
 * @see https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 */
class AwsElasticBlockStorePersistentVolume extends PersistentVolume {
    constructor(scope, id, props) {
        var _e, _f;
        super(scope, id, props);
        this.volumeId = props.volumeId;
        this.readOnly = (_e = props.readOnly) !== null && _e !== void 0 ? _e : false;
        this.fsType = (_f = props.fsType) !== null && _f !== void 0 ? _f : 'ext4';
        this.partition = props.partition;
    }
    /**
     * @internal
     */
    _toKube() {
        const spec = super._toKube();
        return {
            ...spec,
            awsElasticBlockStore: {
                volumeId: this.volumeId,
                fsType: this.fsType,
                partition: this.partition,
                readOnly: this.readOnly,
            },
        };
    }
}
exports.AwsElasticBlockStorePersistentVolume = AwsElasticBlockStorePersistentVolume;
_b = JSII_RTTI_SYMBOL_1;
AwsElasticBlockStorePersistentVolume[_b] = { fqn: "cdk8s-plus-22.AwsElasticBlockStorePersistentVolume", version: "2.0.0-rc.2" };
/**
 * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 */
class AzureDiskPersistentVolume extends PersistentVolume {
    constructor(scope, id, props) {
        var _e, _f, _g, _h;
        super(scope, id, props);
        this.diskName = props.diskName;
        this.diskUri = props.diskUri;
        this.cachingMode = (_e = props.cachingMode) !== null && _e !== void 0 ? _e : volume.AzureDiskPersistentVolumeCachingMode.NONE;
        this.fsType = (_f = props.fsType) !== null && _f !== void 0 ? _f : 'ext4';
        this.azureKind = (_g = props.kind) !== null && _g !== void 0 ? _g : volume.AzureDiskPersistentVolumeKind.SHARED;
        this.readOnly = (_h = props.readOnly) !== null && _h !== void 0 ? _h : false;
    }
    /**
     * @internal
     *
     * @see https://github.com/kubernetes/examples/blob/master/staging/volumes/azure_disk/README.md
     */
    _toKube() {
        const spec = super._toKube();
        return {
            ...spec,
            azureDisk: {
                diskName: this.diskName,
                diskUri: this.diskUri,
                cachingMode: this.cachingMode,
                fsType: this.fsType,
                kind: this.azureKind,
                readOnly: this.readOnly,
            },
        };
    }
}
exports.AzureDiskPersistentVolume = AzureDiskPersistentVolume;
_c = JSII_RTTI_SYMBOL_1;
AzureDiskPersistentVolume[_c] = { fqn: "cdk8s-plus-22.AzureDiskPersistentVolume", version: "2.0.0-rc.2" };
/**
 * GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine
 * and then exposed to the pod. Provisioned by an admin.
 *
 * @see https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 */
class GCEPersistentDiskPersistentVolume extends PersistentVolume {
    constructor(scope, id, props) {
        var _e, _f;
        super(scope, id, props);
        this.pdName = props.pdName;
        this.readOnly = (_e = props.readOnly) !== null && _e !== void 0 ? _e : false;
        this.fsType = (_f = props.fsType) !== null && _f !== void 0 ? _f : 'ext4';
        this.partition = props.partition;
    }
    /**
     * @internal
     *
     * @see https://github.com/kubernetes/examples/blob/master/staging/volumes/azure_disk/README.md
     */
    _toKube() {
        const spec = super._toKube();
        return {
            ...spec,
            gcePersistentDisk: {
                pdName: this.pdName,
                fsType: this.fsType,
                partition: this.partition,
                readOnly: this.readOnly,
            },
        };
    }
}
exports.GCEPersistentDiskPersistentVolume = GCEPersistentDiskPersistentVolume;
_d = JSII_RTTI_SYMBOL_1;
GCEPersistentDiskPersistentVolume[_d] = { fqn: "cdk8s-plus-22.GCEPersistentDiskPersistentVolume", version: "2.0.0-rc.2" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHYuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvcHYudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxpQ0FBOEM7QUFDOUMsMkNBQXVDO0FBQ3ZDLCtCQUErQjtBQUMvQixxQ0FBcUM7QUFDckMsNkJBQTZCO0FBQzdCLG1DQUFtQztBQXdFbkMsTUFBTSx3QkFBeUIsU0FBUSxzQkFBUztJQUk5QyxZQUFZLEtBQWdCLEVBQUUsRUFBVSxFQUFFLElBQVk7UUFDcEQsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNqQixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztJQUNwQixDQUFDO0lBRUQsSUFBVyxJQUFJO1FBQ2IsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ3BCLENBQUM7SUFFRCxJQUFXLFVBQVU7UUFDbkIsT0FBTyxHQUFHLENBQUMsb0JBQW9CLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQztJQUNqRCxDQUFDO0lBRUQsSUFBVyxRQUFRO1FBQ2pCLE9BQU8sRUFBRSxDQUFDO0lBQ1osQ0FBQztJQUVELElBQVcsSUFBSTtRQUNiLE9BQU8sR0FBRyxDQUFDLG9CQUFvQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUM7SUFDM0MsQ0FBQztDQUVGO0FBRUQ7Ozs7Ozs7O0dBUUc7QUFDSCxNQUFhLGdCQUFpQixTQUFRLElBQUksQ0FBQyxRQUFRO0lBZ0RqRCxZQUFzQixLQUFnQixFQUFFLEVBQVUsRUFBRSxRQUErQixFQUFHOztRQUNwRixLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBbkNILGlCQUFZLEdBQUcsbUJBQW1CLENBQUM7UUFxQ2pELElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQztRQUM3QixJQUFJLENBQUMsSUFBSSxTQUFHLEtBQUssQ0FBQyxVQUFVLG1DQUFJLEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQyxXQUFXLENBQUM7UUFDckUsSUFB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RUFBRTtnQkFDakIsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO2dCQUNuQixNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07Z0JBQ25CLFNBQVMsRUFBRSxJQUFJLENBQUMsU0FBUztnQkFDekIsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRO2FBQ3hCO1NBQ0YsQ0FBQztJQUNKLENBQUM7O0FBaERILDhFQWlEQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwaU9iamVjdCwgTGF6eSwgU2l6ZSB9IGZyb20gJ2NkazhzJztcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xuaW1wb3J0ICogYXMgYmFzZSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0ICogYXMgazhzIGZyb20gJy4vaW1wb3J0cy9rOHMnO1xuaW1wb3J0ICogYXMgcHZjIGZyb20gJy4vcHZjJztcbmltcG9ydCAqIGFzIHZvbHVtZSBmcm9tICcuL3ZvbHVtZSc7XG5cbi8qKlxuICogQ29udHJhY3Qgb2YgYSBgUGVyc2lzdGVudFZvbHVtZUNsYWltYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJUGVyc2lzdGVudFZvbHVtZSBleHRlbmRzIGJhc2UuSVJlc291cmNlIHtcbn1cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIGZvciBgUGVyc2lzdGVudFZvbHVtZWAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGVyc2lzdGVudFZvbHVtZVByb3BzIGV4dGVuZHMgYmFzZS5SZXNvdXJjZVByb3BzIHtcblxuICAvKipcbiAgICogQ29udGFpbnMgYWxsIHdheXMgdGhlIHZvbHVtZSBjYW4gYmUgbW91bnRlZC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3BlcnNpc3RlbnQtdm9sdW1lcyNhY2Nlc3MtbW9kZXNcbiAgICogQGRlZmF1bHQgLSBObyBhY2Nlc3MgbW9kZXMuXG4gICAqL1xuICByZWFkb25seSBhY2Nlc3NNb2Rlcz86IHB2Yy5QZXJzaXN0ZW50Vm9sdW1lQWNjZXNzTW9kZVtdO1xuXG4gIC8qKlxuICAgKiBXaGF0IGlzIHRoZSBzdG9yYWdlIGNhcGFjaXR5IG9mIHRoaXMgdm9sdW1lLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2UvcGVyc2lzdGVudC12b2x1bWVzI3Jlc291cmNlc1xuICAgKiBAZGVmYXVsdCAtIE5vIHNwZWNpZmllZC5cbiAgICovXG4gIHJlYWRvbmx5IHN0b3JhZ2U/OiBTaXplO1xuXG4gIC8qKlxuICAgKiBQYXJ0IG9mIGEgYmktZGlyZWN0aW9uYWwgYmluZGluZyBiZXR3ZWVuIFBlcnNpc3RlbnRWb2x1bWUgYW5kIFBlcnNpc3RlbnRWb2x1bWVDbGFpbS5cbiAgICogRXhwZWN0ZWQgdG8gYmUgbm9uLW5pbCB3aGVuIGJvdW5kLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2UvcGVyc2lzdGVudC12b2x1bWVzI2JpbmRpbmdcbiAgICogQGRlZmF1bHQgLSBOb3QgYm91bmQgdG8gYSBzcGVjaWZpYyBjbGFpbS5cbiAgICovXG4gIHJlYWRvbmx5IGNsYWltPzogcHZjLklQZXJzaXN0ZW50Vm9sdW1lQ2xhaW07XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBtb3VudCBvcHRpb25zLCBlLmcuIFtcInJvXCIsIFwic29mdFwiXS4gTm90IHZhbGlkYXRlZCAtIG1vdW50IHdpbGwgc2ltcGx5IGZhaWwgaWYgb25lIGlzIGludmFsaWQuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvc3RvcmFnZS9wZXJzaXN0ZW50LXZvbHVtZXMvI21vdW50LW9wdGlvbnNcbiAgICogQGRlZmF1bHQgLSBObyBvcHRpb25zLlxuICAgKi9cbiAgcmVhZG9ubHkgbW91bnRPcHRpb25zPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIFdoZW4gYSB1c2VyIGlzIGRvbmUgd2l0aCB0aGVpciB2b2x1bWUsIHRoZXkgY2FuIGRlbGV0ZSB0aGUgUFZDIG9iamVjdHMgZnJvbSB0aGUgQVBJIHRoYXRcbiAgICogYWxsb3dzIHJlY2xhbWF0aW9uIG9mIHRoZSByZXNvdXJjZS4gVGhlIHJlY2xhaW0gcG9saWN5IHRlbGxzIHRoZSBjbHVzdGVyIHdoYXQgdG8gZG8gd2l0aFxuICAgKiB0aGUgdm9sdW1lIGFmdGVyIGl0IGhhcyBiZWVuIHJlbGVhc2VkIG9mIGl0cyBjbGFpbS5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3BlcnNpc3RlbnQtdm9sdW1lcyNyZWNsYWltaW5nXG4gICAqIEBkZWZhdWx0IFBlcnNpc3RlbnRWb2x1bWVSZWNsYWltUG9saWN5LlJFVEFJTlxuICAgKi9cbiAgcmVhZG9ubHkgcmVjbGFpbVBvbGljeT86IFBlcnNpc3RlbnRWb2x1bWVSZWNsYWltUG9saWN5O1xuXG4gIC8qKlxuICAgKiBOYW1lIG9mIFN0b3JhZ2VDbGFzcyB0byB3aGljaCB0aGlzIHBlcnNpc3RlbnQgdm9sdW1lIGJlbG9uZ3MuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gVm9sdW1lIGRvZXMgbm90IGJlbG9uZyB0byBhbnkgc3RvcmFnZSBjbGFzcy5cbiAgICovXG4gIHJlYWRvbmx5IHN0b3JhZ2VDbGFzc05hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIERlZmluZXMgd2hhdCB0eXBlIG9mIHZvbHVtZSBpcyByZXF1aXJlZCBieSB0aGUgY2xhaW0uXG4gICAqXG4gICAqIEBkZWZhdWx0IFZvbHVtZU1vZGUuRklMRV9TWVNURU1cbiAgICovXG4gIHJlYWRvbmx5IHZvbHVtZU1vZGU/OiBwdmMuUGVyc2lzdGVudFZvbHVtZU1vZGU7XG5cbn1cblxuY2xhc3MgSW1wb3J0ZWRQZXJzaXN0ZW50Vm9sdW1lIGV4dGVuZHMgQ29uc3RydWN0IGltcGxlbWVudHMgSVBlcnNpc3RlbnRWb2x1bWUge1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgX25hbWU6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBuYW1lOiBzdHJpbmcpIHtcbiAgICBzdXBlcihzY29wZSwgaWQpO1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICB9XG5cbiAgcHVibGljIGdldCBuYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGFwaVZlcnNpb24oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gazhzLkt1YmVQZXJzaXN0ZW50Vm9sdW1lLkdWSy5hcGlWZXJzaW9uO1xuICB9XG5cbiAgcHVibGljIGdldCBhcGlHcm91cCgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHB1YmxpYyBnZXQga2luZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBrOHMuS3ViZVBlcnNpc3RlbnRWb2x1bWUuR1ZLLmtpbmQ7XG4gIH1cblxufVxuXG4vKipcbiAqIEEgUGVyc2lzdGVudFZvbHVtZSAoUFYpIGlzIGEgcGllY2Ugb2Ygc3RvcmFnZSBpbiB0aGUgY2x1c3RlciB0aGF0IGhhcyBiZWVuXG4gKiBwcm92aXNpb25lZCBieSBhbiBhZG1pbmlzdHJhdG9yIG9yIGR5bmFtaWNhbGx5IHByb3Zpc2lvbmVkIHVzaW5nIFN0b3JhZ2UgQ2xhc3Nlcy5cbiAqIEl0IGlzIGEgcmVzb3VyY2UgaW4gdGhlIGNsdXN0ZXIganVzdCBsaWtlIGEgbm9kZSBpcyBhIGNsdXN0ZXIgcmVzb3VyY2UuXG4gKiBQVnMgYXJlIHZvbHVtZSBwbHVnaW5zIGxpa2UgVm9sdW1lcywgYnV0IGhhdmUgYSBsaWZlY3ljbGUgaW5kZXBlbmRlbnQgb2YgYW55XG4gKiBpbmRpdmlkdWFsIFBvZCB0aGF0IHVzZXMgdGhlIFBWLiBUaGlzIEFQSSBvYmplY3QgY2FwdHVyZXMgdGhlIGRldGFpbHMgb2YgdGhlXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3RvcmFnZSwgYmUgdGhhdCBORlMsIGlTQ1NJLCBvciBhXG4gKiBjbG91ZC1wcm92aWRlci1zcGVjaWZpYyBzdG9yYWdlIHN5c3RlbS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBlcnNpc3RlbnRWb2x1bWUgZXh0ZW5kcyBiYXNlLlJlc291cmNlIGltcGxlbWVudHMgSVBlcnNpc3RlbnRWb2x1bWUsIHZvbHVtZS5JU3RvcmFnZSB7XG5cbiAgLyoqXG4gICAqIEltcG9ydHMgYSBwdiBmcm9tIHRoZSBjbHVzdGVyIGFzIGEgcmVmZXJlbmNlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tUGVyc2lzdGVudFZvbHVtZU5hbWUoc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgdm9sdW1lTmFtZTogc3RyaW5nKTogSVBlcnNpc3RlbnRWb2x1bWUge1xuICAgIHJldHVybiBuZXcgSW1wb3J0ZWRQZXJzaXN0ZW50Vm9sdW1lKHNjb3BlLCBpZCwgdm9sdW1lTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBiYXNlLlJlc291cmNlLmFwaU9iamVjdFxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGFwaU9iamVjdDogQXBpT2JqZWN0O1xuXG4gIHB1YmxpYyByZWFkb25seSByZXNvdXJjZVR5cGUgPSAncGVyc2lzdGVudHZvbHVtZXMnO1xuXG4gIHByaXZhdGUgX2NsYWltPzogcHZjLklQZXJzaXN0ZW50Vm9sdW1lQ2xhaW07XG5cbiAgLyoqXG4gICAqIFN0b3JhZ2Ugc2l6ZSBvZiB0aGlzIHZvbHVtZS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBzdG9yYWdlPzogU2l6ZTtcblxuICAvKipcbiAgICogVm9sdW1lIG1vZGUgb2YgdGhpcyB2b2x1bWUuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbW9kZTogcHZjLlBlcnNpc3RlbnRWb2x1bWVNb2RlO1xuXG4gIC8qKlxuICAgICogU3RvcmFnZSBjbGFzcyB0aGlzIHZvbHVtZSBiZWxvbmdzIHRvLlxuICAgICovXG4gIHB1YmxpYyByZWFkb25seSBzdG9yYWdlQ2xhc3NOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBY2Nlc3MgbW9kZXMgcmVxdWlyZW1lbnQgb2YgdGhpcyBjbGFpbS5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgX2FjY2Vzc01vZGVzPzogcHZjLlBlcnNpc3RlbnRWb2x1bWVBY2Nlc3NNb2RlW107XG5cbiAgLyoqXG4gICAqIE1vdW50IG9wdGlvbnMgb2YgdGhpcyB2b2x1bWUuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbW91bnRPcHRpb25zPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIFJlY2xhaW0gcG9saWN5IG9mIHRoaXMgdm9sdW1lLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHJlY2xhaW1Qb2xpY3k6IFBlcnNpc3RlbnRWb2x1bWVSZWNsYWltUG9saWN5O1xuXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogUGVyc2lzdGVudFZvbHVtZVByb3BzID0geyB9KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkKTtcblxuICAgIHRoaXMuc3RvcmFnZSA9IHByb3BzLnN0b3JhZ2U7XG4gICAgdGhpcy5tb2RlID0gcHJvcHMudm9sdW1lTW9kZSA/PyBwdmMuUGVyc2lzdGVudFZvbHVtZU1vZGUuRklMRV9TWVNURU07XG4gICAgdGhpcy5zdG9yYWdlQ2xhc3NOYW1lID0gcHJvcHMuc3RvcmFnZUNsYXNzTmFtZTtcbiAgICB0aGlzLl9hY2Nlc3NNb2RlcyA9IHByb3BzLmFjY2Vzc01vZGVzO1xuICAgIHRoaXMubW91bnRPcHRpb25zID0gcHJvcHMubW91bnRPcHRpb25zO1xuICAgIHRoaXMucmVjbGFpbVBvbGljeSA9IHByb3BzLnJlY2xhaW1Qb2xpY3kgPz8gUGVyc2lzdGVudFZvbHVtZVJlY2xhaW1Qb2xpY3kuUkVUQUlOO1xuXG4gICAgaWYgKHByb3BzLmNsYWltKSB7XG4gICAgICB0aGlzLmJpbmQocHJvcHMuY2xhaW0pO1xuICAgIH1cblxuICAgIHRoaXMuYXBpT2JqZWN0ID0gbmV3IGs4cy5LdWJlUGVyc2lzdGVudFZvbHVtZSh0aGlzLCAnUmVzb3VyY2UnLCB7XG4gICAgICBtZXRhZGF0YTogcHJvcHMubWV0YWRhdGEsXG4gICAgICBzcGVjOiBMYXp5LmFueSh7IHByb2R1Y2U6ICgpID0+IHRoaXMuX3RvS3ViZSgpIH0pLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VzcyBtb2RlcyByZXF1aXJlbWVudCBvZiB0aGlzIGNsYWltLlxuICAgKi9cbiAgcHVibGljIGdldCBhY2Nlc3NNb2RlcygpOiBwdmMuUGVyc2lzdGVudFZvbHVtZUFjY2Vzc01vZGVbXSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX2FjY2Vzc01vZGVzID8gWy4uLnRoaXMuX2FjY2Vzc01vZGVzXSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQVkMgdGhpcyB2b2x1bWUgaXMgYm91bmQgdG8uIFVuZGVmaW5lZCBtZWFucyB0aGlzIHZvbHVtZSBpcyBub3QgeWV0XG4gICAqIGNsYWltZWQgYnkgYW55IFBWQy5cbiAgICovXG4gIHB1YmxpYyBnZXQgY2xhaW0oKTogcHZjLklQZXJzaXN0ZW50Vm9sdW1lQ2xhaW0gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9jbGFpbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNlcnZlIGEgYFBlcnNpc3RlbnRWb2x1bWVgIGJ5IGNyZWF0aW5nIGEgYFBlcnNpc3RlbnRWb2x1bWVDbGFpbWBcbiAgICogdGhhdCBpcyB3aXJlZCB0byBjbGFpbSB0aGlzIHZvbHVtZS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIHdpbGwgdGhyb3cgaW4gY2FzZSB0aGUgdm9sdW1lIGlzIGFscmVhZHkgY2xhaW1lZC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3BlcnNpc3RlbnQtdm9sdW1lcy8jcmVzZXJ2aW5nLWEtcGVyc2lzdGVudHZvbHVtZVxuICAgKi9cbiAgcHVibGljIHJlc2VydmUoKTogcHZjLlBlcnNpc3RlbnRWb2x1bWVDbGFpbSB7XG4gICAgY29uc3QgY2xhaW0gPSBuZXcgcHZjLlBlcnNpc3RlbnRWb2x1bWVDbGFpbSh0aGlzLCBgJHt0aGlzLm5hbWV9UFZDYCwge1xuICAgICAgbWV0YWRhdGE6IHsgbmFtZTogYHB2Yy0ke3RoaXMubmFtZX1gLCBuYW1lc3BhY2U6IHRoaXMubWV0YWRhdGEubmFtZXNwYWNlIH0sXG5cbiAgICAgIC8vIHRoZSBzdG9yYWdlIGNsYXNzZXMgbXVzdCBtYXRjaCwgb3RoZXJ3aXNlIHRoZSBjbGFpbVxuICAgICAgLy8gd2lsbCB1c2UgdGhlIGRlZmF1bHQgY2xhc3MgKG9yIG5vIGNsYXNzIGF0IGFsbCksIHdoaWNoIG1heSBiZSBkaWZmZXJlbnQgdGhhbiB0aGUgY2xhc3NcbiAgICAgIC8vIG9mIHRoaXMgdm9sdW1lLiBub3RlIHRoYXQgb3RoZXIgcmVxdWlyZW1lbnRzIGFyZSBub3QgbmVlZGVkIHNpbmNlXG4gICAgICAvLyB3aGVuIHRoZXkgYXJlIG5vdCBkZWZpbmVkLCBhbnkgdm9sdW1lIHNhdGlzaWZpZXMgdGhlbS5cbiAgICAgIHN0b3JhZ2VDbGFzc05hbWU6IHRoaXMuc3RvcmFnZUNsYXNzTmFtZSxcbiAgICB9KTtcblxuICAgIHRoaXMuYmluZChjbGFpbSk7XG4gICAgY2xhaW0uYmluZCh0aGlzKTtcblxuICAgIHJldHVybiBjbGFpbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kIGEgdm9sdW1lIHRvIGEgc3BlY2lmaWMgY2xhaW0uXG4gICAqIE5vdGUgdGhhdCB5b3UgbXVzdCBhbHNvIGJpbmQgdGhlIGNsYWltIHRvIHRoZSB2b2x1bWUuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvc3RvcmFnZS9wZXJzaXN0ZW50LXZvbHVtZXMvI2JpbmRpbmdcbiAgICpcbiAgICogQHBhcmFtIGNsYWltIFRoZSBQVkMgdG8gYmluZCB0by5cbiAgICovXG4gIHB1YmxpYyBiaW5kKGNsYWltOiBwdmMuSVBlcnNpc3RlbnRWb2x1bWVDbGFpbSkge1xuICAgIGlmICh0aGlzLl9jbGFpbSAmJiB0aGlzLl9jbGFpbS5uYW1lICE9PSBjbGFpbS5uYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBiaW5kIHZvbHVtZSAnJHt0aGlzLm5hbWV9JyB0byBjbGFpbSAnJHtjbGFpbS5uYW1lfScgc2luY2UgaXQgaXMgYWxyZWFkeSBib3VuZCB0byBjbGFpbSAnJHt0aGlzLl9jbGFpbS5uYW1lfSdgKTtcbiAgICB9XG4gICAgdGhpcy5fY2xhaW0gPSBjbGFpbTtcbiAgfVxuXG4gIHB1YmxpYyBhc1ZvbHVtZSgpOiB2b2x1bWUuVm9sdW1lIHtcbiAgICBjb25zdCBjbGFpbSA9IHRoaXMucmVzZXJ2ZSgpO1xuICAgIHJldHVybiB2b2x1bWUuVm9sdW1lLmZyb21QZXJzaXN0ZW50Vm9sdW1lQ2xhaW0odGhpcywgJ1ZvbHVtZScsIGNsYWltKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHB1YmxpYyBfdG9LdWJlKCk6IGs4cy5QZXJzaXN0ZW50Vm9sdW1lU3BlYyB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuc3RvcmFnZSA/IGs4cy5RdWFudGl0eS5mcm9tU3RyaW5nKHRoaXMuc3RvcmFnZS50b0dpYmlieXRlcygpICsgJ0dpJykgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYWltUmVmOiB0aGlzLl9jbGFpbSA/IHsgbmFtZTogdGhpcy5fY2xhaW0/Lm5hbWUgfSA6IHVuZGVmaW5lZCxcbiAgICAgIGFjY2Vzc01vZGVzOiB0aGlzLmFjY2Vzc01vZGVzPy5tYXAoYSA9PiBhLnRvU3RyaW5nKCkpLFxuICAgICAgY2FwYWNpdHk6IHN0b3JhZ2UgPyB7IHN0b3JhZ2UgfSA6IHVuZGVmaW5lZCxcbiAgICAgIG1vdW50T3B0aW9uczogdGhpcy5tb3VudE9wdGlvbnM/Lm1hcChvID0+IG8pLFxuICAgICAgc3RvcmFnZUNsYXNzTmFtZTogdGhpcy5zdG9yYWdlQ2xhc3NOYW1lLFxuICAgICAgcGVyc2lzdGVudFZvbHVtZVJlY2xhaW1Qb2xpY3k6IHRoaXMucmVjbGFpbVBvbGljeSxcbiAgICAgIHZvbHVtZU1vZGU6IHRoaXMubW9kZSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUmVjbGFpbSBQb2xpY2llcy5cbiAqL1xuZXhwb3J0IGVudW0gUGVyc2lzdGVudFZvbHVtZVJlY2xhaW1Qb2xpY3kge1xuXG4gIC8qKlxuICAgKiBUaGUgUmV0YWluIHJlY2xhaW0gcG9saWN5IGFsbG93cyBmb3IgbWFudWFsIHJlY2xhbWF0aW9uIG9mIHRoZSByZXNvdXJjZS5cbiAgICogV2hlbiB0aGUgUGVyc2lzdGVudFZvbHVtZUNsYWltIGlzIGRlbGV0ZWQsIHRoZSBQZXJzaXN0ZW50Vm9sdW1lIHN0aWxsIGV4aXN0cyBhbmQgdGhlXG4gICAqIHZvbHVtZSBpcyBjb25zaWRlcmVkIFwicmVsZWFzZWRcIi4gQnV0IGl0IGlzIG5vdCB5ZXQgYXZhaWxhYmxlIGZvciBhbm90aGVyIGNsYWltXG4gICAqIGJlY2F1c2UgdGhlIHByZXZpb3VzIGNsYWltYW50J3MgZGF0YSByZW1haW5zIG9uIHRoZSB2b2x1bWUuXG4gICAqIEFuIGFkbWluaXN0cmF0b3IgY2FuIG1hbnVhbGx5IHJlY2xhaW0gdGhlIHZvbHVtZSB3aXRoIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG4gICAqXG4gICAqIDEuIERlbGV0ZSB0aGUgUGVyc2lzdGVudFZvbHVtZS4gVGhlIGFzc29jaWF0ZWQgc3RvcmFnZSBhc3NldCBpbiBleHRlcm5hbFxuICAgKiAgICBpbmZyYXN0cnVjdHVyZSAoc3VjaCBhcyBhbiBBV1MgRUJTLCBHQ0UgUEQsIEF6dXJlIERpc2ssIG9yIENpbmRlciB2b2x1bWUpIHN0aWxsIGV4aXN0cyBhZnRlciB0aGUgUFYgaXMgZGVsZXRlZC5cbiAgICogMi4gTWFudWFsbHkgY2xlYW4gdXAgdGhlIGRhdGEgb24gdGhlIGFzc29jaWF0ZWQgc3RvcmFnZSBhc3NldCBhY2NvcmRpbmdseS5cbiAgICogMy4gTWFudWFsbHkgZGVsZXRlIHRoZSBhc3NvY2lhdGVkIHN0b3JhZ2UgYXNzZXQuXG4gICAqXG4gICAqIElmIHlvdSB3YW50IHRvIHJldXNlIHRoZSBzYW1lIHN0b3JhZ2UgYXNzZXQsIGNyZWF0ZSBhIG5ldyBQZXJzaXN0ZW50Vm9sdW1lXG4gICAqIHdpdGggdGhlIHNhbWUgc3RvcmFnZSBhc3NldCBkZWZpbml0aW9uLlxuICAgKi9cbiAgUkVUQUlOID0gJ1JldGFpbicsXG5cbiAgLyoqXG4gICAqIEZvciB2b2x1bWUgcGx1Z2lucyB0aGF0IHN1cHBvcnQgdGhlIERlbGV0ZSByZWNsYWltIHBvbGljeSwgZGVsZXRpb24gcmVtb3ZlcyBib3RoIHRoZVxuICAgKiBQZXJzaXN0ZW50Vm9sdW1lIG9iamVjdCBmcm9tIEt1YmVybmV0ZXMsIGFzIHdlbGwgYXMgdGhlIGFzc29jaWF0ZWQgc3RvcmFnZSBhc3NldCBpblxuICAgKiB0aGUgZXh0ZXJuYWwgaW5mcmFzdHJ1Y3R1cmUsIHN1Y2ggYXMgYW4gQVdTIEVCUywgR0NFIFBELCBBenVyZSBEaXNrLCBvciBDaW5kZXIgdm9sdW1lLlxuICAgKiBWb2x1bWVzIHRoYXQgd2VyZSBkeW5hbWljYWxseSBwcm92aXNpb25lZCBpbmhlcml0IHRoZSByZWNsYWltIHBvbGljeSBvZiB0aGVpciBTdG9yYWdlQ2xhc3MsIHdoaWNoIGRlZmF1bHRzIHRvIERlbGV0ZS5cbiAgICogVGhlIGFkbWluaXN0cmF0b3Igc2hvdWxkIGNvbmZpZ3VyZSB0aGUgU3RvcmFnZUNsYXNzIGFjY29yZGluZyB0byB1c2VycycgZXhwZWN0YXRpb25zOyBvdGhlcndpc2UsXG4gICAqIHRoZSBQViBtdXN0IGJlIGVkaXRlZCBvciBwYXRjaGVkIGFmdGVyIGl0IGlzIGNyZWF0ZWRcbiAgICovXG4gIERFTEVURSA9ICdEZWxldGUnLFxuXG59XG5cbi8qKlxuICogUHJvcGVydGllcyBmb3IgYEF3c0VsYXN0aWNCbG9ja1N0b3JlUGVyc2lzdGVudFZvbHVtZWAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXdzRWxhc3RpY0Jsb2NrU3RvcmVQZXJzaXN0ZW50Vm9sdW1lUHJvcHMgZXh0ZW5kcyBQZXJzaXN0ZW50Vm9sdW1lUHJvcHMge1xuXG4gIC8qKlxuICAgKiBVbmlxdWUgSUQgb2YgdGhlIHBlcnNpc3RlbnQgZGlzayByZXNvdXJjZSBpbiBBV1MgKEFtYXpvbiBFQlMgdm9sdW1lKS4gTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3ZvbHVtZXMjYXdzZWxhc3RpY2Jsb2Nrc3RvcmVcbiAgICpcbiAgICogQHNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3ZvbHVtZXMjYXdzZWxhc3RpY2Jsb2Nrc3RvcmVcbiAgICovXG4gIHJlYWRvbmx5IHZvbHVtZUlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEZpbGVzeXN0ZW0gdHlwZSBvZiB0aGUgdm9sdW1lIHRoYXQgeW91IHdhbnQgdG8gbW91bnQuXG4gICAqIFRpcDogRW5zdXJlIHRoYXQgdGhlIGZpbGVzeXN0ZW0gdHlwZSBpcyBzdXBwb3J0ZWQgYnkgdGhlIGhvc3Qgb3BlcmF0aW5nIHN5c3RlbS5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3ZvbHVtZXMjYXdzZWxhc3RpY2Jsb2Nrc3RvcmVcbiAgICogQGRlZmF1bHQgJ2V4dDQnXG4gICAqL1xuICByZWFkb25seSBmc1R5cGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAgKiBUaGUgcGFydGl0aW9uIGluIHRoZSB2b2x1bWUgdGhhdCB5b3Ugd2FudCB0byBtb3VudC4gSWYgb21pdHRlZCwgdGhlIGRlZmF1bHQgaXMgdG8gbW91bnQgYnkgdm9sdW1lIG5hbWUuXG4gICAgKiBFeGFtcGxlczogRm9yIHZvbHVtZSAvZGV2L3NkYTEsIHlvdSBzcGVjaWZ5IHRoZSBwYXJ0aXRpb24gYXMgXCIxXCIuXG4gICAgKiBTaW1pbGFybHksIHRoZSB2b2x1bWUgcGFydGl0aW9uIGZvciAvZGV2L3NkYSBpcyBcIjBcIiAob3IgeW91IGNhbiBsZWF2ZSB0aGUgcHJvcGVydHkgZW1wdHkpLlxuICAgICpcbiAgICAqIEBkZWZhdWx0IC0gTm8gcGFydGl0aW9uLlxuICAgICovXG4gIHJlYWRvbmx5IHBhcnRpdGlvbj86IG51bWJlcjtcblxuICAvKipcbiAgICAqIFNwZWNpZnkgXCJ0cnVlXCIgdG8gZm9yY2UgYW5kIHNldCB0aGUgUmVhZE9ubHkgcHJvcGVydHkgaW4gVm9sdW1lTW91bnRzIHRvIFwidHJ1ZVwiLlxuICAgICpcbiAgICAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvc3RvcmFnZS92b2x1bWVzI2F3c2VsYXN0aWNibG9ja3N0b3JlXG4gICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICovXG4gIHJlYWRvbmx5IHJlYWRPbmx5PzogYm9vbGVhbjtcblxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gQVdTIERpc2sgcmVzb3VyY2UgdGhhdCBpcyBhdHRhY2hlZCB0byBhIGt1YmVsZXQncyBob3N0IG1hY2hpbmUgYW5kXG4gKiB0aGVuIGV4cG9zZWQgdG8gdGhlIHBvZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2Uvdm9sdW1lcyNhd3NlbGFzdGljYmxvY2tzdG9yZVxuICovXG5leHBvcnQgY2xhc3MgQXdzRWxhc3RpY0Jsb2NrU3RvcmVQZXJzaXN0ZW50Vm9sdW1lIGV4dGVuZHMgUGVyc2lzdGVudFZvbHVtZSB7XG5cbiAgLyoqXG4gICAqIFZvbHVtZSBpZCBvZiB0aGlzIHZvbHVtZS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSB2b2x1bWVJZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCBpdCBpcyBtb3VudGVkIGFzIGEgcmVhZC1vbmx5IHZvbHVtZS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSByZWFkT25seTogYm9vbGVhbjtcblxuICAvKipcbiAgICogRmlsZSBzeXN0ZW0gdHlwZSBvZiB0aGlzIHZvbHVtZS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBmc1R5cGU6IHN0cmluZztcblxuICAvKipcbiAgICogUGFydGl0aW9uIG9mIHRoaXMgdm9sdW1lLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHBhcnRpdGlvbj86IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogQXdzRWxhc3RpY0Jsb2NrU3RvcmVQZXJzaXN0ZW50Vm9sdW1lUHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHByb3BzKTtcblxuICAgIHRoaXMudm9sdW1lSWQgPSBwcm9wcy52b2x1bWVJZDtcbiAgICB0aGlzLnJlYWRPbmx5ID0gcHJvcHMucmVhZE9ubHkgPz8gZmFsc2U7XG4gICAgdGhpcy5mc1R5cGUgPSBwcm9wcy5mc1R5cGUgPz8gJ2V4dDQnO1xuICAgIHRoaXMucGFydGl0aW9uID0gcHJvcHMucGFydGl0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHVibGljIF90b0t1YmUoKTogazhzLlBlcnNpc3RlbnRWb2x1bWVTcGVjIHtcbiAgICBjb25zdCBzcGVjID0gc3VwZXIuX3RvS3ViZSgpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zcGVjLFxuICAgICAgYXdzRWxhc3RpY0Jsb2NrU3RvcmU6IHtcbiAgICAgICAgdm9sdW1lSWQ6IHRoaXMudm9sdW1lSWQsXG4gICAgICAgIGZzVHlwZTogdGhpcy5mc1R5cGUsXG4gICAgICAgIHBhcnRpdGlvbjogdGhpcy5wYXJ0aXRpb24sXG4gICAgICAgIHJlYWRPbmx5OiB0aGlzLnJlYWRPbmx5LFxuICAgICAgfSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUHJvcGVydGllcyBmb3IgYEF6dXJlRGlza1BlcnNpc3RlbnRWb2x1bWVgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEF6dXJlRGlza1BlcnNpc3RlbnRWb2x1bWVQcm9wcyBleHRlbmRzIFBlcnNpc3RlbnRWb2x1bWVQcm9wcyB7XG5cbiAgLyoqXG4gICAqIFRoZSBOYW1lIG9mIHRoZSBkYXRhIGRpc2sgaW4gdGhlIGJsb2Igc3RvcmFnZVxuICAgKi9cbiAgcmVhZG9ubHkgZGlza05hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVSSSB0aGUgZGF0YSBkaXNrIGluIHRoZSBibG9iIHN0b3JhZ2VcbiAgICovXG4gIHJlYWRvbmx5IGRpc2tVcmk6IHN0cmluZztcblxuICAvKipcbiAgICogSG9zdCBDYWNoaW5nIG1vZGUuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gQXp1cmVEaXNrUGVyc2lzdGVudFZvbHVtZUNhY2hpbmdNb2RlLk5PTkUuXG4gICAqL1xuICByZWFkb25seSBjYWNoaW5nTW9kZT86IHZvbHVtZS5BenVyZURpc2tQZXJzaXN0ZW50Vm9sdW1lQ2FjaGluZ01vZGU7XG5cbiAgLyoqXG4gICAgKiBGaWxlc3lzdGVtIHR5cGUgdG8gbW91bnQuIE11c3QgYmUgYSBmaWxlc3lzdGVtIHR5cGUgc3VwcG9ydGVkIGJ5IHRoZSBob3N0IG9wZXJhdGluZyBzeXN0ZW0uXG4gICAgKlxuICAgICogQGRlZmF1bHQgJ2V4dDQnXG4gICAgKi9cbiAgcmVhZG9ubHkgZnNUeXBlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgICogS2luZCBvZiBkaXNrLlxuICAgICpcbiAgICAqIEBkZWZhdWx0IEF6dXJlRGlza1BlcnNpc3RlbnRWb2x1bWVLaW5kLlNIQVJFRFxuICAgICovXG4gIHJlYWRvbmx5IGtpbmQ/OiB2b2x1bWUuQXp1cmVEaXNrUGVyc2lzdGVudFZvbHVtZUtpbmQ7XG5cbiAgLyoqXG4gICAgKiBGb3JjZSB0aGUgUmVhZE9ubHkgc2V0dGluZyBpbiBWb2x1bWVNb3VudHMuXG4gICAgKlxuICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAqL1xuICByZWFkb25seSByZWFkT25seT86IGJvb2xlYW47XG5cbn1cblxuLyoqXG4gKiBBenVyZURpc2sgcmVwcmVzZW50cyBhbiBBenVyZSBEYXRhIERpc2sgbW91bnQgb24gdGhlIGhvc3QgYW5kIGJpbmQgbW91bnQgdG8gdGhlIHBvZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEF6dXJlRGlza1BlcnNpc3RlbnRWb2x1bWUgZXh0ZW5kcyBQZXJzaXN0ZW50Vm9sdW1lIHtcblxuICAvKipcbiAgICogRGlzayBuYW1lIG9mIHRoaXMgdm9sdW1lLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGRpc2tOYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIERpc2sgVVJJIG9mIHRoaXMgdm9sdW1lLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGRpc2tVcmk6IHN0cmluZztcblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgaXQgaXMgbW91bnRlZCBhcyBhIHJlYWQtb25seSB2b2x1bWUuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgcmVhZE9ubHk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIENhY2hpbmcgbW9kZSBvZiB0aGlzIHZvbHVtZS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBjYWNoaW5nTW9kZTogdm9sdW1lLkF6dXJlRGlza1BlcnNpc3RlbnRWb2x1bWVDYWNoaW5nTW9kZTtcblxuICAvKipcbiAgICogRmlsZSBzeXN0ZW0gdHlwZSBvZiB0aGlzIHZvbHVtZS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBmc1R5cGU6IHN0cmluZztcblxuICAvKipcbiAgICogQXp1cmUga2luZCBvZiB0aGlzIHZvbHVtZS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBhenVyZUtpbmQ6IHZvbHVtZS5BenVyZURpc2tQZXJzaXN0ZW50Vm9sdW1lS2luZDtcblxuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogQXp1cmVEaXNrUGVyc2lzdGVudFZvbHVtZVByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCBwcm9wcyk7XG5cbiAgICB0aGlzLmRpc2tOYW1lID0gcHJvcHMuZGlza05hbWU7XG4gICAgdGhpcy5kaXNrVXJpID0gcHJvcHMuZGlza1VyaTtcbiAgICB0aGlzLmNhY2hpbmdNb2RlID0gcHJvcHMuY2FjaGluZ01vZGUgPz8gdm9sdW1lLkF6dXJlRGlza1BlcnNpc3RlbnRWb2x1bWVDYWNoaW5nTW9kZS5OT05FO1xuICAgIHRoaXMuZnNUeXBlID0gcHJvcHMuZnNUeXBlID8/ICdleHQ0JztcbiAgICB0aGlzLmF6dXJlS2luZCA9IHByb3BzLmtpbmQgPz8gdm9sdW1lLkF6dXJlRGlza1BlcnNpc3RlbnRWb2x1bWVLaW5kLlNIQVJFRDtcbiAgICB0aGlzLnJlYWRPbmx5ID0gcHJvcHMucmVhZE9ubHkgPz8gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2t1YmVybmV0ZXMvZXhhbXBsZXMvYmxvYi9tYXN0ZXIvc3RhZ2luZy92b2x1bWVzL2F6dXJlX2Rpc2svUkVBRE1FLm1kXG4gICAqL1xuICBwdWJsaWMgX3RvS3ViZSgpOiBrOHMuUGVyc2lzdGVudFZvbHVtZVNwZWMge1xuICAgIGNvbnN0IHNwZWMgPSBzdXBlci5fdG9LdWJlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnNwZWMsXG4gICAgICBhenVyZURpc2s6IHtcbiAgICAgICAgZGlza05hbWU6IHRoaXMuZGlza05hbWUsXG4gICAgICAgIGRpc2tVcmk6IHRoaXMuZGlza1VyaSxcbiAgICAgICAgY2FjaGluZ01vZGU6IHRoaXMuY2FjaGluZ01vZGUsXG4gICAgICAgIGZzVHlwZTogdGhpcy5mc1R5cGUsXG4gICAgICAgIGtpbmQ6IHRoaXMuYXp1cmVLaW5kLFxuICAgICAgICByZWFkT25seTogdGhpcy5yZWFkT25seSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFByb3BlcnRpZXMgZm9yIGBHQ0VQZXJzaXN0ZW50RGlza1BlcnNpc3RlbnRWb2x1bWVgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdDRVBlcnNpc3RlbnREaXNrUGVyc2lzdGVudFZvbHVtZVByb3BzIGV4dGVuZHMgUGVyc2lzdGVudFZvbHVtZVByb3BzIHtcblxuICAvKipcbiAgICogVW5pcXVlIG5hbWUgb2YgdGhlIFBEIHJlc291cmNlIGluIEdDRS4gVXNlZCB0byBpZGVudGlmeSB0aGUgZGlzayBpbiBHQ0UuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvc3RvcmFnZS92b2x1bWVzI2djZXBlcnNpc3RlbnRkaXNrXG4gICAqL1xuICByZWFkb25seSBwZE5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogRmlsZXN5c3RlbSB0eXBlIG9mIHRoZSB2b2x1bWUgdGhhdCB5b3Ugd2FudCB0byBtb3VudC5cbiAgICogVGlwOiBFbnN1cmUgdGhhdCB0aGUgZmlsZXN5c3RlbSB0eXBlIGlzIHN1cHBvcnRlZCBieSB0aGUgaG9zdCBvcGVyYXRpbmcgc3lzdGVtLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2Uvdm9sdW1lcyNhd3NlbGFzdGljYmxvY2tzdG9yZVxuICAgKiBAZGVmYXVsdCAnZXh0NCdcbiAgICovXG4gIHJlYWRvbmx5IGZzVHlwZT86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHBhcnRpdGlvbiBpbiB0aGUgdm9sdW1lIHRoYXQgeW91IHdhbnQgdG8gbW91bnQuIElmIG9taXR0ZWQsIHRoZSBkZWZhdWx0IGlzIHRvIG1vdW50IGJ5IHZvbHVtZSBuYW1lLlxuICAgKiBFeGFtcGxlczogRm9yIHZvbHVtZSAvZGV2L3NkYTEsIHlvdSBzcGVjaWZ5IHRoZSBwYXJ0aXRpb24gYXMgXCIxXCIuXG4gICAqIFNpbWlsYXJseSwgdGhlIHZvbHVtZSBwYXJ0aXRpb24gZm9yIC9kZXYvc2RhIGlzIFwiMFwiIChvciB5b3UgY2FuIGxlYXZlIHRoZSBwcm9wZXJ0eSBlbXB0eSkuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gcGFydGl0aW9uLlxuICAgKi9cbiAgcmVhZG9ubHkgcGFydGl0aW9uPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IFwidHJ1ZVwiIHRvIGZvcmNlIGFuZCBzZXQgdGhlIFJlYWRPbmx5IHByb3BlcnR5IGluIFZvbHVtZU1vdW50cyB0byBcInRydWVcIi5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3ZvbHVtZXMjYXdzZWxhc3RpY2Jsb2Nrc3RvcmVcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IHJlYWRPbmx5PzogYm9vbGVhbjtcblxufVxuXG4vKipcbiAqIEdDRVBlcnNpc3RlbnREaXNrIHJlcHJlc2VudHMgYSBHQ0UgRGlzayByZXNvdXJjZSB0aGF0IGlzIGF0dGFjaGVkIHRvIGEga3ViZWxldCdzIGhvc3QgbWFjaGluZVxuICogYW5kIHRoZW4gZXhwb3NlZCB0byB0aGUgcG9kLiBQcm92aXNpb25lZCBieSBhbiBhZG1pbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2Uvdm9sdW1lcyNnY2VwZXJzaXN0ZW50ZGlza1xuICovXG5leHBvcnQgY2xhc3MgR0NFUGVyc2lzdGVudERpc2tQZXJzaXN0ZW50Vm9sdW1lIGV4dGVuZHMgUGVyc2lzdGVudFZvbHVtZSB7XG5cbiAgLyoqXG4gICAqIFBEIHJlc291cmNlIGluIEdDRSBvZiB0aGlzIHZvbHVtZS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBwZE5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgaXQgaXMgbW91bnRlZCBhcyBhIHJlYWQtb25seSB2b2x1bWUuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgcmVhZE9ubHk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEZpbGUgc3lzdGVtIHR5cGUgb2YgdGhpcyB2b2x1bWUuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgZnNUeXBlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFBhcnRpdGlvbiBvZiB0aGlzIHZvbHVtZS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBwYXJ0aXRpb24/OiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEdDRVBlcnNpc3RlbnREaXNrUGVyc2lzdGVudFZvbHVtZVByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCBwcm9wcyk7XG5cbiAgICB0aGlzLnBkTmFtZSA9IHByb3BzLnBkTmFtZTtcbiAgICB0aGlzLnJlYWRPbmx5ID0gcHJvcHMucmVhZE9ubHkgPz8gZmFsc2U7XG4gICAgdGhpcy5mc1R5cGUgPSBwcm9wcy5mc1R5cGUgPz8gJ2V4dDQnO1xuICAgIHRoaXMucGFydGl0aW9uID0gcHJvcHMucGFydGl0aW9uO1xuXG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2t1YmVybmV0ZXMvZXhhbXBsZXMvYmxvYi9tYXN0ZXIvc3RhZ2luZy92b2x1bWVzL2F6dXJlX2Rpc2svUkVBRE1FLm1kXG4gICAqL1xuICBwdWJsaWMgX3RvS3ViZSgpOiBrOHMuUGVyc2lzdGVudFZvbHVtZVNwZWMge1xuICAgIGNvbnN0IHNwZWMgPSBzdXBlci5fdG9LdWJlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnNwZWMsXG4gICAgICBnY2VQZXJzaXN0ZW50RGlzazoge1xuICAgICAgICBwZE5hbWU6IHRoaXMucGROYW1lLFxuICAgICAgICBmc1R5cGU6IHRoaXMuZnNUeXBlLFxuICAgICAgICBwYXJ0aXRpb246IHRoaXMucGFydGl0aW9uLFxuICAgICAgICByZWFkT25seTogdGhpcy5yZWFkT25seSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxufSJdfQ==

/***/ }),

/***/ 1967:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PersistentVolumeMode = exports.PersistentVolumeAccessMode = exports.PersistentVolumeClaim = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const cdk8s_1 = __nccwpck_require__(1227);
const constructs_1 = __nccwpck_require__(1963);
const base = __nccwpck_require__(415);
const k8s = __nccwpck_require__(4879);
class ImportedPersistentVolumeClaim extends constructs_1.Construct {
    constructor(scope, id, name) {
        super(scope, id);
        this._name = name;
    }
    get name() {
        return this._name;
    }
    get apiVersion() {
        return k8s.KubePersistentVolumeClaim.GVK.apiVersion;
    }
    get apiGroup() {
        return '';
    }
    get kind() {
        return k8s.KubePersistentVolumeClaim.GVK.kind;
    }
}
/**
 * A PersistentVolumeClaim (PVC) is a request for storage by a user.
 * It is similar to a Pod. Pods consume node resources and PVCs consume PV resources.
 * Pods can request specific levels of resources (CPU and Memory).
 * Claims can request specific size and access modes
 */
class PersistentVolumeClaim extends base.Resource {
    constructor(scope, id, props = {}) {
        var _b;
        super(scope, id);
        this.resourceType = 'persistentvolumeclaims';
        this.storage = props.storage;
        this.volumeMode = (_b = props.volumeMode) !== null && _b !== void 0 ? _b : PersistentVolumeMode.FILE_SYSTEM;
        this.storageClassName = props.storageClassName;
        this._accessModes = props.accessModes;
        if (props.volume) {
            this.bind(props.volume);
        }
        this.apiObject = new k8s.KubePersistentVolumeClaim(this, 'Resource', {
            metadata: props.metadata,
            spec: cdk8s_1.Lazy.any({ produce: () => this._toKube() }),
        });
    }
    /**
     * Imports a pvc from the cluster as a reference.
     */
    static fromClaimName(scope, id, claimName) {
        return new ImportedPersistentVolumeClaim(scope, id, claimName);
    }
    /**
     * Access modes requirement of this claim.
     */
    get accessModes() {
        return this._accessModes ? [...this._accessModes] : undefined;
    }
    /**
     * PV this claim is bound to. Undefined means the claim is not bound
     * to any specific volume.
     */
    get volume() {
        return this._volume;
    }
    /**
     * Bind a claim to a specific volume.
     * Note that you must also bind the volume to the claim.
     *
     * @see https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding
     *
     * @param vol The PV to bind to.
     */
    bind(vol) {
        if (this._volume && this._volume.name !== vol.name) {
            throw new Error(`Cannot bind claim '${this.name}' to volume '${vol.name}' since it is already bound to volume '${this._volume.name}'`);
        }
        this._volume = vol;
    }
    /**
     * @internal
     */
    _toKube() {
        var _b;
        const storage = this.storage ? k8s.Quantity.fromString(this.storage.toGibibytes() + 'Gi') : undefined;
        return {
            volumeName: this.volume ? this.volume.name : undefined,
            accessModes: (_b = this.accessModes) === null || _b === void 0 ? void 0 : _b.map(a => a.toString()),
            resources: storage ? { requests: { storage } } : undefined,
            volumeMode: this.volumeMode,
            storageClassName: this.storageClassName,
        };
    }
}
exports.PersistentVolumeClaim = PersistentVolumeClaim;
_a = JSII_RTTI_SYMBOL_1;
PersistentVolumeClaim[_a] = { fqn: "cdk8s-plus-22.PersistentVolumeClaim", version: "2.0.0-rc.2" };
/**
 * Access Modes.
 */
var PersistentVolumeAccessMode;
(function (PersistentVolumeAccessMode) {
    /**
     * The volume can be mounted as read-write by a single node.
     * ReadWriteOnce access mode still can allow multiple pods to access
     * the volume when the pods are running on the same node.
     */
    PersistentVolumeAccessMode["READ_WRITE_ONCE"] = "ReadWriteOnce";
    /**
     * The volume can be mounted as read-only by many nodes.
     */
    PersistentVolumeAccessMode["READ_ONLY_MANY"] = "ReadOnlyMany";
    /**
     * The volume can be mounted as read-write by many nodes.
     */
    PersistentVolumeAccessMode["READ_WRITE_MANY"] = "ReadWriteMany";
    /**
     * The volume can be mounted as read-write by a single Pod.
     * Use ReadWriteOncePod access mode if you want to ensure that
     * only one pod across whole cluster can read that PVC or write to it.
     * This is only supported for CSI volumes and Kubernetes version 1.22+.
     */
    PersistentVolumeAccessMode["READ_WRITE_ONCE_POD"] = "ReadWriteOncePod";
})(PersistentVolumeAccessMode = exports.PersistentVolumeAccessMode || (exports.PersistentVolumeAccessMode = {}));
/**
 * Volume Modes.
 */
var PersistentVolumeMode;
(function (PersistentVolumeMode) {
    /**
     * Volume is ounted into Pods into a directory.
     * If the volume is backed by a block device and the device is empty,
     * Kubernetes creates a filesystem on the device before mounting it
     * for the first time.
     */
    PersistentVolumeMode["FILE_SYSTEM"] = "Filesystem";
    /**
     * Use a volume as a raw block device. Such volume is presented into a Pod as a block device,
     * without any filesystem on it. This mode is useful to provide a Pod the fastest possible way
     * to access a volume, without any filesystem layer between the Pod
     * and the volume. On the other hand, the application running in
     * the Pod must know how to handle a raw block device
     */
    PersistentVolumeMode["BLOCK"] = "Block";
})(PersistentVolumeMode = exports.PersistentVolumeMode || (exports.PersistentVolumeMode = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHZjLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3B2Yy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGlDQUE4QztBQUM5QywyQ0FBdUM7QUFDdkMsK0JBQStCO0FBQy9CLHFDQUFxQztBQXNFckMsTUFBTSw2QkFBOEIsU0FBUSxzQkFBUztJQUluRCxZQUFZLEtBQWdCLEVBQUUsRUFBVSxFQUFFLElBQVk7UUFDcEQsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNqQixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztJQUNwQixDQUFDO0lBRUQsSUFBVyxJQUFJO1FBQ2IsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ3BCLENBQUM7SUFFRCxJQUFXLFVBQVU7UUFDbkIsT0FBTyxHQUFHLENBQUMseUJBQXlCLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQztJQUN0RCxDQUFDO0lBRUQsSUFBVyxRQUFRO1FBQ2pCLE9BQU8sRUFBRSxDQUFDO0lBQ1osQ0FBQztJQUVELElBQVcsSUFBSTtRQUNiLE9BQU8sR0FBRyxDQUFDLHlCQUF5QixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUM7SUFDaEQsQ0FBQztDQUVGO0FBRUQ7Ozs7O0dBS0c7QUFDSCxNQUFhLHFCQUFzQixTQUFRLElBQUksQ0FBQyxRQUFRO0lBbUN0RCxZQUFtQixLQUFnQixFQUFFLEVBQVUsRUFBRSxRQUFvQyxFQUFHOztRQUN0RixLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBdEJILGlCQUFZLEdBQUcsd0JBQXdCLENBQUM7UUF3QnRELElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQztRQUM3QixJQUFJLENBQUMsVUFBVSxTQUFHLEtBQUssQ0FBQyxVQUFVLG1DQUFJLG9CQUFvQixDQUFDLFdBQVcsQ0FBQztRQUN2RSxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDLGdCQUFnQixD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O0FBbEJELFdBQVksb0JBQW9CO0lBRTlCOzs7OztPQUtHO0lBQ0gsa0RBQTBCLENBQUE7SUFFMUI7Ozs7OztPQU1HO0lBQ0gsdUNBQWUsQ0FBQTtBQUNqQixDQUFDLEVBbEJXLG9CQUFvQixHQUFwQiw0QkFBb0IsS0FBcEIsNEJBQW9CLFFBa0IvQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNpemUsIEFwaU9iamVjdCwgTGF6eSB9IGZyb20gJ2NkazhzJztcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xuaW1wb3J0ICogYXMgYmFzZSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0ICogYXMgazhzIGZyb20gJy4vaW1wb3J0cy9rOHMnO1xuaW1wb3J0ICogYXMgcHYgZnJvbSAnLi9wdic7XG5cbi8qKlxuICogQ29udHJhY3Qgb2YgYSBgUGVyc2lzdGVudFZvbHVtZUNsYWltYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJUGVyc2lzdGVudFZvbHVtZUNsYWltIGV4dGVuZHMgYmFzZS5JUmVzb3VyY2Uge1xuXG59XG5cbi8qKlxuICogUHJvcGVydGllcyBmb3IgYFBlcnNpc3RlbnRWb2x1bWVDbGFpbWAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGVyc2lzdGVudFZvbHVtZUNsYWltUHJvcHMgZXh0ZW5kcyBiYXNlLlJlc291cmNlUHJvcHMge1xuXG4gIC8qKlxuICAgKiBDb250YWlucyB0aGUgYWNjZXNzIG1vZGVzIHRoZSB2b2x1bWUgc2hvdWxkIHN1cHBvcnQuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvc3RvcmFnZS9wZXJzaXN0ZW50LXZvbHVtZXMjYWNjZXNzLW1vZGVzLTFcbiAgICogQGRlZmF1bHQgLSBObyBhY2Nlc3MgbW9kZXMgcmVxdWlyZW1lbnQuXG4gICAqL1xuICByZWFkb25seSBhY2Nlc3NNb2Rlcz86IFBlcnNpc3RlbnRWb2x1bWVBY2Nlc3NNb2RlW107XG5cbiAgLyoqXG4gICAqIE1pbmltdW0gc3RvcmFnZSBzaXplIHRoZSB2b2x1bWUgc2hvdWxkIGhhdmUuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvc3RvcmFnZS9wZXJzaXN0ZW50LXZvbHVtZXMjcmVzb3VyY2VzXG4gICAqIEBkZWZhdWx0IC0gTm8gc3RvcmFnZSByZXF1aXJlbWVudC5cbiAgICovXG4gIHJlYWRvbmx5IHN0b3JhZ2U/OiBTaXplO1xuXG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBTdG9yYWdlQ2xhc3MgcmVxdWlyZWQgYnkgdGhlIGNsYWltLlxuICAgKiBXaGVuIHRoaXMgcHJvcGVydHkgaXMgbm90IHNldCwgdGhlIGJlaGF2aW9yIGlzIGFzIGZvbGxvd3M6XG4gICAqXG4gICAqIC0gSWYgdGhlIGFkbWlzc2lvbiBwbHVnaW4gaXMgdHVybmVkIG9uLCB0aGUgc3RvcmFnZSBjbGFzcyBtYXJrZWQgYXMgZGVmYXVsdCB3aWxsIGJlIHVzZWQuXG4gICAqIC0gSWYgdGhlIGFkbWlzc2lvbiBwbHVnaW4gaXMgdHVybmVkIG9mZiwgdGhlIHB2YyBjYW4gb25seSBiZSBib3VuZCB0byB2b2x1bWVzIHdpdGhvdXQgYSBzdG9yYWdlIGNsYXNzLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2UvcGVyc2lzdGVudC12b2x1bWVzI2NsYXNzLTFcbiAgICogQGRlZmF1bHQgLSBOb3Qgc2V0LlxuICAgKi9cbiAgcmVhZG9ubHkgc3RvcmFnZUNsYXNzTmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogRGVmaW5lcyB3aGF0IHR5cGUgb2Ygdm9sdW1lIGlzIHJlcXVpcmVkIGJ5IHRoZSBjbGFpbS5cbiAgICpcbiAgICogQGRlZmF1bHQgVm9sdW1lTW9kZS5GSUxFX1NZU1RFTVxuICAgKi9cbiAgcmVhZG9ubHkgdm9sdW1lTW9kZT86IFBlcnNpc3RlbnRWb2x1bWVNb2RlO1xuXG4gIC8qKlxuICAgKiBUaGUgUGVyc2lzdGVudFZvbHVtZSBiYWNraW5nIHRoaXMgY2xhaW0uXG4gICAqXG4gICAqIFRoZSBjb250cm9sIHBsYW5lIHN0aWxsIGNoZWNrcyB0aGF0IHN0b3JhZ2UgY2xhc3MsIGFjY2VzcyBtb2RlcyxcbiAgICogYW5kIHJlcXVlc3RlZCBzdG9yYWdlIHNpemUgb24gdGhlIHZvbHVtZSBhcmUgdmFsaWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBpbiBvcmRlciB0byBndWFyYW50ZWUgYSBwcm9wZXIgYmluZGluZywgdGhlIHZvbHVtZSBzaG91bGRcbiAgICogYWxzbyBkZWZpbmUgYSBgY2xhaW1SZWZgIHJlZmVycmluZyB0byB0aGlzIGNsYWltLiBPdGhlcndpc2UsIHRoZSB2b2x1bWUgbWF5IGJlXG4gICAqIGNsYWltZWQgYmUgb3RoZXIgcHZjJ3MgYmVmb3JlIGl0IGdldHMgYSBjaGFuY2UgdG8gYmluZCB0byB0aGlzIG9uZS5cbiAgICpcbiAgICogSWYgdGhlIHZvbHVtZSBpcyBtYW5hZ2VkIChpLmUgbm90IGltcG9ydGVkKSwgeW91IGNhbiB1c2UgYHB2LmNsYWltKClgIHRvIGVhc2lseVxuICAgKiBjcmVhdGUgYSBiaS1kaXJlY3Rpb25hbCBib3VuZGVkIGNsYWltLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2UvcGVyc2lzdGVudC12b2x1bWVzLyNiaW5kaW5nLlxuICAgKiBAZGVmYXVsdCAtIE5vIHNwZWNpZmljIHZvbHVtZSBiaW5kaW5nLlxuICAgKi9cbiAgcmVhZG9ubHkgdm9sdW1lPzogcHYuSVBlcnNpc3RlbnRWb2x1bWU7XG5cbn1cblxuY2xhc3MgSW1wb3J0ZWRQZXJzaXN0ZW50Vm9sdW1lQ2xhaW0gZXh0ZW5kcyBDb25zdHJ1Y3QgaW1wbGVtZW50cyBJUGVyc2lzdGVudFZvbHVtZUNsYWltIHtcblxuICBwcml2YXRlIHJlYWRvbmx5IF9uYW1lOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgbmFtZTogc3RyaW5nKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkKTtcbiAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgbmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICB9XG5cbiAgcHVibGljIGdldCBhcGlWZXJzaW9uKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGs4cy5LdWJlUGVyc2lzdGVudFZvbHVtZUNsYWltLkdWSy5hcGlWZXJzaW9uO1xuICB9XG5cbiAgcHVibGljIGdldCBhcGlHcm91cCgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHB1YmxpYyBnZXQga2luZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBrOHMuS3ViZVBlcnNpc3RlbnRWb2x1bWVDbGFpbS5HVksua2luZDtcbiAgfVxuXG59XG5cbi8qKlxuICogQSBQZXJzaXN0ZW50Vm9sdW1lQ2xhaW0gKFBWQykgaXMgYSByZXF1ZXN0IGZvciBzdG9yYWdlIGJ5IGEgdXNlci5cbiAqIEl0IGlzIHNpbWlsYXIgdG8gYSBQb2QuIFBvZHMgY29uc3VtZSBub2RlIHJlc291cmNlcyBhbmQgUFZDcyBjb25zdW1lIFBWIHJlc291cmNlcy5cbiAqIFBvZHMgY2FuIHJlcXVlc3Qgc3BlY2lmaWMgbGV2ZWxzIG9mIHJlc291cmNlcyAoQ1BVIGFuZCBNZW1vcnkpLlxuICogQ2xhaW1zIGNhbiByZXF1ZXN0IHNwZWNpZmljIHNpemUgYW5kIGFjY2VzcyBtb2Rlc1xuICovXG5leHBvcnQgY2xhc3MgUGVyc2lzdGVudFZvbHVtZUNsYWltIGV4dGVuZHMgYmFzZS5SZXNvdXJjZSBpbXBsZW1lbnRzIElQZXJzaXN0ZW50Vm9sdW1lQ2xhaW0ge1xuXG4gIC8qKlxuICAgKiBJbXBvcnRzIGEgcHZjIGZyb20gdGhlIGNsdXN0ZXIgYXMgYSByZWZlcmVuY2UuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21DbGFpbU5hbWUoc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgY2xhaW1OYW1lOiBzdHJpbmcpOiBJUGVyc2lzdGVudFZvbHVtZUNsYWltIHtcbiAgICByZXR1cm4gbmV3IEltcG9ydGVkUGVyc2lzdGVudFZvbHVtZUNsYWltKHNjb3BlLCBpZCwgY2xhaW1OYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGJhc2UuUmVzb3VyY2UuYXBpT2JqZWN0XG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgYXBpT2JqZWN0OiBBcGlPYmplY3Q7XG5cbiAgcHVibGljIHJlYWRvbmx5IHJlc291cmNlVHlwZSA9ICdwZXJzaXN0ZW50dm9sdW1lY2xhaW1zJztcblxuICAvKipcbiAgICogU3RvcmFnZSByZXF1aXJlbWVudCBvZiB0aGlzIGNsYWltLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHN0b3JhZ2U/OiBTaXplO1xuXG4gIC8qKlxuICAgKiBWb2x1bWUgbW9kZSByZXF1aXJlbWVudCBvZiB0aGlzIGNsYWltLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHZvbHVtZU1vZGU6IFBlcnNpc3RlbnRWb2x1bWVNb2RlO1xuXG4gIC8qKlxuICAgKiBTdG9yYWdlIGNsYXNzIHJlcXVpcm1lbnQgb2YgdGhpcyBjbGFpbS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBzdG9yYWdlQ2xhc3NOYW1lPzogc3RyaW5nO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgX2FjY2Vzc01vZGVzPzogUGVyc2lzdGVudFZvbHVtZUFjY2Vzc01vZGVbXTtcblxuICBwcml2YXRlIF92b2x1bWU/OiBwdi5JUGVyc2lzdGVudFZvbHVtZTtcblxuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IFBlcnNpc3RlbnRWb2x1bWVDbGFpbVByb3BzID0geyB9KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkKTtcblxuICAgIHRoaXMuc3RvcmFnZSA9IHByb3BzLnN0b3JhZ2U7XG4gICAgdGhpcy52b2x1bWVNb2RlID0gcHJvcHMudm9sdW1lTW9kZSA/PyBQZXJzaXN0ZW50Vm9sdW1lTW9kZS5GSUxFX1NZU1RFTTtcbiAgICB0aGlzLnN0b3JhZ2VDbGFzc05hbWUgPSBwcm9wcy5zdG9yYWdlQ2xhc3NOYW1lO1xuICAgIHRoaXMuX2FjY2Vzc01vZGVzID0gcHJvcHMuYWNjZXNzTW9kZXM7XG5cbiAgICBpZiAocHJvcHMudm9sdW1lKSB7XG4gICAgICB0aGlzLmJpbmQocHJvcHMudm9sdW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLmFwaU9iamVjdCA9IG5ldyBrOHMuS3ViZVBlcnNpc3RlbnRWb2x1bWVDbGFpbSh0aGlzLCAnUmVzb3VyY2UnLCB7XG4gICAgICBtZXRhZGF0YTogcHJvcHMubWV0YWRhdGEsXG4gICAgICBzcGVjOiBMYXp5LmFueSh7IHByb2R1Y2U6ICgpID0+IHRoaXMuX3RvS3ViZSgpIH0pLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VzcyBtb2RlcyByZXF1aXJlbWVudCBvZiB0aGlzIGNsYWltLlxuICAgKi9cbiAgcHVibGljIGdldCBhY2Nlc3NNb2RlcygpOiBQZXJzaXN0ZW50Vm9sdW1lQWNjZXNzTW9kZVtdIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fYWNjZXNzTW9kZXMgPyBbLi4udGhpcy5fYWNjZXNzTW9kZXNdIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFBWIHRoaXMgY2xhaW0gaXMgYm91bmQgdG8uIFVuZGVmaW5lZCBtZWFucyB0aGUgY2xhaW0gaXMgbm90IGJvdW5kXG4gICAqIHRvIGFueSBzcGVjaWZpYyB2b2x1bWUuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHZvbHVtZSgpOiBwdi5JUGVyc2lzdGVudFZvbHVtZSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX3ZvbHVtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kIGEgY2xhaW0gdG8gYSBzcGVjaWZpYyB2b2x1bWUuXG4gICAqIE5vdGUgdGhhdCB5b3UgbXVzdCBhbHNvIGJpbmQgdGhlIHZvbHVtZSB0byB0aGUgY2xhaW0uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvc3RvcmFnZS9wZXJzaXN0ZW50LXZvbHVtZXMvI2JpbmRpbmdcbiAgICpcbiAgICogQHBhcmFtIHZvbCBUaGUgUFYgdG8gYmluZCB0by5cbiAgICovXG4gIHB1YmxpYyBiaW5kKHZvbDogcHYuSVBlcnNpc3RlbnRWb2x1bWUpIHtcbiAgICBpZiAodGhpcy5fdm9sdW1lICYmIHRoaXMuX3ZvbHVtZS5uYW1lICE9PSB2b2wubmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgYmluZCBjbGFpbSAnJHt0aGlzLm5hbWV9JyB0byB2b2x1bWUgJyR7dm9sLm5hbWV9JyBzaW5jZSBpdCBpcyBhbHJlYWR5IGJvdW5kIHRvIHZvbHVtZSAnJHt0aGlzLl92b2x1bWUubmFtZX0nYCk7XG4gICAgfVxuICAgIHRoaXMuX3ZvbHVtZSA9IHZvbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHB1YmxpYyBfdG9LdWJlKCk6IGs4cy5QZXJzaXN0ZW50Vm9sdW1lQ2xhaW1TcGVjIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5zdG9yYWdlID8gazhzLlF1YW50aXR5LmZyb21TdHJpbmcodGhpcy5zdG9yYWdlLnRvR2liaWJ5dGVzKCkgKyAnR2knKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4ge1xuICAgICAgdm9sdW1lTmFtZTogdGhpcy52b2x1bWUgPyB0aGlzLnZvbHVtZS5uYW1lIDogdW5kZWZpbmVkLFxuICAgICAgYWNjZXNzTW9kZXM6IHRoaXMuYWNjZXNzTW9kZXM/Lm1hcChhID0+IGEudG9TdHJpbmcoKSksXG4gICAgICByZXNvdXJjZXM6IHN0b3JhZ2UgPyB7IHJlcXVlc3RzOiB7IHN0b3JhZ2UgfSB9IDogdW5kZWZpbmVkLFxuICAgICAgdm9sdW1lTW9kZTogdGhpcy52b2x1bWVNb2RlLFxuICAgICAgc3RvcmFnZUNsYXNzTmFtZTogdGhpcy5zdG9yYWdlQ2xhc3NOYW1lLFxuICAgIH07XG4gIH1cblxufVxuXG4vKipcbiAqIEFjY2VzcyBNb2Rlcy5cbiAqL1xuZXhwb3J0IGVudW0gUGVyc2lzdGVudFZvbHVtZUFjY2Vzc01vZGUge1xuXG4gIC8qKlxuICAgKiBUaGUgdm9sdW1lIGNhbiBiZSBtb3VudGVkIGFzIHJlYWQtd3JpdGUgYnkgYSBzaW5nbGUgbm9kZS5cbiAgICogUmVhZFdyaXRlT25jZSBhY2Nlc3MgbW9kZSBzdGlsbCBjYW4gYWxsb3cgbXVsdGlwbGUgcG9kcyB0byBhY2Nlc3NcbiAgICogdGhlIHZvbHVtZSB3aGVuIHRoZSBwb2RzIGFyZSBydW5uaW5nIG9uIHRoZSBzYW1lIG5vZGUuXG4gICAqL1xuICBSRUFEX1dSSVRFX09OQ0UgPSAnUmVhZFdyaXRlT25jZScsXG5cbiAgLyoqXG4gICAqIFRoZSB2b2x1bWUgY2FuIGJlIG1vdW50ZWQgYXMgcmVhZC1vbmx5IGJ5IG1hbnkgbm9kZXMuXG4gICAqL1xuICBSRUFEX09OTFlfTUFOWSA9ICdSZWFkT25seU1hbnknLFxuXG4gIC8qKlxuICAgKiBUaGUgdm9sdW1lIGNhbiBiZSBtb3VudGVkIGFzIHJlYWQtd3JpdGUgYnkgbWFueSBub2Rlcy5cbiAgICovXG4gIFJFQURfV1JJVEVfTUFOWSA9ICdSZWFkV3JpdGVNYW55JyxcblxuICAvKipcbiAgICogVGhlIHZvbHVtZSBjYW4gYmUgbW91bnRlZCBhcyByZWFkLXdyaXRlIGJ5IGEgc2luZ2xlIFBvZC5cbiAgICogVXNlIFJlYWRXcml0ZU9uY2VQb2QgYWNjZXNzIG1vZGUgaWYgeW91IHdhbnQgdG8gZW5zdXJlIHRoYXRcbiAgICogb25seSBvbmUgcG9kIGFjcm9zcyB3aG9sZSBjbHVzdGVyIGNhbiByZWFkIHRoYXQgUFZDIG9yIHdyaXRlIHRvIGl0LlxuICAgKiBUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBDU0kgdm9sdW1lcyBhbmQgS3ViZXJuZXRlcyB2ZXJzaW9uIDEuMjIrLlxuICAgKi9cbiAgUkVBRF9XUklURV9PTkNFX1BPRCA9ICdSZWFkV3JpdGVPbmNlUG9kJ1xuXG59XG5cbi8qKlxuICogVm9sdW1lIE1vZGVzLlxuICovXG5leHBvcnQgZW51bSBQZXJzaXN0ZW50Vm9sdW1lTW9kZSB7XG5cbiAgLyoqXG4gICAqIFZvbHVtZSBpcyBvdW50ZWQgaW50byBQb2RzIGludG8gYSBkaXJlY3RvcnkuXG4gICAqIElmIHRoZSB2b2x1bWUgaXMgYmFja2VkIGJ5IGEgYmxvY2sgZGV2aWNlIGFuZCB0aGUgZGV2aWNlIGlzIGVtcHR5LFxuICAgKiBLdWJlcm5ldGVzIGNyZWF0ZXMgYSBmaWxlc3lzdGVtIG9uIHRoZSBkZXZpY2UgYmVmb3JlIG1vdW50aW5nIGl0XG4gICAqIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgICovXG4gIEZJTEVfU1lTVEVNID0gJ0ZpbGVzeXN0ZW0nLFxuXG4gIC8qKlxuICAgKiBVc2UgYSB2b2x1bWUgYXMgYSByYXcgYmxvY2sgZGV2aWNlLiBTdWNoIHZvbHVtZSBpcyBwcmVzZW50ZWQgaW50byBhIFBvZCBhcyBhIGJsb2NrIGRldmljZSxcbiAgICogd2l0aG91dCBhbnkgZmlsZXN5c3RlbSBvbiBpdC4gVGhpcyBtb2RlIGlzIHVzZWZ1bCB0byBwcm92aWRlIGEgUG9kIHRoZSBmYXN0ZXN0IHBvc3NpYmxlIHdheVxuICAgKiB0byBhY2Nlc3MgYSB2b2x1bWUsIHdpdGhvdXQgYW55IGZpbGVzeXN0ZW0gbGF5ZXIgYmV0d2VlbiB0aGUgUG9kXG4gICAqIGFuZCB0aGUgdm9sdW1lLiBPbiB0aGUgb3RoZXIgaGFuZCwgdGhlIGFwcGxpY2F0aW9uIHJ1bm5pbmcgaW5cbiAgICogdGhlIFBvZCBtdXN0IGtub3cgaG93IHRvIGhhbmRsZSBhIHJhdyBibG9jayBkZXZpY2VcbiAgICovXG4gIEJMT0NLID0gJ0Jsb2NrJ1xufVxuIl19

/***/ }),

/***/ 8131:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Group = exports.User = exports.ClusterRoleBinding = exports.RoleBinding = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const cdk8s_1 = __nccwpck_require__(1227);
const constructs_1 = __nccwpck_require__(1963);
const base_1 = __nccwpck_require__(415);
const k8s = __nccwpck_require__(4879);
const utils_1 = __nccwpck_require__(6594);
/**
 * A RoleBinding grants permissions within a specific namespace to a user or
 * set of users.
 */
class RoleBinding extends base_1.Resource {
    constructor(scope, id, props) {
        super(scope, id);
        this.resourceType = 'rolebindings';
        this.role = props.role;
        this._subjects = new Array();
        this.apiObject = new k8s.KubeRoleBinding(this, 'Resource', {
            metadata: props.metadata,
            subjects: cdk8s_1.Lazy.any({ produce: () => this.synthesizeSubjects() }),
            roleRef: cdk8s_1.Lazy.any({ produce: () => this.synthesizeRoleRef() }),
        });
    }
    /**
     * Adds a subject to the role.
     * @param subjects The subjects to add
     */
    addSubjects(...subjects) {
        for (const subject of subjects) {
            this._subjects.push(subject);
        }
    }
    get subjects() {
        return [...this._subjects];
    }
    synthesizeRoleRef() {
        return {
            apiGroup: this.role.apiGroup,
            kind: this.role.kind,
            name: this.role.name,
        };
    }
    synthesizeSubjects() {
        return this._subjects.map(subject => subject.toSubjectConfiguration()).map((subject) => utils_1.filterUndefined({
            apiGroup: subject.apiGroup === 'core' ? '' : subject.apiGroup,
            kind: subject.kind,
            name: subject.name,
            namespace: subject.namespace,
        }));
    }
}
exports.RoleBinding = RoleBinding;
_a = JSII_RTTI_SYMBOL_1;
RoleBinding[_a] = { fqn: "cdk8s-plus-22.RoleBinding", version: "2.0.0-rc.2" };
/**
 * A ClusterRoleBinding grants permissions cluster-wide to a user or
 * set of users.
 */
class ClusterRoleBinding extends base_1.Resource {
    constructor(scope, id, props) {
        super(scope, id);
        this.resourceType = 'clusterrolebindings';
        this.role = props.role;
        this._subjects = new Array();
        this.apiObject = new k8s.KubeClusterRoleBinding(this, 'Resource', {
            metadata: props.metadata,
            subjects: cdk8s_1.Lazy.any({ produce: () => this.synthesizeSubjects() }),
            roleRef: cdk8s_1.Lazy.any({ produce: () => this.synthesizeRoleRef() }),
        });
    }
    /**
     * Adds a subject to the role.
     * @param subjects The subjects to add
     */
    addSubjects(...subjects) {
        for (const subject of subjects) {
            this._subjects.push(subject);
        }
    }
    get subjects() {
        return [...this._subjects];
    }
    synthesizeRoleRef() {
        return {
            apiGroup: this.role.apiGroup,
            kind: this.role.kind,
            name: this.role.name,
        };
    }
    synthesizeSubjects() {
        return this._subjects.map(subject => subject.toSubjectConfiguration()).map((subject) => utils_1.filterUndefined({
            apiGroup: subject.apiGroup === 'core' ? '' : subject.apiGroup,
            kind: subject.kind,
            name: subject.name,
            namespace: subject.namespace,
        }));
    }
}
exports.ClusterRoleBinding = ClusterRoleBinding;
_b = JSII_RTTI_SYMBOL_1;
ClusterRoleBinding[_b] = { fqn: "cdk8s-plus-22.ClusterRoleBinding", version: "2.0.0-rc.2" };
/**
 * Represents a user.
 */
class User extends constructs_1.Construct {
    constructor(scope, id, name) {
        super(scope, id);
        this.apiGroup = 'rbac.authorization.k8s.io';
        this.kind = 'User';
        this.name = name;
    }
    /**
     * Reference a user in the cluster by name.
     */
    static fromName(scope, id, name) {
        return new User(scope, id, name);
    }
    /**
     * @see ISubect.toSubjectConfiguration()
     */
    toSubjectConfiguration() {
        return {
            kind: this.kind,
            name: this.name,
            apiGroup: this.apiGroup,
        };
    }
}
exports.User = User;
_c = JSII_RTTI_SYMBOL_1;
User[_c] = { fqn: "cdk8s-plus-22.User", version: "2.0.0-rc.2" };
/**
 * Represents a group.
 */
class Group extends constructs_1.Construct {
    constructor(scope, id, name) {
        super(scope, id);
        this.apiGroup = 'rbac.authorization.k8s.io';
        this.kind = 'Group';
        this.name = name;
    }
    /**
     * Reference a group by name.
     */
    static fromName(scope, id, name) {
        return new Group(scope, id, name);
    }
    /**
     * @see ISubect.toSubjectConfiguration()
     */
    toSubjectConfiguration() {
        return {
            kind: this.kind,
            name: this.name,
            apiGroup: this.apiGroup,
        };
    }
}
exports.Group = Group;
_d = JSII_RTTI_SYMBOL_1;
Group[_d] = { fqn: "cdk8s-plus-22.Group", version: "2.0.0-rc.2" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm9sZS1iaW5kaW5nLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3JvbGUtYmluZGluZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGlDQUF3QztBQUN4QywyQ0FBbUQ7QUFDbkQsaUNBQWlEO0FBQ2pELHFDQUFxQztBQUVyQyxtQ0FBMEM7QUEyRDFDOzs7R0FHRztBQUNILE1BQWEsV0FBWSxTQUFRLGVBQVE7SUFZdkMsWUFBWSxLQUFnQixFQUFFLEVBQVUsRUFBRSxLQUF1QjtRQUMvRCxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBUEgsaUJBQVksR0FBRyxjQUFjLENBQUM7UUFTNUMsSUFBSSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDO1FBRXZCLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxLQUFLLEVBQVksQ0FBQztRQUV2QyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksR0FBRyxDQUFDLGVBQWUsQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFO1lBQ3pELFFBQVEsRUFBRSxLQUFLLENBQUMsUUFBUTtZQUN4QixRQUFRLEVBQUUsWUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsRUFBRSxDQUFDO1lBQ2hFLE9BQU8sRUFBRSxZQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxFQUFFLENBQUM7U0FDL0QsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7T0FHRztJQUNJLFdBQVcsQ0FBQyxHQUFHLFFBQW9CO1FBQ3hDLEtBQUssTUFBTSxPQUFPLElBQUksUUFBUSxFQUFFO1lBQzlCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQzlCO0lBQ0gsQ0FBQztJQUVELElBQVcsUUFBUTtR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RUFBRSxFQUFVLEVBQUUsSUFBWTtRQUMvRCxPQUFPLElBQUksS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQVdEOztPQUVHO0lBQ0ksc0JBQXNCO1FBQzNCLE9BQU87WUFDTCxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7WUFDZixJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7WUFDZixRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVE7U0FDeEIsQ0FBQztJQUNKLENBQUM7O0FBM0JILHNCQTZCQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwaU9iamVjdCwgTGF6eSB9IGZyb20gJ2NkazhzJztcbmltcG9ydCB7IENvbnN0cnVjdCwgSUNvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xuaW1wb3J0IHsgUmVzb3VyY2UsIFJlc291cmNlUHJvcHMgfSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0ICogYXMgazhzIGZyb20gJy4vaW1wb3J0cy9rOHMnO1xuaW1wb3J0ICogYXMgcm9sZSBmcm9tICcuL3JvbGUnO1xuaW1wb3J0IHsgZmlsdGVyVW5kZWZpbmVkIH0gZnJvbSAnLi91dGlscyc7XG5cbi8qKlxuICogU3ViamVjdCBjb250YWlucyBhIHJlZmVyZW5jZSB0byB0aGUgb2JqZWN0IG9yIHVzZXIgaWRlbnRpdGllcyBhIHJvbGUgYmluZGluZ1xuICogYXBwbGllcyB0by4gVGhpcyBjYW4gZWl0aGVyIGhvbGQgYSBkaXJlY3QgQVBJIG9iamVjdCByZWZlcmVuY2UsIG9yIGEgdmFsdWVcbiAqIGZvciBub24tb2JqZWN0cyBzdWNoIGFzIHVzZXIgYW5kIGdyb3VwIG5hbWVzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN1YmplY3RDb25maWd1cmF0aW9uIHtcblxuICAvKipcbiAgICogQVBJR3JvdXAgaG9sZHMgdGhlIEFQSSBncm91cCBvZiB0aGUgcmVmZXJlbmNlZCBzdWJqZWN0LiBEZWZhdWx0cyB0byBcIlwiIGZvclxuICAgKiBTZXJ2aWNlQWNjb3VudCBzdWJqZWN0cy4gRGVmYXVsdHMgdG8gXCJyYmFjLmF1dGhvcml6YXRpb24uazhzLmlvXCIgZm9yIFVzZXJcbiAgICogYW5kIEdyb3VwIHN1YmplY3RzLlxuICAgKi9cbiAgcmVhZG9ubHkgYXBpR3JvdXA/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEtpbmQgb2Ygb2JqZWN0IGJlaW5nIHJlZmVyZW5jZWQuIFZhbHVlcyBkZWZpbmVkIGJ5IHRoaXMgQVBJIGdyb3VwIGFyZVxuICAgKiBcIlVzZXJcIiwgXCJHcm91cFwiLCBhbmQgXCJTZXJ2aWNlQWNjb3VudFwiLiBJZiB0aGUgQXV0aG9yaXplciBkb2VzIG5vdFxuICAgKiByZWNvZ25pemVkIHRoZSBraW5kIHZhbHVlLCB0aGUgQXV0aG9yaXplciBzaG91bGQgcmVwb3J0IGFuIGVycm9yLlxuICAgKi9cbiAgcmVhZG9ubHkga2luZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBvYmplY3QgYmVpbmcgcmVmZXJlbmNlZC5cbiAgICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogTmFtZXNwYWNlIG9mIHRoZSByZWZlcmVuY2VkIG9iamVjdC4gIElmIHRoZSBvYmplY3Qga2luZCBpcyBub24tbmFtZXNwYWNlLFxuICAgKiBzdWNoIGFzIFwiVXNlclwiIG9yIFwiR3JvdXBcIiwgYW5kIHRoaXMgdmFsdWUgaXMgbm90IGVtcHR5IHRoZSBBdXRob3JpemVyXG4gICAqIHNob3VsZCByZXBvcnQgYW4gZXJyb3IuXG4gICAqL1xuICByZWFkb25seSBuYW1lc3BhY2U/OiBzdHJpbmc7XG5cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgcm9sZSBiaW5kaW5nIHN1YmplY3QuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSVN1YmplY3QgZXh0ZW5kcyBJQ29uc3RydWN0IHtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBzdWJqZWN0IGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuICB0b1N1YmplY3RDb25maWd1cmF0aW9uKCk6IFN1YmplY3RDb25maWd1cmF0aW9uO1xuXG59XG5cbi8qKlxuICogUHJvcGVydGllcyBmb3IgYFJvbGVCaW5kaW5nYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb2xlQmluZGluZ1Byb3BzIGV4dGVuZHMgUmVzb3VyY2VQcm9wcyB7XG4gIC8qKlxuICAgKiBUaGUgcm9sZSB0byBiaW5kIHRvLiBBIFJvbGVCaW5kaW5nIGNhbiByZWZlcmVuY2UgYSBSb2xlIG9yIGEgQ2x1c3RlclJvbGUuXG4gICAqL1xuICByZWFkb25seSByb2xlOiByb2xlLklSb2xlO1xufVxuXG4vKipcbiAqIEEgUm9sZUJpbmRpbmcgZ3JhbnRzIHBlcm1pc3Npb25zIHdpdGhpbiBhIHNwZWNpZmljIG5hbWVzcGFjZSB0byBhIHVzZXIgb3JcbiAqIHNldCBvZiB1c2Vycy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJvbGVCaW5kaW5nIGV4dGVuZHMgUmVzb3VyY2Uge1xuICAvKipcbiAgICogQHNlZSBiYXNlLlJlc291cmNlLmFwaU9iamVjdFxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGFwaU9iamVjdDogQXBpT2JqZWN0O1xuXG4gIHB1YmxpYyByZWFkb25seSByZXNvdXJjZVR5cGUgPSAncm9sZWJpbmRpbmdzJztcblxuICBwdWJsaWMgcmVhZG9ubHkgcm9sZTogcm9sZS5JUm9sZTtcblxuICBwcml2YXRlIHJlYWRvbmx5IF9zdWJqZWN0czogQXJyYXk8SVN1YmplY3Q+O1xuXG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBSb2xlQmluZGluZ1Byb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkKTtcblxuICAgIHRoaXMucm9sZSA9IHByb3BzLnJvbGU7XG5cbiAgICB0aGlzLl9zdWJqZWN0cyA9IG5ldyBBcnJheTxJU3ViamVjdD4oKTtcblxuICAgIHRoaXMuYXBpT2JqZWN0ID0gbmV3IGs4cy5LdWJlUm9sZUJpbmRpbmcodGhpcywgJ1Jlc291cmNlJywge1xuICAgICAgbWV0YWRhdGE6IHByb3BzLm1ldGFkYXRhLFxuICAgICAgc3ViamVjdHM6IExhenkuYW55KHsgcHJvZHVjZTogKCkgPT4gdGhpcy5zeW50aGVzaXplU3ViamVjdHMoKSB9KSxcbiAgICAgIHJvbGVSZWY6IExhenkuYW55KHsgcHJvZHVjZTogKCkgPT4gdGhpcy5zeW50aGVzaXplUm9sZVJlZigpIH0pLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBzdWJqZWN0IHRvIHRoZSByb2xlLlxuICAgKiBAcGFyYW0gc3ViamVjdHMgVGhlIHN1YmplY3RzIHRvIGFkZFxuICAgKi9cbiAgcHVibGljIGFkZFN1YmplY3RzKC4uLnN1YmplY3RzOiBJU3ViamVjdFtdKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBzdWJqZWN0IG9mIHN1YmplY3RzKSB7XG4gICAgICB0aGlzLl9zdWJqZWN0cy5wdXNoKHN1YmplY3QpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXQgc3ViamVjdHMoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLl9zdWJqZWN0c107XG4gIH1cblxuICBwcml2YXRlIHN5bnRoZXNpemVSb2xlUmVmKCk6IGs4cy5Sb2xlUmVmIHtcbiAgICByZXR1cm4ge1xuICAgICAgYXBpR3JvdXA6IHRoaXMucm9sZS5hcGlHcm91cCxcbiAgICAgIGtpbmQ6IHRoaXMucm9sZS5raW5kLFxuICAgICAgbmFtZTogdGhpcy5yb2xlLm5hbWUsXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgc3ludGhlc2l6ZVN1YmplY3RzKCk6IGs4cy5TdWJqZWN0W10ge1xuICAgIHJldHVybiB0aGlzLl9zdWJqZWN0cy5tYXAoc3ViamVjdCA9PiBzdWJqZWN0LnRvU3ViamVjdENvbmZpZ3VyYXRpb24oKSkubWFwKChzdWJqZWN0KSA9PiBmaWx0ZXJVbmRlZmluZWQoe1xuICAgICAgYXBpR3JvdXA6IHN1YmplY3QuYXBpR3JvdXAgPT09ICdjb3JlJyA/ICcnIDogc3ViamVjdC5hcGlHcm91cCxcbiAgICAgIGtpbmQ6IHN1YmplY3Qua2luZCxcbiAgICAgIG5hbWU6IHN1YmplY3QubmFtZSxcbiAgICAgIG5hbWVzcGFjZTogc3ViamVjdC5uYW1lc3BhY2UsXG4gICAgfSkpO1xuICB9XG59XG5cbi8qKlxuICogUHJvcGVydGllcyBmb3IgYENsdXN0ZXJSb2xlQmluZGluZ2AuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2x1c3RlclJvbGVCaW5kaW5nUHJvcHMgZXh0ZW5kcyBSZXNvdXJjZVByb3BzIHtcbiAgLyoqXG4gICAqIFRoZSByb2xlIHRvIGJpbmQgdG8uXG4gICAqL1xuICByZWFkb25seSByb2xlOiByb2xlLklDbHVzdGVyUm9sZTtcbn1cblxuLyoqXG4gKiBBIENsdXN0ZXJSb2xlQmluZGluZyBncmFudHMgcGVybWlzc2lvbnMgY2x1c3Rlci13aWRlIHRvIGEgdXNlciBvclxuICogc2V0IG9mIHVzZXJzLlxuICovXG5leHBvcnQgY2xhc3MgQ2x1c3RlclJvbGVCaW5kaW5nIGV4dGVuZHMgUmVzb3VyY2Uge1xuICAvKipcbiAgICogQHNlZSBiYXNlLlJlc291cmNlLmFwaU9iamVjdFxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGFwaU9iamVjdDogQXBpT2JqZWN0O1xuXG4gIHB1YmxpYyByZWFkb25seSByZXNvdXJjZVR5cGUgPSAnY2x1c3RlcnJvbGViaW5kaW5ncyc7XG5cbiAgcHVibGljIHJlYWRvbmx5IHJvbGU6IHJvbGUuSUNsdXN0ZXJSb2xlO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgX3N1YmplY3RzOiBBcnJheTxJU3ViamVjdD47XG5cbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IENsdXN0ZXJSb2xlQmluZGluZ1Byb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkKTtcblxuICAgIHRoaXMucm9sZSA9IHByb3BzLnJvbGU7XG5cbiAgICB0aGlzLl9zdWJqZWN0cyA9IG5ldyBBcnJheTxJU3ViamVjdD4oKTtcblxuICAgIHRoaXMuYXBpT2JqZWN0ID0gbmV3IGs4cy5LdWJlQ2x1c3RlclJvbGVCaW5kaW5nKHRoaXMsICdSZXNvdXJjZScsIHtcbiAgICAgIG1ldGFkYXRhOiBwcm9wcy5tZXRhZGF0YSxcbiAgICAgIHN1YmplY3RzOiBMYXp5LmFueSh7IHByb2R1Y2U6ICgpID0+IHRoaXMuc3ludGhlc2l6ZVN1YmplY3RzKCkgfSksXG4gICAgICByb2xlUmVmOiBMYXp5LmFueSh7IHByb2R1Y2U6ICgpID0+IHRoaXMuc3ludGhlc2l6ZVJvbGVSZWYoKSB9KSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgc3ViamVjdCB0byB0aGUgcm9sZS5cbiAgICogQHBhcmFtIHN1YmplY3RzIFRoZSBzdWJqZWN0cyB0byBhZGRcbiAgICovXG4gIHB1YmxpYyBhZGRTdWJqZWN0cyguLi5zdWJqZWN0czogSVN1YmplY3RbXSk6IHZvaWQge1xuICAgIGZvciAoY29uc3Qgc3ViamVjdCBvZiBzdWJqZWN0cykge1xuICAgICAgdGhpcy5fc3ViamVjdHMucHVzaChzdWJqZWN0KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0IHN1YmplY3RzKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5fc3ViamVjdHNdO1xuICB9XG5cbiAgcHJpdmF0ZSBzeW50aGVzaXplUm9sZVJlZigpOiBrOHMuUm9sZVJlZiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFwaUdyb3VwOiB0aGlzLnJvbGUuYXBpR3JvdXAsXG4gICAgICBraW5kOiB0aGlzLnJvbGUua2luZCxcbiAgICAgIG5hbWU6IHRoaXMucm9sZS5uYW1lLFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIHN5bnRoZXNpemVTdWJqZWN0cygpOiBrOHMuU3ViamVjdFtdIHtcbiAgICByZXR1cm4gdGhpcy5fc3ViamVjdHMubWFwKHN1YmplY3QgPT4gc3ViamVjdC50b1N1YmplY3RDb25maWd1cmF0aW9uKCkpLm1hcCgoc3ViamVjdCkgPT4gZmlsdGVyVW5kZWZpbmVkKHtcbiAgICAgIGFwaUdyb3VwOiBzdWJqZWN0LmFwaUdyb3VwID09PSAnY29yZScgPyAnJyA6IHN1YmplY3QuYXBpR3JvdXAsXG4gICAgICBraW5kOiBzdWJqZWN0LmtpbmQsXG4gICAgICBuYW1lOiBzdWJqZWN0Lm5hbWUsXG4gICAgICBuYW1lc3BhY2U6IHN1YmplY3QubmFtZXNwYWNlLFxuICAgIH0pKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB1c2VyLlxuICovXG5leHBvcnQgY2xhc3MgVXNlciBleHRlbmRzIENvbnN0cnVjdCBpbXBsZW1lbnRzIElTdWJqZWN0IHtcblxuICAvKipcbiAgICogUmVmZXJlbmNlIGEgdXNlciBpbiB0aGUgY2x1c3RlciBieSBuYW1lLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tTmFtZShzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBuYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IFVzZXIoc2NvcGUsIGlkLCBuYW1lKTtcbiAgfVxuXG4gIHB1YmxpYyByZWFkb25seSBhcGlHcm91cDogc3RyaW5nIHwgdW5kZWZpbmVkID0gJ3JiYWMuYXV0aG9yaXphdGlvbi5rOHMuaW8nO1xuICBwdWJsaWMgcmVhZG9ubHkga2luZDogc3RyaW5nID0gJ1VzZXInO1xuICBwdWJsaWMgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgbmFtZTogc3RyaW5nKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgSVN1YmVjdC50b1N1YmplY3RDb25maWd1cmF0aW9uKClcbiAgICovXG4gIHB1YmxpYyB0b1N1YmplY3RDb25maWd1cmF0aW9uKCk6IFN1YmplY3RDb25maWd1cmF0aW9uIHtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogdGhpcy5raW5kLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgYXBpR3JvdXA6IHRoaXMuYXBpR3JvdXAsXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBncm91cC5cbiAqL1xuZXhwb3J0IGNsYXNzIEdyb3VwIGV4dGVuZHMgQ29uc3RydWN0IGltcGxlbWVudHMgSVN1YmplY3Qge1xuXG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgYSBncm91cCBieSBuYW1lLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tTmFtZShzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBuYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IEdyb3VwKHNjb3BlLCBpZCwgbmFtZSk7XG4gIH1cblxuICBwdWJsaWMgcmVhZG9ubHkgYXBpR3JvdXA6IHN0cmluZyB8IHVuZGVmaW5lZCA9ICdyYmFjLmF1dGhvcml6YXRpb24uazhzLmlvJztcbiAgcHVibGljIHJlYWRvbmx5IGtpbmQ6IHN0cmluZyA9ICdHcm91cCc7XG4gIHB1YmxpYyByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBuYW1lOiBzdHJpbmcpIHtcbiAgICBzdXBlcihzY29wZSwgaWQpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBJU3ViZWN0LnRvU3ViamVjdENvbmZpZ3VyYXRpb24oKVxuICAgKi9cbiAgcHVibGljIHRvU3ViamVjdENvbmZpZ3VyYXRpb24oKTogU3ViamVjdENvbmZpZ3VyYXRpb24ge1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBhcGlHcm91cDogdGhpcy5hcGlHcm91cCxcbiAgICB9O1xuICB9XG5cbn1cbiJdfQ==

/***/ }),

/***/ 1886:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClusterRole = exports.Role = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const cdk8s_1 = __nccwpck_require__(1227);
const constructs_1 = __nccwpck_require__(1963);
const base = __nccwpck_require__(415);
const k8s = __nccwpck_require__(4879);
const rb = __nccwpck_require__(8131);
const utils_1 = __nccwpck_require__(6594);
class ImportedRole extends constructs_1.Construct {
    constructor(scope, id, name) {
        super(scope, id);
        this._name = name;
    }
    get name() {
        return this._name;
    }
    get apiVersion() {
        return k8s.KubeRole.GVK.apiVersion;
    }
    get apiGroup() {
        return 'rbac.authorization.k8s.io';
    }
    get kind() {
        return k8s.KubeRole.GVK.kind;
    }
}
/**
 * Role is a namespaced, logical grouping of PolicyRules that can be referenced
 * as a unit by a RoleBinding.
 */
class Role extends base.Resource {
    constructor(scope, id, props = {}) {
        super(scope, id);
        this.resourceType = 'roles';
        this._rules = [];
        this.apiObject = new k8s.KubeRole(this, 'Resource', {
            metadata: props.metadata,
            rules: cdk8s_1.Lazy.any({ produce: () => this.synthesizeRules() }),
        });
    }
    /**
     * Imports a role from the cluster as a reference.
     */
    static fromRoleName(scope, id, name) {
        return new ImportedRole(scope, id, name);
    }
    /**
     * Rules associaated with this Role.
     * Returns a copy, use `allow` to add rules.
     */
    get rules() {
        return [...this._rules];
    }
    /**
     * Add permission to perform a list of HTTP verbs on a collection of
     * resources.
     *
     * @param resources The resource(s) to apply to
     * @see https://kubernetes.io/docs/reference/access-authn-authz/authorization/#determine-the-request-verb
     */
    allow(verbs, ...resources) {
        this._rules.push({ verbs, resources });
    }
    /**
     * Add "create" permission for the resources.
     * @param resources The resource(s) to apply to
     */
    allowCreate(...resources) {
        this.allow(['create'], ...resources);
    }
    /**
     * Add "get" permission for the resources.
     * @param resources The resource(s) to apply to
     */
    allowGet(...resources) {
        this.allow(['get'], ...resources);
    }
    /**
     * Add "list" permission for the resources.
     * @param resources The resource(s) to apply to
     */
    allowList(...resources) {
        this.allow(['list'], ...resources);
    }
    /**
     * Add "watch" permission for the resources.
     * @param resources The resource(s) to apply to
     */
    allowWatch(...resources) {
        this.allow(['watch'], ...resources);
    }
    /**
     * Add "update" permission for the resources.
     * @param resources The resource(s) to apply to
     */
    allowUpdate(...resources) {
        this.allow(['update'], ...resources);
    }
    /**
     * Add "patch" permission for the resources.
     * @param resources The resource(s) to apply to
     */
    allowPatch(...resources) {
        this.allow(['patch'], ...resources);
    }
    /**
     * Add "delete" permission for the resources.
     * @param resources The resource(s) to apply to
     */
    allowDelete(...resources) {
        this.allow(['delete'], ...resources);
    }
    /**
     * Add "deletecollection" permission for the resources.
     * @param resources The resource(s) to apply to
     */
    allowDeleteCollection(...resources) {
        this.allow(['deletecollection'], ...resources);
    }
    /**
     * Add "get", "list", and "watch" permissions for the resources.
     * @param resources The resource(s) to apply to
     */
    allowRead(...resources) {
        this.allow(['get', 'list', 'watch'], ...resources);
    }
    /**
     * Add "get", "list", "watch", "create", "update", "patch", "delete", and
     * "deletecollection" permissions for the resources.
     *
     * @param resources The resource(s) to apply to
     */
    allowReadWrite(...resources) {
        this.allow(['get', 'list', 'watch', 'create', 'update', 'patch', 'delete', 'deletecollection'], ...resources);
    }
    /**
     * Create a RoleBinding that binds the permissions in this Role
     * to a list of subjects, that will only apply this role's namespace.
     * @param subjects a list of subjects to bind to
     */
    bind(...subjects) {
        const subjectsAddress = utils_1.address(...subjects);
        const binding = new rb.RoleBinding(this, `RoleBinding${subjectsAddress}`, {
            metadata: {
                namespace: this.metadata.namespace,
            },
            role: this,
        });
        binding.addSubjects(...subjects);
        return binding;
    }
    synthesizeRules() {
        const rules = [];
        for (const rule of this._rules) {
            for (const resource of rule.resources) {
                rules.push({
                    verbs: rule.verbs,
                    apiGroups: [resource.apiGroup === 'core' ? '' : resource.apiGroup],
                    resourceNames: resource.resourceName ? [resource.resourceName] : undefined,
                    resources: resource.resourceType ? [resource.resourceType] : undefined,
                });
            }
        }
        return rules;
    }
}
exports.Role = Role;
_a = JSII_RTTI_SYMBOL_1;
Role[_a] = { fqn: "cdk8s-plus-22.Role", version: "2.0.0-rc.2" };
class ImportedClusterRole extends constructs_1.Construct {
    constructor(scope, id, name) {
        super(scope, id);
        this._name = name;
    }
    get name() {
        return this._name;
    }
    get apiVersion() {
        return k8s.KubeClusterRole.GVK.apiVersion;
    }
    get apiGroup() {
        return 'rbac.authorization.k8s.io';
    }
    get kind() {
        return k8s.KubeClusterRole.GVK.kind;
    }
}
/**
 * ClusterRole is a cluster level, logical grouping of PolicyRules that can be
 * referenced as a unit by a RoleBinding or ClusterRoleBinding.
 */
class ClusterRole extends base.Resource {
    constructor(scope, id, props = {}) {
        var _c, _d;
        super(scope, id);
        this.resourceType = 'clusterroles';
        this._labelSelector = {};
        this._rules = [];
        this.apiObject = new k8s.KubeClusterRole(this, 'Resource', {
            metadata: props.metadata,
            rules: cdk8s_1.Lazy.any({ produce: () => this.synthesizeRules() }),
            aggregationRule: cdk8s_1.Lazy.any({ produce: () => this.synthesizeAggregationRules() }),
        });
        for (const rule of (_c = props.rules) !== null && _c !== void 0 ? _c : []) {
            this.allow(rule.verbs, ...rule.endpoints);
        }
        for (const [key, value] of Object.entries((_d = props.aggregationLabels) !== null && _d !== void 0 ? _d : {})) {
            this.aggregate(key, value);
        }
    }
    /**
     * Imports a role from the cluster as a reference.
     */
    static fromClusterRoleName(scope, id, name) {
        return new ImportedClusterRole(scope, id, name);
    }
    /**
     * Rules associaated with this Role.
     * Returns a copy, use `allow` to add rules.
     */
    get rules() {
        return [...this._rules];
    }
    /**
     * Add permission to perform a list of HTTP verbs on a collection of
     * resources.
     *
     * @param endpoints The endpoints(s) to apply to
     * @see https://kubernetes.io/docs/reference/access-authn-authz/authorization/#determine-the-request-verb
     */
    allow(verbs, ...endpoints) {
        this._rules.push({ verbs, endpoints });
    }
    /**
     * Add "create" permission for the resources.
     * @param endpoints The resource(s) to apply to
     */
    allowCreate(...endpoints) {
        this.allow(['create'], ...endpoints);
    }
    /**
     * Add "get" permission for the resources.
     * @param endpoints The resource(s) to apply to
     */
    allowGet(...endpoints) {
        this.allow(['get'], ...endpoints);
    }
    /**
     * Add "list" permission for the resources.
     * @param endpoints The resource(s) to apply to
     */
    allowList(...endpoints) {
        this.allow(['list'], ...endpoints);
    }
    /**
     * Add "watch" permission for the resources.
     * @param endpoints The resource(s) to apply to
     */
    allowWatch(...endpoints) {
        this.allow(['watch'], ...endpoints);
    }
    /**
     * Add "update" permission for the resources.
     * @param endpoints The resource(s) to apply to
     */
    allowUpdate(...endpoints) {
        this.allow(['update'], ...endpoints);
    }
    /**
     * Add "patch" permission for the resources.
     * @param endpoints The resource(s) to apply to
     */
    allowPatch(...endpoints) {
        this.allow(['patch'], ...endpoints);
    }
    /**
     * Add "delete" permission for the resources.
     * @param endpoints The resource(s) to apply to
     */
    allowDelete(...endpoints) {
        this.allow(['delete'], ...endpoints);
    }
    /**
     * Add "deletecollection" permission for the resources.
     * @param endpoints The resource(s) to apply to
     */
    allowDeleteCollection(...endpoints) {
        this.allow(['deletecollection'], ...endpoints);
    }
    /**
     * Add "get", "list", and "watch" permissions for the resources.
     * @param endpoints The resource(s) to apply to
     */
    allowRead(...endpoints) {
        this.allow(['get', 'list', 'watch'], ...endpoints);
    }
    /**
     * Add "get", "list", "watch", "create", "update", "patch", "delete", and
     * "deletecollection" permissions for the resources.
     *
     * @param endpoints The resource(s) to apply to
     */
    allowReadWrite(...endpoints) {
        this.allow(['get', 'list', 'watch', 'create', 'update', 'patch', 'delete', 'deletecollection'], ...endpoints);
    }
    /**
     * Aggregate rules from roles matching this label selector.
     */
    aggregate(key, value) {
        this._labelSelector[key] = value;
    }
    /**
     * Combines the rules of the argument ClusterRole into this ClusterRole
     * using aggregation labels.
     * @param rol
     */
    combine(rol) {
        const key = `cdk8s.cluster-role/aggregate-to-${cdk8s_1.Names.toLabelValue(this)}`;
        const value = 'true';
        rol.metadata.addLabel(key, value);
        this.aggregate(key, value);
    }
    /**
     * Create a RoleBinding that binds the permissions in this ClusterRole
     * to a list of subjects, that will only apply to the given namespace.
     * @param namespace the namespace to limit permissions to.
     * @param subjects a list of subjects to bind to
     */
    bindInNamespace(namespace, ...subjects) {
        const binding = new rb.RoleBinding(this, `RoleBinding-${namespace}`, {
            metadata: {
                namespace,
            },
            role: this,
        });
        binding.addSubjects(...subjects);
        return binding;
    }
    /**
     * Create a ClusterRoleBinding that binds the permissions in this
     * ClusterRole to a list of subjects, without namespace restrictions.
     * @param subjects a list of subjects to bind to
     */
    bind(...subjects) {
        const binding = new rb.ClusterRoleBinding(this, 'ClusterRoleBinding', {
            role: this,
        });
        binding.addSubjects(...subjects);
        return binding;
    }
    synthesizeRules() {
        const rules = [];
        for (const rule of this._rules) {
            for (const endpoint of rule.endpoints) {
                const resource = endpoint.asApiResource();
                const nonResource = endpoint.asNonApiResource();
                if (resource && nonResource) {
                    throw new Error('Endpoint must be either resource or non resource. not both.');
                }
                if (!resource && !nonResource) {
                    throw new Error('Endpoint must be either resource or non resource. not neither.');
                }
                if (resource) {
                    rules.push({
                        apiGroups: [resource.apiGroup === 'core' ? '' : resource.apiGroup],
                        resources: [resource.resourceType],
                        resourceNames: resource.resourceName ? [resource.resourceName] : [],
                        verbs: rule.verbs,
                    });
                }
                if (nonResource) {
                    rules.push({ verbs: rule.verbs, nonResourceUrLs: [nonResource] });
                }
            }
        }
        return rules;
    }
    synthesizeAggregationRules() {
        if (Object.keys(this._labelSelector).length === 0) {
            return undefined;
        }
        return { clusterRoleSelectors: [{ matchLabels: this._labelSelector }] };
    }
}
exports.ClusterRole = ClusterRole;
_b = JSII_RTTI_SYMBOL_1;
ClusterRole[_b] = { fqn: "cdk8s-plus-22.ClusterRole", version: "2.0.0-rc.2" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm9sZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9yb2xlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsaUNBQStDO0FBQy9DLDJDQUF1QztBQUV2QywrQkFBK0I7QUFDL0IscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyxtQ0FBa0M7QUFzQ2xDLE1BQU0sWUFBYSxTQUFRLHNCQUFTO0lBR2xDLFlBQVksS0FBZ0IsRUFBRSxFQUFVLEVBQUUsSUFBWTtRQUNwRCxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ2pCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO0lBQ3BCLENBQUM7SUFFRCxJQUFXLElBQUk7UUFDYixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7SUFDcEIsQ0FBQztJQUVELElBQVcsVUFBVTtRQUNuQixPQUFPLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQztJQUNyQyxDQUFDO0lBRUQsSUFBVyxRQUFRO1FBQ2pCLE9BQU8sMkJBQTJCLENBQUM7SUFDckMsQ0FBQztJQUVELElBQVcsSUFBSTtRQUNiLE9BQU8sR0FBRyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDO0lBQy9CLENBQUM7Q0FDRjtBQUVEOzs7R0FHRztBQUNILE1BQWEsSUFBSyxTQUFRLElBQUksQ0FBQyxRQUFRO0lBa0JyQyxZQUFZLEtBQWdCLEVBQUUsRUFBVSxFQUFFLFFBQW1CLEVBQUU7UUFDN0QsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUxILGlCQUFZLEdBQUcsT0FBTyxDQUFDO1FBRXRCLFdBQU0sR0FBMEIsRUFBRSxDQUFDO1FBS2xELElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxVQUFVLEVBQUU7WUFDbEQsUUFBUSxFQUFFLEtBQUssQ0FBQyxRQUFRO1lBQ3hCLEtBQUssRUFBRSxZ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Q0FBQztJQUNmLENBQUM7SUFFTywwQkFBMEI7UUFDaEMsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ2pELE9BQU8sU0FBUyxDQUFDO1NBQ2xCO1FBRUQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLENBQUMsRUFBRSxXQUFXLEVBQUUsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDLEVBQUUsQ0FBQztJQUMxRSxDQUFDOztBQWpPSCxrQ0FrT0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcGlPYmplY3QsIExhenksIE5hbWVzIH0gZnJvbSAnY2RrOHMnO1xuaW1wb3J0IHsgQ29uc3RydWN0IH0gZnJvbSAnY29uc3RydWN0cyc7XG5pbXBvcnQgeyBJQXBpUmVzb3VyY2UsIElBcGlFbmRwb2ludCB9IGZyb20gJy4vYXBpLXJlc291cmNlLmdlbmVyYXRlZCc7XG5pbXBvcnQgKiBhcyBiYXNlIGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgKiBhcyBrOHMgZnJvbSAnLi9pbXBvcnRzL2s4cyc7XG5pbXBvcnQgKiBhcyByYiBmcm9tICcuL3JvbGUtYmluZGluZyc7XG5pbXBvcnQgeyBhZGRyZXNzIH0gZnJvbSAnLi91dGlscyc7XG5cbi8qKlxuICogQSByZWZlcmVuY2UgdG8gYW55IFJvbGUgb3IgQ2x1c3RlclJvbGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSVJvbGUgZXh0ZW5kcyBiYXNlLklSZXNvdXJjZSB7XG5cbn1cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIGZvciBgUm9sZWAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm9sZVByb3BzIGV4dGVuZHMgYmFzZS5SZXNvdXJjZVByb3BzIHtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIHJ1bGVzIHRoZSByb2xlIHNob3VsZCBhbGxvdy5cbiAgICpcbiAgICogQGRlZmF1bHQgW11cbiAgICovXG4gIHJlYWRvbmx5IHJ1bGVzPzogUm9sZVBvbGljeVJ1bGVbXTtcbn1cblxuLyoqXG4gKiBQb2xpY3kgcnVsZSBvZiBhIGBSb2xlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvbGVQb2xpY3lSdWxlIHtcblxuICAvKipcbiAgICogVmVyYnMgdG8gYWxsb3cuIChlLmcgWydnZXQnLCAnd2F0Y2gnXSlcbiAgICovXG4gIHJlYWRvbmx5IHZlcmJzOiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogUmVzb3VyY2VzIHRoaXMgcnVsZSBhcHBsaWVzIHRvLlxuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VzOiBJQXBpUmVzb3VyY2VbXTtcbn1cblxuY2xhc3MgSW1wb3J0ZWRSb2xlIGV4dGVuZHMgQ29uc3RydWN0IGltcGxlbWVudHMgSVJvbGUge1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgX25hbWU6IHN0cmluZztcbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgbmFtZTogc3RyaW5nKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkKTtcbiAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgbmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICB9XG5cbiAgcHVibGljIGdldCBhcGlWZXJzaW9uKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGs4cy5LdWJlUm9sZS5HVksuYXBpVmVyc2lvbjtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYXBpR3JvdXAoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ3JiYWMuYXV0aG9yaXphdGlvbi5rOHMuaW8nO1xuICB9XG5cbiAgcHVibGljIGdldCBraW5kKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGs4cy5LdWJlUm9sZS5HVksua2luZDtcbiAgfVxufVxuXG4vKipcbiAqIFJvbGUgaXMgYSBuYW1lc3BhY2VkLCBsb2dpY2FsIGdyb3VwaW5nIG9mIFBvbGljeVJ1bGVzIHRoYXQgY2FuIGJlIHJlZmVyZW5jZWRcbiAqIGFzIGEgdW5pdCBieSBhIFJvbGVCaW5kaW5nLlxuICovXG5leHBvcnQgY2xhc3MgUm9sZSBleHRlbmRzIGJhc2UuUmVzb3VyY2UgaW1wbGVtZW50cyBJUm9sZSB7XG5cbiAgLyoqXG4gICAqIEltcG9ydHMgYSByb2xlIGZyb20gdGhlIGNsdXN0ZXIgYXMgYSByZWZlcmVuY2UuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21Sb2xlTmFtZShzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBuYW1lOiBzdHJpbmcpOiBJUm9sZSB7XG4gICAgcmV0dXJuIG5ldyBJbXBvcnRlZFJvbGUoc2NvcGUsIGlkLCBuYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGJhc2UuUmVzb3VyY2UuYXBpT2JqZWN0XG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgYXBpT2JqZWN0OiBBcGlPYmplY3Q7XG5cbiAgcHVibGljIHJlYWRvbmx5IHJlc291cmNlVHlwZSA9ICdyb2xlcyc7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBfcnVsZXM6IEFycmF5PFJvbGVQb2xpY3lSdWxlPiA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBSb2xlUHJvcHMgPSB7fSkge1xuICAgIHN1cGVyKHNjb3BlLCBpZCk7XG5cbiAgICB0aGlzLmFwaU9iamVjdCA9IG5ldyBrOHMuS3ViZVJvbGUodGhpcywgJ1Jlc291cmNlJywge1xuICAgICAgbWV0YWRhdGE6IHByb3BzLm1ldGFkYXRhLFxuICAgICAgcnVsZXM6IExhenkuYW55KHsgcHJvZHVjZTogKCkgPT4gdGhpcy5zeW50aGVzaXplUnVsZXMoKSB9KSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdWxlcyBhc3NvY2lhYXRlZCB3aXRoIHRoaXMgUm9sZS5cbiAgICogUmV0dXJucyBhIGNvcHksIHVzZSBgYWxsb3dgIHRvIGFkZCBydWxlcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgcnVsZXMoKTogUm9sZVBvbGljeVJ1bGVbXSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLl9ydWxlc107XG4gIH1cblxuICAvKipcbiAgICogQWRkIHBlcm1pc3Npb24gdG8gcGVyZm9ybSBhIGxpc3Qgb2YgSFRUUCB2ZXJicyBvbiBhIGNvbGxlY3Rpb24gb2ZcbiAgICogcmVzb3VyY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gcmVzb3VyY2VzIFRoZSByZXNvdXJjZShzKSB0byBhcHBseSB0b1xuICAgKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL3JlZmVyZW5jZS9hY2Nlc3MtYXV0aG4tYXV0aHovYXV0aG9yaXphdGlvbi8jZGV0ZXJtaW5lLXRoZS1yZXF1ZXN0LXZlcmJcbiAgICovXG4gIHB1YmxpYyBhbGxvdyh2ZXJiczogc3RyaW5nW10sIC4uLnJlc291cmNlczogSUFwaVJlc291cmNlW10pOiB2b2lkIHtcbiAgICB0aGlzLl9ydWxlcy5wdXNoKHsgdmVyYnMsIHJlc291cmNlcyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgXCJjcmVhdGVcIiBwZXJtaXNzaW9uIGZvciB0aGUgcmVzb3VyY2VzLlxuICAgKiBAcGFyYW0gcmVzb3VyY2VzIFRoZSByZXNvdXJjZShzKSB0byBhcHBseSB0b1xuICAgKi9cbiAgcHVibGljIGFsbG93Q3JlYXRlKC4uLnJlc291cmNlczogSUFwaVJlc291cmNlW10pOiB2b2lkIHtcbiAgICB0aGlzLmFsbG93KFsnY3JlYXRlJ10sIC4uLnJlc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIFwiZ2V0XCIgcGVybWlzc2lvbiBmb3IgdGhlIHJlc291cmNlcy5cbiAgICogQHBhcmFtIHJlc291cmNlcyBUaGUgcmVzb3VyY2UocykgdG8gYXBwbHkgdG9cbiAgICovXG4gIHB1YmxpYyBhbGxvd0dldCguLi5yZXNvdXJjZXM6IElBcGlSZXNvdXJjZVtdKTogdm9pZCB7XG4gICAgdGhpcy5hbGxvdyhbJ2dldCddLCAuLi5yZXNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBcImxpc3RcIiBwZXJtaXNzaW9uIGZvciB0aGUgcmVzb3VyY2VzLlxuICAgKiBAcGFyYW0gcmVzb3VyY2VzIFRoZSByZXNvdXJjZShzKSB0byBhcHBseSB0b1xuICAgKi9cbiAgcHVibGljIGFsbG93TGlzdCguLi5yZXNvdXJjZXM6IElBcGlSZXNvdXJjZVtdKTogdm9pZCB7XG4gICAgdGhpcy5hbGxvdyhbJ2xpc3QnXSwgLi4ucmVzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgXCJ3YXRjaFwiIHBlcm1pc3Npb24gZm9yIHRoZSByZXNvdXJjZXMuXG4gICAqIEBwYXJhbSByZXNvdXJjZXMgVGhlIHJlc291cmNlKHMpIHRvIGFwcGx5IHRvXG4gICAqL1xuICBwdWJsaWMgYWxsb3dXYXRjaCguLi5yZXNvdXJjZXM6IElBcGlSZXNvdXJjZVtdKTogdm9pZCB7XG4gICAgdGhpcy5hbGxvdyhbJ3dhdGNoJ10sIC4uLnJlc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIFwidXBkYXRlXCIgcGVybWlzc2lvbiBmb3IgdGhlIHJlc291cmNlcy5cbiAgICogQHBhcmFtIHJlc291cmNlcyBUaGUgcmVzb3VyY2UocykgdG8gYXBwbHkgdG9cbiAgICovXG4gIHB1YmxpYyBhbGxvd1VwZGF0ZSguLi5yZXNvdXJjZXM6IElBcGlSZXNvdXJjZVtdKTogdm9pZCB7XG4gICAgdGhpcy5hbGxvdyhbJ3VwZGF0ZSddLCAuLi5yZXNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBcInBhdGNoXCIgcGVybWlzc2lvbiBmb3IgdGhlIHJlc291cmNlcy5cbiAgICogQHBhcmFtIHJlc291cmNlcyBUaGUgcmVzb3VyY2UocykgdG8gYXBwbHkgdG9cbiAgICovXG4gIHB1YmxpYyBhbGxvd1BhdGNoKC4uLnJlc291cmNlczogSUFwaVJlc291cmNlW10pOiB2b2lkIHtcbiAgICB0aGlzLmFsbG93KFsncGF0Y2gnXSwgLi4ucmVzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgXCJkZWxldGVcIiBwZXJtaXNzaW9uIGZvciB0aGUgcmVzb3VyY2VzLlxuICAgKiBAcGFyYW0gcmVzb3VyY2VzIFRoZSByZXNvdXJjZShzKSB0byBhcHBseSB0b1xuICAgKi9cbiAgcHVibGljIGFsbG93RGVsZXRlKC4uLnJlc291cmNlczogSUFwaVJlc291cmNlW10pOiB2b2lkIHtcbiAgICB0aGlzLmFsbG93KFsnZGVsZXRlJ10sIC4uLnJlc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIFwiZGVsZXRlY29sbGVjdGlvblwiIHBlcm1pc3Npb24gZm9yIHRoZSByZXNvdXJjZXMuXG4gICAqIEBwYXJhbSByZXNvdXJjZXMgVGhlIHJlc291cmNlKHMpIHRvIGFwcGx5IHRvXG4gICAqL1xuICBwdWJsaWMgYWxsb3dEZWxldGVDb2xsZWN0aW9uKC4uLnJlc291cmNlczogSUFwaVJlc291cmNlW10pOiB2b2lkIHtcbiAgICB0aGlzLmFsbG93KFsnZGVsZXRlY29sbGVjdGlvbiddLCAuLi5yZXNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBcImdldFwiLCBcImxpc3RcIiwgYW5kIFwid2F0Y2hcIiBwZXJtaXNzaW9ucyBmb3IgdGhlIHJlc291cmNlcy5cbiAgICogQHBhcmFtIHJlc291cmNlcyBUaGUgcmVzb3VyY2UocykgdG8gYXBwbHkgdG9cbiAgICovXG4gIHB1YmxpYyBhbGxvd1JlYWQoLi4ucmVzb3VyY2VzOiBJQXBpUmVzb3VyY2VbXSk6IHZvaWQge1xuICAgIHRoaXMuYWxsb3coWydnZXQnLCAnbGlzdCcsICd3YXRjaCddLCAuLi5yZXNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBcImdldFwiLCBcImxpc3RcIiwgXCJ3YXRjaFwiLCBcImNyZWF0ZVwiLCBcInVwZGF0ZVwiLCBcInBhdGNoXCIsIFwiZGVsZXRlXCIsIGFuZFxuICAgKiBcImRlbGV0ZWNvbGxlY3Rpb25cIiBwZXJtaXNzaW9ucyBmb3IgdGhlIHJlc291cmNlcy5cbiAgICpcbiAgICogQHBhcmFtIHJlc291cmNlcyBUaGUgcmVzb3VyY2UocykgdG8gYXBwbHkgdG9cbiAgICovXG4gIHB1YmxpYyBhbGxvd1JlYWRXcml0ZSguLi5yZXNvdXJjZXM6IElBcGlSZXNvdXJjZVtdKTogdm9pZCB7XG4gICAgdGhpcy5hbGxvdyhbJ2dldCcsICdsaXN0JywgJ3dhdGNoJywgJ2NyZWF0ZScsICd1cGRhdGUnLCAncGF0Y2gnLCAnZGVsZXRlJywgJ2RlbGV0ZWNvbGxlY3Rpb24nXSwgLi4ucmVzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBSb2xlQmluZGluZyB0aGF0IGJpbmRzIHRoZSBwZXJtaXNzaW9ucyBpbiB0aGlzIFJvbGVcbiAgICogdG8gYSBsaXN0IG9mIHN1YmplY3RzLCB0aGF0IHdpbGwgb25seSBhcHBseSB0aGlzIHJvbGUncyBuYW1lc3BhY2UuXG4gICAqIEBwYXJhbSBzdWJqZWN0cyBhIGxpc3Qgb2Ygc3ViamVjdHMgdG8gYmluZCB0b1xuICAgKi9cbiAgcHVibGljIGJpbmQoLi4uc3ViamVjdHM6IHJiLklTdWJqZWN0W10pOiByYi5Sb2xlQmluZGluZyB7XG4gICAgY29uc3Qgc3ViamVjdHNBZGRyZXNzID0gYWRkcmVzcyguLi5zdWJqZWN0cyk7XG4gICAgY29uc3QgYmluZGluZyA9IG5ldyByYi5Sb2xlQmluZGluZyh0aGlzLCBgUm9sZUJpbmRpbmcke3N1YmplY3RzQWRkcmVzc31gLCB7XG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBuYW1lc3BhY2U6IHRoaXMubWV0YWRhdGEubmFtZXNwYWNlLFxuICAgICAgfSxcbiAgICAgIHJvbGU6IHRoaXMsXG4gICAgfSk7XG4gICAgYmluZGluZy5hZGRTdWJqZWN0cyguLi5zdWJqZWN0cyk7XG4gICAgcmV0dXJuIGJpbmRpbmc7XG4gIH1cblxuICBwcml2YXRlIHN5bnRoZXNpemVSdWxlcygpOiBrOHMuUG9saWN5UnVsZVtdIHtcbiAgICBjb25zdCBydWxlczogazhzLlBvbGljeVJ1bGVbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgcnVsZSBvZiB0aGlzLl9ydWxlcykge1xuICAgICAgZm9yIChjb25zdCByZXNvdXJjZSBvZiBydWxlLnJlc291cmNlcykge1xuICAgICAgICBydWxlcy5wdXNoKHtcbiAgICAgICAgICB2ZXJiczogcnVsZS52ZXJicyxcbiAgICAgICAgICBhcGlHcm91cHM6IFtyZXNvdXJjZS5hcGlHcm91cCA9PT0gJ2NvcmUnID8gJycgOiByZXNvdXJjZS5hcGlHcm91cF0sXG4gICAgICAgICAgcmVzb3VyY2VOYW1lczogcmVzb3VyY2UucmVzb3VyY2VOYW1lID8gW3Jlc291cmNlLnJlc291cmNlTmFtZV0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgcmVzb3VyY2VzOiByZXNvdXJjZS5yZXNvdXJjZVR5cGUgPyBbcmVzb3VyY2UucmVzb3VyY2VUeXBlXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydWxlcztcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjbHVzdGVyLWxldmVsIHJvbGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUNsdXN0ZXJSb2xlIGV4dGVuZHMgYmFzZS5JUmVzb3VyY2Uge1xuXG59XG5cbi8qKlxuICogUHJvcGVydGllcyBmb3IgYENsdXN0ZXJSb2xlYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDbHVzdGVyUm9sZVByb3BzIGV4dGVuZHMgYmFzZS5SZXNvdXJjZVByb3BzIHtcblxuICAvKipcbiAgICAqIEEgbGlzdCBvZiBydWxlcyB0aGUgcm9sZSBzaG91bGQgYWxsb3cuXG4gICAgKlxuICAgICogQGRlZmF1bHQgW11cbiAgICAqL1xuICByZWFkb25seSBydWxlcz86IENsdXN0ZXJSb2xlUG9saWN5UnVsZVtdO1xuXG4gIC8qKlxuICAgICogU3BlY2lmeSBsYWJlbHMgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBsb2NhdGUgQ2x1c3RlclJvbGVzLCB3aG9zZSBydWxlc1xuICAgICogd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGZpbGxlZCBpbnRvIHRoaXMgQ2x1c3RlclJvbGUncyBydWxlcy5cbiAgICAqL1xuICByZWFkb25seSBhZ2dyZWdhdGlvbkxhYmVscz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG59XG5cbi8qKlxuICogUG9saWN5IHJ1bGUgb2YgYSBgQ2x1c3RlclJvbGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2x1c3RlclJvbGVQb2xpY3lSdWxlIHtcblxuICAvKipcbiAgICogVmVyYnMgdG8gYWxsb3cuIChlLmcgWydnZXQnLCAnd2F0Y2gnXSlcbiAgICovXG4gIHJlYWRvbmx5IHZlcmJzOiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogRW5kcG9pbnRzIHRoaXMgcnVsZSBhcHBsaWVzIHRvLiBDYW4gYmUgZWl0aGVyIGFwaSByZXNvdXJjZXNcbiAgICogb3Igbm9uIGFwaSByZXNvdXJjZXMuXG4gICAqL1xuICByZWFkb25seSBlbmRwb2ludHM6IElBcGlFbmRwb2ludFtdO1xufVxuXG5jbGFzcyBJbXBvcnRlZENsdXN0ZXJSb2xlIGV4dGVuZHMgQ29uc3RydWN0IGltcGxlbWVudHMgSUNsdXN0ZXJSb2xlIHtcblxuICBwcml2YXRlIHJlYWRvbmx5IF9uYW1lOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgbmFtZTogc3RyaW5nKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkKTtcbiAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgbmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICB9XG5cbiAgcHVibGljIGdldCBhcGlWZXJzaW9uKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGs4cy5LdWJlQ2x1c3RlclJvbGUuR1ZLLmFwaVZlcnNpb247XG4gIH1cblxuICBwdWJsaWMgZ2V0IGFwaUdyb3VwKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdyYmFjLmF1dGhvcml6YXRpb24uazhzLmlvJztcbiAgfVxuXG4gIHB1YmxpYyBnZXQga2luZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBrOHMuS3ViZUNsdXN0ZXJSb2xlLkdWSy5raW5kO1xuICB9XG5cbn1cblxuLyoqXG4gKiBDbHVzdGVyUm9sZSBpcyBhIGNsdXN0ZXIgbGV2ZWwsIGxvZ2ljYWwgZ3JvdXBpbmcgb2YgUG9saWN5UnVsZXMgdGhhdCBjYW4gYmVcbiAqIHJlZmVyZW5jZWQgYXMgYSB1bml0IGJ5IGEgUm9sZUJpbmRpbmcgb3IgQ2x1c3RlclJvbGVCaW5kaW5nLlxuICovXG5leHBvcnQgY2xhc3MgQ2x1c3RlclJvbGUgZXh0ZW5kcyBiYXNlLlJlc291cmNlIGltcGxlbWVudHMgSUNsdXN0ZXJSb2xlLCBJUm9sZSB7XG5cbiAgLyoqXG4gICAqIEltcG9ydHMgYSByb2xlIGZyb20gdGhlIGNsdXN0ZXIgYXMgYSByZWZlcmVuY2UuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21DbHVzdGVyUm9sZU5hbWUoc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgbmFtZTogc3RyaW5nKTogSUNsdXN0ZXJSb2xlIHtcbiAgICByZXR1cm4gbmV3IEltcG9ydGVkQ2x1c3RlclJvbGUoc2NvcGUsIGlkLCBuYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGJhc2UuUmVzb3VyY2UuYXBpT2JqZWN0XG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgYXBpT2JqZWN0OiBBcGlPYmplY3Q7XG5cbiAgcHVibGljIHJlYWRvbmx5IHJlc291cmNlVHlwZSA9ICdjbHVzdGVycm9sZXMnO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgX2xhYmVsU2VsZWN0b3I6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgcHJpdmF0ZSByZWFkb25seSBfcnVsZXM6IEFycmF5PENsdXN0ZXJSb2xlUG9saWN5UnVsZT4gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogQ2x1c3RlclJvbGVQcm9wcyA9IHt9KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkKTtcblxuICAgIHRoaXMuYXBpT2JqZWN0ID0gbmV3IGs4cy5LdWJlQ2x1c3RlclJvbGUodGhpcywgJ1Jlc291cmNlJywge1xuICAgICAgbWV0YWRhdGE6IHByb3BzLm1ldGFkYXRhLFxuICAgICAgcnVsZXM6IExhenkuYW55KHsgcHJvZHVjZTogKCkgPT4gdGhpcy5zeW50aGVzaXplUnVsZXMoKSB9KSxcbiAgICAgIGFnZ3JlZ2F0aW9uUnVsZTogTGF6eS5hbnkoeyBwcm9kdWNlOiAoKSA9PiB0aGlzLnN5bnRoZXNpemVBZ2dyZWdhdGlvblJ1bGVzKCkgfSksXG4gICAgfSk7XG5cbiAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgcHJvcHMucnVsZXMgPz8gW10pIHtcbiAgICAgIHRoaXMuYWxsb3cocnVsZS52ZXJicywgLi4ucnVsZS5lbmRwb2ludHMpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BzLmFnZ3JlZ2F0aW9uTGFiZWxzID8/IHt9KSkge1xuICAgICAgdGhpcy5hZ2dyZWdhdGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJ1bGVzIGFzc29jaWFhdGVkIHdpdGggdGhpcyBSb2xlLlxuICAgKiBSZXR1cm5zIGEgY29weSwgdXNlIGBhbGxvd2AgdG8gYWRkIHJ1bGVzLlxuICAgKi9cbiAgcHVibGljIGdldCBydWxlcygpOiBDbHVzdGVyUm9sZVBvbGljeVJ1bGVbXSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLl9ydWxlc107XG4gIH1cblxuICAvKipcbiAgICogQWRkIHBlcm1pc3Npb24gdG8gcGVyZm9ybSBhIGxpc3Qgb2YgSFRUUCB2ZXJicyBvbiBhIGNvbGxlY3Rpb24gb2ZcbiAgICogcmVzb3VyY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gZW5kcG9pbnRzIFRoZSBlbmRwb2ludHMocykgdG8gYXBwbHkgdG9cbiAgICogQHNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9yZWZlcmVuY2UvYWNjZXNzLWF1dGhuLWF1dGh6L2F1dGhvcml6YXRpb24vI2RldGVybWluZS10aGUtcmVxdWVzdC12ZXJiXG4gICAqL1xuICBwdWJsaWMgYWxsb3codmVyYnM6IHN0cmluZ1tdLCAuLi5lbmRwb2ludHM6IElBcGlFbmRwb2ludFtdKTogdm9pZCB7XG4gICAgdGhpcy5fcnVsZXMucHVzaCh7IHZlcmJzLCBlbmRwb2ludHMgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIFwiY3JlYXRlXCIgcGVybWlzc2lvbiBmb3IgdGhlIHJlc291cmNlcy5cbiAgICogQHBhcmFtIGVuZHBvaW50cyBUaGUgcmVzb3VyY2UocykgdG8gYXBwbHkgdG9cbiAgICovXG4gIHB1YmxpYyBhbGxvd0NyZWF0ZSguLi5lbmRwb2ludHM6IElBcGlFbmRwb2ludFtdKTogdm9pZCB7XG4gICAgdGhpcy5hbGxvdyhbJ2NyZWF0ZSddLCAuLi5lbmRwb2ludHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBcImdldFwiIHBlcm1pc3Npb24gZm9yIHRoZSByZXNvdXJjZXMuXG4gICAqIEBwYXJhbSBlbmRwb2ludHMgVGhlIHJlc291cmNlKHMpIHRvIGFwcGx5IHRvXG4gICAqL1xuICBwdWJsaWMgYWxsb3dHZXQoLi4uZW5kcG9pbnRzOiBJQXBpRW5kcG9pbnRbXSk6IHZvaWQge1xuICAgIHRoaXMuYWxsb3coWydnZXQnXSwgLi4uZW5kcG9pbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgXCJsaXN0XCIgcGVybWlzc2lvbiBmb3IgdGhlIHJlc291cmNlcy5cbiAgICogQHBhcmFtIGVuZHBvaW50cyBUaGUgcmVzb3VyY2UocykgdG8gYXBwbHkgdG9cbiAgICovXG4gIHB1YmxpYyBhbGxvd0xpc3QoLi4uZW5kcG9pbnRzOiBJQXBpRW5kcG9pbnRbXSk6IHZvaWQge1xuICAgIHRoaXMuYWxsb3coWydsaXN0J10sIC4uLmVuZHBvaW50cyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIFwid2F0Y2hcIiBwZXJtaXNzaW9uIGZvciB0aGUgcmVzb3VyY2VzLlxuICAgKiBAcGFyYW0gZW5kcG9pbnRzIFRoZSByZXNvdXJjZShzKSB0byBhcHBseSB0b1xuICAgKi9cbiAgcHVibGljIGFsbG93V2F0Y2goLi4uZW5kcG9pbnRzOiBJQXBpRW5kcG9pbnRbXSk6IHZvaWQge1xuICAgIHRoaXMuYWxsb3coWyd3YXRjaCddLCAuLi5lbmRwb2ludHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBcInVwZGF0ZVwiIHBlcm1pc3Npb24gZm9yIHRoZSByZXNvdXJjZXMuXG4gICAqIEBwYXJhbSBlbmRwb2ludHMgVGhlIHJlc291cmNlKHMpIHRvIGFwcGx5IHRvXG4gICAqL1xuICBwdWJsaWMgYWxsb3dVcGRhdGUoLi4uZW5kcG9pbnRzOiBJQXBpRW5kcG9pbnRbXSk6IHZvaWQge1xuICAgIHRoaXMuYWxsb3coWyd1cGRhdGUnXSwgLi4uZW5kcG9pbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgXCJwYXRjaFwiIHBlcm1pc3Npb24gZm9yIHRoZSByZXNvdXJjZXMuXG4gICAqIEBwYXJhbSBlbmRwb2ludHMgVGhlIHJlc291cmNlKHMpIHRvIGFwcGx5IHRvXG4gICAqL1xuICBwdWJsaWMgYWxsb3dQYXRjaCguLi5lbmRwb2ludHM6IElBcGlFbmRwb2ludFtdKTogdm9pZCB7XG4gICAgdGhpcy5hbGxvdyhbJ3BhdGNoJ10sIC4uLmVuZHBvaW50cyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIFwiZGVsZXRlXCIgcGVybWlzc2lvbiBmb3IgdGhlIHJlc291cmNlcy5cbiAgICogQHBhcmFtIGVuZHBvaW50cyBUaGUgcmVzb3VyY2UocykgdG8gYXBwbHkgdG9cbiAgICovXG4gIHB1YmxpYyBhbGxvd0RlbGV0ZSguLi5lbmRwb2ludHM6IElBcGlFbmRwb2ludFtdKTogdm9pZCB7XG4gICAgdGhpcy5hbGxvdyhbJ2RlbGV0ZSddLCAuLi5lbmRwb2ludHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBcImRlbGV0ZWNvbGxlY3Rpb25cIiBwZXJtaXNzaW9uIGZvciB0aGUgcmVzb3VyY2VzLlxuICAgKiBAcGFyYW0gZW5kcG9pbnRzIFRoZSByZXNvdXJjZShzKSB0byBhcHBseSB0b1xuICAgKi9cbiAgcHVibGljIGFsbG93RGVsZXRlQ29sbGVjdGlvbiguLi5lbmRwb2ludHM6IElBcGlFbmRwb2ludFtdKTogdm9pZCB7XG4gICAgdGhpcy5hbGxvdyhbJ2RlbGV0ZWNvbGxlY3Rpb24nXSwgLi4uZW5kcG9pbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgXCJnZXRcIiwgXCJsaXN0XCIsIGFuZCBcIndhdGNoXCIgcGVybWlzc2lvbnMgZm9yIHRoZSByZXNvdXJjZXMuXG4gICAqIEBwYXJhbSBlbmRwb2ludHMgVGhlIHJlc291cmNlKHMpIHRvIGFwcGx5IHRvXG4gICAqL1xuICBwdWJsaWMgYWxsb3dSZWFkKC4uLmVuZHBvaW50czogSUFwaUVuZHBvaW50W10pOiB2b2lkIHtcbiAgICB0aGlzLmFsbG93KFsnZ2V0JywgJ2xpc3QnLCAnd2F0Y2gnXSwgLi4uZW5kcG9pbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgXCJnZXRcIiwgXCJsaXN0XCIsIFwid2F0Y2hcIiwgXCJjcmVhdGVcIiwgXCJ1cGRhdGVcIiwgXCJwYXRjaFwiLCBcImRlbGV0ZVwiLCBhbmRcbiAgICogXCJkZWxldGVjb2xsZWN0aW9uXCIgcGVybWlzc2lvbnMgZm9yIHRoZSByZXNvdXJjZXMuXG4gICAqXG4gICAqIEBwYXJhbSBlbmRwb2ludHMgVGhlIHJlc291cmNlKHMpIHRvIGFwcGx5IHRvXG4gICAqL1xuICBwdWJsaWMgYWxsb3dSZWFkV3JpdGUoLi4uZW5kcG9pbnRzOiBJQXBpRW5kcG9pbnRbXSk6IHZvaWQge1xuICAgIHRoaXMuYWxsb3coWydnZXQnLCAnbGlzdCcsICd3YXRjaCcsICdjcmVhdGUnLCAndXBkYXRlJywgJ3BhdGNoJywgJ2RlbGV0ZScsICdkZWxldGVjb2xsZWN0aW9uJ10sIC4uLmVuZHBvaW50cyk7XG4gIH1cblxuICAvKipcbiAgICogQWdncmVnYXRlIHJ1bGVzIGZyb20gcm9sZXMgbWF0Y2hpbmcgdGhpcyBsYWJlbCBzZWxlY3Rvci5cbiAgICovXG4gIHB1YmxpYyBhZ2dyZWdhdGUoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLl9sYWJlbFNlbGVjdG9yW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21iaW5lcyB0aGUgcnVsZXMgb2YgdGhlIGFyZ3VtZW50IENsdXN0ZXJSb2xlIGludG8gdGhpcyBDbHVzdGVyUm9sZVxuICAgKiB1c2luZyBhZ2dyZWdhdGlvbiBsYWJlbHMuXG4gICAqIEBwYXJhbSByb2xcbiAgICovXG4gIHB1YmxpYyBjb21iaW5lKHJvbDogQ2x1c3RlclJvbGUpOiB2b2lkIHtcbiAgICBjb25zdCBrZXkgPSBgY2RrOHMuY2x1c3Rlci1yb2xlL2FnZ3JlZ2F0ZS10by0ke05hbWVzLnRvTGFiZWxWYWx1ZSh0aGlzKX1gO1xuICAgIGNvbnN0IHZhbHVlID0gJ3RydWUnO1xuICAgIHJvbC5tZXRhZGF0YS5hZGRMYWJlbChrZXksIHZhbHVlKTtcbiAgICB0aGlzLmFnZ3JlZ2F0ZShrZXksIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBSb2xlQmluZGluZyB0aGF0IGJpbmRzIHRoZSBwZXJtaXNzaW9ucyBpbiB0aGlzIENsdXN0ZXJSb2xlXG4gICAqIHRvIGEgbGlzdCBvZiBzdWJqZWN0cywgdGhhdCB3aWxsIG9ubHkgYXBwbHkgdG8gdGhlIGdpdmVuIG5hbWVzcGFjZS5cbiAgICogQHBhcmFtIG5hbWVzcGFjZSB0aGUgbmFtZXNwYWNlIHRvIGxpbWl0IHBlcm1pc3Npb25zIHRvLlxuICAgKiBAcGFyYW0gc3ViamVjdHMgYSBsaXN0IG9mIHN1YmplY3RzIHRvIGJpbmQgdG9cbiAgICovXG4gIHB1YmxpYyBiaW5kSW5OYW1lc3BhY2UobmFtZXNwYWNlOiBzdHJpbmcsIC4uLnN1YmplY3RzOiByYi5JU3ViamVjdFtdKTogcmIuUm9sZUJpbmRpbmcge1xuICAgIGNvbnN0IGJpbmRpbmcgPSBuZXcgcmIuUm9sZUJpbmRpbmcodGhpcywgYFJvbGVCaW5kaW5nLSR7bmFtZXNwYWNlfWAsIHtcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgIH0sXG4gICAgICByb2xlOiB0aGlzLFxuICAgIH0pO1xuICAgIGJpbmRpbmcuYWRkU3ViamVjdHMoLi4uc3ViamVjdHMpO1xuICAgIHJldHVybiBiaW5kaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIENsdXN0ZXJSb2xlQmluZGluZyB0aGF0IGJpbmRzIHRoZSBwZXJtaXNzaW9ucyBpbiB0aGlzXG4gICAqIENsdXN0ZXJSb2xlIHRvIGEgbGlzdCBvZiBzdWJqZWN0cywgd2l0aG91dCBuYW1lc3BhY2UgcmVzdHJpY3Rpb25zLlxuICAgKiBAcGFyYW0gc3ViamVjdHMgYSBsaXN0IG9mIHN1YmplY3RzIHRvIGJpbmQgdG9cbiAgICovXG4gIHB1YmxpYyBiaW5kKC4uLnN1YmplY3RzOiByYi5JU3ViamVjdFtdKTogcmIuQ2x1c3RlclJvbGVCaW5kaW5nIHtcbiAgICBjb25zdCBiaW5kaW5nID0gbmV3IHJiLkNsdXN0ZXJSb2xlQmluZGluZyh0aGlzLCAnQ2x1c3RlclJvbGVCaW5kaW5nJywge1xuICAgICAgcm9sZTogdGhpcyxcbiAgICB9KTtcbiAgICBiaW5kaW5nLmFkZFN1YmplY3RzKC4uLnN1YmplY3RzKTtcbiAgICByZXR1cm4gYmluZGluZztcbiAgfVxuXG4gIHByaXZhdGUgc3ludGhlc2l6ZVJ1bGVzKCk6IGs4cy5Qb2xpY3lSdWxlW10ge1xuICAgIGNvbnN0IHJ1bGVzOiBrOHMuUG9saWN5UnVsZVtdID0gW107XG4gICAgZm9yIChjb25zdCBydWxlIG9mIHRoaXMuX3J1bGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IGVuZHBvaW50IG9mIHJ1bGUuZW5kcG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IHJlc291cmNlID0gZW5kcG9pbnQuYXNBcGlSZXNvdXJjZSgpO1xuICAgICAgICBjb25zdCBub25SZXNvdXJjZSA9IGVuZHBvaW50LmFzTm9uQXBpUmVzb3VyY2UoKTtcblxuICAgICAgICBpZiAocmVzb3VyY2UgJiYgbm9uUmVzb3VyY2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuZHBvaW50IG11c3QgYmUgZWl0aGVyIHJlc291cmNlIG9yIG5vbiByZXNvdXJjZS4gbm90IGJvdGguJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlc291cmNlICYmICFub25SZXNvdXJjZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5kcG9pbnQgbXVzdCBiZSBlaXRoZXIgcmVzb3VyY2Ugb3Igbm9uIHJlc291cmNlLiBub3QgbmVpdGhlci4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNvdXJjZSkge1xuICAgICAgICAgIHJ1bGVzLnB1c2goe1xuICAgICAgICAgICAgYXBpR3JvdXBzOiBbcmVzb3VyY2UuYXBpR3JvdXAgPT09ICdjb3JlJyA/ICcnIDogcmVzb3VyY2UuYXBpR3JvdXBdLFxuICAgICAgICAgICAgcmVzb3VyY2VzOiBbcmVzb3VyY2UucmVzb3VyY2VUeXBlXSxcbiAgICAgICAgICAgIHJlc291cmNlTmFtZXM6IHJlc291cmNlLnJlc291cmNlTmFtZSA/IFtyZXNvdXJjZS5yZXNvdXJjZU5hbWVdIDogW10sXG4gICAgICAgICAgICB2ZXJiczogcnVsZS52ZXJicyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uUmVzb3VyY2UpIHtcbiAgICAgICAgICBydWxlcy5wdXNoKHsgdmVyYnM6IHJ1bGUudmVyYnMsIG5vblJlc291cmNlVXJMczogW25vblJlc291cmNlXSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuICAgIHJldHVybiBydWxlcztcbiAgfVxuXG4gIHByaXZhdGUgc3ludGhlc2l6ZUFnZ3JlZ2F0aW9uUnVsZXMoKTogazhzLkFnZ3JlZ2F0aW9uUnVsZSB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX2xhYmVsU2VsZWN0b3IpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4geyBjbHVzdGVyUm9sZVNlbGVjdG9yczogW3sgbWF0Y2hMYWJlbHM6IHRoaXMuX2xhYmVsU2VsZWN0b3IgfV0gfTtcbiAgfVxufSJdfQ==

/***/ }),

/***/ 880:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DockerConfigSecret = exports.TlsSecret = exports.ServiceAccountTokenSecret = exports.SshAuthSecret = exports.BasicAuthSecret = exports.Secret = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const constructs_1 = __nccwpck_require__(1963);
const base = __nccwpck_require__(415);
const k8s = __nccwpck_require__(4879);
class ImportedSecret extends constructs_1.Construct {
    constructor(scope, id, name) {
        super(scope, id);
        this._name = name;
    }
    get name() {
        return this._name;
    }
    get apiVersion() {
        return k8s.KubeSecret.GVK.apiVersion;
    }
    get apiGroup() {
        return '';
    }
    get kind() {
        return k8s.KubeSecret.GVK.kind;
    }
}
/**
 * Kubernetes Secrets let you store and manage sensitive information, such as
 * passwords, OAuth tokens, and ssh keys. Storing confidential information in a
 * Secret is safer and more flexible than putting it verbatim in a Pod
 * definition or in a container image.
 *
 * @see https://kubernetes.io/docs/concepts/configuration/secret
 */
class Secret extends base.Resource {
    constructor(scope, id, props = {}) {
        var _g, _h;
        super(scope, id);
        this.resourceType = 'secrets';
        this.stringData = (_g = props.stringData) !== null && _g !== void 0 ? _g : {};
        this.immutable = (_h = props.immutable) !== null && _h !== void 0 ? _h : false;
        this.apiObject = new k8s.KubeSecret(this, 'Resource', {
            metadata: props.metadata,
            type: props.type,
            stringData: this.stringData,
            immutable: this.immutable,
        });
    }
    /**
     * Imports a secret from the cluster as a reference.
     */
    static fromSecretName(scope, id, name) {
        return new ImportedSecret(scope, id, name);
    }
    /**
     * Adds a string data field to the secert.
     * @param key Key
     * @param value Value
     */
    addStringData(key, value) {
        this.stringData[key] = value;
    }
    /**
     * Gets a string data by key or undefined
     * @param key Key
     */
    getStringData(key) {
        return this.stringData[key];
    }
}
exports.Secret = Secret;
_a = JSII_RTTI_SYMBOL_1;
Secret[_a] = { fqn: "cdk8s-plus-22.Secret", version: "2.0.0-rc.2" };
/**
 * Create a secret for basic authentication.
 *
 * @see https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret
 */
class BasicAuthSecret extends Secret {
    constructor(scope, id, props) {
        super(scope, id, {
            type: 'kubernetes.io/basic-auth',
            stringData: {
                username: props.username,
                password: props.password,
            },
            immutable: props.immutable,
        });
    }
}
exports.BasicAuthSecret = BasicAuthSecret;
_b = JSII_RTTI_SYMBOL_1;
BasicAuthSecret[_b] = { fqn: "cdk8s-plus-22.BasicAuthSecret", version: "2.0.0-rc.2" };
/**
 * Create a secret for ssh authentication.
 *
 * @see https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets
 */
class SshAuthSecret extends Secret {
    constructor(scope, id, props) {
        super(scope, id, {
            type: 'kubernetes.io/ssh-auth',
            stringData: {
                'ssh-privatekey': props.sshPrivateKey,
            },
            immutable: props.immutable,
        });
    }
}
exports.SshAuthSecret = SshAuthSecret;
_c = JSII_RTTI_SYMBOL_1;
SshAuthSecret[_c] = { fqn: "cdk8s-plus-22.SshAuthSecret", version: "2.0.0-rc.2" };
/**
 * Create a secret for a service account token.
 *
 * @see https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets
 */
class ServiceAccountTokenSecret extends Secret {
    constructor(scope, id, props) {
        super(scope, id, {
            type: 'kubernetes.io/service-account-token',
            metadata: {
                annotations: {
                    'kubernetes.io/service-account.name': props.serviceAccount.name,
                },
            },
            immutable: props.immutable,
        });
    }
}
exports.ServiceAccountTokenSecret = ServiceAccountTokenSecret;
_d = JSII_RTTI_SYMBOL_1;
ServiceAccountTokenSecret[_d] = { fqn: "cdk8s-plus-22.ServiceAccountTokenSecret", version: "2.0.0-rc.2" };
/**
 * Create a secret for storing a TLS certificate and its associated key.
 *
 * @see https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets
 */
class TlsSecret extends Secret {
    constructor(scope, id, props) {
        super(scope, id, {
            type: 'kubernetes.io/tls',
            stringData: {
                'tls.crt': props.tlsCert,
                'tls.key': props.tlsKey,
            },
            immutable: props.immutable,
        });
    }
}
exports.TlsSecret = TlsSecret;
_e = JSII_RTTI_SYMBOL_1;
TlsSecret[_e] = { fqn: "cdk8s-plus-22.TlsSecret", version: "2.0.0-rc.2" };
/**
 * Create a secret for storing credentials for accessing a container image
 * registry.
 *
 * @see https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets
 */
class DockerConfigSecret extends Secret {
    constructor(scope, id, props) {
        super(scope, id, {
            type: 'kubernetes.io/dockerconfigjson',
            stringData: {
                '.dockerconfigjson': JSON.stringify(props.data),
            },
            immutable: props.immutable,
        });
    }
}
exports.DockerConfigSecret = DockerConfigSecret;
_f = JSII_RTTI_SYMBOL_1;
DockerConfigSecret[_f] = { fqn: "cdk8s-plus-22.DockerConfigSecret", version: "2.0.0-rc.2" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VjcmV0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3NlY3JldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUNBLDJDQUF1QztBQUN2QywrQkFBK0I7QUFDL0IscUNBQXFDO0FBMkRyQyxNQUFNLGNBQWUsU0FBUSxzQkFBUztJQUlwQyxZQUFZLEtBQWdCLEVBQUUsRUFBVSxFQUFFLElBQVk7UUFDcEQsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNqQixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztJQUNwQixDQUFDO0lBRUQsSUFBVyxJQUFJO1FBQ2IsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ3BCLENBQUM7SUFFRCxJQUFXLFVBQVU7UUFDbkIsT0FBTyxHQUFHLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUM7SUFDdkMsQ0FBQztJQUVELElBQVcsUUFBUTtRQUNqQixPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFFRCxJQUFXLElBQUk7UUFDYixPQUFPLEdBQUcsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztJQUNqQyxDQUFDO0NBRUY7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsTUFBYSxNQUFPLFNBQVEsSUFBSSxDQUFDLFFBQVE7SUF1QnZDLFlBQW1CLEtBQWdCLEVBQUUsRUFBVSxFQUFFLFFBQXFCLEVBQUc7O1FBQ3ZFLEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFWSCxpQkFBWSxHQUFHLFNBQVMsQ0FBQztRQVl2QyxJQUFJLENBQUMsVUFBVSxTQUFHLEtBQUssQ0FBQyxVQUFVLG1DQUFJLEVBQUUsQ0FBQztRQUV6QyxJQUFJLENBQUMsU0FBUyxTQUFHLEtBQUssQ0FBQyxTQUFTLG1DQUFJLEtBQUssQ0FBQztRQUMxQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksR0FBRyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsVUFB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bUJBQW1CLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDO2FBQ2hEO1lBQ0QsU0FBUyxFQUFFLEtBQUssQ0FBQyxTQUFTO1NBQzNCLENBQUMsQ0FBQztJQUNMLENBQUM7O0FBVEgsZ0RBVUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcGlPYmplY3QgfSBmcm9tICdjZGs4cyc7XG5pbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tICdjb25zdHJ1Y3RzJztcbmltcG9ydCAqIGFzIGJhc2UgZnJvbSAnLi9iYXNlJztcbmltcG9ydCAqIGFzIGs4cyBmcm9tICcuL2ltcG9ydHMvazhzJztcbmltcG9ydCAqIGFzIHNlcnZpY2VhY2NvdW50IGZyb20gJy4vc2VydmljZS1hY2NvdW50JztcblxuLyoqXG4gKiBDb21tb24gcHJvcGVydGllcyBmb3IgYFNlY3JldGAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29tbW9uU2VjcmV0UHJvcHMgZXh0ZW5kcyBiYXNlLlJlc291cmNlUHJvcHMge1xuXG4gIC8qKlxuICAgKiBJZiBzZXQgdG8gdHJ1ZSwgZW5zdXJlcyB0aGF0IGRhdGEgc3RvcmVkIGluIHRoZSBTZWNyZXQgY2Fubm90IGJlIHVwZGF0ZWQgKG9ubHkgb2JqZWN0IG1ldGFkYXRhIGNhbiBiZSBtb2RpZmllZCkuXG4gICAqIElmIG5vdCBzZXQgdG8gdHJ1ZSwgdGhlIGZpZWxkIGNhbiBiZSBtb2RpZmllZCBhdCBhbnkgdGltZS5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IGltbXV0YWJsZT86IGJvb2xlYW47XG5cbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBgU2VjcmV0YC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZWNyZXRQcm9wcyBleHRlbmRzIENvbW1vblNlY3JldFByb3BzIHtcbiAgLyoqXG4gICAqIHN0cmluZ0RhdGEgYWxsb3dzIHNwZWNpZnlpbmcgbm9uLWJpbmFyeSBzZWNyZXQgZGF0YSBpbiBzdHJpbmcgZm9ybS4gSXQgaXNcbiAgICogcHJvdmlkZWQgYXMgYSB3cml0ZS1vbmx5IGNvbnZlbmllbmNlIG1ldGhvZC4gQWxsIGtleXMgYW5kIHZhbHVlcyBhcmUgbWVyZ2VkXG4gICAqIGludG8gdGhlIGRhdGEgZmllbGQgb24gd3JpdGUsIG92ZXJ3cml0aW5nIGFueSBleGlzdGluZyB2YWx1ZXMuIEl0IGlzIG5ldmVyXG4gICAqIG91dHB1dCB3aGVuIHJlYWRpbmcgZnJvbSB0aGUgQVBJLlxuICAgKi9cbiAgcmVhZG9ubHkgc3RyaW5nRGF0YT86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIHR5cGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBzZWNyZXQuICBVc2VkIHRvIGZhY2lsaXRhdGUgcHJvZ3JhbW1hdGljXG4gICAqIGhhbmRsaW5nIG9mIHNlY3JldCBkYXRhIGJ5IHZhcmlvdXMgY29udHJvbGxlcnMuXG4gICAqXG4gICAqIEBkZWZhdWx0IHVuZGVmaW5lZCAtIERvbid0IHNldCBhIHR5cGUuXG4gICAqL1xuICByZWFkb25seSB0eXBlPzogc3RyaW5nO1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVNlY3JldCBleHRlbmRzIGJhc2UuSVJlc291cmNlIHtcblxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzcGVjaWZpYyB2YWx1ZSBpbiBKU09OIHNlY3JldC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZWNyZXRWYWx1ZSB7XG4gIC8qKlxuICAgKiBUaGUgc2VjcmV0XG4gICAqL1xuICByZWFkb25seSBzZWNyZXQ6IElTZWNyZXQ7XG5cbiAgLyoqXG4gICAqIFRoZSBKU09OIGtleVxuICAgKi9cbiAgcmVhZG9ubHkga2V5OiBzdHJpbmc7XG59XG5cbmNsYXNzIEltcG9ydGVkU2VjcmV0IGV4dGVuZHMgQ29uc3RydWN0IGltcGxlbWVudHMgSVNlY3JldCB7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBfbmFtZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIG5hbWU6IHN0cmluZykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCk7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIH1cblxuICBwdWJsaWMgZ2V0IG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYXBpVmVyc2lvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiBrOHMuS3ViZVNlY3JldC5HVksuYXBpVmVyc2lvbjtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYXBpR3JvdXAoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGtpbmQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gazhzLkt1YmVTZWNyZXQuR1ZLLmtpbmQ7XG4gIH1cblxufVxuXG4vKipcbiAqIEt1YmVybmV0ZXMgU2VjcmV0cyBsZXQgeW91IHN0b3JlIGFuZCBtYW5hZ2Ugc2Vuc2l0aXZlIGluZm9ybWF0aW9uLCBzdWNoIGFzXG4gKiBwYXNzd29yZHMsIE9BdXRoIHRva2VucywgYW5kIHNzaCBrZXlzLiBTdG9yaW5nIGNvbmZpZGVudGlhbCBpbmZvcm1hdGlvbiBpbiBhXG4gKiBTZWNyZXQgaXMgc2FmZXIgYW5kIG1vcmUgZmxleGlibGUgdGhhbiBwdXR0aW5nIGl0IHZlcmJhdGltIGluIGEgUG9kXG4gKiBkZWZpbml0aW9uIG9yIGluIGEgY29udGFpbmVyIGltYWdlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvY29uZmlndXJhdGlvbi9zZWNyZXRcbiAqL1xuZXhwb3J0IGNsYXNzIFNlY3JldCBleHRlbmRzIGJhc2UuUmVzb3VyY2UgaW1wbGVtZW50cyBJU2VjcmV0IHtcblxuICAvKipcbiAgICogSW1wb3J0cyBhIHNlY3JldCBmcm9tIHRoZSBjbHVzdGVyIGFzIGEgcmVmZXJlbmNlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tU2VjcmV0TmFtZShzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBuYW1lOiBzdHJpbmcpOiBJU2VjcmV0IHtcbiAgICByZXR1cm4gbmV3IEltcG9ydGVkU2VjcmV0KHNjb3BlLCBpZCwgbmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBiYXNlLlJlc291cmNlLmFwaU9iamVjdFxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGFwaU9iamVjdDogQXBpT2JqZWN0O1xuXG4gIHB1YmxpYyByZWFkb25seSByZXNvdXJjZVR5cGUgPSAnc2VjcmV0cyc7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSBzZWNyZXQgaXMgaW1tdXRhYmxlLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGltbXV0YWJsZTogYm9vbGVhbjtcblxuICBwcml2YXRlIHJlYWRvbmx5IHN0cmluZ0RhdGE6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBTZWNyZXRQcm9wcyA9IHsgfSkge1xuICAgIHN1cGVyKHNjb3BlLCBpZCk7XG5cbiAgICB0aGlzLnN0cmluZ0RhdGEgPSBwcm9wcy5zdHJpbmdEYXRhID8/IHt9O1xuXG4gICAgdGhpcy5pbW11dGFibGUgPSBwcm9wcy5pbW11dGFibGUgPz8gZmFsc2U7XG4gICAgdGhpcy5hcGlPYmplY3QgPSBuZXcgazhzLkt1YmVTZWNyZXQodGhpcywgJ1Jlc291cmNlJywge1xuICAgICAgbWV0YWRhdGE6IHByb3BzLm1ldGFkYXRhLFxuICAgICAgdHlwZTogcHJvcHMudHlwZSxcbiAgICAgIHN0cmluZ0RhdGE6IHRoaXMuc3RyaW5nRGF0YSxcbiAgICAgIGltbXV0YWJsZTogdGhpcy5pbW11dGFibGUsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHN0cmluZyBkYXRhIGZpZWxkIHRvIHRoZSBzZWNlcnQuXG4gICAqIEBwYXJhbSBrZXkgS2V5XG4gICAqIEBwYXJhbSB2YWx1ZSBWYWx1ZVxuICAgKi9cbiAgcHVibGljIGFkZFN0cmluZ0RhdGEoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLnN0cmluZ0RhdGFba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSBzdHJpbmcgZGF0YSBieSBrZXkgb3IgdW5kZWZpbmVkXG4gICAqIEBwYXJhbSBrZXkgS2V5XG4gICAqL1xuICBwdWJsaWMgZ2V0U3RyaW5nRGF0YShrZXk6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nRGF0YVtrZXldO1xuICB9XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYEJhc2ljQXV0aFNlY3JldGAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmFzaWNBdXRoU2VjcmV0UHJvcHMgZXh0ZW5kcyBDb21tb25TZWNyZXRQcm9wcyB7XG4gIC8qKlxuICAgKiBUaGUgdXNlciBuYW1lIGZvciBhdXRoZW50aWNhdGlvblxuICAgKi9cbiAgcmVhZG9ubHkgdXNlcm5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHBhc3N3b3JkIG9yIHRva2VuIGZvciBhdXRoZW50aWNhdGlvblxuICAgKi9cbiAgcmVhZG9ubHkgcGFzc3dvcmQ6IHN0cmluZztcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzZWNyZXQgZm9yIGJhc2ljIGF1dGhlbnRpY2F0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvY29uZmlndXJhdGlvbi9zZWNyZXQvI2Jhc2ljLWF1dGhlbnRpY2F0aW9uLXNlY3JldFxuICovXG5leHBvcnQgY2xhc3MgQmFzaWNBdXRoU2VjcmV0IGV4dGVuZHMgU2VjcmV0IHtcbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBCYXNpY0F1dGhTZWNyZXRQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgdHlwZTogJ2t1YmVybmV0ZXMuaW8vYmFzaWMtYXV0aCcsXG4gICAgICBzdHJpbmdEYXRhOiB7XG4gICAgICAgIHVzZXJuYW1lOiBwcm9wcy51c2VybmFtZSxcbiAgICAgICAgcGFzc3dvcmQ6IHByb3BzLnBhc3N3b3JkLFxuICAgICAgfSxcbiAgICAgIGltbXV0YWJsZTogcHJvcHMuaW1tdXRhYmxlLFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYFNzaEF1dGhTZWNyZXRgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNzaEF1dGhTZWNyZXRQcm9wcyBleHRlbmRzIENvbW1vblNlY3JldFByb3BzIHtcbiAgLyoqXG4gICAqIFRoZSBTU0ggcHJpdmF0ZSBrZXkgdG8gdXNlXG4gICAqL1xuICByZWFkb25seSBzc2hQcml2YXRlS2V5OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgc2VjcmV0IGZvciBzc2ggYXV0aGVudGljYXRpb24uXG4gKlxuICogQHNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9jb25maWd1cmF0aW9uL3NlY3JldC8jc3NoLWF1dGhlbnRpY2F0aW9uLXNlY3JldHNcbiAqL1xuZXhwb3J0IGNsYXNzIFNzaEF1dGhTZWNyZXQgZXh0ZW5kcyBTZWNyZXQge1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IFNzaEF1dGhTZWNyZXRQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgdHlwZTogJ2t1YmVybmV0ZXMuaW8vc3NoLWF1dGgnLFxuICAgICAgc3RyaW5nRGF0YToge1xuICAgICAgICAnc3NoLXByaXZhdGVrZXknOiBwcm9wcy5zc2hQcml2YXRlS2V5LFxuICAgICAgfSxcbiAgICAgIGltbXV0YWJsZTogcHJvcHMuaW1tdXRhYmxlLFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYFNlcnZpY2VBY2NvdW50VG9rZW5TZWNyZXRgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZpY2VBY2NvdW50VG9rZW5TZWNyZXRQcm9wcyBleHRlbmRzIENvbW1vblNlY3JldFByb3BzIHtcbiAgLyoqXG4gICAqIFRoZSBzZXJ2aWNlIGFjY291bnQgdG8gc3RvcmUgYSBzZWNyZXQgZm9yXG4gICAqL1xuICByZWFkb25seSBzZXJ2aWNlQWNjb3VudDogc2VydmljZWFjY291bnQuSVNlcnZpY2VBY2NvdW50O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHNlY3JldCBmb3IgYSBzZXJ2aWNlIGFjY291bnQgdG9rZW4uXG4gKlxuICogQHNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9jb25maWd1cmF0aW9uL3NlY3JldC8jc2VydmljZS1hY2NvdW50LXRva2VuLXNlY3JldHNcbiAqL1xuZXhwb3J0IGNsYXNzIFNlcnZpY2VBY2NvdW50VG9rZW5TZWNyZXQgZXh0ZW5kcyBTZWNyZXQge1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IFNlcnZpY2VBY2NvdW50VG9rZW5TZWNyZXRQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgdHlwZTogJ2t1YmVybmV0ZXMuaW8vc2VydmljZS1hY2NvdW50LXRva2VuJyxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIGFubm90YXRpb25zOiB7XG4gICAgICAgICAgJ2t1YmVybmV0ZXMuaW8vc2VydmljZS1hY2NvdW50Lm5hbWUnOiBwcm9wcy5zZXJ2aWNlQWNjb3VudC5uYW1lLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGltbXV0YWJsZTogcHJvcHMuaW1tdXRhYmxlLFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYFRsc1NlY3JldGAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGxzU2VjcmV0UHJvcHMgZXh0ZW5kcyBDb21tb25TZWNyZXRQcm9wcyB7XG4gIC8qKlxuICAgKiBUaGUgVExTIGNlcnRcbiAgICovXG4gIHJlYWRvbmx5IHRsc0NlcnQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFRMUyBrZXlcbiAgICovXG4gIHJlYWRvbmx5IHRsc0tleTogc3RyaW5nO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHNlY3JldCBmb3Igc3RvcmluZyBhIFRMUyBjZXJ0aWZpY2F0ZSBhbmQgaXRzIGFzc29jaWF0ZWQga2V5LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvY29uZmlndXJhdGlvbi9zZWNyZXQvI3Rscy1zZWNyZXRzXG4gKi9cbmV4cG9ydCBjbGFzcyBUbHNTZWNyZXQgZXh0ZW5kcyBTZWNyZXQge1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IFRsc1NlY3JldFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICB0eXBlOiAna3ViZXJuZXRlcy5pby90bHMnLFxuICAgICAgc3RyaW5nRGF0YToge1xuICAgICAgICAndGxzLmNydCc6IHByb3BzLnRsc0NlcnQsXG4gICAgICAgICd0bHMua2V5JzogcHJvcHMudGxzS2V5LFxuICAgICAgfSxcbiAgICAgIGltbXV0YWJsZTogcHJvcHMuaW1tdXRhYmxlLFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYERvY2tlckNvbmZpZ1NlY3JldGAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRG9ja2VyQ29uZmlnU2VjcmV0UHJvcHMgZXh0ZW5kcyBDb21tb25TZWNyZXRQcm9wcyB7XG4gIC8qKlxuICAgKiBKU09OIGNvbnRlbnQgdG8gcHJvdmlkZSBmb3IgdGhlIGB+Ly5kb2NrZXIvY29uZmlnLmpzb25gIGZpbGUuIFRoaXMgd2lsbFxuICAgKiBiZSBzdHJpbmdpZmllZCBhbmQgaW5zZXJ0ZWQgYXMgc3RyaW5nRGF0YS5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2RvY3MuZG9ja2VyLmNvbS9lbmdpbmUvcmVmZXJlbmNlL2NvbW1hbmRsaW5lL2NsaS8jc2FtcGxlLWNvbmZpZ3VyYXRpb24tZmlsZVxuICAgKi9cbiAgcmVhZG9ubHkgZGF0YTogeyBba2V5OiBzdHJpbmddOiBhbnkgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzZWNyZXQgZm9yIHN0b3JpbmcgY3JlZGVudGlhbHMgZm9yIGFjY2Vzc2luZyBhIGNvbnRhaW5lciBpbWFnZVxuICogcmVnaXN0cnkuXG4gKlxuICogQHNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9jb25maWd1cmF0aW9uL3NlY3JldC8jZG9ja2VyLWNvbmZpZy1zZWNyZXRzXG4gKi9cbmV4cG9ydCBjbGFzcyBEb2NrZXJDb25maWdTZWNyZXQgZXh0ZW5kcyBTZWNyZXQge1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IERvY2tlckNvbmZpZ1NlY3JldFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICB0eXBlOiAna3ViZXJuZXRlcy5pby9kb2NrZXJjb25maWdqc29uJyxcbiAgICAgIHN0cmluZ0RhdGE6IHtcbiAgICAgICAgJy5kb2NrZXJjb25maWdqc29uJzogSlNPTi5zdHJpbmdpZnkocHJvcHMuZGF0YSksXG4gICAgICB9LFxuICAgICAgaW1tdXRhYmxlOiBwcm9wcy5pbW11dGFibGUsXG4gICAgfSk7XG4gIH1cbn1cbiJdfQ==

/***/ }),

/***/ 9089:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceAccount = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const cdk8s_1 = __nccwpck_require__(1227);
const constructs_1 = __nccwpck_require__(1963);
const base = __nccwpck_require__(415);
const k8s = __nccwpck_require__(4879);
const utils_1 = __nccwpck_require__(6594);
class ImportedServiceAccount extends constructs_1.Construct {
    constructor(scope, id, name) {
        super(scope, id);
        this._name = name;
    }
    get name() {
        return this._name;
    }
    get apiVersion() {
        return k8s.KubeServiceAccount.GVK.apiVersion;
    }
    get apiGroup() {
        return '';
    }
    get kind() {
        return k8s.KubeServiceAccount.GVK.kind;
    }
}
/**
 * A service account provides an identity for processes that run in a Pod.
 *
 * When you (a human) access the cluster (for example, using kubectl), you are
 * authenticated by the apiserver as a particular User Account (currently this
 * is usually admin, unless your cluster administrator has customized your
 * cluster). Processes in containers inside pods can also contact the apiserver.
 * When they do, they are authenticated as a particular Service Account (for
 * example, default).
 *
 * @see https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account
 */
class ServiceAccount extends base.Resource {
    constructor(scope, id, props = {}) {
        var _b, _c;
        super(scope, id);
        this.resourceType = 'serviceaccounts';
        this._secrets = (_b = props.secrets) !== null && _b !== void 0 ? _b : [];
        this.automountToken = (_c = props.automountToken) !== null && _c !== void 0 ? _c : true;
        this.apiObject = new k8s.KubeServiceAccount(this, 'Resource', {
            metadata: props.metadata,
            secrets: cdk8s_1.Lazy.any({ produce: () => utils_1.undefinedIfEmpty(this._secrets.map(s => ({ name: s.name }))) }),
            automountServiceAccountToken: this.automountToken,
        });
    }
    /**
     * Imports a service account from the cluster as a reference.
     * @param name The name of the service account resource.
     */
    static fromServiceAccountName(scope, id, name) {
        return new ImportedServiceAccount(scope, id, name);
    }
    /**
     * Allow a secret to be accessed by pods using this service account.
     * @param secr The secret
     */
    addSecret(secr) {
        this._secrets.push(secr);
    }
    /**
     * List of secrets allowed to be used by pods running using this service
     * account.
     *
     * Returns a copy. To add a secret, use `addSecret()`.
     */
    get secrets() {
        return [...this._secrets];
    }
    /**
     * @see ISubect.toSubjectConfiguration()
     */
    toSubjectConfiguration() {
        return {
            kind: this.kind,
            name: this.name,
            apiGroup: this.apiGroup,
        };
    }
}
exports.ServiceAccount = ServiceAccount;
_a = JSII_RTTI_SYMBOL_1;
ServiceAccount[_a] = { fqn: "cdk8s-plus-22.ServiceAccount", version: "2.0.0-rc.2" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VydmljZS1hY2NvdW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3NlcnZpY2UtYWNjb3VudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGlDQUF3QztBQUN4QywyQ0FBdUM7QUFDdkMsK0JBQStCO0FBQy9CLHFDQUFxQztBQUdyQyxtQ0FBMkM7QUE2QjNDLE1BQU0sc0JBQXVCLFNBQVEsc0JBQVM7SUFJNUMsWUFBWSxLQUFnQixFQUFFLEVBQVUsRUFBRSxJQUFZO1FBQ3BELEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDakIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7SUFDcEIsQ0FBQztJQUVELElBQVcsSUFBSTtRQUNiLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztJQUNwQixDQUFDO0lBRUQsSUFBVyxVQUFVO1FBQ25CLE9BQU8sR0FBRyxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUM7SUFDL0MsQ0FBQztJQUVELElBQVcsUUFBUTtRQUNqQixPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFFRCxJQUFXLElBQUk7UUFDYixPQUFPLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDO0lBQ3pDLENBQUM7Q0FFRjtBQUVEOzs7Ozs7Ozs7OztHQVdHO0FBQ0gsTUFBYSxjQUFlLFNBQVEsSUFBSSxDQUFDLFFBQVE7SUF5Qi9DLFlBQVksS0FBZ0IsRUFBRSxFQUFVLEVBQUUsUUFBNkIsRUFBRzs7UUFDeEUsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQVhILGlCQUFZLEdBQUcsaUJBQWlCLENBQUM7UUFhL0MsSUFBSSxDQUFDLFFBQVEsU0FBRyxLQUFLLENBQUMsT0FBTyxtQ0FBSSxFQUFFLENBQUM7UUFDcEMsSUFBSSxDQUFDLGNBQWMsU0FBRyxLQUFLLENBQUMsY0FBYyxtQ0FBSSxJQUFJLENBQUM7UUFFbkQsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFO1lBQzVELFFBQVEsRUFBRSxLQUFLLENBQUMsUUFBUTtZQUN4QixPQUFPLEVBQUUsWUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyx3QkFBZ0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDbEcsNEJBQTRCLEVBQUUsSUFBSSxDQUFDLGNBQWM7U0FDbEQsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQWxDRDs7O09BR0c7SUFDSSxNQUFNLENBQUMsc0JBQXNCLENBQUMsS0FBZ0IsRUFBRSxFQUFVLEVBQUUsSUFBWTtRQUM3RSxPQUFPLElBQUksc0JBQXNCLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBOEJEOzs7T0FHRztJQUNJLFNBQVMsQ0FBQyxJQUFvQjtRQUNuQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxJQUFXLE9BQU87UUFDaEIsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzVCLENBQUM7SUFFRDs7T0FFRztJQUNJLHNCQUFzQjtRQUMzQixPQUFPO1lBQ0wsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO1lBQ2YsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO1lBQ2YsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRO1NBQ3hCLENBQUM7SUFDSixDQUFDOztBQWpFSCx3Q0FtRUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcGlPYmplY3QsIExhenkgfSBmcm9tICdjZGs4cyc7XG5pbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tICdjb25zdHJ1Y3RzJztcbmltcG9ydCAqIGFzIGJhc2UgZnJvbSAnLi9iYXNlJztcbmltcG9ydCAqIGFzIGs4cyBmcm9tICcuL2ltcG9ydHMvazhzJztcbmltcG9ydCAqIGFzIHJiIGZyb20gJy4vcm9sZS1iaW5kaW5nJztcbmltcG9ydCAqIGFzIHNlY3JldCBmcm9tICcuL3NlY3JldCc7XG5pbXBvcnQgeyB1bmRlZmluZWRJZkVtcHR5IH0gZnJvbSAnLi91dGlscyc7XG5cblxuZXhwb3J0IGludGVyZmFjZSBJU2VydmljZUFjY291bnQgZXh0ZW5kcyBiYXNlLklSZXNvdXJjZSB7XG5cbn1cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIGZvciBpbml0aWFsaXphdGlvbiBvZiBgU2VydmljZUFjY291bnRgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZpY2VBY2NvdW50UHJvcHMgZXh0ZW5kcyBiYXNlLlJlc291cmNlUHJvcHMge1xuICAvKipcbiAgICogTGlzdCBvZiBzZWNyZXRzIGFsbG93ZWQgdG8gYmUgdXNlZCBieSBwb2RzIHJ1bm5pbmcgdXNpbmcgdGhpc1xuICAgKiBTZXJ2aWNlQWNjb3VudC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9jb25maWd1cmF0aW9uL3NlY3JldFxuICAgKi9cbiAgcmVhZG9ubHkgc2VjcmV0cz86IHNlY3JldC5JU2VjcmV0W107XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHBvZHMgcnVubmluZyBhcyB0aGlzIHNlcnZpY2UgYWNjb3VudFxuICAgKiBzaG91bGQgaGF2ZSBhbiBBUEkgdG9rZW4gYXV0b21hdGljYWxseSBtb3VudGVkLiBDYW4gYmUgb3ZlcnJpZGRlbiBhdCB0aGUgcG9kIGxldmVsLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvdGFza3MvY29uZmlndXJlLXBvZC1jb250YWluZXIvY29uZmlndXJlLXNlcnZpY2UtYWNjb3VudC8jdXNlLXRoZS1kZWZhdWx0LXNlcnZpY2UtYWNjb3VudC10by1hY2Nlc3MtdGhlLWFwaS1zZXJ2ZXJcbiAgICovXG4gIHJlYWRvbmx5IGF1dG9tb3VudFRva2VuPzogYm9vbGVhbjtcbn1cblxuY2xhc3MgSW1wb3J0ZWRTZXJ2aWNlQWNjb3VudCBleHRlbmRzIENvbnN0cnVjdCBpbXBsZW1lbnRzIElTZXJ2aWNlQWNjb3VudCB7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBfbmFtZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIG5hbWU6IHN0cmluZykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCk7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIH1cblxuICBwdWJsaWMgZ2V0IG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYXBpVmVyc2lvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiBrOHMuS3ViZVNlcnZpY2VBY2NvdW50LkdWSy5hcGlWZXJzaW9uO1xuICB9XG5cbiAgcHVibGljIGdldCBhcGlHcm91cCgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHB1YmxpYyBnZXQga2luZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBrOHMuS3ViZVNlcnZpY2VBY2NvdW50LkdWSy5raW5kO1xuICB9XG5cbn1cblxuLyoqXG4gKiBBIHNlcnZpY2UgYWNjb3VudCBwcm92aWRlcyBhbiBpZGVudGl0eSBmb3IgcHJvY2Vzc2VzIHRoYXQgcnVuIGluIGEgUG9kLlxuICpcbiAqIFdoZW4geW91IChhIGh1bWFuKSBhY2Nlc3MgdGhlIGNsdXN0ZXIgKGZvciBleGFtcGxlLCB1c2luZyBrdWJlY3RsKSwgeW91IGFyZVxuICogYXV0aGVudGljYXRlZCBieSB0aGUgYXBpc2VydmVyIGFzIGEgcGFydGljdWxhciBVc2VyIEFjY291bnQgKGN1cnJlbnRseSB0aGlzXG4gKiBpcyB1c3VhbGx5IGFkbWluLCB1bmxlc3MgeW91ciBjbHVzdGVyIGFkbWluaXN0cmF0b3IgaGFzIGN1c3RvbWl6ZWQgeW91clxuICogY2x1c3RlcikuIFByb2Nlc3NlcyBpbiBjb250YWluZXJzIGluc2lkZSBwb2RzIGNhbiBhbHNvIGNvbnRhY3QgdGhlIGFwaXNlcnZlci5cbiAqIFdoZW4gdGhleSBkbywgdGhleSBhcmUgYXV0aGVudGljYXRlZCBhcyBhIHBhcnRpY3VsYXIgU2VydmljZSBBY2NvdW50IChmb3JcbiAqIGV4YW1wbGUsIGRlZmF1bHQpLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvdGFza3MvY29uZmlndXJlLXBvZC1jb250YWluZXIvY29uZmlndXJlLXNlcnZpY2UtYWNjb3VudFxuICovXG5leHBvcnQgY2xhc3MgU2VydmljZUFjY291bnQgZXh0ZW5kcyBiYXNlLlJlc291cmNlIGltcGxlbWVudHMgSVNlcnZpY2VBY2NvdW50LCByYi5JU3ViamVjdCB7XG5cbiAgLyoqXG4gICAqIEltcG9ydHMgYSBzZXJ2aWNlIGFjY291bnQgZnJvbSB0aGUgY2x1c3RlciBhcyBhIHJlZmVyZW5jZS5cbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHNlcnZpY2UgYWNjb3VudCByZXNvdXJjZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbVNlcnZpY2VBY2NvdW50TmFtZShzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBuYW1lOiBzdHJpbmcpOiBJU2VydmljZUFjY291bnQge1xuICAgIHJldHVybiBuZXcgSW1wb3J0ZWRTZXJ2aWNlQWNjb3VudChzY29wZSwgaWQsIG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgYmFzZS5SZXNvdXJjZS5hcGlPYmplY3RcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBhcGlPYmplY3Q6IEFwaU9iamVjdDtcblxuICBwdWJsaWMgcmVhZG9ubHkgcmVzb3VyY2VUeXBlID0gJ3NlcnZpY2VhY2NvdW50cyc7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBfc2VjcmV0czogc2VjcmV0LklTZWNyZXRbXTtcblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgYSB0b2tlbiBpcyBhdXRvbWF0aWNhbGx5IG1vdW50ZWQgZm9yIHRoaXNcbiAgICogc2VydmljZSBhY2NvdW50LlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGF1dG9tb3VudFRva2VuOiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBTZXJ2aWNlQWNjb3VudFByb3BzID0geyB9KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkKTtcblxuICAgIHRoaXMuX3NlY3JldHMgPSBwcm9wcy5zZWNyZXRzID8/IFtdO1xuICAgIHRoaXMuYXV0b21vdW50VG9rZW4gPSBwcm9wcy5hdXRvbW91bnRUb2tlbiA/PyB0cnVlO1xuXG4gICAgdGhpcy5hcGlPYmplY3QgPSBuZXcgazhzLkt1YmVTZXJ2aWNlQWNjb3VudCh0aGlzLCAnUmVzb3VyY2UnLCB7XG4gICAgICBtZXRhZGF0YTogcHJvcHMubWV0YWRhdGEsXG4gICAgICBzZWNyZXRzOiBMYXp5LmFueSh7IHByb2R1Y2U6ICgpID0+IHVuZGVmaW5lZElmRW1wdHkodGhpcy5fc2VjcmV0cy5tYXAocyA9PiAoeyBuYW1lOiBzLm5hbWUgfSkpKSB9KSxcbiAgICAgIGF1dG9tb3VudFNlcnZpY2VBY2NvdW50VG9rZW46IHRoaXMuYXV0b21vdW50VG9rZW4sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3cgYSBzZWNyZXQgdG8gYmUgYWNjZXNzZWQgYnkgcG9kcyB1c2luZyB0aGlzIHNlcnZpY2UgYWNjb3VudC5cbiAgICogQHBhcmFtIHNlY3IgVGhlIHNlY3JldFxuICAgKi9cbiAgcHVibGljIGFkZFNlY3JldChzZWNyOiBzZWNyZXQuSVNlY3JldCkge1xuICAgIHRoaXMuX3NlY3JldHMucHVzaChzZWNyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIHNlY3JldHMgYWxsb3dlZCB0byBiZSB1c2VkIGJ5IHBvZHMgcnVubmluZyB1c2luZyB0aGlzIHNlcnZpY2VcbiAgICogYWNjb3VudC5cbiAgICpcbiAgICogUmV0dXJucyBhIGNvcHkuIFRvIGFkZCBhIHNlY3JldCwgdXNlIGBhZGRTZWNyZXQoKWAuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHNlY3JldHMoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLl9zZWNyZXRzXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIElTdWJlY3QudG9TdWJqZWN0Q29uZmlndXJhdGlvbigpXG4gICAqL1xuICBwdWJsaWMgdG9TdWJqZWN0Q29uZmlndXJhdGlvbigpOiByYi5TdWJqZWN0Q29uZmlndXJhdGlvbiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIGFwaUdyb3VwOiB0aGlzLmFwaUdyb3VwLFxuICAgIH07XG4gIH1cblxufSJdfQ==

/***/ }),

/***/ 5445:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Protocol = exports.Service = exports.ServiceType = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const cdk8s_1 = __nccwpck_require__(1227);
const base = __nccwpck_require__(415);
const k8s = __nccwpck_require__(4879);
const ingress = __nccwpck_require__(1145);
/**
 * For some parts of your application (for example, frontends) you may want to expose a Service onto an
 * external IP address, that's outside of your cluster.
 * Kubernetes ServiceTypes allow you to specify what kind of Service you want.
 * The default is ClusterIP.
 */
var ServiceType;
(function (ServiceType) {
    /**
     * Exposes the Service on a cluster-internal IP.
     * Choosing this value makes the Service only reachable from within the cluster.
     * This is the default ServiceType
     */
    ServiceType["CLUSTER_IP"] = "ClusterIP";
    /**
     * Exposes the Service on each Node's IP at a static port (the NodePort).
     * A ClusterIP Service, to which the NodePort Service routes, is automatically created.
     * You'll be able to contact the NodePort Service, from outside the cluster,
     * by requesting <NodeIP>:<NodePort>.
     */
    ServiceType["NODE_PORT"] = "NodePort";
    /**
     * Exposes the Service externally using a cloud provider's load balancer.
     * NodePort and ClusterIP Services, to which the external load balancer routes,
     * are automatically created.
     */
    ServiceType["LOAD_BALANCER"] = "LoadBalancer";
    /**
     * Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value.
     * No proxying of any kind is set up.
     *
     * > Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.
     */
    ServiceType["EXTERNAL_NAME"] = "ExternalName";
})(ServiceType = exports.ServiceType || (exports.ServiceType = {}));
/**
 * An abstract way to expose an application running on a set of Pods as a network service.
 * With Kubernetes you don't need to modify your application to use an unfamiliar service discovery mechanism.
 * Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them.
 *
 * For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible—frontends do not care which backend they use.
 * While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that,
 * nor should they need to keep track of the set of backends themselves.
 * The Service abstraction enables this decoupling.
 *
 * If you're able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints,
 * that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port
 * or load balancer in between your application and the backend Pods.
 */
class Service extends base.Resource {
    constructor(scope, id, props = {}) {
        var _b, _c, _d;
        super(scope, id);
        this.resourceType = 'services';
        this.apiObject = new k8s.KubeService(this, 'Resource', {
            metadata: props.metadata,
            spec: cdk8s_1.Lazy.any({ produce: () => this._toKube() }),
        });
        this.clusterIP = props.clusterIP;
        this.externalName = props.externalName;
        if (props.externalName !== undefined) {
            this.type = ServiceType.EXTERNAL_NAME;
        }
        else {
            this.type = (_b = props.type) !== null && _b !== void 0 ? _b : ServiceType.CLUSTER_IP;
        }
        this._externalIPs = (_c = props.externalIPs) !== null && _c !== void 0 ? _c : [];
        this._ports = [];
        this._selector = {};
        this._loadBalancerSourceRanges = props.loadBalancerSourceRanges;
        if (props.selector) {
            this.select(props.selector);
        }
        for (const port of (_d = props.ports) !== null && _d !== void 0 ? _d : []) {
            this.bind(port.port, port);
        }
    }
    /**
     * Expose a service via an ingress using the specified path.
     *
     * @param path The path to expose the service under.
     * @param options Additional options.
     *
     * @returns The `Ingress` resource that was used.
     */
    exposeViaIngress(path, options = {}) {
        var _b;
        const ingr = (_b = options.ingress) !== null && _b !== void 0 ? _b : new ingress.Ingress(this, 'Ingress');
        ingr.addRule(path, ingress.IngressBackend.fromService(this), options.pathType);
        return ingr;
    }
    /**
     * Ports for this service.
     *
     * Use `bind()` to bind additional service ports.
     */
    get ports() {
        return [...this._ports];
    }
    /**
     * Configure a port the service will bind to.
     * This method can be called multiple times.
     *
     * @param port The port definition.
     */
    bind(port, options = {}) {
        this._ports.push({ ...options, port });
    }
    /**
     * Require this service to select pods matching the selector.
     *
     * Note that invoking this method multiple times acts as an AND operator
     * on the resulting labels.
     */
    select(selector) {
        var _b;
        const labels = (_b = selector.toPodSelectorConfig().labelSelector._toKube().matchLabels) !== null && _b !== void 0 ? _b : {};
        for (const [key, value] of Object.entries(labels)) {
            this._selector[key] = value;
        }
    }
    /**
     * Require this service to select pods with this label.
     *
     * Note that invoking this method multiple times acts as an AND operator
     * on the resulting labels.
     */
    selectLabel(key, value) {
        this._selector[key] = value;
    }
    /**
     * @internal
     */
    _toKube() {
        if (this._ports.length === 0 && this.type !== ServiceType.EXTERNAL_NAME) {
            throw new Error('A service must be configured with a port');
        }
        if (this.type === ServiceType.EXTERNAL_NAME && this.externalName === undefined) {
            throw new Error('A service with type EXTERNAL_NAME requires an externalName prop');
        }
        const ports = [];
        for (const port of this._ports) {
            ports.push({
                name: port.name,
                port: port.port,
                targetPort: port.targetPort ? k8s.IntOrString.fromNumber(port.targetPort) : undefined,
                nodePort: port.nodePort,
                protocol: port.protocol,
            });
        }
        return this.type !== ServiceType.EXTERNAL_NAME ? {
            clusterIp: this.clusterIP,
            externalIPs: this._externalIPs,
            externalName: this.externalName,
            type: this.type,
            selector: this._selector,
            ports: ports,
            loadBalancerSourceRanges: this._loadBalancerSourceRanges,
        } : {
            type: this.type,
            externalName: this.externalName,
        };
    }
}
exports.Service = Service;
_a = JSII_RTTI_SYMBOL_1;
Service[_a] = { fqn: "cdk8s-plus-22.Service", version: "2.0.0-rc.2" };
var Protocol;
(function (Protocol) {
    Protocol["TCP"] = "TCP";
    Protocol["UDP"] = "UDP";
    Protocol["SCTP"] = "SCTP";
})(Protocol = exports.Protocol || (exports.Protocol = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsaUNBQXdDO0FBRXhDLCtCQUErQjtBQUMvQixxQ0FBcUM7QUFDckMscUNBQXFDO0FBaUhyQzs7Ozs7R0FLRztBQUNILElBQVksV0ErQlg7QUEvQkQsV0FBWSxXQUFXO0lBRXJCOzs7O09BSUc7SUFDSCx1Q0FBd0IsQ0FBQTtJQUV4Qjs7Ozs7T0FLRztJQUNILHFDQUFzQixDQUFBO0lBRXRCOzs7O09BSUc7SUFDSCw2Q0FBOEIsQ0FBQTtJQUU5Qjs7Ozs7T0FLRztJQUNILDZDQUE4QixDQUFBO0FBQ2hDLENBQUMsRUEvQlcsV0FBVyxHQUFYLG1CQUFXLEtBQVgsbUJBQVcsUUErQnRCO0FBY0Q7Ozs7Ozs7Ozs7Ozs7R0FhRztBQUNILE1BQWEsT0FBUSxTQUFRLElBQUksQ0FBQyxRQUFRO0lBOEJ4QyxZQUFZLEtBQWdCLEVBQUUsRUFBVSxFQUFFLFFBQXNCLEVBQUU7O1FBQ2hFLEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFSSCxpQkFBWSxHQUFHLFVBQVUsQ0FBQztRQVV4QyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksR0FBRyxDQUFDLFdBQVcsQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFO1lBQ3JELFFBQVEsRUFBRSxLQUFLLENBQUMsUUFBUTtZQUN4QixJQUFJLEVBQUUsWUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQztTQUNsRCxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUM7UUFDakMsSUFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUMsWUFBWSxDQUFDO1FBRXZDLElBQUksS0FBSyxDQUFDLFlBQVksS0FBSyxTQUFTLEVBQUU7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QUFJLENBQUM7Z0JBQ1QsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO2dCQUNmLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtnQkFDZixVQUFVLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTO2dCQUNyRixRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVE7Z0JBQ3ZCLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUTthQUN4QixDQUFDLENBQUM7U0FDSjtRQUVELE9BQU8sSUFBSSxDQUFDLElBQUksS0FBSyxXQUFXLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztZQUMvQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFNBQVM7WUFDekIsV0FBVyxFQUFFLElBQUksQ0FBQyxZQUFZO1lBQzlCLFlBQVksRUFBRSxJQUFJLENBQUMsWUFBWTtZQUMvQixJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7WUFDZixRQUFRLEVBQUUsSUFBSSxDQUFDLFNBQVM7WUFDeEIsS0FBSyxFQUFFLEtBQUs7WUFDWix3QkFBd0IsRUFBRSxJQUFJLENBQUMseUJBQXlCO1NBQ3pELENBQUMsQ0FBQyxDQUFDO1lBQ0YsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO1lBQ2YsWUFBWSxFQUFFLElBQUksQ0FBQyxZQUFZO1NBQ2hDLENBQUM7SUFDSixDQUFDOztBQXpKSCwwQkEwSkM7OztBQUVELElBQVksUUFJWDtBQUpELFdBQVksUUFBUTtJQUNsQix1QkFBVyxDQUFBO0lBQ1gsdUJBQVcsQ0FBQTtJQUNYLHlCQUFhLENBQUE7QUFDZixDQUFDLEVBSlcsUUFBUSxHQUFSLGdCQUFRLEtBQVIsZ0JBQVEsUUFJbkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcGlPYmplY3QsIExhenkgfSBmcm9tICdjZGs4cyc7XG5pbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tICdjb25zdHJ1Y3RzJztcbmltcG9ydCAqIGFzIGJhc2UgZnJvbSAnLi9iYXNlJztcbmltcG9ydCAqIGFzIGs4cyBmcm9tICcuL2ltcG9ydHMvazhzJztcbmltcG9ydCAqIGFzIGluZ3Jlc3MgZnJvbSAnLi9pbmdyZXNzJztcbmltcG9ydCAqIGFzIHBvZCBmcm9tICcuL3BvZCc7XG5cbi8qKlxuICogUHJvcGVydGllcyBmb3IgYFNlcnZpY2VgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZpY2VQcm9wcyBleHRlbmRzIGJhc2UuUmVzb3VyY2VQcm9wcyB7XG4gIC8qKlxuICAgKiBXaGljaCBwb2RzIHNob3VsZCB0aGUgc2VydmljZSBzZWxlY3QgYW5kIHJvdXRlIHRvLlxuICAgKlxuICAgKiBZb3UgY2FuIHBhc3Mgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAqXG4gICAqIC0gQW4gaW5zdGFuY2Ugb2YgYFBvZGAgb3IgYW55IHdvcmtsb2FkIHJlc291cmNlIChlLmcgYERlcGxveW1lbnRgLCBgU3RhdGVmdWxTZXRgLCAuLi4pXG4gICAqIC0gUG9kcyBzZWxlY3RlZCBieSB0aGUgYFBvZHMuc2VsZWN0YCBmdW5jdGlvbi4gTm90ZSB0aGF0IGluIHRoaXMgY2FzZSBvbmx5IGxhYmVscyBjYW4gYmUgc3BlY2lmaWVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIHVuc2V0LCB0aGUgc2VydmljZSBpcyBhc3N1bWVkIHRvIGhhdmUgYW4gZXh0ZXJuYWwgcHJvY2VzcyBtYW5hZ2luZ1xuICAgKiBpdHMgZW5kcG9pbnRzLCB3aGljaCBLdWJlcm5ldGVzIHdpbGwgbm90IG1vZGlmeS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogLy8gc2VsZWN0IHRoZSBwb2RzIG9mIGEgc3BlY2lmaWMgZGVwbG95bWVudFxuICAgKiBjb25zdCBiYWNrZW5kID0gbmV3IGtwbHVzLkRlcGxveW1lbnQodGhpcywgJ0JhY2tlbmQnLCAuLi4pO1xuICAgKiBuZXcga3BsdXMuU2VydmljZSh0aGlzLCAnU2VydmljZScsIHsgc2VsZWN0b3I6IGJhY2tlbmQgfSk7XG4gICAqXG4gICAqIC8vIHNlbGVjdCBhbGwgcG9kcyBsYWJlbGVkIHdpdGggdGhlIGB0aWVyPWJhY2tlbmRgIGxhYmVsXG4gICAqIGNvbnN0IGJhY2tlbmQgPSBrcGx1cy5Qb2QubGFiZWxlZCh7IHRpZXI6ICdiYWNrZW5kJyB9KTtcbiAgICogbmV3IGtwbHVzLlNlcnZpY2UodGhpcywgJ1NlcnZpY2UnLCB7IHNlbGVjdG9yOiBiYWNrZW5kIH0pO1xuICAgKi9cbiAgcmVhZG9ubHkgc2VsZWN0b3I/OiBwb2QuSVBvZFNlbGVjdG9yO1xuXG4gIC8qKlxuICAgKiBUaGUgSVAgYWRkcmVzcyBvZiB0aGUgc2VydmljZSBhbmQgaXMgdXN1YWxseSBhc3NpZ25lZCByYW5kb21seSBieSB0aGVcbiAgICogbWFzdGVyLiBJZiBhbiBhZGRyZXNzIGlzIHNwZWNpZmllZCBtYW51YWxseSBhbmQgaXMgbm90IGluIHVzZSBieSBvdGhlcnMsIGl0XG4gICAqIHdpbGwgYmUgYWxsb2NhdGVkIHRvIHRoZSBzZXJ2aWNlOyBvdGhlcndpc2UsIGNyZWF0aW9uIG9mIHRoZSBzZXJ2aWNlIHdpbGxcbiAgICogZmFpbC4gVGhpcyBmaWVsZCBjYW4gbm90IGJlIGNoYW5nZWQgdGhyb3VnaCB1cGRhdGVzLiBWYWxpZCB2YWx1ZXMgYXJlXG4gICAqIFwiTm9uZVwiLCBlbXB0eSBzdHJpbmcgKFwiXCIpLCBvciBhIHZhbGlkIElQIGFkZHJlc3MuIFwiTm9uZVwiIGNhbiBiZSBzcGVjaWZpZWRcbiAgICogZm9yIGhlYWRsZXNzIHNlcnZpY2VzIHdoZW4gcHJveHlpbmcgaXMgbm90IHJlcXVpcmVkLiBPbmx5IGFwcGxpZXMgdG8gdHlwZXNcbiAgICogQ2x1c3RlcklQLCBOb2RlUG9ydCwgYW5kIExvYWRCYWxhbmNlci4gSWdub3JlZCBpZiB0eXBlIGlzIEV4dGVybmFsTmFtZS5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zZXJ2aWNlcy1uZXR3b3JraW5nL3NlcnZpY2UvI3ZpcnR1YWwtaXBzLWFuZC1zZXJ2aWNlLXByb3hpZXNcbiAgICogQGRlZmF1bHQgLSBBdXRvbWF0aWNhbGx5IGFzc2lnbmVkLlxuICAgKlxuICAgKi9cbiAgcmVhZG9ubHkgY2x1c3RlcklQPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgSVAgYWRkcmVzc2VzIGZvciB3aGljaCBub2RlcyBpbiB0aGUgY2x1c3RlciB3aWxsIGFsc28gYWNjZXB0XG4gICAqIHRyYWZmaWMgZm9yIHRoaXMgc2VydmljZS4gVGhlc2UgSVBzIGFyZSBub3QgbWFuYWdlZCBieSBLdWJlcm5ldGVzLiBUaGUgdXNlclxuICAgKiBpcyByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgdGhhdCB0cmFmZmljIGFycml2ZXMgYXQgYSBub2RlIHdpdGggdGhpcyBJUC4gQVxuICAgKiBjb21tb24gZXhhbXBsZSBpcyBleHRlcm5hbCBsb2FkLWJhbGFuY2VycyB0aGF0IGFyZSBub3QgcGFydCBvZiB0aGVcbiAgICogS3ViZXJuZXRlcyBzeXN0ZW0uXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gZXh0ZXJuYWwgSVBzLlxuICAgKi9cbiAgcmVhZG9ubHkgZXh0ZXJuYWxJUHM/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBob3cgdGhlIFNlcnZpY2UgaXMgZXhwb3NlZC5cbiAgICpcbiAgICogTW9yZSBpbmZvOiBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zZXJ2aWNlcy1uZXR3b3JraW5nL3NlcnZpY2UvI3B1Ymxpc2hpbmctc2VydmljZXMtc2VydmljZS10eXBlc1xuICAgKlxuICAgKiBAZGVmYXVsdCBTZXJ2aWNlVHlwZS5DbHVzdGVySVBcbiAgICovXG4gIHJlYWRvbmx5IHR5cGU/OiBTZXJ2aWNlVHlwZTtcblxuICAvKipcbiAgICogVGhlIHBvcnRzIHRoaXMgc2VydmljZSBiaW5kcyB0by5cbiAgICpcbiAgICogSWYgdGhlIHNlbGVjdG9yIG9mIHRoZSBzZXJ2aWNlIGlzIGEgbWFuYWdlZCBwb2QgLyB3b3JrbG9hZCxcbiAgICogaXRzIHBvcnRzIHdpbGwgYXJlIGF1dG9tYXRpY2FsbHkgZXh0cmFjdGVkIGFuZCB1c2VkIGFzIHRoZSBkZWZhdWx0IHZhbHVlLlxuICAgKiBPdGhlcndpc2UsIG5vIHBvcnRzIGFyZSBib3VuZC5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBlaXRoZXIgdGhlIHNlbGVjdG9yIHBvcnRzLCBvciBub25lLlxuICAgKi9cbiAgcmVhZG9ubHkgcG9ydHM/OiBTZXJ2aWNlUG9ydFtdO1xuXG4gIC8qKlxuICAgKiBUaGUgZXh0ZXJuYWxOYW1lIHRvIGJlIHVzZWQgd2hlbiBTZXJ2aWNlVHlwZS5FWFRFUk5BTF9OQU1FIGlzIHNldFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIE5vIGV4dGVybmFsIG5hbWUuXG4gICAqL1xuICByZWFkb25seSBleHRlcm5hbE5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBDSURSIElQIGFkZHJlc3NlcywgaWYgc3BlY2lmaWVkIGFuZCBzdXBwb3J0ZWQgYnkgdGhlIHBsYXRmb3JtLFxuICAgKiB3aWxsIHJlc3RyaWN0IHRyYWZmaWMgdGhyb3VnaCB0aGUgY2xvdWQtcHJvdmlkZXIgbG9hZC1iYWxhbmNlciB0byB0aGUgc3BlY2lmaWVkIGNsaWVudCBJUHMuXG4gICAqXG4gICAqIE1vcmUgaW5mbzogaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvdGFza3MvYWNjZXNzLWFwcGxpY2F0aW9uLWNsdXN0ZXIvY29uZmlndXJlLWNsb3VkLXByb3ZpZGVyLWZpcmV3YWxsL1xuICAgKi9cbiAgcmVhZG9ubHkgbG9hZEJhbGFuY2VyU291cmNlUmFuZ2VzPzogc3RyaW5nW107XG5cbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBleHBvc2luZyBhIHNlcnZpY2UgdXNpbmcgYW4gaW5ncmVzcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFeHBvc2VTZXJ2aWNlVmlhSW5ncmVzc09wdGlvbnMge1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgcGF0aFxuICAgKlxuICAgKiBAZGVmYXVsdCBIdHRwSW5ncmVzc1BhdGhUeXBlLlBSRUZJWFxuICAgKi9cbiAgcmVhZG9ubHkgcGF0aFR5cGU/OiBpbmdyZXNzLkh0dHBJbmdyZXNzUGF0aFR5cGU7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmdyZXNzIHRvIGFkZCBydWxlcyB0by5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBBbiBpbmdyZXNzIHdpbGwgYmUgYXV0b21hdGljYWxseSBjcmVhdGVkLlxuICAgKi9cbiAgcmVhZG9ubHkgaW5ncmVzcz86IGluZ3Jlc3MuSW5ncmVzcztcbn1cblxuLyoqXG4gKiBGb3Igc29tZSBwYXJ0cyBvZiB5b3VyIGFwcGxpY2F0aW9uIChmb3IgZXhhbXBsZSwgZnJvbnRlbmRzKSB5b3UgbWF5IHdhbnQgdG8gZXhwb3NlIGEgU2VydmljZSBvbnRvIGFuXG4gKiBleHRlcm5hbCBJUCBhZGRyZXNzLCB0aGF0J3Mgb3V0c2lkZSBvZiB5b3VyIGNsdXN0ZXIuXG4gKiBLdWJlcm5ldGVzIFNlcnZpY2VUeXBlcyBhbGxvdyB5b3UgdG8gc3BlY2lmeSB3aGF0IGtpbmQgb2YgU2VydmljZSB5b3Ugd2FudC5cbiAqIFRoZSBkZWZhdWx0IGlzIENsdXN0ZXJJUC5cbiAqL1xuZXhwb3J0IGVudW0gU2VydmljZVR5cGUge1xuXG4gIC8qKlxuICAgKiBFeHBvc2VzIHRoZSBTZXJ2aWNlIG9uIGEgY2x1c3Rlci1pbnRlcm5hbCBJUC5cbiAgICogQ2hvb3NpbmcgdGhpcyB2YWx1ZSBtYWtlcyB0aGUgU2VydmljZSBvbmx5IHJlYWNoYWJsZSBmcm9tIHdpdGhpbiB0aGUgY2x1c3Rlci5cbiAgICogVGhpcyBpcyB0aGUgZGVmYXVsdCBTZXJ2aWNlVHlwZVxuICAgKi9cbiAgQ0xVU1RFUl9JUCA9ICdDbHVzdGVySVAnLFxuXG4gIC8qKlxuICAgKiBFeHBvc2VzIHRoZSBTZXJ2aWNlIG9uIGVhY2ggTm9kZSdzIElQIGF0IGEgc3RhdGljIHBvcnQgKHRoZSBOb2RlUG9ydCkuXG4gICAqIEEgQ2x1c3RlcklQIFNlcnZpY2UsIHRvIHdoaWNoIHRoZSBOb2RlUG9ydCBTZXJ2aWNlIHJvdXRlcywgaXMgYXV0b21hdGljYWxseSBjcmVhdGVkLlxuICAgKiBZb3UnbGwgYmUgYWJsZSB0byBjb250YWN0IHRoZSBOb2RlUG9ydCBTZXJ2aWNlLCBmcm9tIG91dHNpZGUgdGhlIGNsdXN0ZXIsXG4gICAqIGJ5IHJlcXVlc3RpbmcgPE5vZGVJUD46PE5vZGVQb3J0Pi5cbiAgICovXG4gIE5PREVfUE9SVCA9ICdOb2RlUG9ydCcsXG5cbiAgLyoqXG4gICAqIEV4cG9zZXMgdGhlIFNlcnZpY2UgZXh0ZXJuYWxseSB1c2luZyBhIGNsb3VkIHByb3ZpZGVyJ3MgbG9hZCBiYWxhbmNlci5cbiAgICogTm9kZVBvcnQgYW5kIENsdXN0ZXJJUCBTZXJ2aWNlcywgdG8gd2hpY2ggdGhlIGV4dGVybmFsIGxvYWQgYmFsYW5jZXIgcm91dGVzLFxuICAgKiBhcmUgYXV0b21hdGljYWxseSBjcmVhdGVkLlxuICAgKi9cbiAgTE9BRF9CQUxBTkNFUiA9ICdMb2FkQmFsYW5jZXInLFxuXG4gIC8qKlxuICAgKiBNYXBzIHRoZSBTZXJ2aWNlIHRvIHRoZSBjb250ZW50cyBvZiB0aGUgZXh0ZXJuYWxOYW1lIGZpZWxkIChlLmcuIGZvby5iYXIuZXhhbXBsZS5jb20pLCBieSByZXR1cm5pbmcgYSBDTkFNRSByZWNvcmQgd2l0aCBpdHMgdmFsdWUuXG4gICAqIE5vIHByb3h5aW5nIG9mIGFueSBraW5kIGlzIHNldCB1cC5cbiAgICpcbiAgICogPiBOb3RlOiBZb3UgbmVlZCBlaXRoZXIga3ViZS1kbnMgdmVyc2lvbiAxLjcgb3IgQ29yZUROUyB2ZXJzaW9uIDAuMC44IG9yIGhpZ2hlciB0byB1c2UgdGhlIEV4dGVybmFsTmFtZSB0eXBlLlxuICAgKi9cbiAgRVhURVJOQUxfTkFNRSA9ICdFeHRlcm5hbE5hbWUnXG59XG5cbi8qKlxuICogT3B0aW9ucyB0byBhZGQgYSBkZXBsb3ltZW50IHRvIGEgc2VydmljZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBZGREZXBsb3ltZW50T3B0aW9ucyBleHRlbmRzIFNlcnZpY2VCaW5kT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgcG9ydCBudW1iZXIgdGhlIHNlcnZpY2Ugd2lsbCBiaW5kIHRvLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIENvcGllZCBmcm9tIHRoZSBmaXJzdCBjb250YWluZXIgb2YgdGhlIGRlcGxveW1lbnQuXG4gICAqL1xuICByZWFkb25seSBwb3J0PzogbnVtYmVyO1xufVxuXG4vKipcbiAqIEFuIGFic3RyYWN0IHdheSB0byBleHBvc2UgYW4gYXBwbGljYXRpb24gcnVubmluZyBvbiBhIHNldCBvZiBQb2RzIGFzIGEgbmV0d29yayBzZXJ2aWNlLlxuICogV2l0aCBLdWJlcm5ldGVzIHlvdSBkb24ndCBuZWVkIHRvIG1vZGlmeSB5b3VyIGFwcGxpY2F0aW9uIHRvIHVzZSBhbiB1bmZhbWlsaWFyIHNlcnZpY2UgZGlzY292ZXJ5IG1lY2hhbmlzbS5cbiAqIEt1YmVybmV0ZXMgZ2l2ZXMgUG9kcyB0aGVpciBvd24gSVAgYWRkcmVzc2VzIGFuZCBhIHNpbmdsZSBETlMgbmFtZSBmb3IgYSBzZXQgb2YgUG9kcywgYW5kIGNhbiBsb2FkLWJhbGFuY2UgYWNyb3NzIHRoZW0uXG4gKlxuICogRm9yIGV4YW1wbGUsIGNvbnNpZGVyIGEgc3RhdGVsZXNzIGltYWdlLXByb2Nlc3NpbmcgYmFja2VuZCB3aGljaCBpcyBydW5uaW5nIHdpdGggMyByZXBsaWNhcy4gVGhvc2UgcmVwbGljYXMgYXJlIGZ1bmdpYmxl4oCUZnJvbnRlbmRzIGRvIG5vdCBjYXJlIHdoaWNoIGJhY2tlbmQgdGhleSB1c2UuXG4gKiBXaGlsZSB0aGUgYWN0dWFsIFBvZHMgdGhhdCBjb21wb3NlIHRoZSBiYWNrZW5kIHNldCBtYXkgY2hhbmdlLCB0aGUgZnJvbnRlbmQgY2xpZW50cyBzaG91bGQgbm90IG5lZWQgdG8gYmUgYXdhcmUgb2YgdGhhdCxcbiAqIG5vciBzaG91bGQgdGhleSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIHNldCBvZiBiYWNrZW5kcyB0aGVtc2VsdmVzLlxuICogVGhlIFNlcnZpY2UgYWJzdHJhY3Rpb24gZW5hYmxlcyB0aGlzIGRlY291cGxpbmcuXG4gKlxuICogSWYgeW91J3JlIGFibGUgdG8gdXNlIEt1YmVybmV0ZXMgQVBJcyBmb3Igc2VydmljZSBkaXNjb3ZlcnkgaW4geW91ciBhcHBsaWNhdGlvbiwgeW91IGNhbiBxdWVyeSB0aGUgQVBJIHNlcnZlciBmb3IgRW5kcG9pbnRzLFxuICogdGhhdCBnZXQgdXBkYXRlZCB3aGVuZXZlciB0aGUgc2V0IG9mIFBvZHMgaW4gYSBTZXJ2aWNlIGNoYW5nZXMuIEZvciBub24tbmF0aXZlIGFwcGxpY2F0aW9ucywgS3ViZXJuZXRlcyBvZmZlcnMgd2F5cyB0byBwbGFjZSBhIG5ldHdvcmsgcG9ydFxuICogb3IgbG9hZCBiYWxhbmNlciBpbiBiZXR3ZWVuIHlvdXIgYXBwbGljYXRpb24gYW5kIHRoZSBiYWNrZW5kIFBvZHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXJ2aWNlIGV4dGVuZHMgYmFzZS5SZXNvdXJjZSB7XG5cbiAgLyoqXG4gICAqIFRoZSBJUCBhZGRyZXNzIG9mIHRoZSBzZXJ2aWNlIGFuZCBpcyB1c3VhbGx5IGFzc2lnbmVkIHJhbmRvbWx5IGJ5IHRoZVxuICAgKiBtYXN0ZXIuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgY2x1c3RlcklQPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGhvdyB0aGUgU2VydmljZSBpcyBleHBvc2VkLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHR5cGU6IFNlcnZpY2VUeXBlO1xuXG4gIC8qKlxuICAgKiBUaGUgZXh0ZXJuYWxOYW1lIHRvIGJlIHVzZWQgZm9yIEVYVEVSTkFMX05BTUUgdHlwZXNcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBleHRlcm5hbE5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEBzZWUgYmFzZS5SZXNvdXJjZS5hcGlPYmplY3RcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBhcGlPYmplY3Q6IEFwaU9iamVjdDtcblxuICBwdWJsaWMgcmVhZG9ubHkgcmVzb3VyY2VUeXBlID0gJ3NlcnZpY2VzJztcblxuICBwcml2YXRlIHJlYWRvbmx5IF9leHRlcm5hbElQczogc3RyaW5nW107XG4gIHByaXZhdGUgcmVhZG9ubHkgX3NlbGVjdG9yOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICBwcml2YXRlIHJlYWRvbmx5IF9wb3J0czogU2VydmljZVBvcnRbXTtcbiAgcHJpdmF0ZSByZWFkb25seSBfbG9hZEJhbGFuY2VyU291cmNlUmFuZ2VzPzogc3RyaW5nW107XG5cbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IFNlcnZpY2VQcm9wcyA9IHt9KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkKTtcblxuICAgIHRoaXMuYXBpT2JqZWN0ID0gbmV3IGs4cy5LdWJlU2VydmljZSh0aGlzLCAnUmVzb3VyY2UnLCB7XG4gICAgICBtZXRhZGF0YTogcHJvcHMubWV0YWRhdGEsXG4gICAgICBzcGVjOiBMYXp5LmFueSh7IHByb2R1Y2U6ICgpID0+IHRoaXMuX3RvS3ViZSgpIH0pLFxuICAgIH0pO1xuXG4gICAgdGhpcy5jbHVzdGVySVAgPSBwcm9wcy5jbHVzdGVySVA7XG4gICAgdGhpcy5leHRlcm5hbE5hbWUgPSBwcm9wcy5leHRlcm5hbE5hbWU7XG5cbiAgICBpZiAocHJvcHMuZXh0ZXJuYWxOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudHlwZSA9IFNlcnZpY2VUeXBlLkVYVEVSTkFMX05BTUU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHlwZSA9IHByb3BzLnR5cGUgPz8gU2VydmljZVR5cGUuQ0xVU1RFUl9JUDtcbiAgICB9XG5cbiAgICB0aGlzLl9leHRlcm5hbElQcyA9IHByb3BzLmV4dGVybmFsSVBzID8/IFtdO1xuICAgIHRoaXMuX3BvcnRzID0gW107XG4gICAgdGhpcy5fc2VsZWN0b3IgPSB7IH07XG4gICAgdGhpcy5fbG9hZEJhbGFuY2VyU291cmNlUmFuZ2VzID0gcHJvcHMubG9hZEJhbGFuY2VyU291cmNlUmFuZ2VzO1xuXG4gICAgaWYgKHByb3BzLnNlbGVjdG9yKSB7XG4gICAgICB0aGlzLnNlbGVjdChwcm9wcy5zZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBwb3J0IG9mIHByb3BzLnBvcnRzID8/IFtdKSB7XG4gICAgICB0aGlzLmJpbmQocG9ydC5wb3J0LCBwb3J0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXhwb3NlIGEgc2VydmljZSB2aWEgYW4gaW5ncmVzcyB1c2luZyB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIGV4cG9zZSB0aGUgc2VydmljZSB1bmRlci5cbiAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgYEluZ3Jlc3NgIHJlc291cmNlIHRoYXQgd2FzIHVzZWQuXG4gICAqL1xuICBwdWJsaWMgZXhwb3NlVmlhSW5ncmVzcyhwYXRoOiBzdHJpbmcsIG9wdGlvbnM6IEV4cG9zZVNlcnZpY2VWaWFJbmdyZXNzT3B0aW9ucyA9IHt9KTogaW5ncmVzcy5JbmdyZXNzIHtcbiAgICBjb25zdCBpbmdyID0gb3B0aW9ucy5pbmdyZXNzID8/IG5ldyBpbmdyZXNzLkluZ3Jlc3ModGhpcywgJ0luZ3Jlc3MnKTtcbiAgICBpbmdyLmFkZFJ1bGUocGF0aCwgaW5ncmVzcy5JbmdyZXNzQmFja2VuZC5mcm9tU2VydmljZSh0aGlzKSwgb3B0aW9ucy5wYXRoVHlwZSk7XG4gICAgcmV0dXJuIGluZ3I7XG4gIH1cblxuICAvKipcbiAgICogUG9ydHMgZm9yIHRoaXMgc2VydmljZS5cbiAgICpcbiAgICogVXNlIGBiaW5kKClgIHRvIGJpbmQgYWRkaXRpb25hbCBzZXJ2aWNlIHBvcnRzLlxuICAgKi9cbiAgcHVibGljIGdldCBwb3J0cygpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuX3BvcnRzXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmUgYSBwb3J0IHRoZSBzZXJ2aWNlIHdpbGwgYmluZCB0by5cbiAgICogVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICpcbiAgICogQHBhcmFtIHBvcnQgVGhlIHBvcnQgZGVmaW5pdGlvbi5cbiAgICovXG4gIHB1YmxpYyBiaW5kKHBvcnQ6IG51bWJlciwgb3B0aW9uczogU2VydmljZUJpbmRPcHRpb25zID0geyB9KSB7XG4gICAgdGhpcy5fcG9ydHMucHVzaCh7IC4uLm9wdGlvbnMsIHBvcnQgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWlyZSB0aGlzIHNlcnZpY2UgdG8gc2VsZWN0IHBvZHMgbWF0Y2hpbmcgdGhlIHNlbGVjdG9yLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgaW52b2tpbmcgdGhpcyBtZXRob2QgbXVsdGlwbGUgdGltZXMgYWN0cyBhcyBhbiBBTkQgb3BlcmF0b3JcbiAgICogb24gdGhlIHJlc3VsdGluZyBsYWJlbHMuXG4gICAqL1xuICBwdWJsaWMgc2VsZWN0KHNlbGVjdG9yOiBwb2QuSVBvZFNlbGVjdG9yKSB7XG4gICAgY29uc3QgbGFiZWxzID0gc2VsZWN0b3IudG9Qb2RTZWxlY3RvckNvbmZpZygpLmxhYmVsU2VsZWN0b3IuX3RvS3ViZSgpLm1hdGNoTGFiZWxzID8/IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGxhYmVscykpIHtcbiAgICAgIHRoaXMuX3NlbGVjdG9yW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVxdWlyZSB0aGlzIHNlcnZpY2UgdG8gc2VsZWN0IHBvZHMgd2l0aCB0aGlzIGxhYmVsLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgaW52b2tpbmcgdGhpcyBtZXRob2QgbXVsdGlwbGUgdGltZXMgYWN0cyBhcyBhbiBBTkQgb3BlcmF0b3JcbiAgICogb24gdGhlIHJlc3VsdGluZyBsYWJlbHMuXG4gICAqL1xuICBwdWJsaWMgc2VsZWN0TGFiZWwoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9zZWxlY3RvcltrZXldID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgX3RvS3ViZSgpOiBrOHMuU2VydmljZVNwZWMge1xuICAgIGlmICh0aGlzLl9wb3J0cy5sZW5ndGggPT09IDAgJiYgdGhpcy50eXBlICE9PSBTZXJ2aWNlVHlwZS5FWFRFUk5BTF9OQU1FKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Egc2VydmljZSBtdXN0IGJlIGNvbmZpZ3VyZWQgd2l0aCBhIHBvcnQnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50eXBlID09PSBTZXJ2aWNlVHlwZS5FWFRFUk5BTF9OQU1FICYmIHRoaXMuZXh0ZXJuYWxOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSBzZXJ2aWNlIHdpdGggdHlwZSBFWFRFUk5BTF9OQU1FIHJlcXVpcmVzIGFuIGV4dGVybmFsTmFtZSBwcm9wJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcG9ydHM6IGs4cy5TZXJ2aWNlUG9ydFtdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHBvcnQgb2YgdGhpcy5fcG9ydHMpIHtcbiAgICAgIHBvcnRzLnB1c2goe1xuICAgICAgICBuYW1lOiBwb3J0Lm5hbWUsXG4gICAgICAgIHBvcnQ6IHBvcnQucG9ydCxcbiAgICAgICAgdGFyZ2V0UG9ydDogcG9ydC50YXJnZXRQb3J0ID8gazhzLkludE9yU3RyaW5nLmZyb21OdW1iZXIocG9ydC50YXJnZXRQb3J0KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgbm9kZVBvcnQ6IHBvcnQubm9kZVBvcnQsXG4gICAgICAgIHByb3RvY29sOiBwb3J0LnByb3RvY29sLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudHlwZSAhPT0gU2VydmljZVR5cGUuRVhURVJOQUxfTkFNRSA/IHtcbiAgICAgIGNsdXN0ZXJJcDogdGhpcy5jbHVzdGVySVAsXG4gICAgICBleHRlcm5hbElQczogdGhpcy5fZXh0ZXJuYWxJUHMsXG4gICAgICBleHRlcm5hbE5hbWU6IHRoaXMuZXh0ZXJuYWxOYW1lLFxuICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgc2VsZWN0b3I6IHRoaXMuX3NlbGVjdG9yLFxuICAgICAgcG9ydHM6IHBvcnRzLFxuICAgICAgbG9hZEJhbGFuY2VyU291cmNlUmFuZ2VzOiB0aGlzLl9sb2FkQmFsYW5jZXJTb3VyY2VSYW5nZXMsXG4gICAgfSA6IHtcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIGV4dGVybmFsTmFtZTogdGhpcy5leHRlcm5hbE5hbWUsXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZW51bSBQcm90b2NvbCB7XG4gIFRDUCA9ICdUQ1AnLFxuICBVRFAgPSAnVURQJyxcbiAgU0NUUCA9ICdTQ1RQJ1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGBTZXJ2aWNlLmJpbmRgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZpY2VCaW5kT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGlzIHBvcnQgd2l0aGluIHRoZSBzZXJ2aWNlLiBUaGlzIG11c3QgYmUgYSBETlNfTEFCRUwuIEFsbFxuICAgKiBwb3J0cyB3aXRoaW4gYSBTZXJ2aWNlU3BlYyBtdXN0IGhhdmUgdW5pcXVlIG5hbWVzLiBUaGlzIG1hcHMgdG8gdGhlICdOYW1lJ1xuICAgKiBmaWVsZCBpbiBFbmRwb2ludFBvcnQgb2JqZWN0cy4gT3B0aW9uYWwgaWYgb25seSBvbmUgU2VydmljZVBvcnQgaXMgZGVmaW5lZFxuICAgKiBvbiB0aGlzIHNlcnZpY2UuXG4gICAqL1xuICByZWFkb25seSBuYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcG9ydCBvbiBlYWNoIG5vZGUgb24gd2hpY2ggdGhpcyBzZXJ2aWNlIGlzIGV4cG9zZWQgd2hlbiB0eXBlPU5vZGVQb3J0XG4gICAqIG9yIExvYWRCYWxhbmNlci4gVXN1YWxseSBhc3NpZ25lZCBieSB0aGUgc3lzdGVtLiBJZiBzcGVjaWZpZWQsIGl0IHdpbGwgYmVcbiAgICogYWxsb2NhdGVkIHRvIHRoZSBzZXJ2aWNlIGlmIHVudXNlZCBvciBlbHNlIGNyZWF0aW9uIG9mIHRoZSBzZXJ2aWNlIHdpbGxcbiAgICogZmFpbC4gRGVmYXVsdCBpcyB0byBhdXRvLWFsbG9jYXRlIGEgcG9ydCBpZiB0aGUgU2VydmljZVR5cGUgb2YgdGhpcyBTZXJ2aWNlXG4gICAqIHJlcXVpcmVzIG9uZS5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zZXJ2aWNlcy1uZXR3b3JraW5nL3NlcnZpY2UvI3R5cGUtbm9kZXBvcnRcbiAgICpcbiAgICogQGRlZmF1bHQgLSBhdXRvLWFsbG9jYXRlIGEgcG9ydCBpZiB0aGUgU2VydmljZVR5cGUgb2YgdGhpcyBTZXJ2aWNlIHJlcXVpcmVzIG9uZS5cbiAgICovXG4gIHJlYWRvbmx5IG5vZGVQb3J0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSVAgcHJvdG9jb2wgZm9yIHRoaXMgcG9ydC4gU3VwcG9ydHMgXCJUQ1BcIiwgXCJVRFBcIiwgYW5kIFwiU0NUUFwiLiBEZWZhdWx0IGlzIFRDUC5cbiAgICpcbiAgICogQGRlZmF1bHQgUHJvdG9jb2wuVENQXG4gICAqL1xuICByZWFkb25seSBwcm90b2NvbD86IFByb3RvY29sO1xuXG4gIC8qKlxuICAgKiBUaGUgcG9ydCBudW1iZXIgdGhlIHNlcnZpY2Ugd2lsbCByZWRpcmVjdCB0by5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBUaGUgdmFsdWUgb2YgYHBvcnRgIHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIHJlYWRvbmx5IHRhcmdldFBvcnQ/OiBudW1iZXI7XG59XG5cbi8qKlxuICogRGVmaW5pdGlvbiBvZiBhIHNlcnZpY2UgcG9ydC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZXJ2aWNlUG9ydCBleHRlbmRzIFNlcnZpY2VCaW5kT3B0aW9ucyB7XG5cbiAgLyoqXG4gICAqIFRoZSBwb3J0IG51bWJlciB0aGUgc2VydmljZSB3aWxsIGJpbmQgdG8uXG4gICAqL1xuICByZWFkb25seSBwb3J0OiBudW1iZXI7XG59XG4iXX0=

/***/ }),

/***/ 120:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatefulSetUpdateStrategy = exports.StatefulSet = exports.PodManagementPolicy = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const cdk8s_1 = __nccwpck_require__(1227);
const k8s = __nccwpck_require__(4879);
const workload = __nccwpck_require__(7967);
/**
 * Controls how pods are created during initial scale up, when replacing pods on nodes,
 * or when scaling down.
 *
 * The default policy is `OrderedReady`, where pods are created in increasing order
 * (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before
 * continuing. When scaling down, the pods are removed in the opposite order.
 *
 * The alternative policy is `Parallel` which will create pods in parallel to match the
 * desired scale without waiting, and on scale down will delete all pods at once.
 */
var PodManagementPolicy;
(function (PodManagementPolicy) {
    PodManagementPolicy["ORDERED_READY"] = "OrderedReady";
    PodManagementPolicy["PARALLEL"] = "Parallel";
})(PodManagementPolicy = exports.PodManagementPolicy || (exports.PodManagementPolicy = {}));
/**
 * StatefulSet is the workload API object used to manage stateful applications.
 *
 * Manages the deployment and scaling of a set of Pods, and provides guarantees
 * about the ordering and uniqueness of these Pods.
 *
 * Like a Deployment, a StatefulSet manages Pods that are based on an identical
 * container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity
 * for each of their Pods. These pods are created from the same spec, but are not
 * interchangeable: each has a persistent identifier that it maintains across any
 * rescheduling.
 *
 * If you want to use storage volumes to provide persistence for your workload, you
 * can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet
 * are susceptible to failure, the persistent Pod identifiers make it easier to match existing
 * volumes to the new Pods that replace any that have failed.
 *
 * Using StatefulSets
 * ------------------
 * StatefulSets are valuable for applications that require one or more of the following.
 *
 * - Stable, unique network identifiers.
 * - Stable, persistent storage.
 * - Ordered, graceful deployment and scaling.
 * - Ordered, automated rolling updates.
 */
class StatefulSet extends workload.Workload {
    constructor(scope, id, props) {
        var _c, _d, _e, _f;
        super(scope, id, props);
        this.resourceType = 'statefulsets';
        this.apiObject = new k8s.KubeStatefulSet(this, 'Resource', {
            metadata: props.metadata,
            spec: cdk8s_1.Lazy.any({ produce: () => this._toKube() }),
        });
        this._service = props.service;
        this.apiObject.addDependency(this._service);
        this.replicas = (_c = props.replicas) !== null && _c !== void 0 ? _c : 1;
        this.strategy = (_d = props.strategy) !== null && _d !== void 0 ? _d : StatefulSetUpdateStrategy.rollingUpdate(),
            this.podManagementPolicy = (_e = props.podManagementPolicy) !== null && _e !== void 0 ? _e : PodManagementPolicy.ORDERED_READY;
        this.minReady = (_f = props.minReady) !== null && _f !== void 0 ? _f : cdk8s_1.Duration.seconds(0);
        this._service.select(this);
    }
    /**
      * @internal
      */
    _toKube() {
        return {
            serviceName: this._service.name,
            replicas: this.replicas,
            minReadySeconds: this.minReady.toSeconds(),
            template: {
                metadata: this.podMetadata.toJson(),
                spec: this._toPodSpec(),
            },
            selector: this._toLabelSelector(),
            podManagementPolicy: this.podManagementPolicy,
            updateStrategy: this.strategy._toKube(),
        };
    }
}
exports.StatefulSet = StatefulSet;
_a = JSII_RTTI_SYMBOL_1;
StatefulSet[_a] = { fqn: "cdk8s-plus-22.StatefulSet", version: "2.0.0-rc.2" };
/**
 * StatefulSet update strategies.
 */
class StatefulSetUpdateStrategy {
    constructor(strategy) {
        this.strategy = strategy;
    }
    /**
     * The controller will not automatically update the Pods in a StatefulSet.
     * Users must manually delete Pods to cause the controller to create new Pods
     * that reflect modifications.
     */
    static onDelete() {
        return new StatefulSetUpdateStrategy({
            type: 'OnDelete',
        });
    }
    /**
     * The controller will delete and recreate each Pod in the StatefulSet.
     * It will proceed in the same order as Pod termination (from the largest ordinal to the smallest),
     * updating each Pod one at a time. The Kubernetes control plane waits until an updated
     * Pod is Running and Ready prior to updating its predecessor.
     */
    static rollingUpdate(options = {}) {
        var _c;
        return new StatefulSetUpdateStrategy({
            type: 'RollingUpdate',
            rollingUpdate: { partition: (_c = options.partition) !== null && _c !== void 0 ? _c : 0 },
        });
    }
    /**
     * @internal
     */
    _toKube() {
        return this.strategy;
    }
}
exports.StatefulSetUpdateStrategy = StatefulSetUpdateStrategy;
_b = JSII_RTTI_SYMBOL_1;
StatefulSetUpdateStrategy[_b] = { fqn: "cdk8s-plus-22.StatefulSetUpdateStrategy", version: "2.0.0-rc.2" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGVmdWwtc2V0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3N0YXRlZnVsLXNldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGlDQUFrRDtBQUVsRCxxQ0FBcUM7QUFFckMsdUNBQXVDO0FBRXZDOzs7Ozs7Ozs7O0dBVUc7QUFDSCxJQUFZLG1CQUdYO0FBSEQsV0FBWSxtQkFBbUI7SUFDN0IscURBQThCLENBQUE7SUFDOUIsNENBQXFCLENBQUE7QUFDdkIsQ0FBQyxFQUhXLG1CQUFtQixHQUFuQiwyQkFBbUIsS0FBbkIsMkJBQW1CLFFBRzlCO0FBNkNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBeUJHO0FBQ0gsTUFBYSxXQUFZLFNBQVEsUUFBUSxDQUFDLFFBQVE7SUErQmhELFlBQVksS0FBZ0IsRUFBRSxFQUFVLEVBQUUsS0FBdUI7O1FBQy9ELEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBTFYsaUJBQVksR0FBRyxjQUFjLENBQUM7UUFPNUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxlQUFlLENBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRTtZQUN6RCxRQUFRLEVBQUUsS0FBSyxDQUFDLFFBQVE7WUFDeEIsSUFBSSxFQUFFLFlBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUM7U0FDbEQsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDO1FBRTlCLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUU1QyxJQUFJLENBQUMsUUFBUSxTQUFHLEtBQUssQ0FBQyxRQUFRLG1DQUFJLENBQUMsQ0FBQztRQUNwQyxJQUFJLENBQUMsUUFBUSxTQUFHLEtBQUssQ0FBQyxRQUFRLG1DQUFJLHlCQUF5QixDQUFDLGFBQWEsRUFBRTtZQUMzRSxJQUFJLENBQUMsbUJBQW1CLFNBQUcsS0FBSyxDQUFDLG1CQUFtQixtQ0FBSSxtQkFBbUIsQ0FBQyxhQUFhLENBQUM7UUFDMUYsSUFBSSxDQUFDLFFBQVEsU0FBRyxLQUFLLENBQUMsUUFBUSxtQ0FBSSxnQkFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUV0RCxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRUQ7O1FBRUk7SUFDRyxPQUFPO1FBQ1osT0FBTztZQUNMLFdBQVcsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUk7WUFDL0IsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRO1lBQ3ZCLGVBQWUsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRTtZQUMxQyxRQUFRLEVBQUU7Z0JBQ1IsUUFBUSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFO2dCQUNuQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFVBQVUsRUFBRTthQUN4QjtZQUNELFFBQVEsRUFBRSxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7WUFDakMsbUJBQW1CLEVBQUUsSUFBSSxDQUFDLG1CQUFtQjtZQUM3QyxjQUFjLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUU7U0FDeEMsQ0FBQztJQUNKLENBQUM7O0FBbEVILGtDQW1FQzs7O0FBd0JEOztHQUVHO0FBQ0gsTUFBYSx5QkFBeUI7SUEyQnBDLFlBQXFDLFFBQXVDO1FBQXZDLGFBQVEsR0FBUixRQUFRLENBQStCO0lBQUcsQ0FBQztJQXpCaEY7Ozs7T0FJRztJQUNJLE1BQU0sQ0FBQyxRQUFRO1FBQ3BCLE9BQU8sSUFBSSx5QkFBeUIsQ0FBQztZQUNuQyxJQUFJLEVBQUUsVUFBVTtTQUNqQixDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxNQUFNLENBQUMsYUFBYSxDQUFDLFVBQXlELEVBQUU7O1FBRXJGLE9BQU8sSUFBSSx5QkFBeUIsQ0FBQztZQUNuQyxJQUFJLEVBQUUsZUFBZTtZQUNyQixhQUFhLEVBQUUsRUFBRSxTQUFTLFFBQUUsT0FBTyxDQUFDLFNBQVMsbUNBQUksQ0FBQyxFQUFFO1NBQ3JELENBQUMsQ0FBQztJQUNMLENBQUM7SUFJRDs7T0FFRztJQUNJLE9BQU87UUFDWixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDdkIsQ0FBQzs7QUFsQ0gsOERBb0NDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBpT2JqZWN0LCBMYXp5LCBEdXJhdGlvbiB9IGZyb20gJ2NkazhzJztcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xuaW1wb3J0ICogYXMgazhzIGZyb20gJy4vaW1wb3J0cy9rOHMnO1xuaW1wb3J0ICogYXMgc2VydmljZSBmcm9tICcuL3NlcnZpY2UnO1xuaW1wb3J0ICogYXMgd29ya2xvYWQgZnJvbSAnLi93b3JrbG9hZCc7XG5cbi8qKlxuICogQ29udHJvbHMgaG93IHBvZHMgYXJlIGNyZWF0ZWQgZHVyaW5nIGluaXRpYWwgc2NhbGUgdXAsIHdoZW4gcmVwbGFjaW5nIHBvZHMgb24gbm9kZXMsXG4gKiBvciB3aGVuIHNjYWxpbmcgZG93bi5cbiAqXG4gKiBUaGUgZGVmYXVsdCBwb2xpY3kgaXMgYE9yZGVyZWRSZWFkeWAsIHdoZXJlIHBvZHMgYXJlIGNyZWF0ZWQgaW4gaW5jcmVhc2luZyBvcmRlclxuICogKHBvZC0wLCB0aGVuIHBvZC0xLCBldGMpIGFuZCB0aGUgY29udHJvbGxlciB3aWxsIHdhaXQgdW50aWwgZWFjaCBwb2QgaXMgcmVhZHkgYmVmb3JlXG4gKiBjb250aW51aW5nLiBXaGVuIHNjYWxpbmcgZG93biwgdGhlIHBvZHMgYXJlIHJlbW92ZWQgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICpcbiAqIFRoZSBhbHRlcm5hdGl2ZSBwb2xpY3kgaXMgYFBhcmFsbGVsYCB3aGljaCB3aWxsIGNyZWF0ZSBwb2RzIGluIHBhcmFsbGVsIHRvIG1hdGNoIHRoZVxuICogZGVzaXJlZCBzY2FsZSB3aXRob3V0IHdhaXRpbmcsIGFuZCBvbiBzY2FsZSBkb3duIHdpbGwgZGVsZXRlIGFsbCBwb2RzIGF0IG9uY2UuXG4gKi9cbmV4cG9ydCBlbnVtIFBvZE1hbmFnZW1lbnRQb2xpY3kge1xuICBPUkRFUkVEX1JFQURZID0gJ09yZGVyZWRSZWFkeScsXG4gIFBBUkFMTEVMID0gJ1BhcmFsbGVsJyxcbn1cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIGZvciBpbml0aWFsaXphdGlvbiBvZiBgU3RhdGVmdWxTZXRgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlZnVsU2V0UHJvcHMgZXh0ZW5kcyB3b3JrbG9hZC5Xb3JrbG9hZFByb3BzIHtcbiAgLyoqXG4gICAqIFNlcnZpY2UgdG8gYXNzb2NpYXRlIHdpdGggdGhlIHN0YXRlZnVsc2V0LlxuICAgKi9cbiAgcmVhZG9ubHkgc2VydmljZTogc2VydmljZS5TZXJ2aWNlO1xuXG4gIC8qKlxuICAgICogTnVtYmVyIG9mIGRlc2lyZWQgcG9kcy5cbiAgICAqXG4gICAgKiBAZGVmYXVsdCAxXG4gICAgKi9cbiAgcmVhZG9ubHkgcmVwbGljYXM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAgKiBQb2QgbWFuYWdlbWVudCBwb2xpY3kgdG8gdXNlIGZvciB0aGlzIHN0YXRlZnVsc2V0LlxuICAgICpcbiAgICAqIEBkZWZhdWx0IFBvZE1hbmFnZW1lbnRQb2xpY3kuT1JERVJFRF9SRUFEWVxuICAgICovXG4gIHJlYWRvbmx5IHBvZE1hbmFnZW1lbnRQb2xpY3k/OiBQb2RNYW5hZ2VtZW50UG9saWN5O1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhlIFN0YXRlZnVsU2V0VXBkYXRlU3RyYXRlZ3kgdGhhdCB3aWxsIGJlIGVtcGxveWVkIHRvIHVwZGF0ZSBQb2RzIGluIHRoZSBTdGF0ZWZ1bFNldCB3aGVuIGEgcmV2aXNpb24gaXMgbWFkZSB0byBUZW1wbGF0ZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBSb2xsaW5nVXBkYXRlIHdpdGggcGFydGl0aW9uIHNldCB0byAwXG4gICAqL1xuICByZWFkb25seSBzdHJhdGVneT86IFN0YXRlZnVsU2V0VXBkYXRlU3RyYXRlZ3k7XG5cbiAgLyoqXG4gICAqIE1pbmltdW0gZHVyYXRpb24gZm9yIHdoaWNoIGEgbmV3bHkgY3JlYXRlZCBwb2Qgc2hvdWxkIGJlIHJlYWR5IHdpdGhvdXQgYW55IG9mIGl0cyBjb250YWluZXIgY3Jhc2hpbmcsXG4gICAqIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGF2YWlsYWJsZS4gWmVybyBtZWFucyB0aGUgcG9kIHdpbGwgYmUgY29uc2lkZXJlZCBhdmFpbGFibGUgYXMgc29vbiBhcyBpdCBpcyByZWFkeS5cbiAgICpcbiAgICogVGhpcyBpcyBhbiBhbHBoYSBmaWVsZCBhbmQgcmVxdWlyZXMgZW5hYmxpbmcgU3RhdGVmdWxTZXRNaW5SZWFkeVNlY29uZHMgZmVhdHVyZSBnYXRlLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3dvcmtsb2Fkcy9jb250cm9sbGVycy9kZXBsb3ltZW50LyNtaW4tcmVhZHktc2Vjb25kc1xuICAgKiBAZGVmYXVsdCBEdXJhdGlvbi5zZWNvbmRzKDApXG4gICAqL1xuICByZWFkb25seSBtaW5SZWFkeT86IER1cmF0aW9uO1xuXG59XG5cbi8qKlxuICogU3RhdGVmdWxTZXQgaXMgdGhlIHdvcmtsb2FkIEFQSSBvYmplY3QgdXNlZCB0byBtYW5hZ2Ugc3RhdGVmdWwgYXBwbGljYXRpb25zLlxuICpcbiAqIE1hbmFnZXMgdGhlIGRlcGxveW1lbnQgYW5kIHNjYWxpbmcgb2YgYSBzZXQgb2YgUG9kcywgYW5kIHByb3ZpZGVzIGd1YXJhbnRlZXNcbiAqIGFib3V0IHRoZSBvcmRlcmluZyBhbmQgdW5pcXVlbmVzcyBvZiB0aGVzZSBQb2RzLlxuICpcbiAqIExpa2UgYSBEZXBsb3ltZW50LCBhIFN0YXRlZnVsU2V0IG1hbmFnZXMgUG9kcyB0aGF0IGFyZSBiYXNlZCBvbiBhbiBpZGVudGljYWxcbiAqIGNvbnRhaW5lciBzcGVjLiBVbmxpa2UgYSBEZXBsb3ltZW50LCBhIFN0YXRlZnVsU2V0IG1haW50YWlucyBhIHN0aWNreSBpZGVudGl0eVxuICogZm9yIGVhY2ggb2YgdGhlaXIgUG9kcy4gVGhlc2UgcG9kcyBhcmUgY3JlYXRlZCBmcm9tIHRoZSBzYW1lIHNwZWMsIGJ1dCBhcmUgbm90XG4gKiBpbnRlcmNoYW5nZWFibGU6IGVhY2ggaGFzIGEgcGVyc2lzdGVudCBpZGVudGlmaWVyIHRoYXQgaXQgbWFpbnRhaW5zIGFjcm9zcyBhbnlcbiAqIHJlc2NoZWR1bGluZy5cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byB1c2Ugc3RvcmFnZSB2b2x1bWVzIHRvIHByb3ZpZGUgcGVyc2lzdGVuY2UgZm9yIHlvdXIgd29ya2xvYWQsIHlvdVxuICogY2FuIHVzZSBhIFN0YXRlZnVsU2V0IGFzIHBhcnQgb2YgdGhlIHNvbHV0aW9uLiBBbHRob3VnaCBpbmRpdmlkdWFsIFBvZHMgaW4gYSBTdGF0ZWZ1bFNldFxuICogYXJlIHN1c2NlcHRpYmxlIHRvIGZhaWx1cmUsIHRoZSBwZXJzaXN0ZW50IFBvZCBpZGVudGlmaWVycyBtYWtlIGl0IGVhc2llciB0byBtYXRjaCBleGlzdGluZ1xuICogdm9sdW1lcyB0byB0aGUgbmV3IFBvZHMgdGhhdCByZXBsYWNlIGFueSB0aGF0IGhhdmUgZmFpbGVkLlxuICpcbiAqIFVzaW5nIFN0YXRlZnVsU2V0c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBTdGF0ZWZ1bFNldHMgYXJlIHZhbHVhYmxlIGZvciBhcHBsaWNhdGlvbnMgdGhhdCByZXF1aXJlIG9uZSBvciBtb3JlIG9mIHRoZSBmb2xsb3dpbmcuXG4gKlxuICogLSBTdGFibGUsIHVuaXF1ZSBuZXR3b3JrIGlkZW50aWZpZXJzLlxuICogLSBTdGFibGUsIHBlcnNpc3RlbnQgc3RvcmFnZS5cbiAqIC0gT3JkZXJlZCwgZ3JhY2VmdWwgZGVwbG95bWVudCBhbmQgc2NhbGluZy5cbiAqIC0gT3JkZXJlZCwgYXV0b21hdGVkIHJvbGxpbmcgdXBkYXRlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0YXRlZnVsU2V0IGV4dGVuZHMgd29ya2xvYWQuV29ya2xvYWQge1xuICAvKipcbiAgICAqIE51bWJlciBvZiBkZXNpcmVkIHBvZHMuXG4gICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHJlcGxpY2FzOiBudW1iZXI7XG5cbiAgLyoqXG4gICAgKiBNYW5hZ2VtZW50IHBvbGljeSB0byB1c2UgZm9yIHRoZSBzZXQuXG4gICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHBvZE1hbmFnZW1lbnRQb2xpY3k6IFBvZE1hbmFnZW1lbnRQb2xpY3k7XG5cbiAgLyoqXG4gICAqIFRoZSB1cGRhdGUgc3RhcnRlZ3kgb2YgdGhpcyBzdGF0ZWZ1bCBzZXQuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgc3RyYXRlZ3k6IFN0YXRlZnVsU2V0VXBkYXRlU3RyYXRlZ3k7XG5cbiAgLyoqXG4gICAqIE1pbmltdW0gZHVyYXRpb24gZm9yIHdoaWNoIGEgbmV3bHkgY3JlYXRlZCBwb2Qgc2hvdWxkIGJlIHJlYWR5IHdpdGhvdXRcbiAgICogYW55IG9mIGl0cyBjb250YWluZXIgY3Jhc2hpbmcsIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGF2YWlsYWJsZS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBtaW5SZWFkeTogRHVyYXRpb247XG5cbiAgLyoqXG4gICAgKiBAc2VlIGJhc2UuUmVzb3VyY2UuYXBpT2JqZWN0XG4gICAgKi9cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGFwaU9iamVjdDogQXBpT2JqZWN0O1xuXG4gIHB1YmxpYyByZWFkb25seSByZXNvdXJjZVR5cGUgPSAnc3RhdGVmdWxzZXRzJztcblxuICBwcml2YXRlIHJlYWRvbmx5IF9zZXJ2aWNlOiBzZXJ2aWNlLlNlcnZpY2U7XG5cbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IFN0YXRlZnVsU2V0UHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHByb3BzKTtcblxuICAgIHRoaXMuYXBpT2JqZWN0ID0gbmV3IGs4cy5LdWJlU3RhdGVmdWxTZXQodGhpcywgJ1Jlc291cmNlJywge1xuICAgICAgbWV0YWRhdGE6IHByb3BzLm1ldGFkYXRhLFxuICAgICAgc3BlYzogTGF6eS5hbnkoeyBwcm9kdWNlOiAoKSA9PiB0aGlzLl90b0t1YmUoKSB9KSxcbiAgICB9KTtcbiAgICB0aGlzLl9zZXJ2aWNlID0gcHJvcHMuc2VydmljZTtcblxuICAgIHRoaXMuYXBpT2JqZWN0LmFkZERlcGVuZGVuY3kodGhpcy5fc2VydmljZSk7XG5cbiAgICB0aGlzLnJlcGxpY2FzID0gcHJvcHMucmVwbGljYXMgPz8gMTtcbiAgICB0aGlzLnN0cmF0ZWd5ID0gcHJvcHMuc3RyYXRlZ3kgPz8gU3RhdGVmdWxTZXRVcGRhdGVTdHJhdGVneS5yb2xsaW5nVXBkYXRlKCksXG4gICAgdGhpcy5wb2RNYW5hZ2VtZW50UG9saWN5ID0gcHJvcHMucG9kTWFuYWdlbWVudFBvbGljeSA/PyBQb2RNYW5hZ2VtZW50UG9saWN5Lk9SREVSRURfUkVBRFk7XG4gICAgdGhpcy5taW5SZWFkeSA9IHByb3BzLm1pblJlYWR5ID8/IER1cmF0aW9uLnNlY29uZHMoMCk7XG5cbiAgICB0aGlzLl9zZXJ2aWNlLnNlbGVjdCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgcHVibGljIF90b0t1YmUoKTogazhzLlN0YXRlZnVsU2V0U3BlYyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlcnZpY2VOYW1lOiB0aGlzLl9zZXJ2aWNlLm5hbWUsXG4gICAgICByZXBsaWNhczogdGhpcy5yZXBsaWNhcyxcbiAgICAgIG1pblJlYWR5U2Vjb25kczogdGhpcy5taW5SZWFkeS50b1NlY29uZHMoKSxcbiAgICAgIHRlbXBsYXRlOiB7XG4gICAgICAgIG1ldGFkYXRhOiB0aGlzLnBvZE1ldGFkYXRhLnRvSnNvbigpLFxuICAgICAgICBzcGVjOiB0aGlzLl90b1BvZFNwZWMoKSxcbiAgICAgIH0sXG4gICAgICBzZWxlY3RvcjogdGhpcy5fdG9MYWJlbFNlbGVjdG9yKCksXG4gICAgICBwb2RNYW5hZ2VtZW50UG9saWN5OiB0aGlzLnBvZE1hbmFnZW1lbnRQb2xpY3ksXG4gICAgICB1cGRhdGVTdHJhdGVneTogdGhpcy5zdHJhdGVneS5fdG9LdWJlKCksXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGBTdGF0ZWZ1bFNldFVwZGF0ZVN0cmF0ZWd5LnJvbGxpbmdVcGRhdGVgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlZnVsU2V0VXBkYXRlU3RyYXRlZ3lSb2xsaW5nVXBkYXRlT3B0aW9ucyB7XG5cbiAgLyoqXG4gICAqIElmIHNwZWNpZmllZCwgYWxsIFBvZHMgd2l0aCBhbiBvcmRpbmFsIHRoYXQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwYXJ0aXRpb24gd2lsbFxuICAgKiBiZSB1cGRhdGVkIHdoZW4gdGhlIFN0YXRlZnVsU2V0J3MgLnNwZWMudGVtcGxhdGUgaXMgdXBkYXRlZC4gQWxsIFBvZHMgd2l0aCBhbiBvcmRpbmFsIHRoYXRcbiAgICogaXMgbGVzcyB0aGFuIHRoZSBwYXJ0aXRpb24gd2lsbCBub3QgYmUgdXBkYXRlZCwgYW5kLCBldmVuIGlmIHRoZXkgYXJlIGRlbGV0ZWQsIHRoZXkgd2lsbCBiZVxuICAgKiByZWNyZWF0ZWQgYXQgdGhlIHByZXZpb3VzIHZlcnNpb24uXG4gICAqXG4gICAqIElmIHRoZSBwYXJ0aXRpb24gaXMgZ3JlYXRlciB0aGFuIHJlcGxpY2FzLCB1cGRhdGVzIHRvIHRoZSBwb2QgdGVtcGxhdGUgd2lsbCBub3QgYmUgcHJvcGFnYXRlZCB0byBQb2RzLlxuICAgKiBJbiBtb3N0IGNhc2VzIHlvdSB3aWxsIG5vdCBuZWVkIHRvIHVzZSBhIHBhcnRpdGlvbiwgYnV0IHRoZXkgYXJlIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBzdGFnZSBhblxuICAgKiB1cGRhdGUsIHJvbGwgb3V0IGEgY2FuYXJ5LCBvciBwZXJmb3JtIGEgcGhhc2VkIHJvbGwgb3V0LlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3dvcmtsb2Fkcy9jb250cm9sbGVycy9zdGF0ZWZ1bHNldC8jcGFydGl0aW9uc1xuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICByZWFkb25seSBwYXJ0aXRpb24/OiBudW1iZXI7XG5cbn1cblxuLyoqXG4gKiBTdGF0ZWZ1bFNldCB1cGRhdGUgc3RyYXRlZ2llcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0YXRlZnVsU2V0VXBkYXRlU3RyYXRlZ3kge1xuXG4gIC8qKlxuICAgKiBUaGUgY29udHJvbGxlciB3aWxsIG5vdCBhdXRvbWF0aWNhbGx5IHVwZGF0ZSB0aGUgUG9kcyBpbiBhIFN0YXRlZnVsU2V0LlxuICAgKiBVc2VycyBtdXN0IG1hbnVhbGx5IGRlbGV0ZSBQb2RzIHRvIGNhdXNlIHRoZSBjb250cm9sbGVyIHRvIGNyZWF0ZSBuZXcgUG9kc1xuICAgKiB0aGF0IHJlZmxlY3QgbW9kaWZpY2F0aW9ucy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgb25EZWxldGUoKTogU3RhdGVmdWxTZXRVcGRhdGVTdHJhdGVneSB7XG4gICAgcmV0dXJuIG5ldyBTdGF0ZWZ1bFNldFVwZGF0ZVN0cmF0ZWd5KHtcbiAgICAgIHR5cGU6ICdPbkRlbGV0ZScsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNvbnRyb2xsZXIgd2lsbCBkZWxldGUgYW5kIHJlY3JlYXRlIGVhY2ggUG9kIGluIHRoZSBTdGF0ZWZ1bFNldC5cbiAgICogSXQgd2lsbCBwcm9jZWVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIFBvZCB0ZXJtaW5hdGlvbiAoZnJvbSB0aGUgbGFyZ2VzdCBvcmRpbmFsIHRvIHRoZSBzbWFsbGVzdCksXG4gICAqIHVwZGF0aW5nIGVhY2ggUG9kIG9uZSBhdCBhIHRpbWUuIFRoZSBLdWJlcm5ldGVzIGNvbnRyb2wgcGxhbmUgd2FpdHMgdW50aWwgYW4gdXBkYXRlZFxuICAgKiBQb2QgaXMgUnVubmluZyBhbmQgUmVhZHkgcHJpb3IgdG8gdXBkYXRpbmcgaXRzIHByZWRlY2Vzc29yLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByb2xsaW5nVXBkYXRlKG9wdGlvbnM6IFN0YXRlZnVsU2V0VXBkYXRlU3RyYXRlZ3lSb2xsaW5nVXBkYXRlT3B0aW9ucyA9IHt9KTogU3RhdGVmdWxTZXRVcGRhdGVTdHJhdGVneSB7XG5cbiAgICByZXR1cm4gbmV3IFN0YXRlZnVsU2V0VXBkYXRlU3RyYXRlZ3koe1xuICAgICAgdHlwZTogJ1JvbGxpbmdVcGRhdGUnLFxuICAgICAgcm9sbGluZ1VwZGF0ZTogeyBwYXJ0aXRpb246IG9wdGlvbnMucGFydGl0aW9uID8/IDAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBzdHJhdGVneTogazhzLlN0YXRlZnVsU2V0VXBkYXRlU3RyYXRlZ3kpIHt9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHVibGljIF90b0t1YmUoKTogazhzLlN0YXRlZnVsU2V0VXBkYXRlU3RyYXRlZ3kge1xuICAgIHJldHVybiB0aGlzLnN0cmF0ZWd5O1xuICB9XG5cbn0iXX0=

/***/ }),

/***/ 6594:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.address = exports.filterUndefined = exports.undefinedIfEmpty = void 0;
function undefinedIfEmpty(obj) {
    if (typeof (obj) === 'string' && obj === '') {
        return undefined;
    }
    if (Array.isArray(obj) && obj.length === 0) {
        return undefined;
    }
    if (typeof (obj) === 'object' && (Object.keys(obj).length === 0 || Object.values(obj).filter(x => x).length === 0)) {
        return undefined;
    }
    return obj;
}
exports.undefinedIfEmpty = undefinedIfEmpty;
function filterUndefined(obj) {
    const ret = {};
    for (const [k, v] of Object.entries(obj)) {
        if (v !== undefined) {
            ret[k] = v;
        }
    }
    return ret;
}
exports.filterUndefined = filterUndefined;
function address(...constructs) {
    const addresses = constructs
        .map(c => c.node.addr)
        .sort((a, b) => a.localeCompare(b));
    return addresses.join('');
}
exports.address = address;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBRUEsU0FBZ0IsZ0JBQWdCLENBQUksR0FBTTtJQUN4QyxJQUFJLE9BQU0sQ0FBQyxHQUFHLENBQUMsS0FBSyxRQUFRLElBQUksR0FBRyxLQUFLLEVBQUUsRUFBRTtRQUFFLE9BQU8sU0FBUyxDQUFDO0tBQUU7SUFDakUsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQUUsT0FBTyxTQUFTLENBQUM7S0FBRTtJQUNqRSxJQUFJLE9BQU0sQ0FBQyxHQUFHLENBQUMsS0FBSyxRQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLEVBQUU7UUFBRSxPQUFPLFNBQVMsQ0FBQztLQUFFO0lBQ3hJLE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQUxELDRDQUtDO0FBRUQsU0FBZ0IsZUFBZSxDQUFDLEdBQVE7SUFDdEMsTUFBTSxHQUFHLEdBQVEsRUFBRSxDQUFDO0lBQ3BCLEtBQUssTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQ3hDLElBQUksQ0FBQyxLQUFLLFNBQVMsRUFBRTtZQUNuQixHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ1o7S0FDRjtJQUNELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQVJELDBDQVFDO0FBRUQsU0FBZ0IsT0FBTyxDQUFDLEdBQUcsVUFBd0I7SUFDakQsTUFBTSxTQUFTLEdBQUcsVUFBVTtTQUN6QixHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztTQUNyQixJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdEMsT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQzVCLENBQUM7QUFMRCwwQkFLQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElDb25zdHJ1Y3QgfSBmcm9tICdjb25zdHJ1Y3RzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHVuZGVmaW5lZElmRW1wdHk8VD4ob2JqOiBUKTogVCB8IHVuZGVmaW5lZCB7XG4gIGlmICh0eXBlb2Yob2JqKSA9PT0gJ3N0cmluZycgJiYgb2JqID09PSAnJykgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikgJiYgb2JqLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGlmICh0eXBlb2Yob2JqKSA9PT0gJ29iamVjdCcgJiYgKE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwIHx8IE9iamVjdC52YWx1ZXMob2JqKS5maWx0ZXIoeCA9PiB4KS5sZW5ndGggPT09IDApKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgcmV0dXJuIG9iajtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlclVuZGVmaW5lZChvYmo6IGFueSk6IGFueSB7XG4gIGNvbnN0IHJldDogYW55ID0ge307XG4gIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXRba10gPSB2O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkcmVzcyguLi5jb25zdHJ1Y3RzOiBJQ29uc3RydWN0W10pIHtcbiAgY29uc3QgYWRkcmVzc2VzID0gY29uc3RydWN0c1xuICAgIC5tYXAoYyA9PiBjLm5vZGUuYWRkcilcbiAgICAuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcbiAgcmV0dXJuIGFkZHJlc3Nlcy5qb2luKCcnKTtcbn1cbiJdfQ==

/***/ }),

/***/ 1680:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AzureDiskPersistentVolumeCachingMode = exports.AzureDiskPersistentVolumeKind = exports.EmptyDirMedium = exports.Volume = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const constructs_1 = __nccwpck_require__(1963);
const k8s = __nccwpck_require__(4879);
/**
 * Volume represents a named volume in a pod that may be accessed by any
 * container in the pod.
 *
 * Docker also has a concept of volumes, though it is somewhat looser and less
 * managed. In Docker, a volume is simply a directory on disk or in another
 * Container. Lifetimes are not managed and until very recently there were only
 * local-disk-backed volumes. Docker now provides volume drivers, but the
 * functionality is very limited for now (e.g. as of Docker 1.7 only one volume
 * driver is allowed per Container and there is no way to pass parameters to
 * volumes).
 *
 * A Kubernetes volume, on the other hand, has an explicit lifetime - the same
 * as the Pod that encloses it. Consequently, a volume outlives any Containers
 * that run within the Pod, and data is preserved across Container restarts. Of
 * course, when a Pod ceases to exist, the volume will cease to exist, too.
 * Perhaps more importantly than this, Kubernetes supports many types of
 * volumes, and a Pod can use any number of them simultaneously.
 *
 * At its core, a volume is just a directory, possibly with some data in it,
 * which is accessible to the Containers in a Pod. How that directory comes to
 * be, the medium that backs it, and the contents of it are determined by the
 * particular volume type used.
 *
 * To use a volume, a Pod specifies what volumes to provide for the Pod (the
 * .spec.volumes field) and where to mount those into Containers (the
 * .spec.containers[*].volumeMounts field).
 *
 * A process in a container sees a filesystem view composed from their Docker
 * image and volumes. The Docker image is at the root of the filesystem
 * hierarchy, and any volumes are mounted at the specified paths within the
 * image. Volumes can not mount onto other volumes
 */
class Volume extends constructs_1.Construct {
    constructor(scope, id, name, config) {
        super(scope, id);
        this.name = name;
        this.config = config;
    }
    /**
     * Mounts an Amazon Web Services (AWS) EBS volume into your pod.
     * Unlike emptyDir, which is erased when a pod is removed, the contents of an EBS volume are
     * persisted and the volume is unmounted. This means that an EBS volume can be pre-populated with data,
     * and that data can be shared between pods.
     *
     * There are some restrictions when using an awsElasticBlockStore volume:
     *
     * - the nodes on which pods are running must be AWS EC2 instances.
     * - those instances need to be in the same region and availability zone as the EBS volume.
     * - EBS only supports a single EC2 instance mounting a volume.
     */
    static fromAwsElasticBlockStore(scope, id, volumeId, options = {}) {
        var _b, _c, _d;
        return new Volume(scope, id, (_b = options.name) !== null && _b !== void 0 ? _b : `ebs-${volumeId}`, {
            awsElasticBlockStore: {
                volumeId,
                fsType: (_c = options.fsType) !== null && _c !== void 0 ? _c : 'ext4',
                partition: options.partition,
                readOnly: (_d = options.readOnly) !== null && _d !== void 0 ? _d : false,
            },
        });
    }
    /**
     * Mounts a Microsoft Azure Data Disk into a pod.
     */
    static fromAzureDisk(scope, id, diskName, diskUri, options = {}) {
        var _b, _c, _d, _e, _f;
        return new Volume(scope, id, (_b = options.name) !== null && _b !== void 0 ? _b : `azuredisk-${diskName}`, {
            azureDisk: {
                diskName,
                diskUri,
                cachingMode: (_c = options.cachingMode) !== null && _c !== void 0 ? _c : AzureDiskPersistentVolumeCachingMode.NONE,
                fsType: (_d = options.fsType) !== null && _d !== void 0 ? _d : 'ext4',
                kind: (_e = options.kind) !== null && _e !== void 0 ? _e : AzureDiskPersistentVolumeKind.SHARED,
                readOnly: (_f = options.readOnly) !== null && _f !== void 0 ? _f : false,
            },
        });
    }
    /**
     * Mounts a Google Compute Engine (GCE) persistent disk (PD) into your Pod.
     * Unlike emptyDir, which is erased when a pod is removed, the contents of a PD are
     * preserved and the volume is merely unmounted. This means that a PD can be pre-populated
     * with data, and that data can be shared between pods.
     *
     * There are some restrictions when using a gcePersistentDisk:
     *
     * - the nodes on which Pods are running must be GCE VMs
     * - those VMs need to be in the same GCE project and zone as the persistent disk
     */
    static fromGcePersistentDisk(scope, id, pdName, options = {}) {
        var _b, _c, _d;
        return new Volume(scope, id, (_b = options.name) !== null && _b !== void 0 ? _b : `gcedisk-${pdName}`, {
            gcePersistentDisk: {
                pdName,
                fsType: (_c = options.fsType) !== null && _c !== void 0 ? _c : 'ext4',
                partition: options.partition,
                readOnly: (_d = options.readOnly) !== null && _d !== void 0 ? _d : false,
            },
        });
    }
    /**
     * Populate the volume from a ConfigMap.
     *
     * The configMap resource provides a way to inject configuration data into
     * Pods. The data stored in a ConfigMap object can be referenced in a volume
     * of type configMap and then consumed by containerized applications running
     * in a Pod.
     *
     * When referencing a configMap object, you can simply provide its name in the
     * volume to reference it. You can also customize the path to use for a
     * specific entry in the ConfigMap.
     *
     * @param configMap The config map to use to populate the volume.
     * @param options Options
     */
    static fromConfigMap(scope, id, configMap, options = {}) {
        var _b;
        return new Volume(scope, id, (_b = options.name) !== null && _b !== void 0 ? _b : `configmap-${configMap.name}`, {
            configMap: {
                name: configMap.name,
                defaultMode: options.defaultMode,
                optional: options.optional,
                items: Volume.renderItems(options.items),
            },
        });
    }
    /**
     * An emptyDir volume is first created when a Pod is assigned to a Node, and
     * exists as long as that Pod is running on that node. As the name says, it is
     * initially empty. Containers in the Pod can all read and write the same
     * files in the emptyDir volume, though that volume can be mounted at the same
     * or different paths in each Container. When a Pod is removed from a node for
     * any reason, the data in the emptyDir is deleted forever.
     *
     * @see http://kubernetes.io/docs/user-guide/volumes#emptydir
     *
     * @param options - Additional options.
     */
    static fromEmptyDir(scope, id, name, options = {}) {
        return new Volume(scope, id, name, {
            emptyDir: {
                medium: options.medium,
                sizeLimit: options.sizeLimit
                    ? k8s.Quantity.fromString(`${options.sizeLimit.toMebibytes()}Mi`)
                    : undefined,
            },
        });
    }
    /**
     * Populate the volume from a Secret.
     *
     * A secret volume is used to pass sensitive information, such as passwords, to Pods.
     * You can store secrets in the Kubernetes API and mount them as files for use by pods
     * without coupling to Kubernetes directly.
     *
     * secret volumes are backed by tmpfs (a RAM-backed filesystem)
     * so they are never written to non-volatile storage.
     *
     * @see https://kubernetes.io/docs/concepts/storage/volumes/#secret
     *
     * @param secr The secret to use to populate the volume.
     * @param options Options
     */
    static fromSecret(scope, id, secr, options = {}) {
        var _b;
        return new Volume(scope, id, (_b = options.name) !== null && _b !== void 0 ? _b : `secret-${secr.name}`, {
            secret: {
                secretName: secr.name,
                defaultMode: options.defaultMode,
                optional: options.optional,
                items: Volume.renderItems(options.items),
            },
        });
    }
    /**
     * Used to mount a PersistentVolume into a Pod.
     * PersistentVolumeClaims are a way for users to "claim" durable storage (such as a GCE PersistentDisk or an iSCSI volume)
     * without knowing the details of the particular cloud environment.
     *
     * @see https://kubernetes.io/docs/concepts/storage/persistent-volumes/
     */
    static fromPersistentVolumeClaim(scope, id, claim, options = {}) {
        var _b, _c;
        return new Volume(scope, id, (_b = options.name) !== null && _b !== void 0 ? _b : `pvc-${claim.name}`, {
            persistentVolumeClaim: {
                claimName: claim.name,
                readOnly: (_c = options.readOnly) !== null && _c !== void 0 ? _c : false,
            },
        });
    }
    asVolume() {
        return this;
    }
    /**
     * @internal
     */
    _toKube() {
        return {
            name: this.name,
            ...this.config,
        };
    }
}
exports.Volume = Volume;
_a = JSII_RTTI_SYMBOL_1;
Volume[_a] = { fqn: "cdk8s-plus-22.Volume", version: "2.0.0-rc.2" };
/**
  * @internal
 */
Volume.renderItems = (items) => {
    if (!items) {
        return undefined;
    }
    const result = new Array();
    for (const key of Object.keys(items).sort()) {
        result.push({
            key,
            path: items[key].path,
            mode: items[key].mode,
        });
    }
    return result;
};
/**
 * The medium on which to store the volume.
 */
var EmptyDirMedium;
(function (EmptyDirMedium) {
    /**
     * The default volume of the backing node.
     */
    EmptyDirMedium["DEFAULT"] = "";
    /**
     * Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very
     * fast, be aware that unlike disks, tmpfs is cleared on node reboot and any
     * files you write will count against your Container's memory limit.
     */
    EmptyDirMedium["MEMORY"] = "Memory";
})(EmptyDirMedium = exports.EmptyDirMedium || (exports.EmptyDirMedium = {}));
/**
 * Azure Disk kinds.
 */
var AzureDiskPersistentVolumeKind;
(function (AzureDiskPersistentVolumeKind) {
    /**
     * Multiple blob disks per storage account.
     */
    AzureDiskPersistentVolumeKind["SHARED"] = "Shared";
    /**
     * Single blob disk per storage account.
     */
    AzureDiskPersistentVolumeKind["DEDICATED"] = "Dedicated";
    /**
     * Azure managed data disk.
     */
    AzureDiskPersistentVolumeKind["MANAGED"] = "Managed";
})(AzureDiskPersistentVolumeKind = exports.AzureDiskPersistentVolumeKind || (exports.AzureDiskPersistentVolumeKind = {}));
/**
 * Azure disk caching modes.
 */
var AzureDiskPersistentVolumeCachingMode;
(function (AzureDiskPersistentVolumeCachingMode) {
    /**
     * None.
     */
    AzureDiskPersistentVolumeCachingMode["NONE"] = "None";
    /**
     * ReadOnly.
     */
    AzureDiskPersistentVolumeCachingMode["READ_ONLY"] = "ReadOnly";
    /**
     * ReadWrite.
     */
    AzureDiskPersistentVolumeCachingMode["READ_WRITE"] = "ReadWrite";
})(AzureDiskPersistentVolumeCachingMode = exports.AzureDiskPersistentVolumeCachingMode || (exports.AzureDiskPersistentVolumeCachingMode = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidm9sdW1lLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3ZvbHVtZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUNBLDJDQUFtRDtBQUVuRCxxQ0FBcUM7QUFlckM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBZ0NHO0FBQ0gsTUFBYSxNQUFPLFNBQVEsc0JBQVM7SUE2S25DLFlBQW9CLEtBQWdCLEVBQUUsRUFBVSxFQUM5QixJQUFZLEVBQ1gsTUFBZ0M7UUFDakQsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUZELFNBQUksR0FBSixJQUFJLENBQVE7UUFDWCxXQUFNLEdBQU4sTUFBTSxDQUEwQjtJQUVuRCxDQUFDO0lBL0tEOzs7Ozs7Ozs7OztPQVdHO0lBQ0ksTUFBTSxDQUFDLHdCQUF3QixDQUFDLEtBQWdCLEVBQUUsRUFBVSxFQUFFLFFBQWdCLEVBQUUsVUFBNkMsRUFBRTs7UUFDcEksT0FBTyxJQUFJLE1BQU0sQ0FBQyxLQUFLLEVBQUUsRUFBRSxRQUFFLE9BQU8sQ0FBQyxJQUFJLG1DQUFJLE9BQU8sUUFBUSxFQUFFLEVBQUU7WUFDOUQsb0JBQW9CLEVBQUU7Z0JBQ3BCLFFBQVE7Z0JBQ1IsTUFBTSxRQUFFLE9BQU8sQ0FBQyxNQUFNLG1DQUFJLE1BQU07Z0JBQ2hDLFNBQVMsRUFBRSxPQUFPLENBQUMsU0FBUztnQkFDNUIsUUFBUSxRQUFFLE9BQU8sQ0FBQyxRQUFRLG1DQUFJLEtBQUs7YUFDcEM7U0FDRixDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxNQUFNLENBQUMsYUFBYSxDQUFDLEtBQWdCLEVBQUUsRUFBVSxFQUFFLFFBQWdCLEVBQUUsT0FBZSxFQUFFLFVBQWtDLEVBQUU7O1FBQy9ILE9BQU8sSUFBSSxNQUFNLENBQUMsS0FBSyxFQUFFLEVBQUUsUUFBRSxPQUFPLENBQUMsSUFBSSxtQ0FBSSxhQUFhLFFBQVEsRUFBRSxFQUFFO1lBQ3BFLFNBQVMs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OztPQUlHO0lBQ0gsbUNBQWlCLENBQUE7QUFDbkIsQ0FBQyxFQVpXLGNBQWMsR0FBZCxzQkFBYyxLQUFkLHNCQUFjLFFBWXpCO0FBa0VEOztHQUVHO0FBQ0gsSUFBWSw2QkFnQlg7QUFoQkQsV0FBWSw2QkFBNkI7SUFFdkM7O09BRUc7SUFDSCxrREFBaUIsQ0FBQTtJQUVqQjs7T0FFRztJQUNILHdEQUF1QixDQUFBO0lBRXZCOztPQUVHO0lBQ0gsb0RBQW1CLENBQUE7QUFDckIsQ0FBQyxFQWhCVyw2QkFBNkIsR0FBN0IscUNBQTZCLEtBQTdCLHFDQUE2QixRQWdCeEM7QUFFRDs7R0FFRztBQUNILElBQVksb0NBZ0JYO0FBaEJELFdBQVksb0NBQW9DO0lBRTlDOztPQUVHO0lBQ0gscURBQWEsQ0FBQTtJQUViOztPQUVHO0lBQ0gsOERBQXNCLENBQUE7SUFFdEI7O09BRUc7SUFDSCxnRUFBd0IsQ0FBQTtBQUMxQixDQUFDLEVBaEJXLG9DQUFvQyxHQUFwQyw0Q0FBb0MsS0FBcEMsNENBQW9DLFFBZ0IvQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNpemUgfSBmcm9tICdjZGs4cyc7XG5pbXBvcnQgeyBJQ29uc3RydWN0LCBDb25zdHJ1Y3QgfSBmcm9tICdjb25zdHJ1Y3RzJztcbmltcG9ydCAqIGFzIGNvbmZpZ21hcCBmcm9tICcuL2NvbmZpZy1tYXAnO1xuaW1wb3J0ICogYXMgazhzIGZyb20gJy4vaW1wb3J0cy9rOHMnO1xuaW1wb3J0ICogYXMgcHZjIGZyb20gJy4vcHZjJztcbmltcG9ydCAqIGFzIHNlY3JldCBmcm9tICcuL3NlY3JldCc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHBpZWNlIG9mIHN0b3JhZ2UgaW4gdGhlIGNsdXN0ZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSVN0b3JhZ2UgZXh0ZW5kcyBJQ29uc3RydWN0IHtcblxuICAvKipcbiAgICogQ29udmVydCB0aGUgcGllY2Ugb2Ygc3RvcmFnZSBpbnRvIGEgY29uY3JldGUgdm9sdW1lLlxuICAgKi9cbiAgYXNWb2x1bWUoKTogVm9sdW1lO1xufVxuXG4vKipcbiAqIFZvbHVtZSByZXByZXNlbnRzIGEgbmFtZWQgdm9sdW1lIGluIGEgcG9kIHRoYXQgbWF5IGJlIGFjY2Vzc2VkIGJ5IGFueVxuICogY29udGFpbmVyIGluIHRoZSBwb2QuXG4gKlxuICogRG9ja2VyIGFsc28gaGFzIGEgY29uY2VwdCBvZiB2b2x1bWVzLCB0aG91Z2ggaXQgaXMgc29tZXdoYXQgbG9vc2VyIGFuZCBsZXNzXG4gKiBtYW5hZ2VkLiBJbiBEb2NrZXIsIGEgdm9sdW1lIGlzIHNpbXBseSBhIGRpcmVjdG9yeSBvbiBkaXNrIG9yIGluIGFub3RoZXJcbiAqIENvbnRhaW5lci4gTGlmZXRpbWVzIGFyZSBub3QgbWFuYWdlZCBhbmQgdW50aWwgdmVyeSByZWNlbnRseSB0aGVyZSB3ZXJlIG9ubHlcbiAqIGxvY2FsLWRpc2stYmFja2VkIHZvbHVtZXMuIERvY2tlciBub3cgcHJvdmlkZXMgdm9sdW1lIGRyaXZlcnMsIGJ1dCB0aGVcbiAqIGZ1bmN0aW9uYWxpdHkgaXMgdmVyeSBsaW1pdGVkIGZvciBub3cgKGUuZy4gYXMgb2YgRG9ja2VyIDEuNyBvbmx5IG9uZSB2b2x1bWVcbiAqIGRyaXZlciBpcyBhbGxvd2VkIHBlciBDb250YWluZXIgYW5kIHRoZXJlIGlzIG5vIHdheSB0byBwYXNzIHBhcmFtZXRlcnMgdG9cbiAqIHZvbHVtZXMpLlxuICpcbiAqIEEgS3ViZXJuZXRlcyB2b2x1bWUsIG9uIHRoZSBvdGhlciBoYW5kLCBoYXMgYW4gZXhwbGljaXQgbGlmZXRpbWUgLSB0aGUgc2FtZVxuICogYXMgdGhlIFBvZCB0aGF0IGVuY2xvc2VzIGl0LiBDb25zZXF1ZW50bHksIGEgdm9sdW1lIG91dGxpdmVzIGFueSBDb250YWluZXJzXG4gKiB0aGF0IHJ1biB3aXRoaW4gdGhlIFBvZCwgYW5kIGRhdGEgaXMgcHJlc2VydmVkIGFjcm9zcyBDb250YWluZXIgcmVzdGFydHMuIE9mXG4gKiBjb3Vyc2UsIHdoZW4gYSBQb2QgY2Vhc2VzIHRvIGV4aXN0LCB0aGUgdm9sdW1lIHdpbGwgY2Vhc2UgdG8gZXhpc3QsIHRvby5cbiAqIFBlcmhhcHMgbW9yZSBpbXBvcnRhbnRseSB0aGFuIHRoaXMsIEt1YmVybmV0ZXMgc3VwcG9ydHMgbWFueSB0eXBlcyBvZlxuICogdm9sdW1lcywgYW5kIGEgUG9kIGNhbiB1c2UgYW55IG51bWJlciBvZiB0aGVtIHNpbXVsdGFuZW91c2x5LlxuICpcbiAqIEF0IGl0cyBjb3JlLCBhIHZvbHVtZSBpcyBqdXN0IGEgZGlyZWN0b3J5LCBwb3NzaWJseSB3aXRoIHNvbWUgZGF0YSBpbiBpdCxcbiAqIHdoaWNoIGlzIGFjY2Vzc2libGUgdG8gdGhlIENvbnRhaW5lcnMgaW4gYSBQb2QuIEhvdyB0aGF0IGRpcmVjdG9yeSBjb21lcyB0b1xuICogYmUsIHRoZSBtZWRpdW0gdGhhdCBiYWNrcyBpdCwgYW5kIHRoZSBjb250ZW50cyBvZiBpdCBhcmUgZGV0ZXJtaW5lZCBieSB0aGVcbiAqIHBhcnRpY3VsYXIgdm9sdW1lIHR5cGUgdXNlZC5cbiAqXG4gKiBUbyB1c2UgYSB2b2x1bWUsIGEgUG9kIHNwZWNpZmllcyB3aGF0IHZvbHVtZXMgdG8gcHJvdmlkZSBmb3IgdGhlIFBvZCAodGhlXG4gKiAuc3BlYy52b2x1bWVzIGZpZWxkKSBhbmQgd2hlcmUgdG8gbW91bnQgdGhvc2UgaW50byBDb250YWluZXJzICh0aGVcbiAqIC5zcGVjLmNvbnRhaW5lcnNbKl0udm9sdW1lTW91bnRzIGZpZWxkKS5cbiAqXG4gKiBBIHByb2Nlc3MgaW4gYSBjb250YWluZXIgc2VlcyBhIGZpbGVzeXN0ZW0gdmlldyBjb21wb3NlZCBmcm9tIHRoZWlyIERvY2tlclxuICogaW1hZ2UgYW5kIHZvbHVtZXMuIFRoZSBEb2NrZXIgaW1hZ2UgaXMgYXQgdGhlIHJvb3Qgb2YgdGhlIGZpbGVzeXN0ZW1cbiAqIGhpZXJhcmNoeSwgYW5kIGFueSB2b2x1bWVzIGFyZSBtb3VudGVkIGF0IHRoZSBzcGVjaWZpZWQgcGF0aHMgd2l0aGluIHRoZVxuICogaW1hZ2UuIFZvbHVtZXMgY2FuIG5vdCBtb3VudCBvbnRvIG90aGVyIHZvbHVtZXNcbiAqL1xuZXhwb3J0IGNsYXNzIFZvbHVtZSBleHRlbmRzIENvbnN0cnVjdCBpbXBsZW1lbnRzIElTdG9yYWdlIHtcblxuICAvKipcbiAgICogTW91bnRzIGFuIEFtYXpvbiBXZWIgU2VydmljZXMgKEFXUykgRUJTIHZvbHVtZSBpbnRvIHlvdXIgcG9kLlxuICAgKiBVbmxpa2UgZW1wdHlEaXIsIHdoaWNoIGlzIGVyYXNlZCB3aGVuIGEgcG9kIGlzIHJlbW92ZWQsIHRoZSBjb250ZW50cyBvZiBhbiBFQlMgdm9sdW1lIGFyZVxuICAgKiBwZXJzaXN0ZWQgYW5kIHRoZSB2b2x1bWUgaXMgdW5tb3VudGVkLiBUaGlzIG1lYW5zIHRoYXQgYW4gRUJTIHZvbHVtZSBjYW4gYmUgcHJlLXBvcHVsYXRlZCB3aXRoIGRhdGEsXG4gICAqIGFuZCB0aGF0IGRhdGEgY2FuIGJlIHNoYXJlZCBiZXR3ZWVuIHBvZHMuXG4gICAqXG4gICAqIFRoZXJlIGFyZSBzb21lIHJlc3RyaWN0aW9ucyB3aGVuIHVzaW5nIGFuIGF3c0VsYXN0aWNCbG9ja1N0b3JlIHZvbHVtZTpcbiAgICpcbiAgICogLSB0aGUgbm9kZXMgb24gd2hpY2ggcG9kcyBhcmUgcnVubmluZyBtdXN0IGJlIEFXUyBFQzIgaW5zdGFuY2VzLlxuICAgKiAtIHRob3NlIGluc3RhbmNlcyBuZWVkIHRvIGJlIGluIHRoZSBzYW1lIHJlZ2lvbiBhbmQgYXZhaWxhYmlsaXR5IHpvbmUgYXMgdGhlIEVCUyB2b2x1bWUuXG4gICAqIC0gRUJTIG9ubHkgc3VwcG9ydHMgYSBzaW5nbGUgRUMyIGluc3RhbmNlIG1vdW50aW5nIGEgdm9sdW1lLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tQXdzRWxhc3RpY0Jsb2NrU3RvcmUoc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgdm9sdW1lSWQ6IHN0cmluZywgb3B0aW9uczogQXdzRWxhc3RpY0Jsb2NrU3RvcmVWb2x1bWVPcHRpb25zID0ge30pOiBWb2x1bWUge1xuICAgIHJldHVybiBuZXcgVm9sdW1lKHNjb3BlLCBpZCwgb3B0aW9ucy5uYW1lID8/IGBlYnMtJHt2b2x1bWVJZH1gLCB7XG4gICAgICBhd3NFbGFzdGljQmxvY2tTdG9yZToge1xuICAgICAgICB2b2x1bWVJZCxcbiAgICAgICAgZnNUeXBlOiBvcHRpb25zLmZzVHlwZSA/PyAnZXh0NCcsXG4gICAgICAgIHBhcnRpdGlvbjogb3B0aW9ucy5wYXJ0aXRpb24sXG4gICAgICAgIHJlYWRPbmx5OiBvcHRpb25zLnJlYWRPbmx5ID8/IGZhbHNlLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3VudHMgYSBNaWNyb3NvZnQgQXp1cmUgRGF0YSBEaXNrIGludG8gYSBwb2QuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21BenVyZURpc2soc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgZGlza05hbWU6IHN0cmluZywgZGlza1VyaTogc3RyaW5nLCBvcHRpb25zOiBBenVyZURpc2tWb2x1bWVPcHRpb25zID0ge30pOiBWb2x1bWUge1xuICAgIHJldHVybiBuZXcgVm9sdW1lKHNjb3BlLCBpZCwgb3B0aW9ucy5uYW1lID8/IGBhenVyZWRpc2stJHtkaXNrTmFtZX1gLCB7XG4gICAgICBhenVyZURpc2s6IHtcbiAgICAgICAgZGlza05hbWUsXG4gICAgICAgIGRpc2tVcmksXG4gICAgICAgIGNhY2hpbmdNb2RlOiBvcHRpb25zLmNhY2hpbmdNb2RlID8/IEF6dXJlRGlza1BlcnNpc3RlbnRWb2x1bWVDYWNoaW5nTW9kZS5OT05FLFxuICAgICAgICBmc1R5cGU6IG9wdGlvbnMuZnNUeXBlID8/ICdleHQ0JyxcbiAgICAgICAga2luZDogb3B0aW9ucy5raW5kID8/IEF6dXJlRGlza1BlcnNpc3RlbnRWb2x1bWVLaW5kLlNIQVJFRCxcbiAgICAgICAgcmVhZE9ubHk6IG9wdGlvbnMucmVhZE9ubHkgPz8gZmFsc2UsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdW50cyBhIEdvb2dsZSBDb21wdXRlIEVuZ2luZSAoR0NFKSBwZXJzaXN0ZW50IGRpc2sgKFBEKSBpbnRvIHlvdXIgUG9kLlxuICAgKiBVbmxpa2UgZW1wdHlEaXIsIHdoaWNoIGlzIGVyYXNlZCB3aGVuIGEgcG9kIGlzIHJlbW92ZWQsIHRoZSBjb250ZW50cyBvZiBhIFBEIGFyZVxuICAgKiBwcmVzZXJ2ZWQgYW5kIHRoZSB2b2x1bWUgaXMgbWVyZWx5IHVubW91bnRlZC4gVGhpcyBtZWFucyB0aGF0IGEgUEQgY2FuIGJlIHByZS1wb3B1bGF0ZWRcbiAgICogd2l0aCBkYXRhLCBhbmQgdGhhdCBkYXRhIGNhbiBiZSBzaGFyZWQgYmV0d2VlbiBwb2RzLlxuICAgKlxuICAgKiBUaGVyZSBhcmUgc29tZSByZXN0cmljdGlvbnMgd2hlbiB1c2luZyBhIGdjZVBlcnNpc3RlbnREaXNrOlxuICAgKlxuICAgKiAtIHRoZSBub2RlcyBvbiB3aGljaCBQb2RzIGFyZSBydW5uaW5nIG11c3QgYmUgR0NFIFZNc1xuICAgKiAtIHRob3NlIFZNcyBuZWVkIHRvIGJlIGluIHRoZSBzYW1lIEdDRSBwcm9qZWN0IGFuZCB6b25lIGFzIHRoZSBwZXJzaXN0ZW50IGRpc2tcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbUdjZVBlcnNpc3RlbnREaXNrKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHBkTmFtZTogc3RyaW5nLCBvcHRpb25zOiBHQ0VQZXJzaXN0ZW50RGlza1ZvbHVtZU9wdGlvbnMgPSB7fSk6IFZvbHVtZSB7XG4gICAgcmV0dXJuIG5ldyBWb2x1bWUoc2NvcGUsIGlkLCBvcHRpb25zLm5hbWUgPz8gYGdjZWRpc2stJHtwZE5hbWV9YCwge1xuICAgICAgZ2NlUGVyc2lzdGVudERpc2s6IHtcbiAgICAgICAgcGROYW1lLFxuICAgICAgICBmc1R5cGU6IG9wdGlvbnMuZnNUeXBlID8/ICdleHQ0JyxcbiAgICAgICAgcGFydGl0aW9uOiBvcHRpb25zLnBhcnRpdGlvbixcbiAgICAgICAgcmVhZE9ubHk6IG9wdGlvbnMucmVhZE9ubHkgPz8gZmFsc2UsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvcHVsYXRlIHRoZSB2b2x1bWUgZnJvbSBhIENvbmZpZ01hcC5cbiAgICpcbiAgICogVGhlIGNvbmZpZ01hcCByZXNvdXJjZSBwcm92aWRlcyBhIHdheSB0byBpbmplY3QgY29uZmlndXJhdGlvbiBkYXRhIGludG9cbiAgICogUG9kcy4gVGhlIGRhdGEgc3RvcmVkIGluIGEgQ29uZmlnTWFwIG9iamVjdCBjYW4gYmUgcmVmZXJlbmNlZCBpbiBhIHZvbHVtZVxuICAgKiBvZiB0eXBlIGNvbmZpZ01hcCBhbmQgdGhlbiBjb25zdW1lZCBieSBjb250YWluZXJpemVkIGFwcGxpY2F0aW9ucyBydW5uaW5nXG4gICAqIGluIGEgUG9kLlxuICAgKlxuICAgKiBXaGVuIHJlZmVyZW5jaW5nIGEgY29uZmlnTWFwIG9iamVjdCwgeW91IGNhbiBzaW1wbHkgcHJvdmlkZSBpdHMgbmFtZSBpbiB0aGVcbiAgICogdm9sdW1lIHRvIHJlZmVyZW5jZSBpdC4gWW91IGNhbiBhbHNvIGN1c3RvbWl6ZSB0aGUgcGF0aCB0byB1c2UgZm9yIGFcbiAgICogc3BlY2lmaWMgZW50cnkgaW4gdGhlIENvbmZpZ01hcC5cbiAgICpcbiAgICogQHBhcmFtIGNvbmZpZ01hcCBUaGUgY29uZmlnIG1hcCB0byB1c2UgdG8gcG9wdWxhdGUgdGhlIHZvbHVtZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tQ29uZmlnTWFwKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIGNvbmZpZ01hcDogY29uZmlnbWFwLklDb25maWdNYXAsIG9wdGlvbnM6IENvbmZpZ01hcFZvbHVtZU9wdGlvbnMgPSB7IH0pOiBWb2x1bWUge1xuICAgIHJldHVybiBuZXcgVm9sdW1lKHNjb3BlLCBpZCwgb3B0aW9ucy5uYW1lID8/IGBjb25maWdtYXAtJHtjb25maWdNYXAubmFtZX1gLCB7XG4gICAgICBjb25maWdNYXA6IHtcbiAgICAgICAgbmFtZTogY29uZmlnTWFwLm5hbWUsXG4gICAgICAgIGRlZmF1bHRNb2RlOiBvcHRpb25zLmRlZmF1bHRNb2RlLFxuICAgICAgICBvcHRpb25hbDogb3B0aW9ucy5vcHRpb25hbCxcbiAgICAgICAgaXRlbXM6IFZvbHVtZS5yZW5kZXJJdGVtcyhvcHRpb25zLml0ZW1zKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQW4gZW1wdHlEaXIgdm9sdW1lIGlzIGZpcnN0IGNyZWF0ZWQgd2hlbiBhIFBvZCBpcyBhc3NpZ25lZCB0byBhIE5vZGUsIGFuZFxuICAgKiBleGlzdHMgYXMgbG9uZyBhcyB0aGF0IFBvZCBpcyBydW5uaW5nIG9uIHRoYXQgbm9kZS4gQXMgdGhlIG5hbWUgc2F5cywgaXQgaXNcbiAgICogaW5pdGlhbGx5IGVtcHR5LiBDb250YWluZXJzIGluIHRoZSBQb2QgY2FuIGFsbCByZWFkIGFuZCB3cml0ZSB0aGUgc2FtZVxuICAgKiBmaWxlcyBpbiB0aGUgZW1wdHlEaXIgdm9sdW1lLCB0aG91Z2ggdGhhdCB2b2x1bWUgY2FuIGJlIG1vdW50ZWQgYXQgdGhlIHNhbWVcbiAgICogb3IgZGlmZmVyZW50IHBhdGhzIGluIGVhY2ggQ29udGFpbmVyLiBXaGVuIGEgUG9kIGlzIHJlbW92ZWQgZnJvbSBhIG5vZGUgZm9yXG4gICAqIGFueSByZWFzb24sIHRoZSBkYXRhIGluIHRoZSBlbXB0eURpciBpcyBkZWxldGVkIGZvcmV2ZXIuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL2t1YmVybmV0ZXMuaW8vZG9jcy91c2VyLWd1aWRlL3ZvbHVtZXMjZW1wdHlkaXJcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21FbXB0eURpcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIG9wdGlvbnM6IEVtcHR5RGlyVm9sdW1lT3B0aW9ucyA9IHsgfSk6IFZvbHVtZSB7XG4gICAgcmV0dXJuIG5ldyBWb2x1bWUoc2NvcGUsIGlkLCBuYW1lLCB7XG4gICAgICBlbXB0eURpcjoge1xuICAgICAgICBtZWRpdW06IG9wdGlvbnMubWVkaXVtLFxuICAgICAgICBzaXplTGltaXQ6IG9wdGlvbnMuc2l6ZUxpbWl0XG4gICAgICAgICAgPyBrOHMuUXVhbnRpdHkuZnJvbVN0cmluZyhgJHtvcHRpb25zLnNpemVMaW1pdC50b01lYmlieXRlcygpfU1pYClcbiAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUG9wdWxhdGUgdGhlIHZvbHVtZSBmcm9tIGEgU2VjcmV0LlxuICAgKlxuICAgKiBBIHNlY3JldCB2b2x1bWUgaXMgdXNlZCB0byBwYXNzIHNlbnNpdGl2ZSBpbmZvcm1hdGlvbiwgc3VjaCBhcyBwYXNzd29yZHMsIHRvIFBvZHMuXG4gICAqIFlvdSBjYW4gc3RvcmUgc2VjcmV0cyBpbiB0aGUgS3ViZXJuZXRlcyBBUEkgYW5kIG1vdW50IHRoZW0gYXMgZmlsZXMgZm9yIHVzZSBieSBwb2RzXG4gICAqIHdpdGhvdXQgY291cGxpbmcgdG8gS3ViZXJuZXRlcyBkaXJlY3RseS5cbiAgICpcbiAgICogc2VjcmV0IHZvbHVtZXMgYXJlIGJhY2tlZCBieSB0bXBmcyAoYSBSQU0tYmFja2VkIGZpbGVzeXN0ZW0pXG4gICAqIHNvIHRoZXkgYXJlIG5ldmVyIHdyaXR0ZW4gdG8gbm9uLXZvbGF0aWxlIHN0b3JhZ2UuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvc3RvcmFnZS92b2x1bWVzLyNzZWNyZXRcbiAgICpcbiAgICogQHBhcmFtIHNlY3IgVGhlIHNlY3JldCB0byB1c2UgdG8gcG9wdWxhdGUgdGhlIHZvbHVtZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tU2VjcmV0KHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHNlY3I6IHNlY3JldC5JU2VjcmV0LCBvcHRpb25zOiBTZWNyZXRWb2x1bWVPcHRpb25zID0geyB9KTogVm9sdW1lIHtcbiAgICByZXR1cm4gbmV3IFZvbHVtZShzY29wZSwgaWQsIG9wdGlvbnMubmFtZSA/PyBgc2VjcmV0LSR7c2Vjci5uYW1lfWAsIHtcbiAgICAgIHNlY3JldDoge1xuICAgICAgICBzZWNyZXROYW1lOiBzZWNyLm5hbWUsXG4gICAgICAgIGRlZmF1bHRNb2RlOiBvcHRpb25zLmRlZmF1bHRNb2RlLFxuICAgICAgICBvcHRpb25hbDogb3B0aW9ucy5vcHRpb25hbCxcbiAgICAgICAgaXRlbXM6IFZvbHVtZS5yZW5kZXJJdGVtcyhvcHRpb25zLml0ZW1zKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBtb3VudCBhIFBlcnNpc3RlbnRWb2x1bWUgaW50byBhIFBvZC5cbiAgICogUGVyc2lzdGVudFZvbHVtZUNsYWltcyBhcmUgYSB3YXkgZm9yIHVzZXJzIHRvIFwiY2xhaW1cIiBkdXJhYmxlIHN0b3JhZ2UgKHN1Y2ggYXMgYSBHQ0UgUGVyc2lzdGVudERpc2sgb3IgYW4gaVNDU0kgdm9sdW1lKVxuICAgKiB3aXRob3V0IGtub3dpbmcgdGhlIGRldGFpbHMgb2YgdGhlIHBhcnRpY3VsYXIgY2xvdWQgZW52aXJvbm1lbnQuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvc3RvcmFnZS9wZXJzaXN0ZW50LXZvbHVtZXMvXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21QZXJzaXN0ZW50Vm9sdW1lQ2xhaW0oc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZyxcbiAgICBjbGFpbTogcHZjLklQZXJzaXN0ZW50Vm9sdW1lQ2xhaW0sXG4gICAgb3B0aW9uczogUGVyc2lzdGVudFZvbHVtZUNsYWltVm9sdW1lT3B0aW9ucyA9IHt9KTogVm9sdW1lIHtcbiAgICByZXR1cm4gbmV3IFZvbHVtZShzY29wZSwgaWQsIG9wdGlvbnMubmFtZSA/PyBgcHZjLSR7Y2xhaW0ubmFtZX1gLCB7XG4gICAgICBwZXJzaXN0ZW50Vm9sdW1lQ2xhaW06IHtcbiAgICAgICAgY2xhaW1OYW1lOiBjbGFpbS5uYW1lLFxuICAgICAgICByZWFkT25seTogb3B0aW9ucy5yZWFkT25seSA/PyBmYWxzZSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgcmVuZGVySXRlbXMgPSAoaXRlbXM/OiB7IFtrZXk6IHN0cmluZ106IFBhdGhNYXBwaW5nIH0pOiB1bmRlZmluZWQgfCBBcnJheTxrOHMuS2V5VG9QYXRoPiA9PiB7XG4gICAgaWYgKCFpdGVtcykgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5PGs4cy5LZXlUb1BhdGg+KCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaXRlbXMpLnNvcnQoKSkge1xuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICBrZXksXG4gICAgICAgIHBhdGg6IGl0ZW1zW2tleV0ucGF0aCxcbiAgICAgICAgbW9kZTogaXRlbXNba2V5XS5tb2RlLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsXG4gICAgcHVibGljIHJlYWRvbmx5IG5hbWU6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNvbmZpZzogT21pdDxrOHMuVm9sdW1lLCAnbmFtZSc+KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkKTtcbiAgfVxuXG4gIHB1YmxpYyBhc1ZvbHVtZSgpOiBWb2x1bWUge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHVibGljIF90b0t1YmUoKTogazhzLlZvbHVtZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBPcHRpb25zIG9mIGBWb2x1bWUuZnJvbUdjZVBlcnNpc3RlbnREaXNrYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHQ0VQZXJzaXN0ZW50RGlza1ZvbHVtZU9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHZvbHVtZSBuYW1lLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGF1dG8tZ2VuZXJhdGVkXG4gICAqL1xuICByZWFkb25seSBuYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBGaWxlc3lzdGVtIHR5cGUgb2YgdGhlIHZvbHVtZSB0aGF0IHlvdSB3YW50IHRvIG1vdW50LlxuICAgKiBUaXA6IEVuc3VyZSB0aGF0IHRoZSBmaWxlc3lzdGVtIHR5cGUgaXMgc3VwcG9ydGVkIGJ5IHRoZSBob3N0IG9wZXJhdGluZyBzeXN0ZW0uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvc3RvcmFnZS92b2x1bWVzI2F3c2VsYXN0aWNibG9ja3N0b3JlXG4gICAqIEBkZWZhdWx0ICdleHQ0J1xuICAgKi9cbiAgcmVhZG9ubHkgZnNUeXBlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcGFydGl0aW9uIGluIHRoZSB2b2x1bWUgdGhhdCB5b3Ugd2FudCB0byBtb3VudC4gSWYgb21pdHRlZCwgdGhlIGRlZmF1bHQgaXMgdG8gbW91bnQgYnkgdm9sdW1lIG5hbWUuXG4gICAqIEV4YW1wbGVzOiBGb3Igdm9sdW1lIC9kZXYvc2RhMSwgeW91IHNwZWNpZnkgdGhlIHBhcnRpdGlvbiBhcyBcIjFcIi5cbiAgICogU2ltaWxhcmx5LCB0aGUgdm9sdW1lIHBhcnRpdGlvbiBmb3IgL2Rldi9zZGEgaXMgXCIwXCIgKG9yIHlvdSBjYW4gbGVhdmUgdGhlIHByb3BlcnR5IGVtcHR5KS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyBwYXJ0aXRpb24uXG4gICAqL1xuICByZWFkb25seSBwYXJ0aXRpb24/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgXCJ0cnVlXCIgdG8gZm9yY2UgYW5kIHNldCB0aGUgUmVhZE9ubHkgcHJvcGVydHkgaW4gVm9sdW1lTW91bnRzIHRvIFwidHJ1ZVwiLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2Uvdm9sdW1lcyNhd3NlbGFzdGljYmxvY2tzdG9yZVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgcmVhZE9ubHk/OiBib29sZWFuO1xuXG59XG5cbi8qKlxuICogT3B0aW9ucyBvZiBgVm9sdW1lLmZyb21BenVyZURpc2tgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEF6dXJlRGlza1ZvbHVtZU9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHZvbHVtZSBuYW1lLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGF1dG8tZ2VuZXJhdGVkXG4gICAqL1xuICByZWFkb25seSBuYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBIb3N0IENhY2hpbmcgbW9kZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBBenVyZURpc2tQZXJzaXN0ZW50Vm9sdW1lQ2FjaGluZ01vZGUuTk9ORS5cbiAgICovXG4gIHJlYWRvbmx5IGNhY2hpbmdNb2RlPzogQXp1cmVEaXNrUGVyc2lzdGVudFZvbHVtZUNhY2hpbmdNb2RlO1xuXG4gIC8qKlxuICAgKiBGaWxlc3lzdGVtIHR5cGUgdG8gbW91bnQuIE11c3QgYmUgYSBmaWxlc3lzdGVtIHR5cGUgc3VwcG9ydGVkIGJ5IHRoZSBob3N0IG9wZXJhdGluZyBzeXN0ZW0uXG4gICAqXG4gICAqIEBkZWZhdWx0ICdleHQ0J1xuICAgKi9cbiAgcmVhZG9ubHkgZnNUeXBlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBLaW5kIG9mIGRpc2suXG4gICAqXG4gICAqIEBkZWZhdWx0IEF6dXJlRGlza1BlcnNpc3RlbnRWb2x1bWVLaW5kLlNIQVJFRFxuICAgKi9cbiAgcmVhZG9ubHkga2luZD86IEF6dXJlRGlza1BlcnNpc3RlbnRWb2x1bWVLaW5kO1xuXG4gIC8qKlxuICAgKiBGb3JjZSB0aGUgUmVhZE9ubHkgc2V0dGluZyBpbiBWb2x1bWVNb3VudHMuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSByZWFkT25seT86IGJvb2xlYW47XG59XG5cbi8qKlxuICogT3B0aW9ucyBvZiBgVm9sdW1lLmZyb21Bd3NFbGFzdGljQmxvY2tTdG9yZWAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXdzRWxhc3RpY0Jsb2NrU3RvcmVWb2x1bWVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB2b2x1bWUgbmFtZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBhdXRvLWdlbmVyYXRlZFxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogRmlsZXN5c3RlbSB0eXBlIG9mIHRoZSB2b2x1bWUgdGhhdCB5b3Ugd2FudCB0byBtb3VudC5cbiAgICogVGlwOiBFbnN1cmUgdGhhdCB0aGUgZmlsZXN5c3RlbSB0eXBlIGlzIHN1cHBvcnRlZCBieSB0aGUgaG9zdCBvcGVyYXRpbmcgc3lzdGVtLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL3N0b3JhZ2Uvdm9sdW1lcyNhd3NlbGFzdGljYmxvY2tzdG9yZVxuICAgKiBAZGVmYXVsdCAnZXh0NCdcbiAgICovXG4gIHJlYWRvbmx5IGZzVHlwZT86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHBhcnRpdGlvbiBpbiB0aGUgdm9sdW1lIHRoYXQgeW91IHdhbnQgdG8gbW91bnQuIElmIG9taXR0ZWQsIHRoZSBkZWZhdWx0IGlzIHRvIG1vdW50IGJ5IHZvbHVtZSBuYW1lLlxuICAgKiBFeGFtcGxlczogRm9yIHZvbHVtZSAvZGV2L3NkYTEsIHlvdSBzcGVjaWZ5IHRoZSBwYXJ0aXRpb24gYXMgXCIxXCIuXG4gICAqIFNpbWlsYXJseSwgdGhlIHZvbHVtZSBwYXJ0aXRpb24gZm9yIC9kZXYvc2RhIGlzIFwiMFwiIChvciB5b3UgY2FuIGxlYXZlIHRoZSBwcm9wZXJ0eSBlbXB0eSkuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gcGFydGl0aW9uLlxuICAgKi9cbiAgcmVhZG9ubHkgcGFydGl0aW9uPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IFwidHJ1ZVwiIHRvIGZvcmNlIGFuZCBzZXQgdGhlIFJlYWRPbmx5IHByb3BlcnR5IGluIFZvbHVtZU1vdW50cyB0byBcInRydWVcIi5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9zdG9yYWdlL3ZvbHVtZXMjYXdzZWxhc3RpY2Jsb2Nrc3RvcmVcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IHJlYWRPbmx5PzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciB0aGUgQ29uZmlnTWFwLWJhc2VkIHZvbHVtZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb25maWdNYXBWb2x1bWVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB2b2x1bWUgbmFtZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBhdXRvLWdlbmVyYXRlZFxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogTW9kZSBiaXRzIHRvIHVzZSBvbiBjcmVhdGVkIGZpbGVzIGJ5IGRlZmF1bHQuIE11c3QgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kXG4gICAqIDA3NzcuIERlZmF1bHRzIHRvIDA2NDQuIERpcmVjdG9yaWVzIHdpdGhpbiB0aGUgcGF0aCBhcmUgbm90IGFmZmVjdGVkIGJ5XG4gICAqIHRoaXMgc2V0dGluZy4gVGhpcyBtaWdodCBiZSBpbiBjb25mbGljdCB3aXRoIG90aGVyIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlXG4gICAqIGZpbGUgbW9kZSwgbGlrZSBmc0dyb3VwLCBhbmQgdGhlIHJlc3VsdCBjYW4gYmUgb3RoZXIgbW9kZSBiaXRzIHNldC5cbiAgICpcbiAgICogQGRlZmF1bHQgMDY0NC4gRGlyZWN0b3JpZXMgd2l0aGluIHRoZSBwYXRoIGFyZSBub3QgYWZmZWN0ZWQgYnkgdGhpc1xuICAgKiBzZXR0aW5nLiBUaGlzIG1pZ2h0IGJlIGluIGNvbmZsaWN0IHdpdGggb3RoZXIgb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgZmlsZVxuICAgKiBtb2RlLCBsaWtlIGZzR3JvdXAsIGFuZCB0aGUgcmVzdWx0IGNhbiBiZSBvdGhlciBtb2RlIGJpdHMgc2V0LlxuICAgKi9cbiAgcmVhZG9ubHkgZGVmYXVsdE1vZGU/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgd2hldGhlciB0aGUgQ29uZmlnTWFwIG9yIGl0cyBrZXlzIG11c3QgYmUgZGVmaW5lZC5cbiAgICogQGRlZmF1bHQgLSB1bmRvY3VtZW50ZWRcbiAgICovXG4gIHJlYWRvbmx5IG9wdGlvbmFsPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSWYgdW5zcGVjaWZpZWQsIGVhY2gga2V5LXZhbHVlIHBhaXIgaW4gdGhlIERhdGEgZmllbGQgb2YgdGhlIHJlZmVyZW5jZWRcbiAgICogQ29uZmlnTWFwIHdpbGwgYmUgcHJvamVjdGVkIGludG8gdGhlIHZvbHVtZSBhcyBhIGZpbGUgd2hvc2UgbmFtZSBpcyB0aGUga2V5XG4gICAqIGFuZCBjb250ZW50IGlzIHRoZSB2YWx1ZS4gSWYgc3BlY2lmaWVkLCB0aGUgbGlzdGVkIGtleXMgd2lsbCBiZSBwcm9qZWN0ZWRcbiAgICogaW50byB0aGUgc3BlY2lmaWVkIHBhdGhzLCBhbmQgdW5saXN0ZWQga2V5cyB3aWxsIG5vdCBiZSBwcmVzZW50LiBJZiBhIGtleVxuICAgKiBpcyBzcGVjaWZpZWQgd2hpY2ggaXMgbm90IHByZXNlbnQgaW4gdGhlIENvbmZpZ01hcCwgdGhlIHZvbHVtZSBzZXR1cCB3aWxsXG4gICAqIGVycm9yIHVubGVzcyBpdCBpcyBtYXJrZWQgb3B0aW9uYWwuIFBhdGhzIG11c3QgYmUgcmVsYXRpdmUgYW5kIG1heSBub3RcbiAgICogY29udGFpbiB0aGUgJy4uJyBwYXRoIG9yIHN0YXJ0IHdpdGggJy4uJy5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBubyBtYXBwaW5nXG4gICAqL1xuICByZWFkb25seSBpdGVtcz86IHsgW2tleTogc3RyaW5nXTogUGF0aE1hcHBpbmcgfTtcbn1cblxuLyoqXG4gKiBNYXBzIGEgc3RyaW5nIGtleSB0byBhIHBhdGggd2l0aGluIGEgdm9sdW1lLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBhdGhNYXBwaW5nIHtcbiAgLyoqXG4gICAqIFRoZSByZWxhdGl2ZSBwYXRoIG9mIHRoZSBmaWxlIHRvIG1hcCB0aGUga2V5IHRvLiBNYXkgbm90IGJlIGFuIGFic29sdXRlXG4gICAqIHBhdGguIE1heSBub3QgY29udGFpbiB0aGUgcGF0aCBlbGVtZW50ICcuLicuIE1heSBub3Qgc3RhcnQgd2l0aCB0aGUgc3RyaW5nXG4gICAqICcuLicuXG4gICAqL1xuICByZWFkb25seSBwYXRoOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsOiBtb2RlIGJpdHMgdG8gdXNlIG9uIHRoaXMgZmlsZSwgbXVzdCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmRcbiAgICogMDc3Ny4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHZvbHVtZSBkZWZhdWx0TW9kZSB3aWxsIGJlIHVzZWQuIFRoaXMgbWlnaHQgYmVcbiAgICogaW4gY29uZmxpY3Qgd2l0aCBvdGhlciBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBmaWxlIG1vZGUsIGxpa2UgZnNHcm91cCwgYW5kXG4gICAqIHRoZSByZXN1bHQgY2FuIGJlIG90aGVyIG1vZGUgYml0cyBzZXQuXG4gICAqL1xuICByZWFkb25seSBtb2RlPzogbnVtYmVyO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHZvbHVtZXMgcG9wdWxhdGVkIHdpdGggYW4gZW1wdHkgZGlyZWN0b3J5LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVtcHR5RGlyVm9sdW1lT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0LCBlbXB0eURpciB2b2x1bWVzIGFyZSBzdG9yZWQgb24gd2hhdGV2ZXIgbWVkaXVtIGlzIGJhY2tpbmcgdGhlXG4gICAqIG5vZGUgLSB0aGF0IG1pZ2h0IGJlIGRpc2sgb3IgU1NEIG9yIG5ldHdvcmsgc3RvcmFnZSwgZGVwZW5kaW5nIG9uIHlvdXJcbiAgICogZW52aXJvbm1lbnQuIEhvd2V2ZXIsIHlvdSBjYW4gc2V0IHRoZSBlbXB0eURpci5tZWRpdW0gZmllbGQgdG9cbiAgICogYEVtcHR5RGlyTWVkaXVtLk1FTU9SWWAgdG8gdGVsbCBLdWJlcm5ldGVzIHRvIG1vdW50IGEgdG1wZnMgKFJBTS1iYWNrZWRcbiAgICogZmlsZXN5c3RlbSkgZm9yIHlvdSBpbnN0ZWFkLiBXaGlsZSB0bXBmcyBpcyB2ZXJ5IGZhc3QsIGJlIGF3YXJlIHRoYXQgdW5saWtlXG4gICAqIGRpc2tzLCB0bXBmcyBpcyBjbGVhcmVkIG9uIG5vZGUgcmVib290IGFuZCBhbnkgZmlsZXMgeW91IHdyaXRlIHdpbGwgY291bnRcbiAgICogYWdhaW5zdCB5b3VyIENvbnRhaW5lcidzIG1lbW9yeSBsaW1pdC5cbiAgICpcbiAgICogQGRlZmF1bHQgRW1wdHlEaXJNZWRpdW0uREVGQVVMVFxuICAgKi9cbiAgcmVhZG9ubHkgbWVkaXVtPzogRW1wdHlEaXJNZWRpdW07XG5cbiAgLyoqXG4gICAqIFRvdGFsIGFtb3VudCBvZiBsb2NhbCBzdG9yYWdlIHJlcXVpcmVkIGZvciB0aGlzIEVtcHR5RGlyIHZvbHVtZS4gVGhlIHNpemVcbiAgICogbGltaXQgaXMgYWxzbyBhcHBsaWNhYmxlIGZvciBtZW1vcnkgbWVkaXVtLiBUaGUgbWF4aW11bSB1c2FnZSBvbiBtZW1vcnlcbiAgICogbWVkaXVtIEVtcHR5RGlyIHdvdWxkIGJlIHRoZSBtaW5pbXVtIHZhbHVlIGJldHdlZW4gdGhlIFNpemVMaW1pdCBzcGVjaWZpZWRcbiAgICogaGVyZSBhbmQgdGhlIHN1bSBvZiBtZW1vcnkgbGltaXRzIG9mIGFsbCBjb250YWluZXJzIGluIGEgcG9kLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGxpbWl0IGlzIHVuZGVmaW5lZFxuICAgKi9cbiAgcmVhZG9ubHkgc2l6ZUxpbWl0PzogU2l6ZTtcbn1cblxuLyoqXG4gKiBUaGUgbWVkaXVtIG9uIHdoaWNoIHRvIHN0b3JlIHRoZSB2b2x1bWUuXG4gKi9cbmV4cG9ydCBlbnVtIEVtcHR5RGlyTWVkaXVtIHtcbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IHZvbHVtZSBvZiB0aGUgYmFja2luZyBub2RlLlxuICAgKi9cbiAgREVGQVVMVCA9ICcnLFxuXG4gIC8qKlxuICAgKiBNb3VudCBhIHRtcGZzIChSQU0tYmFja2VkIGZpbGVzeXN0ZW0pIGZvciB5b3UgaW5zdGVhZC4gV2hpbGUgdG1wZnMgaXMgdmVyeVxuICAgKiBmYXN0LCBiZSBhd2FyZSB0aGF0IHVubGlrZSBkaXNrcywgdG1wZnMgaXMgY2xlYXJlZCBvbiBub2RlIHJlYm9vdCBhbmQgYW55XG4gICAqIGZpbGVzIHlvdSB3cml0ZSB3aWxsIGNvdW50IGFnYWluc3QgeW91ciBDb250YWluZXIncyBtZW1vcnkgbGltaXQuXG4gICAqL1xuICBNRU1PUlkgPSAnTWVtb3J5J1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGEgUGVyc2lzdGVudFZvbHVtZUNsYWltLWJhc2VkIHZvbHVtZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQZXJzaXN0ZW50Vm9sdW1lQ2xhaW1Wb2x1bWVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB2b2x1bWUgbmFtZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBEZXJpdmVkIGZyb20gdGhlIFBWQyBuYW1lLlxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogV2lsbCBmb3JjZSB0aGUgUmVhZE9ubHkgc2V0dGluZyBpbiBWb2x1bWVNb3VudHMuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSByZWFkT25seT86IGJvb2xlYW47XG5cbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciB0aGUgU2VjcmV0LWJhc2VkIHZvbHVtZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZWNyZXRWb2x1bWVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB2b2x1bWUgbmFtZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBhdXRvLWdlbmVyYXRlZFxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogTW9kZSBiaXRzIHRvIHVzZSBvbiBjcmVhdGVkIGZpbGVzIGJ5IGRlZmF1bHQuIE11c3QgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kXG4gICAqIDA3NzcuIERlZmF1bHRzIHRvIDA2NDQuIERpcmVjdG9yaWVzIHdpdGhpbiB0aGUgcGF0aCBhcmUgbm90IGFmZmVjdGVkIGJ5XG4gICAqIHRoaXMgc2V0dGluZy4gVGhpcyBtaWdodCBiZSBpbiBjb25mbGljdCB3aXRoIG90aGVyIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlXG4gICAqIGZpbGUgbW9kZSwgbGlrZSBmc0dyb3VwLCBhbmQgdGhlIHJlc3VsdCBjYW4gYmUgb3RoZXIgbW9kZSBiaXRzIHNldC5cbiAgICpcbiAgICogQGRlZmF1bHQgMDY0NC4gRGlyZWN0b3JpZXMgd2l0aGluIHRoZSBwYXRoIGFyZSBub3QgYWZmZWN0ZWQgYnkgdGhpc1xuICAgKiBzZXR0aW5nLiBUaGlzIG1pZ2h0IGJlIGluIGNvbmZsaWN0IHdpdGggb3RoZXIgb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgZmlsZVxuICAgKiBtb2RlLCBsaWtlIGZzR3JvdXAsIGFuZCB0aGUgcmVzdWx0IGNhbiBiZSBvdGhlciBtb2RlIGJpdHMgc2V0LlxuICAgKi9cbiAgcmVhZG9ubHkgZGVmYXVsdE1vZGU/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgd2hldGhlciB0aGUgc2VjcmV0IG9yIGl0cyBrZXlzIG11c3QgYmUgZGVmaW5lZC5cbiAgICogQGRlZmF1bHQgLSB1bmRvY3VtZW50ZWRcbiAgICovXG4gIHJlYWRvbmx5IG9wdGlvbmFsPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSWYgdW5zcGVjaWZpZWQsIGVhY2gga2V5LXZhbHVlIHBhaXIgaW4gdGhlIERhdGEgZmllbGQgb2YgdGhlIHJlZmVyZW5jZWRcbiAgICogc2VjcmV0IHdpbGwgYmUgcHJvamVjdGVkIGludG8gdGhlIHZvbHVtZSBhcyBhIGZpbGUgd2hvc2UgbmFtZSBpcyB0aGUga2V5XG4gICAqIGFuZCBjb250ZW50IGlzIHRoZSB2YWx1ZS4gSWYgc3BlY2lmaWVkLCB0aGUgbGlzdGVkIGtleXMgd2lsbCBiZSBwcm9qZWN0ZWRcbiAgICogaW50byB0aGUgc3BlY2lmaWVkIHBhdGhzLCBhbmQgdW5saXN0ZWQga2V5cyB3aWxsIG5vdCBiZSBwcmVzZW50LiBJZiBhIGtleVxuICAgKiBpcyBzcGVjaWZpZWQgd2hpY2ggaXMgbm90IHByZXNlbnQgaW4gdGhlIHNlY3JldCwgdGhlIHZvbHVtZSBzZXR1cCB3aWxsXG4gICAqIGVycm9yIHVubGVzcyBpdCBpcyBtYXJrZWQgb3B0aW9uYWwuIFBhdGhzIG11c3QgYmUgcmVsYXRpdmUgYW5kIG1heSBub3RcbiAgICogY29udGFpbiB0aGUgJy4uJyBwYXRoIG9yIHN0YXJ0IHdpdGggJy4uJy5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBubyBtYXBwaW5nXG4gICAqL1xuICByZWFkb25seSBpdGVtcz86IHsgW2tleTogc3RyaW5nXTogUGF0aE1hcHBpbmcgfTtcblxufVxuXG4vKipcbiAqIEF6dXJlIERpc2sga2luZHMuXG4gKi9cbmV4cG9ydCBlbnVtIEF6dXJlRGlza1BlcnNpc3RlbnRWb2x1bWVLaW5kIHtcblxuICAvKipcbiAgICogTXVsdGlwbGUgYmxvYiBkaXNrcyBwZXIgc3RvcmFnZSBhY2NvdW50LlxuICAgKi9cbiAgU0hBUkVEID0gJ1NoYXJlZCcsXG5cbiAgLyoqXG4gICAqIFNpbmdsZSBibG9iIGRpc2sgcGVyIHN0b3JhZ2UgYWNjb3VudC5cbiAgICovXG4gIERFRElDQVRFRCA9ICdEZWRpY2F0ZWQnLFxuXG4gIC8qKlxuICAgKiBBenVyZSBtYW5hZ2VkIGRhdGEgZGlzay5cbiAgICovXG4gIE1BTkFHRUQgPSAnTWFuYWdlZCcsXG59XG5cbi8qKlxuICogQXp1cmUgZGlzayBjYWNoaW5nIG1vZGVzLlxuICovXG5leHBvcnQgZW51bSBBenVyZURpc2tQZXJzaXN0ZW50Vm9sdW1lQ2FjaGluZ01vZGUge1xuXG4gIC8qKlxuICAgKiBOb25lLlxuICAgKi9cbiAgTk9ORSA9ICdOb25lJyxcblxuICAvKipcbiAgICogUmVhZE9ubHkuXG4gICAqL1xuICBSRUFEX09OTFkgPSAnUmVhZE9ubHknLFxuXG4gIC8qKlxuICAgKiBSZWFkV3JpdGUuXG4gICAqL1xuICBSRUFEX1dSSVRFID0gJ1JlYWRXcml0ZSdcbn1cbiJdfQ==

/***/ }),

/***/ 7967:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkloadScheduling = exports.Workload = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const cdk8s_1 = __nccwpck_require__(1227);
const pod = __nccwpck_require__(442);
const utils_1 = __nccwpck_require__(6594);
/**
 * A workload is an application running on Kubernetes. Whether your workload is a single
 * component or several that work together, on Kubernetes you run it inside a set of pods.
 * In Kubernetes, a Pod represents a set of running containers on your cluster.
 */
class Workload extends pod.AbstractPod {
    constructor(scope, id, props = {}) {
        var _c;
        super(scope, id, props);
        this._matchLabels = {};
        this._matchExpressions = [];
        this.podMetadata = new cdk8s_1.ApiObjectMetadataDefinition(props.podMetadata);
        this.scheduling = new WorkloadScheduling(this);
        this.connections = new pod.PodConnections(this);
        const matcher = cdk8s_1.Names.toLabelValue(this);
        this.podMetadata.addLabel(pod.Pod.ADDRESS_LABEL, matcher);
        if ((_c = props.select) !== null && _c !== void 0 ? _c : true) {
            this.select(pod.LabelSelector.of({ labels: { [pod.Pod.ADDRESS_LABEL]: matcher } }));
        }
    }
    /**
     * Configure selectors for this workload.
     */
    select(...selectors) {
        var _c, _d;
        for (const selector of selectors) {
            const kube = selector._toKube();
            this._matchExpressions.push(...(_c = kube.matchExpressions) !== null && _c !== void 0 ? _c : []);
            for (const [key, value] of Object.entries((_d = kube.matchLabels) !== null && _d !== void 0 ? _d : {})) {
                this._matchLabels[key] = value;
            }
        }
    }
    /**
     * The label matchers this workload will use in order to select pods.
     *
     * Returns a a copy. Use `select()` to add label matchers.
     */
    get matchLabels() {
        return { ...this._matchLabels };
    }
    /**
     * The expression matchers this workload will use in order to select pods.
     *
     * Returns a a copy. Use `select()` to add expression matchers.
     */
    get matchExpressions() {
        return [...this._matchExpressions];
    }
    /**
     * @internal
     */
    _toLabelSelector() {
        return {
            matchExpressions: utils_1.undefinedIfEmpty(this._matchExpressions),
            matchLabels: utils_1.undefinedIfEmpty(this._matchLabels),
        };
    }
    /**
     * @internal
     */
    _toPodSpec() {
        const scheduling = this.scheduling._toKube();
        return {
            ...super._toPodSpec(),
            affinity: scheduling.affinity,
            nodeName: scheduling.nodeName,
            tolerations: scheduling.tolerations,
        };
    }
}
exports.Workload = Workload;
_a = JSII_RTTI_SYMBOL_1;
Workload[_a] = { fqn: "cdk8s-plus-22.Workload", version: "2.0.0-rc.2" };
/**
 * Controls the pod scheduling strategy of this workload.
 * It offers some additional API's on top of the core pod scheduling.
 */
class WorkloadScheduling extends pod.PodScheduling {
    /**
     * Spread the pods in this workload by the topology key.
     * A spread is a separation of the pod from itself and is used to
     * balance out pod replicas across a given topology.
     */
    spread(options = {}) {
        var _c;
        this.separate(this.instance, { weight: options.weight, topology: (_c = options.topology) !== null && _c !== void 0 ? _c : pod.Topology.HOSTNAME });
    }
}
exports.WorkloadScheduling = WorkloadScheduling;
_b = JSII_RTTI_SYMBOL_1;
WorkloadScheduling[_b] = { fqn: "cdk8s-plus-22.WorkloadScheduling", version: "2.0.0-rc.2" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid29ya2xvYWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvd29ya2xvYWQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxpQ0FBOEU7QUFHOUUsNkJBQTZCO0FBQzdCLG1DQUEyQztBQThDM0M7Ozs7R0FJRztBQUNILE1BQXNCLFFBQVMsU0FBUSxHQUFHLENBQUMsV0FBVztJQWNwRCxZQUFZLEtBQWdCLEVBQUUsRUFBVSxFQUFFLFFBQXVCLEVBQUU7O1FBQ2pFLEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBSlQsaUJBQVksR0FBMkIsRUFBRSxDQUFDO1FBQzFDLHNCQUFpQixHQUErQixFQUFFLENBQUM7UUFLbEUsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLG1DQUEyQixDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUN0RSxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDL0MsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLEdBQUcsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFaEQsTUFBTSxPQUFPLEdBQUcsYUFBSyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN6QyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUUxRCxVQUFJLEtBQUssQ0FBQyxNQUFNLG1DQUFJLElBQUksRUFBRTtZQUN4QixJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxFQUFFLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ3JGO0lBRUgsQ0FBQztJQUVEOztPQUVHO0lBQ0ksTUFBTSxDQUFDLEdBQUcsU0FBOEI7O1FBQzdDLEtBQUssTUFBTSxRQUFRLElBQUksU0FBUyxFQUFFO1lBQ2hDLE1BQU0sSUFBSSxHQUFHLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNoQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLFNBQUcsSUFBSSxDQUFDLGdCQUFnQixtQ0FBSSxFQUFFLENBQUMsQ0FBQztZQUM1RCxLQUFLLE1BQU0sQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sT0FBQyxJQUFJLENBQUMsV0FBVyxtQ0FBSSxFQUFFLENBQUMsRUFBRTtnQkFDakUsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUM7YUFDaEM7U0FDRjtJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsSUFBVyxXQUFXO1FBQ3BCLE9BQU8sRUFBRSxHQUFHLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUNsQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILElBQVcsZ0JBQWdCO1FBQ3pCLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7T0FFRztJQUNJLGdCQUFnQjtRQUNyQixPQUFPO1lBQ0wsZ0JBQWdCLEVBQUUsd0JBQWdCLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDO1lBQzFELFdBQVcsRUFBRSx3QkFBZ0IsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDO1NBQ2pELENBQUM7SUFDSixDQUFDO0lBRUQ7O09BRUc7SUFDSSxVQUFVO1FBQ2YsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUM3QyxPQUFPO1lBQ0wsR0FBRyxLQUFLLENBQUMsVUFBVSxFQUFFO1lBQ3JCLFFBQVEsRUFBRSxVQUFVLENBQUMsUUFBUTtZQUM3QixRQUFRLEVBQUUsVUFBVSxDQUFDLFFBQVE7WUFDN0IsV0FBVyxFQUFFLFVBQVUsQ0FBQyxXQUFXO1NBQ3BDLENBQUM7SUFDSixDQUFDOztBQWxGSCw0QkFtRkM7OztBQXVCRDs7O0dBR0c7QUFDSCxNQUFhLGtCQUFtQixTQUFRLEdBQUcsQ0FBQyxhQUFhO0lBRXZEOzs7O09BSUc7SUFDSSxNQUFNLENBQUMsVUFBMkMsRUFBRTs7UUFDekQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEVBQUUsTUFBTSxFQUFFLE9BQU8sQ0FBQyxNQUFNLEVBQUUsUUFBUSxRQUFFLE9BQU8sQ0FBQyxRQUFRLG1DQUFJLEdBQUcsQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztJQUNoSCxDQUFDOztBQVRILGdEQVdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBpT2JqZWN0TWV0YWRhdGEsIEFwaU9iamVjdE1ldGFkYXRhRGVmaW5pdGlvbiwgTmFtZXMgfSBmcm9tICdjZGs4cyc7XG5pbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tICdjb25zdHJ1Y3RzJztcbmltcG9ydCAqIGFzIGs4cyBmcm9tICcuL2ltcG9ydHMvazhzJztcbmltcG9ydCAqIGFzIHBvZCBmcm9tICcuL3BvZCc7XG5pbXBvcnQgeyB1bmRlZmluZWRJZkVtcHR5IH0gZnJvbSAnLi91dGlscyc7XG5cbi8qKlxuICogUHJvcGVydGllcyBmb3IgYFdvcmtsb2FkYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBXb3JrbG9hZFByb3BzIGV4dGVuZHMgcG9kLkFic3RyYWN0UG9kUHJvcHMge1xuXG4gIC8qKlxuICAgKiBUaGUgcG9kIG1ldGFkYXRhIG9mIHRoaXMgd29ya2xvYWQuXG4gICAqL1xuICByZWFkb25seSBwb2RNZXRhZGF0YT86IEFwaU9iamVjdE1ldGFkYXRhO1xuXG4gIC8qKlxuICAgKiBBdXRvbWF0aWNhbGx5IGFsbG9jYXRlcyBhIHBvZCBsYWJlbCBzZWxlY3RvciBmb3IgdGhpcyB3b3JrbG9hZCBhbmQgYWRkXG4gICAqIGl0IHRvIHRoZSBwb2QgbWV0YWRhdGEuIFRoaXMgZW5zdXJlcyB0aGlzIHdvcmtsb2FkIG1hbmFnZXMgcG9kcyBjcmVhdGVkIGJ5XG4gICAqIGl0cyBwb2QgdGVtcGxhdGUuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IHNlbGVjdD86IGJvb2xlYW47XG5cbn1cblxuLyoqXG4gKiBBIGxhYmVsIHNlbGVjdG9yIHJlcXVpcmVtZW50IGlzIGEgc2VsZWN0b3IgdGhhdCBjb250YWlucyB2YWx1ZXMsIGEga2V5LCBhbmQgYW4gb3BlcmF0b3IgdGhhdFxuICogcmVsYXRlcyB0aGUga2V5IGFuZCB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGFiZWxTZWxlY3RvclJlcXVpcmVtZW50IHtcbiAgLyoqXG4gICAqIFRoZSBsYWJlbCBrZXkgdGhhdCB0aGUgc2VsZWN0b3IgYXBwbGllcyB0by5cbiAgICovXG4gIHJlYWRvbmx5IGtleTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEga2V5J3MgcmVsYXRpb25zaGlwIHRvIGEgc2V0IG9mIHZhbHVlcy5cbiAgICovXG4gIHJlYWRvbmx5IG9wZXJhdG9yOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIHN0cmluZyB2YWx1ZXMuIElmIHRoZSBvcGVyYXRvciBpcyBJbiBvciBOb3RJbiwgdGhlIHZhbHVlcyBhcnJheVxuICAgKiBtdXN0IGJlIG5vbi1lbXB0eS4gSWYgdGhlIG9wZXJhdG9yIGlzIEV4aXN0cyBvciBEb2VzTm90RXhpc3QsXG4gICAqIHRoZSB2YWx1ZXMgYXJyYXkgbXVzdCBiZSBlbXB0eS4gVGhpcyBhcnJheSBpcyByZXBsYWNlZCBkdXJpbmcgYSBzdHJhdGVnaWMgbWVyZ2UgcGF0Y2guXG4gICAqL1xuICByZWFkb25seSB2YWx1ZXM/OiBzdHJpbmdbXTtcbn1cblxuLyoqXG4gKiBBIHdvcmtsb2FkIGlzIGFuIGFwcGxpY2F0aW9uIHJ1bm5pbmcgb24gS3ViZXJuZXRlcy4gV2hldGhlciB5b3VyIHdvcmtsb2FkIGlzIGEgc2luZ2xlXG4gKiBjb21wb25lbnQgb3Igc2V2ZXJhbCB0aGF0IHdvcmsgdG9nZXRoZXIsIG9uIEt1YmVybmV0ZXMgeW91IHJ1biBpdCBpbnNpZGUgYSBzZXQgb2YgcG9kcy5cbiAqIEluIEt1YmVybmV0ZXMsIGEgUG9kIHJlcHJlc2VudHMgYSBzZXQgb2YgcnVubmluZyBjb250YWluZXJzIG9uIHlvdXIgY2x1c3Rlci5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFdvcmtsb2FkIGV4dGVuZHMgcG9kLkFic3RyYWN0UG9kIHtcblxuICAvKipcbiAgICogVGhlIG1ldGFkYXRhIG9mIHBvZHMgaW4gdGhpcyB3b3JrbG9hZC5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBwb2RNZXRhZGF0YTogQXBpT2JqZWN0TWV0YWRhdGFEZWZpbml0aW9uO1xuXG4gIHB1YmxpYyByZWFkb25seSBjb25uZWN0aW9uczogcG9kLlBvZENvbm5lY3Rpb25zO1xuXG4gIHB1YmxpYyByZWFkb25seSBzY2hlZHVsaW5nOiBXb3JrbG9hZFNjaGVkdWxpbmc7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBfbWF0Y2hMYWJlbHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgcHJpdmF0ZSByZWFkb25seSBfbWF0Y2hFeHByZXNzaW9uczogTGFiZWxTZWxlY3RvclJlcXVpcmVtZW50W10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogV29ya2xvYWRQcm9wcyA9IHt9KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCBwcm9wcyk7XG5cbiAgICB0aGlzLnBvZE1ldGFkYXRhID0gbmV3IEFwaU9iamVjdE1ldGFkYXRhRGVmaW5pdGlvbihwcm9wcy5wb2RNZXRhZGF0YSk7XG4gICAgdGhpcy5zY2hlZHVsaW5nID0gbmV3IFdvcmtsb2FkU2NoZWR1bGluZyh0aGlzKTtcbiAgICB0aGlzLmNvbm5lY3Rpb25zID0gbmV3IHBvZC5Qb2RDb25uZWN0aW9ucyh0aGlzKTtcblxuICAgIGNvbnN0IG1hdGNoZXIgPSBOYW1lcy50b0xhYmVsVmFsdWUodGhpcyk7XG4gICAgdGhpcy5wb2RNZXRhZGF0YS5hZGRMYWJlbChwb2QuUG9kLkFERFJFU1NfTEFCRUwsIG1hdGNoZXIpO1xuXG4gICAgaWYgKHByb3BzLnNlbGVjdCA/PyB0cnVlKSB7XG4gICAgICB0aGlzLnNlbGVjdChwb2QuTGFiZWxTZWxlY3Rvci5vZih7IGxhYmVsczogeyBbcG9kLlBvZC5BRERSRVNTX0xBQkVMXTogbWF0Y2hlciB9IH0pKTtcbiAgICB9XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmUgc2VsZWN0b3JzIGZvciB0aGlzIHdvcmtsb2FkLlxuICAgKi9cbiAgcHVibGljIHNlbGVjdCguLi5zZWxlY3RvcnM6IHBvZC5MYWJlbFNlbGVjdG9yW10pIHtcbiAgICBmb3IgKGNvbnN0IHNlbGVjdG9yIG9mIHNlbGVjdG9ycykge1xuICAgICAgY29uc3Qga3ViZSA9IHNlbGVjdG9yLl90b0t1YmUoKTtcbiAgICAgIHRoaXMuX21hdGNoRXhwcmVzc2lvbnMucHVzaCguLi5rdWJlLm1hdGNoRXhwcmVzc2lvbnMgPz8gW10pO1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoa3ViZS5tYXRjaExhYmVscyA/PyB7fSkpIHtcbiAgICAgICAgdGhpcy5fbWF0Y2hMYWJlbHNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbGFiZWwgbWF0Y2hlcnMgdGhpcyB3b3JrbG9hZCB3aWxsIHVzZSBpbiBvcmRlciB0byBzZWxlY3QgcG9kcy5cbiAgICpcbiAgICogUmV0dXJucyBhIGEgY29weS4gVXNlIGBzZWxlY3QoKWAgdG8gYWRkIGxhYmVsIG1hdGNoZXJzLlxuICAgKi9cbiAgcHVibGljIGdldCBtYXRjaExhYmVscygpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICByZXR1cm4geyAuLi50aGlzLl9tYXRjaExhYmVscyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBleHByZXNzaW9uIG1hdGNoZXJzIHRoaXMgd29ya2xvYWQgd2lsbCB1c2UgaW4gb3JkZXIgdG8gc2VsZWN0IHBvZHMuXG4gICAqXG4gICAqIFJldHVybnMgYSBhIGNvcHkuIFVzZSBgc2VsZWN0KClgIHRvIGFkZCBleHByZXNzaW9uIG1hdGNoZXJzLlxuICAgKi9cbiAgcHVibGljIGdldCBtYXRjaEV4cHJlc3Npb25zKCk6IExhYmVsU2VsZWN0b3JSZXF1aXJlbWVudFtdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuX21hdGNoRXhwcmVzc2lvbnNdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHVibGljIF90b0xhYmVsU2VsZWN0b3IoKTogazhzLkxhYmVsU2VsZWN0b3Ige1xuICAgIHJldHVybiB7XG4gICAgICBtYXRjaEV4cHJlc3Npb25zOiB1bmRlZmluZWRJZkVtcHR5KHRoaXMuX21hdGNoRXhwcmVzc2lvbnMpLFxuICAgICAgbWF0Y2hMYWJlbHM6IHVuZGVmaW5lZElmRW1wdHkodGhpcy5fbWF0Y2hMYWJlbHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgX3RvUG9kU3BlYygpOiBrOHMuUG9kU3BlYyB7XG4gICAgY29uc3Qgc2NoZWR1bGluZyA9IHRoaXMuc2NoZWR1bGluZy5fdG9LdWJlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLl90b1BvZFNwZWMoKSxcbiAgICAgIGFmZmluaXR5OiBzY2hlZHVsaW5nLmFmZmluaXR5LFxuICAgICAgbm9kZU5hbWU6IHNjaGVkdWxpbmcubm9kZU5hbWUsXG4gICAgICB0b2xlcmF0aW9uczogc2NoZWR1bGluZy50b2xlcmF0aW9ucyxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYFdvcmtsb2FkU2NoZWR1bGluZy5zcHJlYWRgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtsb2FkU2NoZWR1bGluZ1NwcmVhZE9wdGlvbnMge1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhlIHNwcmVhZCBpcyBvcHRpb25hbCwgd2l0aCB0aGlzIHdlaWdodCBzY29yZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBubyB3ZWlnaHQuIHNwcmVhZCBpcyBhc3N1bWVkIHRvIGJlIHJlcXVpcmVkLlxuICAgKi9cbiAgcmVhZG9ubHkgd2VpZ2h0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBXaGljaCB0b3BvbG9neSB0byBzcHJlYWQgb24uXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gVG9wb2xvZ3kuSE9TVE5BTUVcbiAgICovXG4gIHJlYWRvbmx5IHRvcG9sb2d5PzogcG9kLlRvcG9sb2d5O1xuXG59XG5cbi8qKlxuICogQ29udHJvbHMgdGhlIHBvZCBzY2hlZHVsaW5nIHN0cmF0ZWd5IG9mIHRoaXMgd29ya2xvYWQuXG4gKiBJdCBvZmZlcnMgc29tZSBhZGRpdGlvbmFsIEFQSSdzIG9uIHRvcCBvZiB0aGUgY29yZSBwb2Qgc2NoZWR1bGluZy5cbiAqL1xuZXhwb3J0IGNsYXNzIFdvcmtsb2FkU2NoZWR1bGluZyBleHRlbmRzIHBvZC5Qb2RTY2hlZHVsaW5nIHtcblxuICAvKipcbiAgICogU3ByZWFkIHRoZSBwb2RzIGluIHRoaXMgd29ya2xvYWQgYnkgdGhlIHRvcG9sb2d5IGtleS5cbiAgICogQSBzcHJlYWQgaXMgYSBzZXBhcmF0aW9uIG9mIHRoZSBwb2QgZnJvbSBpdHNlbGYgYW5kIGlzIHVzZWQgdG9cbiAgICogYmFsYW5jZSBvdXQgcG9kIHJlcGxpY2FzIGFjcm9zcyBhIGdpdmVuIHRvcG9sb2d5LlxuICAgKi9cbiAgcHVibGljIHNwcmVhZChvcHRpb25zOiBXb3JrbG9hZFNjaGVkdWxpbmdTcHJlYWRPcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnNlcGFyYXRlKHRoaXMuaW5zdGFuY2UsIHsgd2VpZ2h0OiBvcHRpb25zLndlaWdodCwgdG9wb2xvZ3k6IG9wdGlvbnMudG9wb2xvZ3kgPz8gcG9kLlRvcG9sb2d5LkhPU1ROQU1FIH0pO1xuICB9XG5cbn0iXX0=

/***/ }),

/***/ 3241:
/***/ ((module) => {


module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    if(a===b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),

/***/ 2530:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var concatMap = __nccwpck_require__(2750);
var balanced = __nccwpck_require__(3241);

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}



/***/ }),

/***/ 2750:
/***/ ((module) => {

module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ 7457:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = (function () { try { return __nccwpck_require__(1017) } catch (e) {}}()) || {
  sep: '/'
}
minimatch.sep = path.sep

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = __nccwpck_require__(2530)

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  b = b || {}
  var t = {}
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || typeof def !== 'object' || !Object.keys(def).length) {
    return minimatch
  }

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }
  m.Minimatch.defaults = function defaults (options) {
    return orig.defaults(ext(def, options)).Minimatch
  }

  m.filter = function filter (pattern, options) {
    return orig.filter(pattern, ext(def, options))
  }

  m.defaults = function defaults (options) {
    return orig.defaults(ext(def, options))
  }

  m.makeRe = function makeRe (pattern, options) {
    return orig.makeRe(pattern, ext(def, options))
  }

  m.braceExpand = function braceExpand (pattern, options) {
    return orig.braceExpand(pattern, ext(def, options))
  }

  m.match = function (list, pattern, options) {
    return orig.match(list, pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  assertValidPattern(pattern)

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  assertValidPattern(pattern)

  if (!options) options = {}

  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (!options.allowWindowsEscape && path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false
  this.partial = !!options.partial

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = function debug() { console.error.apply(console, arguments) }

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  assertValidPattern(pattern)

  // Thanks to Yeting Li <https://github.com/yetingli> for
  // improving this regexp to avoid a ReDOS vulnerability.
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

var MAX_PATTERN_LENGTH = 1024 * 64
var assertValidPattern = function (pattern) {
  if (typeof pattern !== 'string') {
    throw new TypeError('invalid pattern')
  }

  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError('pattern is too long')
  }
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  assertValidPattern(pattern)

  var options = this.options

  // shortcuts
  if (pattern === '**') {
    if (!options.noglobstar)
      return GLOBSTAR
    else
      pattern = '*'
  }
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      /* istanbul ignore next */
      case '/': {
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false
      }

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        // split where the last [ was, make sure we don't have
        // an invalid re. if so, re-walk the contents of the
        // would-be class to re-translate any characters that
        // were passed through as-is
        // TODO: It would probably be faster to determine this
        // without a try/catch and a new RegExp, but it's tricky
        // to do safely.  For now, this is safe and works.
        var cs = pattern.substring(classStart + 1, i)
        try {
          RegExp('[' + cs + ']')
        } catch (er) {
          // not a valid class!
          var sp = this.parse(cs, SUBPARSE)
          re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
          hasMagic = hasMagic || sp[1]
          inClass = false
          continue
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '[': case '.': case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) /* istanbul ignore next - should be impossible */ {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) /* istanbul ignore next - should be impossible */ {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = function match (f, partial) {
  if (typeof partial === 'undefined') partial = this.partial
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    /* istanbul ignore if */
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      /* istanbul ignore if */
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      hit = f === p
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else /* istanbul ignore else */ if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    return (fi === fl - 1) && (file[fi] === '')
  }

  // should be unreachable.
  /* istanbul ignore next */
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}


/***/ }),

/***/ 2580:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._child_process = void 0;
/****************************************************************************************
 * Expose `child_process` via our own object that can be easily patched by jest for tests.
 * Consumers of the `child_process` module should add functions to this object and import it
 * wherever needed.
 */
const child_process_1 = __nccwpck_require__(2081);
exports._child_process = {
    spawnSync: child_process_1.spawnSync,
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiX2NoaWxkX3Byb2Nlc3MuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvX2NoaWxkX3Byb2Nlc3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7Ozs7R0FJRztBQUNILGlEQUEwQztBQUU3QixRQUFBLGNBQWMsR0FBRztJQUM1QixTQUFTLEVBQUUseUJBQVM7Q0FDckIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBFeHBvc2UgYGNoaWxkX3Byb2Nlc3NgIHZpYSBvdXIgb3duIG9iamVjdCB0aGF0IGNhbiBiZSBlYXNpbHkgcGF0Y2hlZCBieSBqZXN0IGZvciB0ZXN0cy5cbiAqIENvbnN1bWVycyBvZiB0aGUgYGNoaWxkX3Byb2Nlc3NgIG1vZHVsZSBzaG91bGQgYWRkIGZ1bmN0aW9ucyB0byB0aGlzIG9iamVjdCBhbmQgaW1wb3J0IGl0XG4gKiB3aGVyZXZlciBuZWVkZWQuXG4gKi9cbmltcG9ydCB7IHNwYXduU3luYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuXG5leHBvcnQgY29uc3QgX2NoaWxkX3Byb2Nlc3MgPSB7XG4gIHNwYXduU3luYzogc3Bhd25TeW5jLFxufTtcbiJdfQ==

/***/ }),

/***/ 2667:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolve = void 0;
const lazy_1 = __nccwpck_require__(7664);
function resolve(value) {
    if (value == null) {
        return value;
    }
    // cdk8s token
    if (value instanceof lazy_1.Lazy) {
        const resolved = value.produce();
        return resolve(resolved);
    }
    // implicit token as generated by the cdk8s-cli (e.g IntOrString)
    if (typeof (value.resolve) === 'function') {
        const resolved = value.resolve();
        return resolve(resolved);
    }
    if (typeof (value) !== 'object') {
        return value;
    }
    if (Array.isArray(value)) {
        return value.map(x => resolve(x));
    }
    const result = {};
    for (const [k, v] of Object.entries(value)) {
        result[k] = resolve(v);
    }
    return result;
}
exports.resolve = resolve;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiX3Jlc29sdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvX3Jlc29sdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsaUNBQThCO0FBRTlCLFNBQWdCLE9BQU8sQ0FBQyxLQUFVO0lBRWhDLElBQUksS0FBSyxJQUFJLElBQUksRUFBRTtRQUNqQixPQUFPLEtBQUssQ0FBQztLQUNkO0lBRUQsY0FBYztJQUNkLElBQUksS0FBSyxZQUFZLFdBQUksRUFBRTtRQUN6QixNQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDakMsT0FBTyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7S0FDMUI7SUFFRCxpRUFBaUU7SUFDakUsSUFBSSxPQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLFVBQVUsRUFBRTtRQUN4QyxNQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDakMsT0FBTyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7S0FDMUI7SUFFRCxJQUFJLE9BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxRQUFRLEVBQUU7UUFDOUIsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUVELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUN4QixPQUFPLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNuQztJQUVELE1BQU0sTUFBTSxHQUFRLEVBQUUsQ0FBQztJQUV2QixLQUFLLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUMxQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3hCO0lBRUQsT0FBTyxNQUFNLENBQUM7QUFFaEIsQ0FBQztBQWxDRCwwQkFrQ0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMYXp5IH0gZnJvbSAnLi9sYXp5JztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmUodmFsdWU6IGFueSk6IGFueSB7XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvLyBjZGs4cyB0b2tlblxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMYXp5KSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSB2YWx1ZS5wcm9kdWNlKCk7XG4gICAgcmV0dXJuIHJlc29sdmUocmVzb2x2ZWQpO1xuICB9XG5cbiAgLy8gaW1wbGljaXQgdG9rZW4gYXMgZ2VuZXJhdGVkIGJ5IHRoZSBjZGs4cy1jbGkgKGUuZyBJbnRPclN0cmluZylcbiAgaWYgKHR5cGVvZih2YWx1ZS5yZXNvbHZlKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IHJlc29sdmVkID0gdmFsdWUucmVzb2x2ZSgpO1xuICAgIHJldHVybiByZXNvbHZlKHJlc29sdmVkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YodmFsdWUpICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5tYXAoeCA9PiByZXNvbHZlKHgpKTtcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdDogYW55ID0ge307XG5cbiAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgcmVzdWx0W2tdID0gcmVzb2x2ZSh2KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG5cbn1cbiJdfQ==

/***/ }),

/***/ 4898:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sanitizeValue = void 0;
function sanitizeValue(obj, options = {}) {
    var _a;
    if (obj == null) {
        return undefined;
    }
    if (typeof (obj) !== 'object') {
        return obj;
    }
    if (Array.isArray(obj)) {
        if (options.filterEmptyArrays && obj.length === 0) {
            return undefined;
        }
        return obj.map(x => sanitizeValue(x, options));
    }
    if (obj.constructor.name !== 'Object') {
        throw new Error(`can't render non-simple object of type '${obj.constructor.name}'`);
    }
    const newObj = {};
    const sortKeys = (_a = options.sortKeys) !== null && _a !== void 0 ? _a : true;
    const keys = sortKeys ? Object.keys(obj).sort() : Object.keys(obj);
    for (const key of keys) {
        const value = obj[key];
        const newValue = sanitizeValue(value, options);
        if (newValue != null) {
            newObj[key] = newValue;
        }
    }
    if (options.filterEmptyObjects && Object.keys(newObj).length === 0) {
        return undefined;
    }
    return newObj;
}
exports.sanitizeValue = sanitizeValue;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiX3V0aWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvX3V0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBb0JBLFNBQWdCLGFBQWEsQ0FBQyxHQUFRLEVBQUUsVUFBMkIsRUFBRzs7SUFDcEUsSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFO1FBQ2YsT0FBTyxTQUFTLENBQUM7S0FDbEI7SUFFRCxJQUFJLE9BQU0sQ0FBQyxHQUFHLENBQUMsS0FBSyxRQUFRLEVBQUU7UUFDNUIsT0FBTyxHQUFHLENBQUM7S0FDWjtJQUVELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUV0QixJQUFJLE9BQU8sQ0FBQyxpQkFBaUIsSUFBSSxHQUFHLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUNqRCxPQUFPLFNBQVMsQ0FBQztTQUNsQjtRQUVELE9BQU8sR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztLQUNoRDtJQUVELElBQUksR0FBRyxDQUFDLFdBQVcsQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO1FBQ3JDLE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLEdBQUcsQ0FBQyxXQUFXLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztLQUNyRjtJQUVELE1BQU0sTUFBTSxHQUEyQixFQUFHLENBQUM7SUFFM0MsTUFBTSxRQUFRLFNBQUcsT0FBTyxDQUFDLFFBQVEsbUNBQUksSUFBSSxDQUFDO0lBQzFDLE1BQU0sSUFBSSxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNuRSxLQUFLLE1BQU0sR0FBRyxJQUFJLElBQUksRUFBRTtRQUN0QixNQUFNLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdkIsTUFBTSxRQUFRLEdBQUcsYUFBYSxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQztRQUMvQyxJQUFJLFFBQVEsSUFBSSxJQUFJLEVBQUU7WUFDcEIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQztTQUN4QjtLQUNGO0lBRUQsSUFBSSxPQUFPLENBQUMsa0JBQWtCLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ2xFLE9BQU8sU0FBUyxDQUFDO0tBQ2xCO0lBRUQsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQXZDRCxzQ0F1Q0MiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIFNhbml0aXplT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBEbyBub3QgaW5jbHVkZSBlbXB0eSBvYmplY3RzIChubyBrZXlzKS5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IGZpbHRlckVtcHR5T2JqZWN0cz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIERvIG5vdCBpbmNsdWRlIGFycmF5cyB3aXRoIG5vIGl0ZW1zLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgZmlsdGVyRW1wdHlBcnJheXM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBTb3J0IGRpY3Rpb25hcnkga2V5cy5cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgc29ydEtleXM/OiBib29sZWFuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVWYWx1ZShvYmo6IGFueSwgb3B0aW9uczogU2FuaXRpemVPcHRpb25zID0geyB9KTogYW55IHtcbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Yob2JqKSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuXG4gICAgaWYgKG9wdGlvbnMuZmlsdGVyRW1wdHlBcnJheXMgJiYgb2JqLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqLm1hcCh4ID0+IHNhbml0aXplVmFsdWUoeCwgb3B0aW9ucykpO1xuICB9XG5cbiAgaWYgKG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnT2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcihgY2FuJ3QgcmVuZGVyIG5vbi1zaW1wbGUgb2JqZWN0IG9mIHR5cGUgJyR7b2JqLmNvbnN0cnVjdG9yLm5hbWV9J2ApO1xuICB9XG5cbiAgY29uc3QgbmV3T2JqOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0geyB9O1xuXG4gIGNvbnN0IHNvcnRLZXlzID0gb3B0aW9ucy5zb3J0S2V5cyA/PyB0cnVlO1xuICBjb25zdCBrZXlzID0gc29ydEtleXMgPyBPYmplY3Qua2V5cyhvYmopLnNvcnQoKSA6IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gc2FuaXRpemVWYWx1ZSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgaWYgKG5ld1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIG5ld09ialtrZXldID0gbmV3VmFsdWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuZmlsdGVyRW1wdHlPYmplY3RzICYmIE9iamVjdC5rZXlzKG5ld09iaikubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBuZXdPYmo7XG59XG4iXX0=

/***/ }),

/***/ 4752:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiObject = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const constructs_1 = __nccwpck_require__(1963);
const _resolve_1 = __nccwpck_require__(2667);
const _util_1 = __nccwpck_require__(4898);
const chart_1 = __nccwpck_require__(2297);
const json_patch_1 = __nccwpck_require__(4768);
const metadata_1 = __nccwpck_require__(8041);
class ApiObject extends constructs_1.Construct {
    /**
     * Defines an API object.
     *
     * @param scope the construct scope
     * @param id namespace
     * @param props options
     */
    constructor(scope, id, props) {
        var _b, _c, _d, _e, _f;
        super(scope, id);
        this.props = props;
        this.patches = new Array();
        this.chart = chart_1.Chart.of(this);
        this.kind = props.kind;
        this.apiVersion = props.apiVersion;
        this.apiGroup = parseApiGroup(this.apiVersion);
        this.name = (_c = (_b = props.metadata) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : this.chart.generateObjectName(this);
        this.metadata = new metadata_1.ApiObjectMetadataDefinition({
            name: this.name,
            // user defined values
            ...props.metadata,
            namespace: (_e = (_d = props.metadata) === null || _d === void 0 ? void 0 : _d.namespace) !== null && _e !== void 0 ? _e : this.chart.namespace,
            labels: {
                ...this.chart.labels,
                ...(_f = props.metadata) === null || _f === void 0 ? void 0 : _f.labels,
            },
        });
    }
    /**
     * Returns the `ApiObject` named `Resource` which is a child of the given
     * construct. If `c` is an `ApiObject`, it is returned directly. Throws an
     * exception if the construct does not have a child named `Default` _or_ if
     * this child is not an `ApiObject`.
     *
     * @param c The higher-level construct
     */
    static of(c) {
        if (c instanceof ApiObject) {
            return c;
        }
        const child = constructs_1.Node.of(c).defaultChild;
        if (!child) {
            throw new Error(`cannot find a (direct or indirect) child of type ApiObject for construct ${constructs_1.Node.of(c).path}`);
        }
        return ApiObject.of(child);
    }
    /**
     * Create a dependency between this ApiObject and other constructs.
     * These can be other ApiObjects, Charts, or custom.
     *
     * @param dependencies the dependencies to add.
     */
    addDependency(...dependencies) {
        constructs_1.Node.of(this).addDependency(...dependencies);
    }
    /**
     * Applies a set of RFC-6902 JSON-Patch operations to the manifest
     * synthesized for this API object.
     *
     * @param ops The JSON-Patch operations to apply.
     *
     * @example
     *
     *   kubePod.addJsonPatch(JsonPatch.replace('/spec/enableServiceLinks', true));
     *
     */
    addJsonPatch(...ops) {
        this.patches.push(...ops);
    }
    /**
     * Renders the object to Kubernetes JSON.
     *
     * To disable sorting of dictionary keys in output object set the
     * `CDK8S_DISABLE_SORT` environment variable to any non-empty value.
     */
    toJson() {
        const data = {
            ...this.props,
            metadata: this.metadata.toJson(),
        };
        const sortKeys = process.env.CDK8S_DISABLE_SORT ? false : true;
        const json = _util_1.sanitizeValue(_resolve_1.resolve(data), { sortKeys });
        const patched = json_patch_1.JsonPatch.apply(json, ...this.patches);
        // reorder top-level keys so that we first have "apiVersion", "kind" and
        // "metadata" and then all the rest
        const result = {};
        const orderedKeys = ['apiVersion', 'kind', 'metadata', ...Object.keys(patched)];
        for (const k of orderedKeys) {
            if (k in patched) {
                result[k] = patched[k];
            }
        }
        return result;
    }
}
exports.ApiObject = ApiObject;
_a = JSII_RTTI_SYMBOL_1;
ApiObject[_a] = { fqn: "cdk8s.ApiObject", version: "2.3.11" };
function parseApiGroup(apiVersion) {
    const v = apiVersion.split('/');
    // no group means "core"
    // https://kubernetes.io/docs/reference/using-api/api-overview/#api-groups
    if (v.length === 1) {
        return 'core';
    }
    if (v.length === 2) {
        return v[0];
    }
    throw new Error(`invalid apiVersion ${apiVersion}, expecting GROUP/VERSION. See https://kubernetes.io/docs/reference/using-api/api-overview/#api-groups`);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBpLW9iamVjdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9hcGktb2JqZWN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsMkNBQXlEO0FBQ3pELHlDQUFxQztBQUNyQyxtQ0FBd0M7QUFDeEMsbUNBQWdDO0FBQ2hDLDZDQUF5QztBQUN6Qyx5Q0FBNEU7QUEwQzVFLE1BQWEsU0FBVSxTQUFRLHNCQUFTO0lBOER0Qzs7Ozs7O09BTUc7SUFDSCxZQUFZLEtBQWdCLEVBQUUsRUFBVSxFQUFtQixLQUFxQjs7UUFDOUUsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUR3QyxVQUFLLEdBQUwsS0FBSyxDQUFnQjtRQUU5RSxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksS0FBSyxFQUFhLENBQUM7UUFDdEMsSUFBSSxDQUFDLEtBQUssR0FBRyxhQUFLLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzVCLElBQUksQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQztRQUN2QixJQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUM7UUFDbkMsSUFBSSxDQUFDLFFBQVEsR0FBRyxhQUFhLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRS9DLElBQUksQ0FBQyxJQUFJLGVBQUcsS0FBSyxDQUFDLFFBQVEsMENBQUUsSUFBSSxtQ0FBSSxJQUFJLENBQUMsS0FBSyxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXhFLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxzQ0FBMkIsQ0FBQztZQUM5QyxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7WUFFZixzQkFBc0I7WUFDdEIsR0FBRyxLQUFLLENBQUMsUUFBUTtZQUVqQixTQUFTLGNBQUUsS0FBSyxDQUFDLFFBQVEsMENBQUUsU0FBUyxtQ0FBSSxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVM7WUFDNUQs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ZnJvbSAnY29uc3RydWN0cyc7XG5pbXBvcnQgeyByZXNvbHZlIH0gZnJvbSAnLi9fcmVzb2x2ZSc7XG5pbXBvcnQgeyBzYW5pdGl6ZVZhbHVlIH0gZnJvbSAnLi9fdXRpbCc7XG5pbXBvcnQgeyBDaGFydCB9IGZyb20gJy4vY2hhcnQnO1xuaW1wb3J0IHsgSnNvblBhdGNoIH0gZnJvbSAnLi9qc29uLXBhdGNoJztcbmltcG9ydCB7IEFwaU9iamVjdE1ldGFkYXRhLCBBcGlPYmplY3RNZXRhZGF0YURlZmluaXRpb24gfSBmcm9tICcuL21ldGFkYXRhJztcblxuLyoqXG4gKiBPcHRpb25zIGZvciBkZWZpbmluZyBBUEkgb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBcGlPYmplY3RQcm9wcyB7XG4gIC8qKlxuICAgKiBPYmplY3QgbWV0YWRhdGEuXG4gICAqXG4gICAqIElmIGBuYW1lYCBpcyBub3Qgc3BlY2lmaWVkLCBhbiBhcHAtdW5pcXVlIG5hbWUgd2lsbCBiZSBhbGxvY2F0ZWQgYnkgdGhlXG4gICAqIGZyYW1ld29yayBiYXNlZCBvbiB0aGUgcGF0aCBvZiB0aGUgY29uc3RydWN0IHdpdGhpbiB0aGVzIGNvbnN0cnVjdCB0cmVlLlxuICAgKi9cbiAgcmVhZG9ubHkgbWV0YWRhdGE/OiBBcGlPYmplY3RNZXRhZGF0YTtcblxuICAvKipcbiAgICogQVBJIHZlcnNpb24uXG4gICAqL1xuICByZWFkb25seSBhcGlWZXJzaW9uOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFJlc291cmNlIGtpbmQuXG4gICAqL1xuICByZWFkb25seSBraW5kOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFkZGl0aW9uYWwgYXR0cmlidXRlcyBmb3IgdGhpcyBBUEkgb2JqZWN0LlxuICAgKi9cbiAgcmVhZG9ubHkgW2tleTogc3RyaW5nXTogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdyb3VwVmVyc2lvbktpbmQge1xuICAvKipcbiAgICogVGhlIG9iamVjdCdzIEFQSSB2ZXJzaW9uIChlLmcuIGBhdXRob3JpemF0aW9uLms4cy5pby92MWApXG4gICAqL1xuICByZWFkb25seSBhcGlWZXJzaW9uOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3Qga2luZC5cbiAgICovXG4gIHJlYWRvbmx5IGtpbmQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIEFwaU9iamVjdCBleHRlbmRzIENvbnN0cnVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgQXBpT2JqZWN0YCBuYW1lZCBgUmVzb3VyY2VgIHdoaWNoIGlzIGEgY2hpbGQgb2YgdGhlIGdpdmVuXG4gICAqIGNvbnN0cnVjdC4gSWYgYGNgIGlzIGFuIGBBcGlPYmplY3RgLCBpdCBpcyByZXR1cm5lZCBkaXJlY3RseS4gVGhyb3dzIGFuXG4gICAqIGV4Y2VwdGlvbiBpZiB0aGUgY29uc3RydWN0IGRvZXMgbm90IGhhdmUgYSBjaGlsZCBuYW1lZCBgRGVmYXVsdGAgX29yXyBpZlxuICAgKiB0aGlzIGNoaWxkIGlzIG5vdCBhbiBgQXBpT2JqZWN0YC5cbiAgICpcbiAgICogQHBhcmFtIGMgVGhlIGhpZ2hlci1sZXZlbCBjb25zdHJ1Y3RcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgb2YoYzogSUNvbnN0cnVjdCk6IEFwaU9iamVjdCB7XG4gICAgaWYgKGMgaW5zdGFuY2VvZiBBcGlPYmplY3QpIHtcbiAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIGNvbnN0IGNoaWxkID0gTm9kZS5vZihjKS5kZWZhdWx0Q2hpbGQ7XG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZmluZCBhIChkaXJlY3Qgb3IgaW5kaXJlY3QpIGNoaWxkIG9mIHR5cGUgQXBpT2JqZWN0IGZvciBjb25zdHJ1Y3QgJHtOb2RlLm9mKGMpLnBhdGh9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEFwaU9iamVjdC5vZihjaGlsZCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIEFQSSBvYmplY3QuXG4gICAqXG4gICAqIElmIGEgbmFtZSBpcyBzcGVjaWZpZWQgaW4gYG1ldGFkYXRhLm5hbWVgIHRoaXMgd2lsbCBiZSB0aGUgbmFtZSByZXR1cm5lZC5cbiAgICogT3RoZXJ3aXNlLCBhIG5hbWUgd2lsbCBiZSBnZW5lcmF0ZWQgYnkgY2FsbGluZ1xuICAgKiBgQ2hhcnQub2YodGhpcykuZ2VuZXJhdGVkT2JqZWN0TmFtZSh0aGlzKWAsIHdoaWNoIGJ5IGRlZmF1bHQgdXNlcyB0aGVcbiAgICogY29uc3RydWN0IHBhdGggdG8gZ2VuZXJhdGUgYSBETlMtY29tcGF0aWJsZSBuYW1lIGZvciB0aGUgcmVzb3VyY2UuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0J3MgQVBJIHZlcnNpb24gKGUuZy4gYGF1dGhvcml6YXRpb24uazhzLmlvL3YxYClcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBhcGlWZXJzaW9uOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBncm91cCBwb3J0aW9uIG9mIHRoZSBBUEkgdmVyc2lvbiAoZS5nLiBgYXV0aG9yaXphdGlvbi5rOHMuaW9gKVxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGFwaUdyb3VwOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3Qga2luZC5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBraW5kOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBjaGFydCBpbiB3aGljaCB0aGlzIG9iamVjdCBpcyBkZWZpbmVkLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGNoYXJ0OiBDaGFydDtcblxuICAvKipcbiAgICogTWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgQVBJIG9iamVjdC5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBtZXRhZGF0YTogQXBpT2JqZWN0TWV0YWRhdGFEZWZpbml0aW9uO1xuXG4gIC8qKlxuICAgKiBBIHNldCBvZiBKU09OIHBhdGNoIG9wZXJhdGlvbnMgdG8gYXBwbHkgdG8gdGhlIGRvY3VtZW50IGFmdGVyIHN5bnRoZXNpcy5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgcGF0Y2hlczogQXJyYXk8SnNvblBhdGNoPjtcblxuICAvKipcbiAgICogRGVmaW5lcyBhbiBBUEkgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gc2NvcGUgdGhlIGNvbnN0cnVjdCBzY29wZVxuICAgKiBAcGFyYW0gaWQgbmFtZXNwYWNlXG4gICAqIEBwYXJhbSBwcm9wcyBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcml2YXRlIHJlYWRvbmx5IHByb3BzOiBBcGlPYmplY3RQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCk7XG4gICAgdGhpcy5wYXRjaGVzID0gbmV3IEFycmF5PEpzb25QYXRjaD4oKTtcbiAgICB0aGlzLmNoYXJ0ID0gQ2hhcnQub2YodGhpcyk7XG4gICAgdGhpcy5raW5kID0gcHJvcHMua2luZDtcbiAgICB0aGlzLmFwaVZlcnNpb24gPSBwcm9wcy5hcGlWZXJzaW9uO1xuICAgIHRoaXMuYXBpR3JvdXAgPSBwYXJzZUFwaUdyb3VwKHRoaXMuYXBpVmVyc2lvbik7XG5cbiAgICB0aGlzLm5hbWUgPSBwcm9wcy5tZXRhZGF0YT8ubmFtZSA/PyB0aGlzLmNoYXJ0LmdlbmVyYXRlT2JqZWN0TmFtZSh0aGlzKTtcblxuICAgIHRoaXMubWV0YWRhdGEgPSBuZXcgQXBpT2JqZWN0TWV0YWRhdGFEZWZpbml0aW9uKHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcblxuICAgICAgLy8gdXNlciBkZWZpbmVkIHZhbHVlc1xuICAgICAgLi4ucHJvcHMubWV0YWRhdGEsXG5cbiAgICAgIG5hbWVzcGFjZTogcHJvcHMubWV0YWRhdGE/Lm5hbWVzcGFjZSA/PyB0aGlzLmNoYXJ0Lm5hbWVzcGFjZSxcbiAgICAgIGxhYmVsczoge1xuICAgICAgICAuLi50aGlzLmNoYXJ0LmxhYmVscyxcbiAgICAgICAgLi4ucHJvcHMubWV0YWRhdGE/LmxhYmVscyxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgZGVwZW5kZW5jeSBiZXR3ZWVuIHRoaXMgQXBpT2JqZWN0IGFuZCBvdGhlciBjb25zdHJ1Y3RzLlxuICAgKiBUaGVzZSBjYW4gYmUgb3RoZXIgQXBpT2JqZWN0cywgQ2hhcnRzLCBvciBjdXN0b20uXG4gICAqXG4gICAqIEBwYXJhbSBkZXBlbmRlbmNpZXMgdGhlIGRlcGVuZGVuY2llcyB0byBhZGQuXG4gICAqL1xuICBwdWJsaWMgYWRkRGVwZW5kZW5jeSguLi5kZXBlbmRlbmNpZXM6IElDb25zdHJ1Y3RbXSkge1xuICAgIE5vZGUub2YodGhpcykuYWRkRGVwZW5kZW5jeSguLi5kZXBlbmRlbmNpZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSBzZXQgb2YgUkZDLTY5MDIgSlNPTi1QYXRjaCBvcGVyYXRpb25zIHRvIHRoZSBtYW5pZmVzdFxuICAgKiBzeW50aGVzaXplZCBmb3IgdGhpcyBBUEkgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gb3BzIFRoZSBKU09OLVBhdGNoIG9wZXJhdGlvbnMgdG8gYXBwbHkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAga3ViZVBvZC5hZGRKc29uUGF0Y2goSnNvblBhdGNoLnJlcGxhY2UoJy9zcGVjL2VuYWJsZVNlcnZpY2VMaW5rcycsIHRydWUpKTtcbiAgICpcbiAgICovXG4gIHB1YmxpYyBhZGRKc29uUGF0Y2goLi4ub3BzOiBKc29uUGF0Y2hbXSkge1xuICAgIHRoaXMucGF0Y2hlcy5wdXNoKC4uLm9wcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIEt1YmVybmV0ZXMgSlNPTi5cbiAgICpcbiAgICogVG8gZGlzYWJsZSBzb3J0aW5nIG9mIGRpY3Rpb25hcnkga2V5cyBpbiBvdXRwdXQgb2JqZWN0IHNldCB0aGVcbiAgICogYENESzhTX0RJU0FCTEVfU09SVGAgZW52aXJvbm1lbnQgdmFyaWFibGUgdG8gYW55IG5vbi1lbXB0eSB2YWx1ZS5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKTogYW55IHtcbiAgICBjb25zdCBkYXRhOiBhbnkgPSB7XG4gICAgICAuLi50aGlzLnByb3BzLFxuICAgICAgbWV0YWRhdGE6IHRoaXMubWV0YWRhdGEudG9Kc29uKCksXG4gICAgfTtcblxuICAgIGNvbnN0IHNvcnRLZXlzID0gcHJvY2Vzcy5lbnYuQ0RLOFNfRElTQUJMRV9TT1JUID8gZmFsc2UgOiB0cnVlO1xuICAgIGNvbnN0IGpzb24gPSBzYW5pdGl6ZVZhbHVlKHJlc29sdmUoZGF0YSksIHsgc29ydEtleXMgfSk7XG4gICAgY29uc3QgcGF0Y2hlZCA9IEpzb25QYXRjaC5hcHBseShqc29uLCAuLi50aGlzLnBhdGNoZXMpO1xuXG4gICAgLy8gcmVvcmRlciB0b3AtbGV2ZWwga2V5cyBzbyB0aGF0IHdlIGZpcnN0IGhhdmUgXCJhcGlWZXJzaW9uXCIsIFwia2luZFwiIGFuZFxuICAgIC8vIFwibWV0YWRhdGFcIiBhbmQgdGhlbiBhbGwgdGhlIHJlc3RcbiAgICBjb25zdCByZXN1bHQ6IGFueSA9IHt9O1xuICAgIGNvbnN0IG9yZGVyZWRLZXlzID0gWydhcGlWZXJzaW9uJywgJ2tpbmQnLCAnbWV0YWRhdGEnLCAuLi5PYmplY3Qua2V5cyhwYXRjaGVkKV07XG4gICAgZm9yIChjb25zdCBrIG9mIG9yZGVyZWRLZXlzKSB7XG4gICAgICBpZiAoayBpbiBwYXRjaGVkKSB7XG4gICAgICAgIHJlc3VsdFtrXSA9IHBhdGNoZWRba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUFwaUdyb3VwKGFwaVZlcnNpb246IHN0cmluZykge1xuICBjb25zdCB2ID0gYXBpVmVyc2lvbi5zcGxpdCgnLycpO1xuXG4gIC8vIG5vIGdyb3VwIG1lYW5zIFwiY29yZVwiXG4gIC8vIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL3JlZmVyZW5jZS91c2luZy1hcGkvYXBpLW92ZXJ2aWV3LyNhcGktZ3JvdXBzXG4gIGlmICh2Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiAnY29yZSc7XG4gIH1cblxuICBpZiAodi5sZW5ndGggPT09IDIpIHtcbiAgICByZXR1cm4gdlswXTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhcGlWZXJzaW9uICR7YXBpVmVyc2lvbn0sIGV4cGVjdGluZyBHUk9VUC9WRVJTSU9OLiBTZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvcmVmZXJlbmNlL3VzaW5nLWFwaS9hcGktb3ZlcnZpZXcvI2FwaS1ncm91cHNgKTtcbn1cbiJdfQ==

/***/ }),

/***/ 4333:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.App = exports.YamlOutputType = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const fs = __nccwpck_require__(7147);
const path = __nccwpck_require__(1017);
const constructs_1 = __nccwpck_require__(1963);
const api_object_1 = __nccwpck_require__(4752);
const chart_1 = __nccwpck_require__(2297);
const dependency_1 = __nccwpck_require__(6653);
const names_1 = __nccwpck_require__(3948);
const yaml_1 = __nccwpck_require__(5096);
/** The method to divide YAML output into files */
var YamlOutputType;
(function (YamlOutputType) {
    /** All resources are output into a single YAML file */
    YamlOutputType[YamlOutputType["FILE_PER_APP"] = 0] = "FILE_PER_APP";
    /** Resources are split into seperate files by chart */
    YamlOutputType[YamlOutputType["FILE_PER_CHART"] = 1] = "FILE_PER_CHART";
    /** Each resource is output to its own file */
    YamlOutputType[YamlOutputType["FILE_PER_RESOURCE"] = 2] = "FILE_PER_RESOURCE";
    /** Each chart in its own folder and each resource in its own file */
    YamlOutputType[YamlOutputType["FOLDER_PER_CHART_FILE_PER_RESOURCE"] = 3] = "FOLDER_PER_CHART_FILE_PER_RESOURCE";
})(YamlOutputType = exports.YamlOutputType || (exports.YamlOutputType = {}));
/**
 * Represents a cdk8s application.
 */
class App extends constructs_1.Construct {
    /**
     * Defines an app
     * @param props configuration options
     */
    constructor(props = {}) {
        var _b, _c, _d, _e;
        super(undefined, '');
        this.outdir = (_c = (_b = props.outdir) !== null && _b !== void 0 ? _b : process.env.CDK8S_OUTDIR) !== null && _c !== void 0 ? _c : 'dist';
        this.outputFileExtension = (_d = props.outputFileExtension) !== null && _d !== void 0 ? _d : '.k8s.yaml';
        this.yamlOutputType = (_e = props.yamlOutputType) !== null && _e !== void 0 ? _e : YamlOutputType.FILE_PER_CHART;
    }
    /**
     * Synthesize a single chart.
     *
     * Each element returned in the resulting array represents a different ApiObject
     * in the scope of the chart.
     *
     * Note that the returned array order is important. It is determined by the various dependencies between
     * the constructs in the chart, where the first element is the one without dependencies, and so on...
     *
     * @returns An array of JSON objects.
     * @param chart the chart to synthesize.
     * @internal
     */
    static _synthChart(chart) {
        const app = App.of(chart);
        // we must prepare the entire app before synthesizing the chart
        // because the dependency inference happens on the app level.
        resolveDependencies(app);
        // validate the app since we want to call onValidate of the relevant constructs.
        // note this will also call onValidate on constructs from possibly different charts,
        // but thats ok too since we no longer treat constructs as a self-contained synthesis unit.
        validate(app);
        return chartToKube(chart).map(obj => obj.toJson());
    }
    static of(c) {
        const scope = constructs_1.Node.of(c).scope;
        if (!scope) {
            // the app is the only construct without a scope.
            return c;
        }
        return App.of(scope);
    }
    /**
     * Returns all the charts in this app, sorted topologically.
     */
    get charts() {
        const isChart = (x) => x instanceof chart_1.Chart;
        return new dependency_1.DependencyGraph(constructs_1.Node.of(this))
            .topology()
            .filter(isChart);
    }
    /**
     * Synthesizes all manifests to the output directory
     */
    synth() {
        fs.mkdirSync(this.outdir, { recursive: true });
        // Since we plan on removing the distributed synth mechanism, we no longer call `Node.synthesize`, but rather simply implement
        // the necessary operations. We do however want to preserve the distributed validation.
        validate(this);
        // this is kind of sucky, eventually I would like the DependencyGraph
        // to be able to answer this question.
        const hasDependantCharts = resolveDependencies(this);
        const charts = this.charts;
        switch (this.yamlOutputType) {
            case YamlOutputType.FILE_PER_APP:
                let apiObjectList = [];
                for (const chart of charts) {
                    apiObjectList.push(...chartToKube(chart));
                }
                if (charts.length > 0) {
                    yaml_1.Yaml.save(path.join(this.outdir, `app${this.outputFileExtension}`), // There is no "app name", so we just hardcode the file name
                    apiObjectList.map((apiObject) => apiObject.toJson()));
                }
                break;
            case YamlOutputType.FILE_PER_CHART:
                const namer = hasDependantCharts ? new IndexedChartNamer() : new SimpleChartNamer();
                for (const chart of charts) {
                    const chartName = namer.name(chart);
                    const objects = chartToKube(chart);
                    yaml_1.Yaml.save(path.join(this.outdir, chartName + this.outputFileExtension), objects.map(obj => obj.toJson()));
                }
                break;
            case YamlOutputType.FILE_PER_RESOURCE:
                for (const chart of charts) {
                    const apiObjects = chartToKube(chart);
                    apiObjects.forEach((apiObject) => {
                        if (!(apiObject === undefined)) {
                            const fileName = `${`${apiObject.kind}.${apiObject.metadata.name}`
                                .replace(/[^0-9a-zA-Z-_.]/g, '')}`;
                            yaml_1.Yaml.save(path.join(this.outdir, fileName + this.outputFileExtension), [apiObject.toJson()]);
                        }
                    });
                }
                break;
            case YamlOutputType.FOLDER_PER_CHART_FILE_PER_RESOURCE:
                const folderNamer = hasDependantCharts ? new IndexedChartFolderNamer() : new SimpleChartFolderNamer();
                for (const chart of charts) {
                    const chartName = folderNamer.name(chart);
                    const apiObjects = chartToKube(chart);
                    const fullOutDir = path.join(this.outdir, chartName);
                    fs.mkdirSync(fullOutDir, { recursive: true });
                    apiObjects.forEach((apiObject) => {
                        if (!(apiObject === undefined)) {
                            const fileName = `${`${apiObject.kind}.${apiObject.metadata.name}`
                                .replace(/[^0-9a-zA-Z-_.]/g, '')}`;
                            yaml_1.Yaml.save(path.join(fullOutDir, fileName + this.outputFileExtension), [apiObject.toJson()]);
                        }
                    });
                }
                break;
            default:
                break;
        }
    }
    /**
     * Synthesizes the app into a YAML string.
     *
     * @returns A string with all YAML objects across all charts in this app.
     */
    synthYaml() {
        validate(this);
        const charts = this.charts;
        const docs = [];
        for (const chart of charts) {
            const apiObjects = chartToKube(chart);
            docs.push(...apiObjects.map(apiObject => apiObject.toJson()));
        }
        return yaml_1.Yaml.stringify(...docs);
    }
}
exports.App = App;
_a = JSII_RTTI_SYMBOL_1;
App[_a] = { fqn: "cdk8s.App", version: "2.3.11" };
function validate(app) {
    const errors = [];
    for (const child of app.node.findAll()) {
        const childErrors = child.node.validate();
        for (const error of childErrors) {
            errors.push(`[${child.node.path}] ${error}`);
        }
    }
    if (errors.length > 0) {
        throw new Error(`Validation failed with the following errors:\n  ${errors.join('\n  ')}`);
    }
}
function resolveDependencies(app) {
    let hasDependantCharts = false;
    const deps = [];
    for (const child of app.node.findAll()) {
        for (const dep of child.node.dependencies) {
            deps.push({ source: child, target: dep });
        }
    }
    for (const dep of deps) {
        // create explicit api object dependencies from implicit construct dependencies
        const targetApiObjects = constructs_1.Node.of(dep.target).findAll().filter(c => c instanceof api_object_1.ApiObject);
        const sourceApiObjects = constructs_1.Node.of(dep.source).findAll().filter(c => c instanceof api_object_1.ApiObject);
        for (const target of targetApiObjects) {
            for (const source of sourceApiObjects) {
                if (target !== source) {
                    constructs_1.Node.of(source).addDependency(target);
                }
            }
        }
        // create an explicit chart dependency from implicit construct dependencies
        const sourceChart = chart_1.Chart.of(dep.source);
        const targetChart = chart_1.Chart.of(dep.target);
        if (sourceChart !== targetChart) {
            constructs_1.Node.of(sourceChart).addDependency(targetChart);
            hasDependantCharts = true;
        }
    }
    const charts = new dependency_1.DependencyGraph(constructs_1.Node.of(app)).topology()
        .filter(x => x instanceof chart_1.Chart);
    for (const parentChart of charts) {
        for (const childChart of constructs_1.Node.of(parentChart).children.filter(x => x instanceof chart_1.Chart)) {
            // create an explicit chart dependency from nested chart relationships
            constructs_1.Node.of(parentChart).addDependency(childChart);
            hasDependantCharts = true;
        }
    }
    return hasDependantCharts;
}
function chartToKube(chart) {
    return new dependency_1.DependencyGraph(constructs_1.Node.of(chart)).topology()
        .filter(x => x instanceof api_object_1.ApiObject)
        .filter(x => chart_1.Chart.of(x) === chart) // include an object only in its closest parent chart
        .map(x => x);
}
class SimpleChartNamer {
    constructor() {
    }
    name(chart) {
        return `${names_1.Names.toDnsLabel(chart)}`;
    }
}
class IndexedChartNamer extends SimpleChartNamer {
    constructor() {
        super();
        this.index = 0;
    }
    name(chart) {
        const name = `${this.index.toString().padStart(4, '0')}-${super.name(chart)}`;
        this.index++;
        return name;
    }
}
class SimpleChartFolderNamer {
    constructor() {
    }
    name(chart) {
        return names_1.Names.toDnsLabel(chart);
    }
}
class IndexedChartFolderNamer extends SimpleChartFolderNamer {
    constructor() {
        super();
        this.index = 0;
    }
    name(chart) {
        const name = `${this.index.toString().padStart(4, '0')}-${super.name(chart)}`;
        this.index++;
        return name;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2FwcC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0IsMkNBQXlEO0FBQ3pELDZDQUF5QztBQUN6QyxtQ0FBZ0M7QUFDaEMsNkNBQStDO0FBQy9DLG1DQUFnQztBQUNoQyxpQ0FBOEI7QUFFOUIsa0RBQWtEO0FBQ2xELElBQVksY0FTWDtBQVRELFdBQVksY0FBYztJQUN4Qix1REFBdUQ7SUFDdkQsbUVBQVksQ0FBQTtJQUNaLHVEQUF1RDtJQUN2RCx1RUFBYyxDQUFBO0lBQ2QsOENBQThDO0lBQzlDLDZFQUFpQixDQUFBO0lBQ2pCLHFFQUFxRTtJQUNyRSwrR0FBa0MsQ0FBQTtBQUNwQyxDQUFDLEVBVFcsY0FBYyxHQUFkLHNCQUFjLEtBQWQsc0JBQWMsUUFTekI7QUFxQkQ7O0dBRUc7QUFDSCxNQUFhLEdBQUksU0FBUSxzQkFBUztJQW9FaEM7OztPQUdHO0lBQ0gsWUFBWSxRQUFrQixFQUFHOztRQUMvQixLQUFLLENBQUMsU0FBZ0IsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUM1QixJQUFJLENBQUMsTUFBTSxlQUFHLEtBQUssQ0FBQyxNQUFNLG1DQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsWUFBWSxtQ0FBSSxNQUFNLENBQUM7UUFDakUsSUFBSSxDQUFDLG1CQUFtQixTQUFHLEtBQUssQ0FBQyxtQkFBbUIsbUNBQUksV0FBVyxDQUFDO1FBQ3BFLElBQUksQ0FBQyxjQUFjLFNBQUcsS0FBSyxDQUFDLGNBQWMsbUNBQUksY0FBYyxDQUFDLGNBQWMsQ0FBQztJQUM5RSxDQUFDO0lBNUVEOzs7Ozs7Ozs7Ozs7T0FZRztJQUNJLE1BQU0sQ0FBQyxXQUFXLENBQUMsS0FBWTtRQUVwQyxNQUFNLEdBQUcsR0FBUSxHQUFHLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRS9CLCtEQUErRDtRQUMvRCw2REFBNkQ7UUFDN0Qs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QUFFLENBQUM7UUFDYixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7Q0FDRjtBQUVELE1BQU0sc0JBQXNCO0lBQzFCO0lBQ0EsQ0FBQztJQUVNLElBQUksQ0FBQyxLQUFZO1FBQ3RCLE9BQU8sYUFBSyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNqQyxDQUFDO0NBQ0Y7QUFFRCxNQUFNLHVCQUF3QixTQUFRLHNCQUFzQjtJQUUxRDtRQUNFLEtBQUssRUFBRSxDQUFDO1FBRkYsVUFBSyxHQUFXLENBQUMsQ0FBQztJQUcxQixDQUFDO0lBRU0sSUFBSSxDQUFDLEtBQVk7UUFDdEIsTUFBTSxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO1FBQzlFLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNiLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IENvbnN0cnVjdCwgTm9kZSwgSUNvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xuaW1wb3J0IHsgQXBpT2JqZWN0IH0gZnJvbSAnLi9hcGktb2JqZWN0JztcbmltcG9ydCB7IENoYXJ0IH0gZnJvbSAnLi9jaGFydCc7XG5pbXBvcnQgeyBEZXBlbmRlbmN5R3JhcGggfSBmcm9tICcuL2RlcGVuZGVuY3knO1xuaW1wb3J0IHsgTmFtZXMgfSBmcm9tICcuL25hbWVzJztcbmltcG9ydCB7IFlhbWwgfSBmcm9tICcuL3lhbWwnO1xuXG4vKiogVGhlIG1ldGhvZCB0byBkaXZpZGUgWUFNTCBvdXRwdXQgaW50byBmaWxlcyAqL1xuZXhwb3J0IGVudW0gWWFtbE91dHB1dFR5cGUge1xuICAvKiogQWxsIHJlc291cmNlcyBhcmUgb3V0cHV0IGludG8gYSBzaW5nbGUgWUFNTCBmaWxlICovXG4gIEZJTEVfUEVSX0FQUCxcbiAgLyoqIFJlc291cmNlcyBhcmUgc3BsaXQgaW50byBzZXBlcmF0ZSBmaWxlcyBieSBjaGFydCAqL1xuICBGSUxFX1BFUl9DSEFSVCxcbiAgLyoqIEVhY2ggcmVzb3VyY2UgaXMgb3V0cHV0IHRvIGl0cyBvd24gZmlsZSAqL1xuICBGSUxFX1BFUl9SRVNPVVJDRSxcbiAgLyoqIEVhY2ggY2hhcnQgaW4gaXRzIG93biBmb2xkZXIgYW5kIGVhY2ggcmVzb3VyY2UgaW4gaXRzIG93biBmaWxlICovXG4gIEZPTERFUl9QRVJfQ0hBUlRfRklMRV9QRVJfUkVTT1VSQ0UsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXBwUHJvcHMge1xuICAvKipcbiAgICogVGhlIGRpcmVjdG9yeSB0byBvdXRwdXQgS3ViZXJuZXRlcyBtYW5pZmVzdHMuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gQ0RLOFNfT1VURElSIGlmIGRlZmluZWQsIG90aGVyd2lzZSBcImRpc3RcIlxuICAgKi9cbiAgcmVhZG9ubHkgb3V0ZGlyPzogc3RyaW5nO1xuICAvKipcbiAgICogIFRoZSBmaWxlIGV4dGVuc2lvbiB0byB1c2UgZm9yIHJlbmRlcmVkIFlBTUwgZmlsZXNcbiAgICogQGRlZmF1bHQgLms4cy55YW1sXG4gICAqL1xuICByZWFkb25seSBvdXRwdXRGaWxlRXh0ZW5zaW9uPzogc3RyaW5nO1xuICAvKipcbiAgICogIEhvdyB0byBkaXZpZGUgdGhlIFlBTUwgb3V0cHV0IGludG8gZmlsZXNcbiAgICogQGRlZmF1bHQgWWFtbE91dHB1dFR5cGUuRklMRV9QRVJfQ0hBUlRcbiAgICovXG4gIHJlYWRvbmx5IHlhbWxPdXRwdXRUeXBlPzogWWFtbE91dHB1dFR5cGU7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNkazhzIGFwcGxpY2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgQXBwIGV4dGVuZHMgQ29uc3RydWN0IHtcbiAgLyoqXG4gICAqIFN5bnRoZXNpemUgYSBzaW5nbGUgY2hhcnQuXG4gICAqXG4gICAqIEVhY2ggZWxlbWVudCByZXR1cm5lZCBpbiB0aGUgcmVzdWx0aW5nIGFycmF5IHJlcHJlc2VudHMgYSBkaWZmZXJlbnQgQXBpT2JqZWN0XG4gICAqIGluIHRoZSBzY29wZSBvZiB0aGUgY2hhcnQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgcmV0dXJuZWQgYXJyYXkgb3JkZXIgaXMgaW1wb3J0YW50LiBJdCBpcyBkZXRlcm1pbmVkIGJ5IHRoZSB2YXJpb3VzIGRlcGVuZGVuY2llcyBiZXR3ZWVuXG4gICAqIHRoZSBjb25zdHJ1Y3RzIGluIHRoZSBjaGFydCwgd2hlcmUgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlIG9uZSB3aXRob3V0IGRlcGVuZGVuY2llcywgYW5kIHNvIG9uLi4uXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIEpTT04gb2JqZWN0cy5cbiAgICogQHBhcmFtIGNoYXJ0IHRoZSBjaGFydCB0byBzeW50aGVzaXplLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgX3N5bnRoQ2hhcnQoY2hhcnQ6IENoYXJ0KTogYW55W10ge1xuXG4gICAgY29uc3QgYXBwOiBBcHAgPSBBcHAub2YoY2hhcnQpO1xuXG4gICAgLy8gd2UgbXVzdCBwcmVwYXJlIHRoZSBlbnRpcmUgYXBwIGJlZm9yZSBzeW50aGVzaXppbmcgdGhlIGNoYXJ0XG4gICAgLy8gYmVjYXVzZSB0aGUgZGVwZW5kZW5jeSBpbmZlcmVuY2UgaGFwcGVucyBvbiB0aGUgYXBwIGxldmVsLlxuICAgIHJlc29sdmVEZXBlbmRlbmNpZXMoYXBwKTtcblxuICAgIC8vIHZhbGlkYXRlIHRoZSBhcHAgc2luY2Ugd2Ugd2FudCB0byBjYWxsIG9uVmFsaWRhdGUgb2YgdGhlIHJlbGV2YW50IGNvbnN0cnVjdHMuXG4gICAgLy8gbm90ZSB0aGlzIHdpbGwgYWxzbyBjYWxsIG9uVmFsaWRhdGUgb24gY29uc3RydWN0cyBmcm9tIHBvc3NpYmx5IGRpZmZlcmVudCBjaGFydHMsXG4gICAgLy8gYnV0IHRoYXRzIG9rIHRvbyBzaW5jZSB3ZSBubyBsb25nZXIgdHJlYXQgY29uc3RydWN0cyBhcyBhIHNlbGYtY29udGFpbmVkIHN5bnRoZXNpcyB1bml0LlxuICAgIHZhbGlkYXRlKGFwcCk7XG5cbiAgICByZXR1cm4gY2hhcnRUb0t1YmUoY2hhcnQpLm1hcChvYmogPT4gb2JqLnRvSnNvbigpKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIG9mKGM6IElDb25zdHJ1Y3QpOiBBcHAge1xuXG4gICAgY29uc3Qgc2NvcGUgPSBOb2RlLm9mKGMpLnNjb3BlO1xuXG4gICAgaWYgKCFzY29wZSkge1xuICAgICAgLy8gdGhlIGFwcCBpcyB0aGUgb25seSBjb25zdHJ1Y3Qgd2l0aG91dCBhIHNjb3BlLlxuICAgICAgcmV0dXJuIGMgYXMgQXBwO1xuICAgIH1cblxuICAgIHJldHVybiBBcHAub2Yoc2NvcGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBvdXRwdXQgZGlyZWN0b3J5IGludG8gd2hpY2ggbWFuaWZlc3RzIHdpbGwgYmUgc3ludGhlc2l6ZWQuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgb3V0ZGlyOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqICBUaGUgZmlsZSBleHRlbnNpb24gdG8gdXNlIGZvciByZW5kZXJlZCBZQU1MIGZpbGVzXG4gICAqIEBkZWZhdWx0IC5rOHMueWFtbFxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IG91dHB1dEZpbGVFeHRlbnNpb246IHN0cmluZztcblxuICAvKiogSG93IHRvIGRpdmlkZSB0aGUgWUFNTCBvdXRwdXQgaW50byBmaWxlc1xuICAgKiBAZGVmYXVsdCBZYW1sT3V0cHV0VHlwZS5GSUxFX1BFUl9DSEFSVFxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHlhbWxPdXRwdXRUeXBlOiBZYW1sT3V0cHV0VHlwZTtcblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgdGhlIGNoYXJ0cyBpbiB0aGlzIGFwcCwgc29ydGVkIHRvcG9sb2dpY2FsbHkuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGNoYXJ0cygpOiBDaGFydFtdIHtcbiAgICBjb25zdCBpc0NoYXJ0ID0gKHg6IElDb25zdHJ1Y3QpOiB4IGlzIENoYXJ0ID0+IHggaW5zdGFuY2VvZiBDaGFydDtcbiAgICByZXR1cm4gbmV3IERlcGVuZGVuY3lHcmFwaChOb2RlLm9mKHRoaXMpKVxuICAgICAgLnRvcG9sb2d5KClcbiAgICAgIC5maWx0ZXIoaXNDaGFydCk7XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBhbiBhcHBcbiAgICogQHBhcmFtIHByb3BzIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHM6IEFwcFByb3BzID0geyB9KSB7XG4gICAgc3VwZXIodW5kZWZpbmVkIGFzIGFueSwgJycpO1xuICAgIHRoaXMub3V0ZGlyID0gcHJvcHMub3V0ZGlyID8/IHByb2Nlc3MuZW52LkNESzhTX09VVERJUiA/PyAnZGlzdCc7XG4gICAgdGhpcy5vdXRwdXRGaWxlRXh0ZW5zaW9uID0gcHJvcHMub3V0cHV0RmlsZUV4dGVuc2lvbiA/PyAnLms4cy55YW1sJztcbiAgICB0aGlzLnlhbWxPdXRwdXRUeXBlID0gcHJvcHMueWFtbE91dHB1dFR5cGUgPz8gWWFtbE91dHB1dFR5cGUuRklMRV9QRVJfQ0hBUlQ7XG4gIH1cblxuICAvKipcbiAgICogU3ludGhlc2l6ZXMgYWxsIG1hbmlmZXN0cyB0byB0aGUgb3V0cHV0IGRpcmVjdG9yeVxuICAgKi9cbiAgcHVibGljIHN5bnRoKCk6IHZvaWQge1xuXG4gICAgZnMubWtkaXJTeW5jKHRoaXMub3V0ZGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcblxuICAgIC8vIFNpbmNlIHdlIHBsYW4gb24gcmVtb3ZpbmcgdGhlIGRpc3RyaWJ1dGVkIHN5bnRoIG1lY2hhbmlzbSwgd2Ugbm8gbG9uZ2VyIGNhbGwgYE5vZGUuc3ludGhlc2l6ZWAsIGJ1dCByYXRoZXIgc2ltcGx5IGltcGxlbWVudFxuICAgIC8vIHRoZSBuZWNlc3Nhcnkgb3BlcmF0aW9ucy4gV2UgZG8gaG93ZXZlciB3YW50IHRvIHByZXNlcnZlIHRoZSBkaXN0cmlidXRlZCB2YWxpZGF0aW9uLlxuICAgIHZhbGlkYXRlKHRoaXMpO1xuXG4gICAgLy8gdGhpcyBpcyBraW5kIG9mIHN1Y2t5LCBldmVudHVhbGx5IEkgd291bGQgbGlrZSB0aGUgRGVwZW5kZW5jeUdyYXBoXG4gICAgLy8gdG8gYmUgYWJsZSB0byBhbnN3ZXIgdGhpcyBxdWVzdGlvbi5cbiAgICBjb25zdCBoYXNEZXBlbmRhbnRDaGFydHMgPSByZXNvbHZlRGVwZW5kZW5jaWVzKHRoaXMpO1xuICAgIGNvbnN0IGNoYXJ0cyA9IHRoaXMuY2hhcnRzO1xuXG4gICAgc3dpdGNoICh0aGlzLnlhbWxPdXRwdXRUeXBlKSB7XG4gICAgICBjYXNlIFlhbWxPdXRwdXRUeXBlLkZJTEVfUEVSX0FQUDpcbiAgICAgICAgbGV0IGFwaU9iamVjdExpc3Q6IEFwaU9iamVjdFtdID0gW107XG5cbiAgICAgICAgZm9yIChjb25zdCBjaGFydCBvZiBjaGFydHMpIHtcbiAgICAgICAgICBhcGlPYmplY3RMaXN0LnB1c2goLi4uY2hhcnRUb0t1YmUoY2hhcnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIFlhbWwuc2F2ZShcbiAgICAgICAgICAgIHBhdGguam9pbih0aGlzLm91dGRpciwgYGFwcCR7dGhpcy5vdXRwdXRGaWxlRXh0ZW5zaW9ufWApLCAvLyBUaGVyZSBpcyBubyBcImFwcCBuYW1lXCIsIHNvIHdlIGp1c3QgaGFyZGNvZGUgdGhlIGZpbGUgbmFtZVxuICAgICAgICAgICAgYXBpT2JqZWN0TGlzdC5tYXAoKGFwaU9iamVjdCkgPT4gYXBpT2JqZWN0LnRvSnNvbigpKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFlhbWxPdXRwdXRUeXBlLkZJTEVfUEVSX0NIQVJUOlxuICAgICAgICBjb25zdCBuYW1lcjogQ2hhcnROYW1lciA9IGhhc0RlcGVuZGFudENoYXJ0cyA/IG5ldyBJbmRleGVkQ2hhcnROYW1lcigpIDogbmV3IFNpbXBsZUNoYXJ0TmFtZXIoKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGNoYXJ0IG9mIGNoYXJ0cykge1xuICAgICAgICAgIGNvbnN0IGNoYXJ0TmFtZSA9IG5hbWVyLm5hbWUoY2hhcnQpO1xuICAgICAgICAgIGNvbnN0IG9iamVjdHMgPSBjaGFydFRvS3ViZShjaGFydCk7XG5cbiAgICAgICAgICBZYW1sLnNhdmUocGF0aC5qb2luKHRoaXMub3V0ZGlyLCBjaGFydE5hbWUrdGhpcy5vdXRwdXRGaWxlRXh0ZW5zaW9uKSwgb2JqZWN0cy5tYXAob2JqID0+IG9iai50b0pzb24oKSkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFlhbWxPdXRwdXRUeXBlLkZJTEVfUEVSX1JFU09VUkNFOlxuICAgICAgICBmb3IgKGNvbnN0IGNoYXJ0IG9mIGNoYXJ0cykge1xuICAgICAgICAgIGNvbnN0IGFwaU9iamVjdHMgPSBjaGFydFRvS3ViZShjaGFydCk7XG5cbiAgICAgICAgICBhcGlPYmplY3RzLmZvckVhY2goKGFwaU9iamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKCEoYXBpT2JqZWN0ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gYCR7YCR7YXBpT2JqZWN0LmtpbmR9LiR7YXBpT2JqZWN0Lm1ldGFkYXRhLm5hbWV9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXjAtOWEtekEtWi1fLl0vZywgJycpfWA7XG4gICAgICAgICAgICAgIFlhbWwuc2F2ZShwYXRoLmpvaW4odGhpcy5vdXRkaXIsIGZpbGVOYW1lK3RoaXMub3V0cHV0RmlsZUV4dGVuc2lvbiksIFthcGlPYmplY3QudG9Kc29uKCldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBZYW1sT3V0cHV0VHlwZS5GT0xERVJfUEVSX0NIQVJUX0ZJTEVfUEVSX1JFU09VUkNFOlxuICAgICAgICBjb25zdCBmb2xkZXJOYW1lcjogQ2hhcnROYW1lciA9IGhhc0RlcGVuZGFudENoYXJ0cyA/IG5ldyBJbmRleGVkQ2hhcnRGb2xkZXJOYW1lcigpIDogbmV3IFNpbXBsZUNoYXJ0Rm9sZGVyTmFtZXIoKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGFydCBvZiBjaGFydHMpIHtcbiAgICAgICAgICBjb25zdCBjaGFydE5hbWUgPSBmb2xkZXJOYW1lci5uYW1lKGNoYXJ0KTtcbiAgICAgICAgICBjb25zdCBhcGlPYmplY3RzID0gY2hhcnRUb0t1YmUoY2hhcnQpO1xuICAgICAgICAgIGNvbnN0IGZ1bGxPdXREaXIgPSBwYXRoLmpvaW4odGhpcy5vdXRkaXIsIGNoYXJ0TmFtZSk7XG4gICAgICAgICAgZnMubWtkaXJTeW5jKGZ1bGxPdXREaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuXG4gICAgICAgICAgYXBpT2JqZWN0cy5mb3JFYWNoKChhcGlPYmplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICghKGFwaU9iamVjdCA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGAke2Ake2FwaU9iamVjdC5raW5kfS4ke2FwaU9iamVjdC5tZXRhZGF0YS5uYW1lfWBcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvW14wLTlhLXpBLVotXy5dL2csICcnKX1gO1xuICAgICAgICAgICAgICBZYW1sLnNhdmUocGF0aC5qb2luKGZ1bGxPdXREaXIsIGZpbGVOYW1lK3RoaXMub3V0cHV0RmlsZUV4dGVuc2lvbiksIFthcGlPYmplY3QudG9Kc29uKCldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gIH1cblxuICAvKipcbiAgICogU3ludGhlc2l6ZXMgdGhlIGFwcCBpbnRvIGEgWUFNTCBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgc3RyaW5nIHdpdGggYWxsIFlBTUwgb2JqZWN0cyBhY3Jvc3MgYWxsIGNoYXJ0cyBpbiB0aGlzIGFwcC5cbiAgICovXG4gIHB1YmxpYyBzeW50aFlhbWwoKTogYW55IHtcbiAgICB2YWxpZGF0ZSh0aGlzKTtcblxuICAgIGNvbnN0IGNoYXJ0cyA9IHRoaXMuY2hhcnRzO1xuICAgIGNvbnN0IGRvY3M6IGFueVtdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGNoYXJ0IG9mIGNoYXJ0cykge1xuICAgICAgY29uc3QgYXBpT2JqZWN0cyA9IGNoYXJ0VG9LdWJlKGNoYXJ0KTtcbiAgICAgIGRvY3MucHVzaCguLi5hcGlPYmplY3RzLm1hcChhcGlPYmplY3QgPT4gYXBpT2JqZWN0LnRvSnNvbigpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFlhbWwuc3RyaW5naWZ5KC4uLmRvY3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKGFwcDogQXBwKSB7XG4gIGNvbnN0IGVycm9ycyA9IFtdO1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGFwcC5ub2RlLmZpbmRBbGwoKSkge1xuICAgIGNvbnN0IGNoaWxkRXJyb3JzID0gY2hpbGQubm9kZS52YWxpZGF0ZSgpO1xuICAgIGZvciAoY29uc3QgZXJyb3Igb2YgY2hpbGRFcnJvcnMpIHtcbiAgICAgIGVycm9ycy5wdXNoKGBbJHtjaGlsZC5ub2RlLnBhdGh9XSAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVmFsaWRhdGlvbiBmYWlsZWQgd2l0aCB0aGUgZm9sbG93aW5nIGVycm9yczpcXG4gICR7ZXJyb3JzLmpvaW4oJ1xcbiAgJyl9YCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZURlcGVuZGVuY2llcyhhcHA6IEFwcCkge1xuXG4gIGxldCBoYXNEZXBlbmRhbnRDaGFydHMgPSBmYWxzZTtcblxuICBjb25zdCBkZXBzID0gW107XG4gIGZvciAoY29uc3QgY2hpbGQgb2YgYXBwLm5vZGUuZmluZEFsbCgpKSB7XG4gICAgZm9yIChjb25zdCBkZXAgb2YgY2hpbGQubm9kZS5kZXBlbmRlbmNpZXMpIHtcbiAgICAgIGRlcHMucHVzaCh7IHNvdXJjZTogY2hpbGQsIHRhcmdldDogZGVwIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgZGVwIG9mIGRlcHMpIHtcblxuICAgIC8vIGNyZWF0ZSBleHBsaWNpdCBhcGkgb2JqZWN0IGRlcGVuZGVuY2llcyBmcm9tIGltcGxpY2l0IGNvbnN0cnVjdCBkZXBlbmRlbmNpZXNcbiAgICBjb25zdCB0YXJnZXRBcGlPYmplY3RzID0gTm9kZS5vZihkZXAudGFyZ2V0KS5maW5kQWxsKCkuZmlsdGVyKGMgPT4gYyBpbnN0YW5jZW9mIEFwaU9iamVjdCk7XG4gICAgY29uc3Qgc291cmNlQXBpT2JqZWN0cyA9IE5vZGUub2YoZGVwLnNvdXJjZSkuZmluZEFsbCgpLmZpbHRlcihjID0+IGMgaW5zdGFuY2VvZiBBcGlPYmplY3QpO1xuXG4gICAgZm9yIChjb25zdCB0YXJnZXQgb2YgdGFyZ2V0QXBpT2JqZWN0cykge1xuICAgICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlQXBpT2JqZWN0cykge1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSBzb3VyY2UpIHtcbiAgICAgICAgICBOb2RlLm9mKHNvdXJjZSkuYWRkRGVwZW5kZW5jeSh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGFuIGV4cGxpY2l0IGNoYXJ0IGRlcGVuZGVuY3kgZnJvbSBpbXBsaWNpdCBjb25zdHJ1Y3QgZGVwZW5kZW5jaWVzXG4gICAgY29uc3Qgc291cmNlQ2hhcnQgPSBDaGFydC5vZihkZXAuc291cmNlKTtcbiAgICBjb25zdCB0YXJnZXRDaGFydCA9IENoYXJ0Lm9mKGRlcC50YXJnZXQpO1xuXG4gICAgaWYgKHNvdXJjZUNoYXJ0ICE9PSB0YXJnZXRDaGFydCkge1xuICAgICAgTm9kZS5vZihzb3VyY2VDaGFydCkuYWRkRGVwZW5kZW5jeSh0YXJnZXRDaGFydCk7XG4gICAgICBoYXNEZXBlbmRhbnRDaGFydHMgPSB0cnVlO1xuICAgIH1cblxuICB9XG5cbiAgY29uc3QgY2hhcnRzID0gbmV3IERlcGVuZGVuY3lHcmFwaChOb2RlLm9mKGFwcCkpLnRvcG9sb2d5KClcbiAgICAuZmlsdGVyKHggPT4geCBpbnN0YW5jZW9mIENoYXJ0KTtcblxuICBmb3IgKGNvbnN0IHBhcmVudENoYXJ0IG9mIGNoYXJ0cykge1xuICAgIGZvciAoY29uc3QgY2hpbGRDaGFydCBvZiBOb2RlLm9mKHBhcmVudENoYXJ0KS5jaGlsZHJlbi5maWx0ZXIoeCA9PiB4IGluc3RhbmNlb2YgQ2hhcnQpKSB7XG4gICAgICAvLyBjcmVhdGUgYW4gZXhwbGljaXQgY2hhcnQgZGVwZW5kZW5jeSBmcm9tIG5lc3RlZCBjaGFydCByZWxhdGlvbnNoaXBzXG4gICAgICBOb2RlLm9mKHBhcmVudENoYXJ0KS5hZGREZXBlbmRlbmN5KGNoaWxkQ2hhcnQpO1xuICAgICAgaGFzRGVwZW5kYW50Q2hhcnRzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaGFzRGVwZW5kYW50Q2hhcnRzO1xuXG59XG5cbmZ1bmN0aW9uIGNoYXJ0VG9LdWJlKGNoYXJ0OiBDaGFydCkge1xuICByZXR1cm4gbmV3IERlcGVuZGVuY3lHcmFwaChOb2RlLm9mKGNoYXJ0KSkudG9wb2xvZ3koKVxuICAgIC5maWx0ZXIoeCA9PiB4IGluc3RhbmNlb2YgQXBpT2JqZWN0KVxuICAgIC5maWx0ZXIoeCA9PiBDaGFydC5vZih4KSA9PT0gY2hhcnQpIC8vIGluY2x1ZGUgYW4gb2JqZWN0IG9ubHkgaW4gaXRzIGNsb3Nlc3QgcGFyZW50IGNoYXJ0XG4gICAgLm1hcCh4ID0+ICh4IGFzIEFwaU9iamVjdCkpO1xufVxuXG5pbnRlcmZhY2UgQ2hhcnROYW1lciB7XG4gIG5hbWUoY2hhcnQ6IENoYXJ0KTogc3RyaW5nO1xufVxuXG5jbGFzcyBTaW1wbGVDaGFydE5hbWVyIGltcGxlbWVudHMgQ2hhcnROYW1lciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICB9XG5cbiAgcHVibGljIG5hbWUoY2hhcnQ6IENoYXJ0KSB7XG4gICAgcmV0dXJuIGAke05hbWVzLnRvRG5zTGFiZWwoY2hhcnQpfWA7XG4gIH1cbn1cblxuY2xhc3MgSW5kZXhlZENoYXJ0TmFtZXIgZXh0ZW5kcyBTaW1wbGVDaGFydE5hbWVyIGltcGxlbWVudHMgQ2hhcnROYW1lciB7XG4gIHByaXZhdGUgaW5kZXg6IG51bWJlciA9IDA7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBwdWJsaWMgbmFtZShjaGFydDogQ2hhcnQpIHtcbiAgICBjb25zdCBuYW1lID0gYCR7dGhpcy5pbmRleC50b1N0cmluZygpLnBhZFN0YXJ0KDQsICcwJyl9LSR7c3VwZXIubmFtZShjaGFydCl9YDtcbiAgICB0aGlzLmluZGV4Kys7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbn1cblxuY2xhc3MgU2ltcGxlQ2hhcnRGb2xkZXJOYW1lciBpbXBsZW1lbnRzIENoYXJ0TmFtZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgfVxuXG4gIHB1YmxpYyBuYW1lKGNoYXJ0OiBDaGFydCkge1xuICAgIHJldHVybiBOYW1lcy50b0Ruc0xhYmVsKGNoYXJ0KTtcbiAgfVxufVxuXG5jbGFzcyBJbmRleGVkQ2hhcnRGb2xkZXJOYW1lciBleHRlbmRzIFNpbXBsZUNoYXJ0Rm9sZGVyTmFtZXIgaW1wbGVtZW50cyBDaGFydE5hbWVyIHtcbiAgcHJpdmF0ZSBpbmRleDogbnVtYmVyID0gMDtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHB1YmxpYyBuYW1lKGNoYXJ0OiBDaGFydCkge1xuICAgIGNvbnN0IG5hbWUgPSBgJHt0aGlzLmluZGV4LnRvU3RyaW5nKCkucGFkU3RhcnQoNCwgJzAnKX0tJHtzdXBlci5uYW1lKGNoYXJ0KX1gO1xuICAgIHRoaXMuaW5kZXgrKztcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxufSJdfQ==

/***/ }),

/***/ 2297:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Chart = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const constructs_1 = __nccwpck_require__(1963);
const app_1 = __nccwpck_require__(4333);
const names_1 = __nccwpck_require__(3948);
const CHART_SYMBOL = Symbol.for('cdk8s.Chart');
class Chart extends constructs_1.Construct {
    constructor(scope, id, props = {}) {
        var _b;
        super(scope, id);
        this.namespace = props.namespace;
        this._labels = (_b = props.labels) !== null && _b !== void 0 ? _b : {};
        Object.defineProperty(this, CHART_SYMBOL, { value: true });
    }
    /**
     * Return whether the given object is a Chart.
     *
     * We do attribute detection since we can't reliably use 'instanceof'.
     */
    static isChart(x) {
        return x !== null && typeof (x) === 'object' && CHART_SYMBOL in x;
    }
    /**
     * Finds the chart in which a node is defined.
     * @param c a construct node
     */
    static of(c) {
        if (Chart.isChart(c)) {
            return c;
        }
        const parent = constructs_1.Node.of(c).scope;
        if (!parent) {
            throw new Error('cannot find a parent chart (directly or indirectly)');
        }
        return Chart.of(parent);
    }
    /**
     * Labels applied to all resources in this chart.
     *
     * This is an immutable copy.
     */
    get labels() {
        return { ...this._labels };
    }
    /**
     * Generates a app-unique name for an object given it's construct node path.
     *
     * Different resource types may have different constraints on names
     * (`metadata.name`). The previous version of the name generator was
     * compatible with DNS_SUBDOMAIN but not with DNS_LABEL.
     *
     * For example, `Deployment` names must comply with DNS_SUBDOMAIN while
     * `Service` names must comply with DNS_LABEL.
     *
     * Since there is no formal specification for this, the default name
     * generation scheme for kubernetes objects in cdk8s was changed to DNS_LABEL,
     * since it’s the common denominator for all kubernetes resources
     * (supposedly).
     *
     * You can override this method if you wish to customize object names at the
     * chart level.
     *
     * @param apiObject The API object to generate a name for.
     */
    generateObjectName(apiObject) {
        return names_1.Names.toDnsLabel(apiObject);
    }
    /**
     * Create a dependency between this Chart and other constructs.
     * These can be other ApiObjects, Charts, or custom.
     *
     * @param dependencies the dependencies to add.
     */
    addDependency(...dependencies) {
        constructs_1.Node.of(this).addDependency(...dependencies);
    }
    /**
     * Renders this chart to a set of Kubernetes JSON resources.
     * @returns array of resource manifests
     */
    toJson() {
        return app_1.App._synthChart(this);
    }
}
exports.Chart = Chart;
_a = JSII_RTTI_SYMBOL_1;
Chart[_a] = { fqn: "cdk8s.Chart", version: "2.3.11" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhcnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvY2hhcnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSwyQ0FBeUQ7QUFFekQsK0JBQTRCO0FBQzVCLG1DQUFnQztBQUVoQyxNQUFNLFlBQVksR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBb0IvQyxNQUFhLEtBQU0sU0FBUSxzQkFBUztJQXFDbEMsWUFBWSxLQUFnQixFQUFFLEVBQVUsRUFBRSxRQUFvQixFQUFHOztRQUMvRCxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ2pCLElBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQztRQUNqQyxJQUFJLENBQUMsT0FBTyxTQUFHLEtBQUssQ0FBQyxNQUFNLG1DQUFJLEVBQUUsQ0FBQztRQUVsQyxNQUFNLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxZQUFZLEVBQUUsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUM3RCxDQUFDO0lBMUNEOzs7O09BSUc7SUFDSSxNQUFNLENBQUMsT0FBTyxDQUFDLENBQU07UUFDMUIsT0FBTyxDQUFDLEtBQUssSUFBSSxJQUFJLE9BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxRQUFRLElBQUksWUFBWSxJQUFJLENBQUMsQ0FBQztJQUNuRSxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFhO1FBQzVCLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUNwQixPQUFPLENBQUMsQ0FBQztTQUNWO1FBRUQsTUFBTSxNQUFNLEdBQUcsaUJBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBa0IsQ0FBQztRQUM3QyxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ1gsTUFBTSxJQUFJLEtBQUssQ0FBQyxxREFBcUQsQ0FBQyxDQUFDO1NBQ3hFO1FBRUQsT0FBTyxLQUFLLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFvQkQ7Ozs7T0FJRztJQUNILElBQVcsTUFBTTtRQUNmLE9BQU8sRUFBRSxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUM3QixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FtQkc7SUFDSSxrQkFBa0IsQ0FBQyxTQUFvQjtRQUM1QyxPQUFPLGFBQUssQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksYUFBYSxDQUFDLEdBQUcsWUFBMEI7UUFDaEQsaUJBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsYUFBYSxDQUFDLEdBQUcsWUFBWSxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVEOzs7T0FHRztJQUNJLE1BQU07UUFDWCxPQUFPLFNBQUcsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDL0IsQ0FBQzs7QUE5Rkgsc0JBK0ZDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29uc3RydWN0LCBOb2RlLCBJQ29uc3RydWN0IH0gZnJvbSAnY29uc3RydWN0cyc7XG5pbXBvcnQgeyBBcGlPYmplY3QgfSBmcm9tICcuL2FwaS1vYmplY3QnO1xuaW1wb3J0IHsgQXBwIH0gZnJvbSAnLi9hcHAnO1xuaW1wb3J0IHsgTmFtZXMgfSBmcm9tICcuL25hbWVzJztcblxuY29uc3QgQ0hBUlRfU1lNQk9MID0gU3ltYm9sLmZvcignY2RrOHMuQ2hhcnQnKTtcblxuZXhwb3J0IGludGVyZmFjZSBDaGFydFByb3BzIHtcbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IG5hbWVzcGFjZSBmb3IgYWxsIG9iamVjdHMgZGVmaW5lZCBpbiB0aGlzIGNoYXJ0IChkaXJlY3RseSBvclxuICAgKiBpbmRpcmVjdGx5KS4gVGhpcyBuYW1lc3BhY2Ugd2lsbCBvbmx5IGFwcGx5IHRvIG9iamVjdHMgdGhhdCBkb24ndCBoYXZlIGFcbiAgICogYG5hbWVzcGFjZWAgZXhwbGljaXRseSBkZWZpbmVkIGZvciB0aGVtLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIG5vIG5hbWVzcGFjZSBpcyBzeW50aGVzaXplZCAodXN1YWxseSB0aGlzIGltcGxpZXMgXCJkZWZhdWx0XCIpXG4gICAqL1xuICByZWFkb25seSBuYW1lc3BhY2U/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIExhYmVscyB0byBhcHBseSB0byBhbGwgcmVzb3VyY2VzIGluIHRoaXMgY2hhcnQuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gbm8gY29tbW9uIGxhYmVsc1xuICAgKi9cbiAgcmVhZG9ubHkgbGFiZWxzPzogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIH07XG59XG5cbmV4cG9ydCBjbGFzcyBDaGFydCBleHRlbmRzIENvbnN0cnVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgQ2hhcnQuXG4gICAqXG4gICAqIFdlIGRvIGF0dHJpYnV0ZSBkZXRlY3Rpb24gc2luY2Ugd2UgY2FuJ3QgcmVsaWFibHkgdXNlICdpbnN0YW5jZW9mJy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgaXNDaGFydCh4OiBhbnkpOiB4IGlzIENoYXJ0IHtcbiAgICByZXR1cm4geCAhPT0gbnVsbCAmJiB0eXBlb2YoeCkgPT09ICdvYmplY3QnICYmIENIQVJUX1NZTUJPTCBpbiB4O1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBjaGFydCBpbiB3aGljaCBhIG5vZGUgaXMgZGVmaW5lZC5cbiAgICogQHBhcmFtIGMgYSBjb25zdHJ1Y3Qgbm9kZVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBvZihjOiBJQ29uc3RydWN0KTogQ2hhcnQge1xuICAgIGlmIChDaGFydC5pc0NoYXJ0KGMpKSB7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnQgPSBOb2RlLm9mKGMpLnNjb3BlIGFzIENvbnN0cnVjdDtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZmluZCBhIHBhcmVudCBjaGFydCAoZGlyZWN0bHkgb3IgaW5kaXJlY3RseSknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQ2hhcnQub2YocGFyZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBuYW1lc3BhY2UgZm9yIGFsbCBvYmplY3RzIGluIHRoaXMgY2hhcnQuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbmFtZXNwYWNlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDaGFydC1sZXZlbCBsYWJlbHMuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IF9sYWJlbHM/OiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfTtcblxuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogQ2hhcnRQcm9wcyA9IHsgfSkge1xuICAgIHN1cGVyKHNjb3BlLCBpZCk7XG4gICAgdGhpcy5uYW1lc3BhY2UgPSBwcm9wcy5uYW1lc3BhY2U7XG4gICAgdGhpcy5fbGFiZWxzID0gcHJvcHMubGFiZWxzID8/IHt9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIENIQVJUX1NZTUJPTCwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMYWJlbHMgYXBwbGllZCB0byBhbGwgcmVzb3VyY2VzIGluIHRoaXMgY2hhcnQuXG4gICAqXG4gICAqIFRoaXMgaXMgYW4gaW1tdXRhYmxlIGNvcHkuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGxhYmVscygpOiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfSB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5fbGFiZWxzIH07XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgYXBwLXVuaXF1ZSBuYW1lIGZvciBhbiBvYmplY3QgZ2l2ZW4gaXQncyBjb25zdHJ1Y3Qgbm9kZSBwYXRoLlxuICAgKlxuICAgKiBEaWZmZXJlbnQgcmVzb3VyY2UgdHlwZXMgbWF5IGhhdmUgZGlmZmVyZW50IGNvbnN0cmFpbnRzIG9uIG5hbWVzXG4gICAqIChgbWV0YWRhdGEubmFtZWApLiBUaGUgcHJldmlvdXMgdmVyc2lvbiBvZiB0aGUgbmFtZSBnZW5lcmF0b3Igd2FzXG4gICAqIGNvbXBhdGlibGUgd2l0aCBETlNfU1VCRE9NQUlOIGJ1dCBub3Qgd2l0aCBETlNfTEFCRUwuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBgRGVwbG95bWVudGAgbmFtZXMgbXVzdCBjb21wbHkgd2l0aCBETlNfU1VCRE9NQUlOIHdoaWxlXG4gICAqIGBTZXJ2aWNlYCBuYW1lcyBtdXN0IGNvbXBseSB3aXRoIEROU19MQUJFTC5cbiAgICpcbiAgICogU2luY2UgdGhlcmUgaXMgbm8gZm9ybWFsIHNwZWNpZmljYXRpb24gZm9yIHRoaXMsIHRoZSBkZWZhdWx0IG5hbWVcbiAgICogZ2VuZXJhdGlvbiBzY2hlbWUgZm9yIGt1YmVybmV0ZXMgb2JqZWN0cyBpbiBjZGs4cyB3YXMgY2hhbmdlZCB0byBETlNfTEFCRUwsXG4gICAqIHNpbmNlIGl04oCZcyB0aGUgY29tbW9uIGRlbm9taW5hdG9yIGZvciBhbGwga3ViZXJuZXRlcyByZXNvdXJjZXNcbiAgICogKHN1cHBvc2VkbHkpLlxuICAgKlxuICAgKiBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHlvdSB3aXNoIHRvIGN1c3RvbWl6ZSBvYmplY3QgbmFtZXMgYXQgdGhlXG4gICAqIGNoYXJ0IGxldmVsLlxuICAgKlxuICAgKiBAcGFyYW0gYXBpT2JqZWN0IFRoZSBBUEkgb2JqZWN0IHRvIGdlbmVyYXRlIGEgbmFtZSBmb3IuXG4gICAqL1xuICBwdWJsaWMgZ2VuZXJhdGVPYmplY3ROYW1lKGFwaU9iamVjdDogQXBpT2JqZWN0KSB7XG4gICAgcmV0dXJuIE5hbWVzLnRvRG5zTGFiZWwoYXBpT2JqZWN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBkZXBlbmRlbmN5IGJldHdlZW4gdGhpcyBDaGFydCBhbmQgb3RoZXIgY29uc3RydWN0cy5cbiAgICogVGhlc2UgY2FuIGJlIG90aGVyIEFwaU9iamVjdHMsIENoYXJ0cywgb3IgY3VzdG9tLlxuICAgKlxuICAgKiBAcGFyYW0gZGVwZW5kZW5jaWVzIHRoZSBkZXBlbmRlbmNpZXMgdG8gYWRkLlxuICAgKi9cbiAgcHVibGljIGFkZERlcGVuZGVuY3koLi4uZGVwZW5kZW5jaWVzOiBJQ29uc3RydWN0W10pIHtcbiAgICBOb2RlLm9mKHRoaXMpLmFkZERlcGVuZGVuY3koLi4uZGVwZW5kZW5jaWVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY2hhcnQgdG8gYSBzZXQgb2YgS3ViZXJuZXRlcyBKU09OIHJlc291cmNlcy5cbiAgICogQHJldHVybnMgYXJyYXkgb2YgcmVzb3VyY2UgbWFuaWZlc3RzXG4gICAqL1xuICBwdWJsaWMgdG9Kc29uKCk6IGFueVtdIHtcbiAgICByZXR1cm4gQXBwLl9zeW50aENoYXJ0KHRoaXMpO1xuICB9XG59XG5cbiJdfQ==

/***/ }),

/***/ 6653:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DependencyVertex = exports.DependencyGraph = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const constructs_1 = __nccwpck_require__(1963);
/**
 * Represents the dependency graph for a given Node.
 *
 * This graph includes the dependency relationships between all nodes in the
 * node (construct) sub-tree who's root is this Node.
 *
 * Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as
 * childless children of the root node of the graph.
 *
 * The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node
 * from a different scope, that relationship is not represented in this graph.
 *
 */
class DependencyGraph {
    constructor(node) {
        this._fosterParent = new DependencyVertex();
        const nodes = {};
        function putVertex(construct) {
            nodes[constructs_1.Node.of(construct).path] = new DependencyVertex(construct);
        }
        function getVertex(construct) {
            return nodes[constructs_1.Node.of(construct).path];
        }
        // create all vertices of the graph.
        for (const n of node.findAll()) {
            putVertex(n);
        }
        const deps = [];
        for (const child of node.findAll()) {
            for (const dep of child.node.dependencies) {
                deps.push({ source: child, target: dep });
            }
        }
        // create all the edges of the graph.
        for (const dep of deps) {
            if (!getVertex(dep.target)) {
                // dont cross scope boundaries.
                // since charts only renders its own children, this is ok and
                // has the benefit of simplifying the graph. we should reconsider this behavior when moving
                // to a more general purpose use-case.
                continue;
            }
            const sourceDepNode = getVertex(dep.source);
            const targetDepNode = getVertex(dep.target);
            sourceDepNode.addChild(targetDepNode);
        }
        // create the root.
        for (const n of Object.values(nodes)) {
            if (n.inbound.length === 0) {
                // orphans are dependency roots. lets adopt them!
                this._fosterParent.addChild(n);
            }
        }
    }
    /**
     * Returns the root of the graph.
     *
     * Note that this vertex will always have `null` as its `.value` since it is an artifical root
     * that binds all the connected spaces of the graph.
     */
    get root() {
        return this._fosterParent;
    }
    /**
     * @see Vertex.topology()
     */
    topology() {
        return this._fosterParent.topology();
    }
}
exports.DependencyGraph = DependencyGraph;
_a = JSII_RTTI_SYMBOL_1;
DependencyGraph[_a] = { fqn: "cdk8s.DependencyGraph", version: "2.3.11" };
/**
 * Represents a vertex in the graph.
 *
 * The value of each vertex is an `IConstruct` that is accessible via the `.value` getter.
 */
class DependencyVertex {
    constructor(value = undefined) {
        this._children = new Set();
        this._parents = new Set();
        this._value = value;
    }
    /**
     * Returns the IConstruct this graph vertex represents.
     *
     * `null` in case this is the root of the graph.
     */
    get value() {
        return this._value;
    }
    /**
     * Returns the children of the vertex (i.e dependencies)
     */
    get outbound() {
        return Array.from(this._children);
    }
    /**
     * Returns the parents of the vertex (i.e dependants)
     */
    get inbound() {
        return Array.from(this._parents);
    }
    /**
     * Returns a topologically sorted array of the constructs in the sub-graph.
     */
    topology() {
        const found = new Set();
        const topology = [];
        function visit(n) {
            for (const c of n.outbound) {
                visit(c);
            }
            if (!found.has(n)) {
                topology.push(n);
                found.add(n);
            }
        }
        visit(this);
        return topology.filter(d => d.value).map(d => d.value);
    }
    /**
     * Adds a vertex as a dependency of the current node.
     * Also updates the parents of `dep`, so that it contains this node as a parent.
     *
     * This operation will fail in case it creates a cycle in the graph.
     *
     * @param dep The dependency
     */
    addChild(dep) {
        const cycle = dep.findRoute(this);
        if (cycle.length !== 0) {
            cycle.push(dep);
            throw new Error(`Dependency cycle detected: ${cycle.filter(d => d.value).map(d => constructs_1.Node.of(d.value).path).join(' => ')}`);
        }
        this._children.add(dep);
        dep.addParent(this);
    }
    addParent(dep) {
        this._parents.add(dep);
    }
    findRoute(dst) {
        const route = [];
        visit(this);
        return route;
        function visit(n) {
            route.push(n);
            let found = false;
            for (const c of n.outbound) {
                if (c === dst) {
                    route.push(c);
                    return true;
                }
                found = visit(c);
            }
            if (!found) {
                route.pop();
            }
            return found;
        }
    }
}
exports.DependencyVertex = DependencyVertex;
_b = JSII_RTTI_SYMBOL_1;
DependencyVertex[_b] = { fqn: "cdk8s.DependencyVertex", version: "2.3.11" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwZW5kZW5jeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9kZXBlbmRlbmN5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsMkNBQThDO0FBRzlDOzs7Ozs7Ozs7Ozs7R0FZRztBQUNILE1BQWEsZUFBZTtJQUkxQixZQUFZLElBQVU7UUFFcEIsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLGdCQUFnQixFQUFFLENBQUM7UUFFNUMsTUFBTSxLQUFLLEdBQXFDLEVBQUUsQ0FBQztRQUVuRCxTQUFTLFNBQVMsQ0FBQyxTQUFxQjtZQUN0QyxLQUFLLENBQUMsaUJBQUksQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNuRSxDQUFDO1FBRUQsU0FBUyxTQUFTLENBQUMsU0FBcUI7WUFDdEMsT0FBTyxLQUFLLENBQUMsaUJBQUksQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDeEMsQ0FBQztRQUVELG9DQUFvQztRQUNwQyxLQUFLLE1BQU0sQ0FBQyxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUUsRUFBRTtZQUM5QixTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDZDtRQUVELE1BQU0sSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUNoQixLQUFLLE1BQU0sS0FBSyxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUUsRUFBRTtZQUNsQyxLQUFLLE1BQU0sR0FBRyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFO2dCQUN6QyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQzthQUMzQztTQUNGO1FBRUQscUNBQXFDO1FBQ3JDLEtBQUssTUFBTSxHQUFHLElBQUksSUFBSSxFQUFFO1lBRXRCLElBQUksQ0FBQyxT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ZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUsIElDb25zdHJ1Y3QgfSBmcm9tICdjb25zdHJ1Y3RzJztcblxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGRlcGVuZGVuY3kgZ3JhcGggZm9yIGEgZ2l2ZW4gTm9kZS5cbiAqXG4gKiBUaGlzIGdyYXBoIGluY2x1ZGVzIHRoZSBkZXBlbmRlbmN5IHJlbGF0aW9uc2hpcHMgYmV0d2VlbiBhbGwgbm9kZXMgaW4gdGhlXG4gKiBub2RlIChjb25zdHJ1Y3QpIHN1Yi10cmVlIHdobydzIHJvb3QgaXMgdGhpcyBOb2RlLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1lYW5zIHRoYXQgbG9uZWx5IG5vZGVzIChubyBkZXBlbmRlbmNpZXMgYW5kIG5vIGRlcGVuZGFudHMpIGFyZSBhbHNvIGluY2x1ZGVkIGluIHRoaXMgZ3JhcGggYXNcbiAqIGNoaWxkbGVzcyBjaGlsZHJlbiBvZiB0aGUgcm9vdCBub2RlIG9mIHRoZSBncmFwaC5cbiAqXG4gKiBUaGUgZ3JhcGggZG9lcyBub3QgaW5jbHVkZSBjcm9zcy1zY29wZSBkZXBlbmRlbmNpZXMuIFRoYXQgaXMsIGlmIGEgY2hpbGQgb24gdGhlIGN1cnJlbnQgc2NvcGUgZGVwZW5kcyBvbiBhIG5vZGVcbiAqIGZyb20gYSBkaWZmZXJlbnQgc2NvcGUsIHRoYXQgcmVsYXRpb25zaGlwIGlzIG5vdCByZXByZXNlbnRlZCBpbiB0aGlzIGdyYXBoLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIERlcGVuZGVuY3lHcmFwaCB7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBfZm9zdGVyUGFyZW50OiBEZXBlbmRlbmN5VmVydGV4O1xuXG4gIGNvbnN0cnVjdG9yKG5vZGU6IE5vZGUpIHtcblxuICAgIHRoaXMuX2Zvc3RlclBhcmVudCA9IG5ldyBEZXBlbmRlbmN5VmVydGV4KCk7XG5cbiAgICBjb25zdCBub2RlczogUmVjb3JkPHN0cmluZywgRGVwZW5kZW5jeVZlcnRleD4gPSB7fTtcblxuICAgIGZ1bmN0aW9uIHB1dFZlcnRleChjb25zdHJ1Y3Q6IElDb25zdHJ1Y3QpIHtcbiAgICAgIG5vZGVzW05vZGUub2YoY29uc3RydWN0KS5wYXRoXSA9IG5ldyBEZXBlbmRlbmN5VmVydGV4KGNvbnN0cnVjdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VmVydGV4KGNvbnN0cnVjdDogSUNvbnN0cnVjdCk6IERlcGVuZGVuY3lWZXJ0ZXgge1xuICAgICAgcmV0dXJuIG5vZGVzW05vZGUub2YoY29uc3RydWN0KS5wYXRoXTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYWxsIHZlcnRpY2VzIG9mIHRoZSBncmFwaC5cbiAgICBmb3IgKGNvbnN0IG4gb2Ygbm9kZS5maW5kQWxsKCkpIHtcbiAgICAgIHB1dFZlcnRleChuKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZXBzID0gW107XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmZpbmRBbGwoKSkge1xuICAgICAgZm9yIChjb25zdCBkZXAgb2YgY2hpbGQubm9kZS5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgZGVwcy5wdXNoKHsgc291cmNlOiBjaGlsZCwgdGFyZ2V0OiBkZXAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGFsbCB0aGUgZWRnZXMgb2YgdGhlIGdyYXBoLlxuICAgIGZvciAoY29uc3QgZGVwIG9mIGRlcHMpIHtcblxuICAgICAgaWYgKCFnZXRWZXJ0ZXgoZGVwLnRhcmdldCkpIHtcbiAgICAgICAgLy8gZG9udCBjcm9zcyBzY29wZSBib3VuZGFyaWVzLlxuICAgICAgICAvLyBzaW5jZSBjaGFydHMgb25seSByZW5kZXJzIGl0cyBvd24gY2hpbGRyZW4sIHRoaXMgaXMgb2sgYW5kXG4gICAgICAgIC8vIGhhcyB0aGUgYmVuZWZpdCBvZiBzaW1wbGlmeWluZyB0aGUgZ3JhcGguIHdlIHNob3VsZCByZWNvbnNpZGVyIHRoaXMgYmVoYXZpb3Igd2hlbiBtb3ZpbmdcbiAgICAgICAgLy8gdG8gYSBtb3JlIGdlbmVyYWwgcHVycG9zZSB1c2UtY2FzZS5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNvdXJjZURlcE5vZGUgPSBnZXRWZXJ0ZXgoZGVwLnNvdXJjZSk7XG4gICAgICBjb25zdCB0YXJnZXREZXBOb2RlID0gZ2V0VmVydGV4KGRlcC50YXJnZXQpO1xuXG4gICAgICBzb3VyY2VEZXBOb2RlLmFkZENoaWxkKHRhcmdldERlcE5vZGUpO1xuXG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIHRoZSByb290LlxuICAgIGZvciAoY29uc3QgbiBvZiBPYmplY3QudmFsdWVzKG5vZGVzKSkge1xuICAgICAgaWYgKG4uaW5ib3VuZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gb3JwaGFucyBhcmUgZGVwZW5kZW5jeSByb290cy4gbGV0cyBhZG9wdCB0aGVtIVxuICAgICAgICB0aGlzLl9mb3N0ZXJQYXJlbnQuYWRkQ2hpbGQobik7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcm9vdCBvZiB0aGUgZ3JhcGguXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIHZlcnRleCB3aWxsIGFsd2F5cyBoYXZlIGBudWxsYCBhcyBpdHMgYC52YWx1ZWAgc2luY2UgaXQgaXMgYW4gYXJ0aWZpY2FsIHJvb3RcbiAgICogdGhhdCBiaW5kcyBhbGwgdGhlIGNvbm5lY3RlZCBzcGFjZXMgb2YgdGhlIGdyYXBoLlxuICAgKi9cbiAgcHVibGljIGdldCByb290KCk6IERlcGVuZGVuY3lWZXJ0ZXgge1xuICAgIHJldHVybiB0aGlzLl9mb3N0ZXJQYXJlbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBWZXJ0ZXgudG9wb2xvZ3koKVxuICAgKi9cbiAgcHVibGljIHRvcG9sb2d5KCk6IElDb25zdHJ1Y3RbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2Zvc3RlclBhcmVudC50b3BvbG9neSgpO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHZlcnRleCBpbiB0aGUgZ3JhcGguXG4gKlxuICogVGhlIHZhbHVlIG9mIGVhY2ggdmVydGV4IGlzIGFuIGBJQ29uc3RydWN0YCB0aGF0IGlzIGFjY2Vzc2libGUgdmlhIHRoZSBgLnZhbHVlYCBnZXR0ZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZXBlbmRlbmN5VmVydGV4IHtcblxuICBwcml2YXRlIHJlYWRvbmx5IF92YWx1ZTogSUNvbnN0cnVjdCB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSByZWFkb25seSBfY2hpbGRyZW46IFNldDxEZXBlbmRlbmN5VmVydGV4PiA9IG5ldyBTZXQ8RGVwZW5kZW5jeVZlcnRleD4oKTtcbiAgcHJpdmF0ZSByZWFkb25seSBfcGFyZW50czogU2V0PERlcGVuZGVuY3lWZXJ0ZXg+ID0gbmV3IFNldDxEZXBlbmRlbmN5VmVydGV4PigpO1xuXG4gIGNvbnN0cnVjdG9yKHZhbHVlOiBJQ29uc3RydWN0IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBJQ29uc3RydWN0IHRoaXMgZ3JhcGggdmVydGV4IHJlcHJlc2VudHMuXG4gICAqXG4gICAqIGBudWxsYCBpbiBjYXNlIHRoaXMgaXMgdGhlIHJvb3Qgb2YgdGhlIGdyYXBoLlxuICAgKi9cbiAgcHVibGljIGdldCB2YWx1ZSgpOiBJQ29uc3RydWN0IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2hpbGRyZW4gb2YgdGhlIHZlcnRleCAoaS5lIGRlcGVuZGVuY2llcylcbiAgICovXG4gIHB1YmxpYyBnZXQgb3V0Ym91bmQoKTogQXJyYXk8RGVwZW5kZW5jeVZlcnRleD4ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX2NoaWxkcmVuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwYXJlbnRzIG9mIHRoZSB2ZXJ0ZXggKGkuZSBkZXBlbmRhbnRzKVxuICAgKi9cbiAgcHVibGljIGdldCBpbmJvdW5kKCk6IEFycmF5PERlcGVuZGVuY3lWZXJ0ZXg+IHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9wYXJlbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdG9wb2xvZ2ljYWxseSBzb3J0ZWQgYXJyYXkgb2YgdGhlIGNvbnN0cnVjdHMgaW4gdGhlIHN1Yi1ncmFwaC5cbiAgICovXG4gIHB1YmxpYyB0b3BvbG9neSgpOiBJQ29uc3RydWN0W10ge1xuXG4gICAgY29uc3QgZm91bmQgPSBuZXcgU2V0PERlcGVuZGVuY3lWZXJ0ZXg+KCk7XG4gICAgY29uc3QgdG9wb2xvZ3k6IERlcGVuZGVuY3lWZXJ0ZXhbXSA9IFtdO1xuXG4gICAgZnVuY3Rpb24gdmlzaXQobjogRGVwZW5kZW5jeVZlcnRleCkge1xuICAgICAgZm9yIChjb25zdCBjIG9mIG4ub3V0Ym91bmQpIHtcbiAgICAgICAgdmlzaXQoYyk7XG4gICAgICB9XG4gICAgICBpZiAoIWZvdW5kLmhhcyhuKSkge1xuICAgICAgICB0b3BvbG9neS5wdXNoKG4pO1xuICAgICAgICBmb3VuZC5hZGQobik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmlzaXQodGhpcyk7XG5cbiAgICByZXR1cm4gdG9wb2xvZ3kuZmlsdGVyKGQgPT4gZC52YWx1ZSkubWFwKGQgPT4gZC52YWx1ZSEpO1xuXG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHZlcnRleCBhcyBhIGRlcGVuZGVuY3kgb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICogQWxzbyB1cGRhdGVzIHRoZSBwYXJlbnRzIG9mIGBkZXBgLCBzbyB0aGF0IGl0IGNvbnRhaW5zIHRoaXMgbm9kZSBhcyBhIHBhcmVudC5cbiAgICpcbiAgICogVGhpcyBvcGVyYXRpb24gd2lsbCBmYWlsIGluIGNhc2UgaXQgY3JlYXRlcyBhIGN5Y2xlIGluIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHBhcmFtIGRlcCBUaGUgZGVwZW5kZW5jeVxuICAgKi9cbiAgcHVibGljIGFkZENoaWxkKGRlcDogRGVwZW5kZW5jeVZlcnRleCkge1xuXG4gICAgY29uc3QgY3ljbGU6IERlcGVuZGVuY3lWZXJ0ZXhbXSA9IGRlcC5maW5kUm91dGUodGhpcyk7XG4gICAgaWYgKGN5Y2xlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgY3ljbGUucHVzaChkZXApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZXBlbmRlbmN5IGN5Y2xlIGRldGVjdGVkOiAke2N5Y2xlLmZpbHRlcihkID0+IGQudmFsdWUpLm1hcChkID0+IE5vZGUub2YoZC52YWx1ZSEpLnBhdGgpLmpvaW4oJyA9PiAnKX1gKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jaGlsZHJlbi5hZGQoZGVwKTtcbiAgICBkZXAuYWRkUGFyZW50KHRoaXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBhZGRQYXJlbnQoZGVwOiBEZXBlbmRlbmN5VmVydGV4KSB7XG4gICAgdGhpcy5fcGFyZW50cy5hZGQoZGVwKTtcbiAgfVxuXG4gIHByaXZhdGUgZmluZFJvdXRlKGRzdDogRGVwZW5kZW5jeVZlcnRleCk6IERlcGVuZGVuY3lWZXJ0ZXhbXSB7XG5cbiAgICBjb25zdCByb3V0ZTogRGVwZW5kZW5jeVZlcnRleFtdID0gW107XG4gICAgdmlzaXQodGhpcyk7XG4gICAgcmV0dXJuIHJvdXRlO1xuXG4gICAgZnVuY3Rpb24gdmlzaXQobjogRGVwZW5kZW5jeVZlcnRleCk6IGJvb2xlYW4ge1xuICAgICAgcm91dGUucHVzaChuKTtcbiAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBjIG9mIG4ub3V0Ym91bmQpIHtcbiAgICAgICAgaWYgKGMgPT09IGRzdCkge1xuICAgICAgICAgIHJvdXRlLnB1c2goYyk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm91bmQgPSB2aXNpdChjKTtcbiAgICAgIH1cbiAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgcm91dGUucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm91bmQ7XG5cbiAgICB9XG5cbiAgfVxufVxuIl19

/***/ }),

/***/ 9413:
/***/ ((__unused_webpack_module, exports) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Duration = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
/**
 * Represents a length of time.
 *
 * The amount can be specified either as a literal value (e.g: `10`) which
 * cannot be negative.
 *
 */
class Duration {
    constructor(amount, unit) {
        if (amount < 0) {
            throw new Error(`Duration amounts cannot be negative. Received: ${amount}`);
        }
        this.amount = amount;
        this.unit = unit;
    }
    /**
     * Create a Duration representing an amount of milliseconds
     *
     * @param amount the amount of Milliseconds the `Duration` will represent.
     * @returns a new `Duration` representing `amount` ms.
     */
    static millis(amount) {
        return new Duration(amount, TimeUnit.Milliseconds);
    }
    /**
     * Create a Duration representing an amount of seconds
     *
     * @param amount the amount of Seconds the `Duration` will represent.
     * @returns a new `Duration` representing `amount` Seconds.
     */
    static seconds(amount) {
        return new Duration(amount, TimeUnit.Seconds);
    }
    /**
     * Create a Duration representing an amount of minutes
     *
     * @param amount the amount of Minutes the `Duration` will represent.
     * @returns a new `Duration` representing `amount` Minutes.
     */
    static minutes(amount) {
        return new Duration(amount, TimeUnit.Minutes);
    }
    /**
     * Create a Duration representing an amount of hours
     *
     * @param amount the amount of Hours the `Duration` will represent.
     * @returns a new `Duration` representing `amount` Hours.
     */
    static hours(amount) {
        return new Duration(amount, TimeUnit.Hours);
    }
    /**
     * Create a Duration representing an amount of days
     *
     * @param amount the amount of Days the `Duration` will represent.
     * @returns a new `Duration` representing `amount` Days.
     */
    static days(amount) {
        return new Duration(amount, TimeUnit.Days);
    }
    /**
     * Parse a period formatted according to the ISO 8601 standard
     *
     * @see https://www.iso.org/fr/standard/70907.html
     * @param duration an ISO-formtted duration to be parsed.
     * @returns the parsed `Duration`.
     */
    static parse(duration) {
        const matches = duration.match(/^PT(?:(\d+)D)?(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?$/);
        if (!matches) {
            throw new Error(`Not a valid ISO duration: ${duration}`);
        }
        const [, days, hours, minutes, seconds] = matches;
        if (!days && !hours && !minutes && !seconds) {
            throw new Error(`Not a valid ISO duration: ${duration}`);
        }
        return Duration.millis(_toInt(seconds) * TimeUnit.Seconds.inMillis
            + (_toInt(minutes) * TimeUnit.Minutes.inMillis)
            + (_toInt(hours) * TimeUnit.Hours.inMillis)
            + (_toInt(days) * TimeUnit.Days.inMillis));
        function _toInt(str) {
            if (!str) {
                return 0;
            }
            return Number(str);
        }
    }
    /**
     * Return the total number of milliseconds in this Duration
     *
     * @returns the value of this `Duration` expressed in Milliseconds.
     */
    toMilliseconds(opts = {}) {
        return convert(this.amount, this.unit, TimeUnit.Milliseconds, opts);
    }
    /**
     * Return the total number of seconds in this Duration
     *
     * @returns the value of this `Duration` expressed in Seconds.
     */
    toSeconds(opts = {}) {
        return convert(this.amount, this.unit, TimeUnit.Seconds, opts);
    }
    /**
     * Return the total number of minutes in this Duration
     *
     * @returns the value of this `Duration` expressed in Minutes.
     */
    toMinutes(opts = {}) {
        return convert(this.amount, this.unit, TimeUnit.Minutes, opts);
    }
    /**
     * Return the total number of hours in this Duration
     *
     * @returns the value of this `Duration` expressed in Hours.
     */
    toHours(opts = {}) {
        return convert(this.amount, this.unit, TimeUnit.Hours, opts);
    }
    /**
     * Return the total number of days in this Duration
     *
     * @returns the value of this `Duration` expressed in Days.
     */
    toDays(opts = {}) {
        return convert(this.amount, this.unit, TimeUnit.Days, opts);
    }
    /**
     * Return an ISO 8601 representation of this period
     *
     * @returns a string starting with 'PT' describing the period
     * @see https://www.iso.org/fr/standard/70907.html
     */
    toIsoString() {
        if (this.amount === 0) {
            return 'PT0S';
        }
        switch (this.unit) {
            case TimeUnit.Seconds: return `PT${this.fractionDuration('S', 60, Duration.minutes)}`;
            case TimeUnit.Minutes: return `PT${this.fractionDuration('M', 60, Duration.hours)}`;
            case TimeUnit.Hours: return `PT${this.fractionDuration('H', 24, Duration.days)}`;
            case TimeUnit.Days: return `PT${this.amount}D`;
            default:
                throw new Error(`Unexpected time unit: ${this.unit}`);
        }
    }
    /**
     * Turn this duration into a human-readable string
     */
    toHumanString() {
        if (this.amount === 0) {
            return fmtUnit(0, this.unit);
        }
        let millis = convert(this.amount, this.unit, TimeUnit.Milliseconds, { integral: false });
        const parts = new Array();
        for (const unit of [TimeUnit.Days, TimeUnit.Hours, TimeUnit.Hours, TimeUnit.Minutes, TimeUnit.Seconds]) {
            const wholeCount = Math.floor(convert(millis, TimeUnit.Milliseconds, unit, { integral: false }));
            if (wholeCount > 0) {
                parts.push(fmtUnit(wholeCount, unit));
                millis -= wholeCount * unit.inMillis;
            }
        }
        // Remainder in millis
        if (millis > 0) {
            parts.push(fmtUnit(millis, TimeUnit.Milliseconds));
        }
        // 2 significant parts, that's totally enough for humans
        return parts.slice(0, 2).join(' ');
        function fmtUnit(amount, unit) {
            if (amount === 1) {
                // All of the labels end in 's'
                return `${amount} ${unit.label.substring(0, unit.label.length - 1)}`;
            }
            return `${amount} ${unit.label}`;
        }
    }
    fractionDuration(symbol, modulus, next) {
        if (this.amount < modulus) {
            return `${this.amount}${symbol}`;
        }
        const remainder = this.amount % modulus;
        const quotient = next((this.amount - remainder) / modulus).toIsoString().slice(2);
        return remainder > 0
            ? `${quotient}${remainder}${symbol}`
            : quotient;
    }
}
exports.Duration = Duration;
_a = JSII_RTTI_SYMBOL_1;
Duration[_a] = { fqn: "cdk8s.Duration", version: "2.3.11" };
class TimeUnit {
    constructor(label, inMillis) {
        this.label = label;
        this.inMillis = inMillis;
        // MAX_SAFE_INTEGER is 2^53, so by representing our duration in millis (the lowest
        // common unit) the highest duration we can represent is
        // 2^53 / 86*10^6 ~= 104 * 10^6 days (about 100 million days).
    }
    toString() {
        return this.label;
    }
}
TimeUnit.Milliseconds = new TimeUnit('millis', 1);
TimeUnit.Seconds = new TimeUnit('seconds', 1000);
TimeUnit.Minutes = new TimeUnit('minutes', 60000);
TimeUnit.Hours = new TimeUnit('hours', 3600000);
TimeUnit.Days = new TimeUnit('days', 86400000);
function convert(amount, fromUnit, toUnit, { integral = true }) {
    if (fromUnit.inMillis === toUnit.inMillis) {
        return amount;
    }
    const multiplier = fromUnit.inMillis / toUnit.inMillis;
    const value = amount * multiplier;
    if (!Number.isInteger(value) && integral) {
        throw new Error(`'${amount} ${fromUnit}' cannot be converted into a whole number of ${toUnit}.`);
    }
    return value;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHVyYXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvZHVyYXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Ozs7O0dBTUc7QUFDSCxNQUFhLFFBQVE7SUFtRm5CLFlBQW9CLE1BQWMsRUFBRSxJQUFjO1FBQ2hELElBQUksTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNkLE1BQU0sSUFBSSxLQUFLLENBQUMsa0RBQWtELE1BQU0sRUFBRSxDQUFDLENBQUM7U0FDN0U7UUFFRCxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztJQUNuQixDQUFDO0lBekZEOzs7OztPQUtHO0lBQ0ksTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFjO1FBQ2pDLE9BQU8sSUFBSSxRQUFRLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQWM7UUFDbEMsT0FBTyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBYztRQUNsQyxPQUFPLElBQUksUUFBUSxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFjO1FBQ2hDLE9BQU8sSUFBSSxRQUFRLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM5QyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQWM7UUFDL0IsT0FBTyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLElBQUks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R0FBRyxRQUFRLENBQUMsUUFBUSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUM7SUFFdkQsTUFBTSxLQUFLLEdBQUcsTUFBTSxHQUFHLFVBQVUsQ0FBQztJQUNsQyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxRQUFRLEVBQUU7UUFDeEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxJQUFJLE1BQU0sSUFBSSxRQUFRLGdEQUFnRCxNQUFNLEdBQUcsQ0FBQyxDQUFDO0tBQ2xHO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZXByZXNlbnRzIGEgbGVuZ3RoIG9mIHRpbWUuXG4gKlxuICogVGhlIGFtb3VudCBjYW4gYmUgc3BlY2lmaWVkIGVpdGhlciBhcyBhIGxpdGVyYWwgdmFsdWUgKGUuZzogYDEwYCkgd2hpY2hcbiAqIGNhbm5vdCBiZSBuZWdhdGl2ZS5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBEdXJhdGlvbiB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiByZXByZXNlbnRpbmcgYW4gYW1vdW50IG9mIG1pbGxpc2Vjb25kc1xuICAgKlxuICAgKiBAcGFyYW0gYW1vdW50IHRoZSBhbW91bnQgb2YgTWlsbGlzZWNvbmRzIHRoZSBgRHVyYXRpb25gIHdpbGwgcmVwcmVzZW50LlxuICAgKiBAcmV0dXJucyBhIG5ldyBgRHVyYXRpb25gIHJlcHJlc2VudGluZyBgYW1vdW50YCBtcy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWlsbGlzKGFtb3VudDogbnVtYmVyKTogRHVyYXRpb24ge1xuICAgIHJldHVybiBuZXcgRHVyYXRpb24oYW1vdW50LCBUaW1lVW5pdC5NaWxsaXNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIER1cmF0aW9uIHJlcHJlc2VudGluZyBhbiBhbW91bnQgb2Ygc2Vjb25kc1xuICAgKlxuICAgKiBAcGFyYW0gYW1vdW50IHRoZSBhbW91bnQgb2YgU2Vjb25kcyB0aGUgYER1cmF0aW9uYCB3aWxsIHJlcHJlc2VudC5cbiAgICogQHJldHVybnMgYSBuZXcgYER1cmF0aW9uYCByZXByZXNlbnRpbmcgYGFtb3VudGAgU2Vjb25kcy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgc2Vjb25kcyhhbW91bnQ6IG51bWJlcik6IER1cmF0aW9uIHtcbiAgICByZXR1cm4gbmV3IER1cmF0aW9uKGFtb3VudCwgVGltZVVuaXQuU2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gcmVwcmVzZW50aW5nIGFuIGFtb3VudCBvZiBtaW51dGVzXG4gICAqXG4gICAqIEBwYXJhbSBhbW91bnQgdGhlIGFtb3VudCBvZiBNaW51dGVzIHRoZSBgRHVyYXRpb25gIHdpbGwgcmVwcmVzZW50LlxuICAgKiBAcmV0dXJucyBhIG5ldyBgRHVyYXRpb25gIHJlcHJlc2VudGluZyBgYW1vdW50YCBNaW51dGVzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtaW51dGVzKGFtb3VudDogbnVtYmVyKTogRHVyYXRpb24ge1xuICAgIHJldHVybiBuZXcgRHVyYXRpb24oYW1vdW50LCBUaW1lVW5pdC5NaW51dGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiByZXByZXNlbnRpbmcgYW4gYW1vdW50IG9mIGhvdXJzXG4gICAqXG4gICAqIEBwYXJhbSBhbW91bnQgdGhlIGFtb3VudCBvZiBIb3VycyB0aGUgYER1cmF0aW9uYCB3aWxsIHJlcHJlc2VudC5cbiAgICogQHJldHVybnMgYSBuZXcgYER1cmF0aW9uYCByZXByZXNlbnRpbmcgYGFtb3VudGAgSG91cnMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGhvdXJzKGFtb3VudDogbnVtYmVyKTogRHVyYXRpb24ge1xuICAgIHJldHVybiBuZXcgRHVyYXRpb24oYW1vdW50LCBUaW1lVW5pdC5Ib3Vycyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gcmVwcmVzZW50aW5nIGFuIGFtb3VudCBvZiBkYXlzXG4gICAqXG4gICAqIEBwYXJhbSBhbW91bnQgdGhlIGFtb3VudCBvZiBEYXlzIHRoZSBgRHVyYXRpb25gIHdpbGwgcmVwcmVzZW50LlxuICAgKiBAcmV0dXJucyBhIG5ldyBgRHVyYXRpb25gIHJlcHJlc2VudGluZyBgYW1vdW50YCBEYXlzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBkYXlzKGFtb3VudDogbnVtYmVyKTogRHVyYXRpb24ge1xuICAgIHJldHVybiBuZXcgRHVyYXRpb24oYW1vdW50LCBUaW1lVW5pdC5EYXlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHBlcmlvZCBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBJU08gODYwMSBzdGFuZGFyZFxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3Lmlzby5vcmcvZnIvc3RhbmRhcmQvNzA5MDcuaHRtbFxuICAgKiBAcGFyYW0gZHVyYXRpb24gYW4gSVNPLWZvcm10dGVkIGR1cmF0aW9uIHRvIGJlIHBhcnNlZC5cbiAgICogQHJldHVybnMgdGhlIHBhcnNlZCBgRHVyYXRpb25gLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBwYXJzZShkdXJhdGlvbjogc3RyaW5nKTogRHVyYXRpb24ge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBkdXJhdGlvbi5tYXRjaCgvXlBUKD86KFxcZCspRCk/KD86KFxcZCspSCk/KD86KFxcZCspTSk/KD86KFxcZCspUyk/JC8pO1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgYSB2YWxpZCBJU08gZHVyYXRpb246ICR7ZHVyYXRpb259YCk7XG4gICAgfVxuICAgIGNvbnN0IFssIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzXSA9IG1hdGNoZXM7XG4gICAgaWYgKCFkYXlzICYmICFob3VycyAmJiAhbWludXRlcyAmJiAhc2Vjb25kcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgYSB2YWxpZCBJU08gZHVyYXRpb246ICR7ZHVyYXRpb259YCk7XG4gICAgfVxuICAgIHJldHVybiBEdXJhdGlvbi5taWxsaXMoXG4gICAgICBfdG9JbnQoc2Vjb25kcykgKiBUaW1lVW5pdC5TZWNvbmRzLmluTWlsbGlzXG4gICAgICArIChfdG9JbnQobWludXRlcykgKiBUaW1lVW5pdC5NaW51dGVzLmluTWlsbGlzKVxuICAgICAgKyAoX3RvSW50KGhvdXJzKSAqIFRpbWVVbml0LkhvdXJzLmluTWlsbGlzKVxuICAgICAgKyAoX3RvSW50KGRheXMpICogVGltZVVuaXQuRGF5cy5pbk1pbGxpcyksXG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIF90b0ludChzdHI6IHN0cmluZyk6IG51bWJlciB7XG4gICAgICBpZiAoIXN0cikgeyByZXR1cm4gMDsgfVxuICAgICAgcmV0dXJuIE51bWJlcihzdHIpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVhZG9ubHkgYW1vdW50OiBudW1iZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgdW5pdDogVGltZVVuaXQ7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihhbW91bnQ6IG51bWJlciwgdW5pdDogVGltZVVuaXQpIHtcbiAgICBpZiAoYW1vdW50IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXJhdGlvbiBhbW91bnRzIGNhbm5vdCBiZSBuZWdhdGl2ZS4gUmVjZWl2ZWQ6ICR7YW1vdW50fWApO1xuICAgIH1cblxuICAgIHRoaXMuYW1vdW50ID0gYW1vdW50O1xuICAgIHRoaXMudW5pdCA9IHVuaXQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB0b3RhbCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGluIHRoaXMgRHVyYXRpb25cbiAgICpcbiAgICogQHJldHVybnMgdGhlIHZhbHVlIG9mIHRoaXMgYER1cmF0aW9uYCBleHByZXNzZWQgaW4gTWlsbGlzZWNvbmRzLlxuICAgKi9cbiAgcHVibGljIHRvTWlsbGlzZWNvbmRzKG9wdHM6IFRpbWVDb252ZXJzaW9uT3B0aW9ucyA9IHt9KTogbnVtYmVyIHtcbiAgICByZXR1cm4gY29udmVydCh0aGlzLmFtb3VudCwgdGhpcy51bml0LCBUaW1lVW5pdC5NaWxsaXNlY29uZHMsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdG90YWwgbnVtYmVyIG9mIHNlY29uZHMgaW4gdGhpcyBEdXJhdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhpcyBgRHVyYXRpb25gIGV4cHJlc3NlZCBpbiBTZWNvbmRzLlxuICAgKi9cbiAgcHVibGljIHRvU2Vjb25kcyhvcHRzOiBUaW1lQ29udmVyc2lvbk9wdGlvbnMgPSB7fSk6IG51bWJlciB7XG4gICAgcmV0dXJuIGNvbnZlcnQodGhpcy5hbW91bnQsIHRoaXMudW5pdCwgVGltZVVuaXQuU2Vjb25kcywgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB0b3RhbCBudW1iZXIgb2YgbWludXRlcyBpbiB0aGlzIER1cmF0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGlzIGBEdXJhdGlvbmAgZXhwcmVzc2VkIGluIE1pbnV0ZXMuXG4gICAqL1xuICBwdWJsaWMgdG9NaW51dGVzKG9wdHM6IFRpbWVDb252ZXJzaW9uT3B0aW9ucyA9IHt9KTogbnVtYmVyIHtcbiAgICByZXR1cm4gY29udmVydCh0aGlzLmFtb3VudCwgdGhpcy51bml0LCBUaW1lVW5pdC5NaW51dGVzLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHRvdGFsIG51bWJlciBvZiBob3VycyBpbiB0aGlzIER1cmF0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGlzIGBEdXJhdGlvbmAgZXhwcmVzc2VkIGluIEhvdXJzLlxuICAgKi9cbiAgcHVibGljIHRvSG91cnMob3B0czogVGltZUNvbnZlcnNpb25PcHRpb25zID0ge30pOiBudW1iZXIge1xuICAgIHJldHVybiBjb252ZXJ0KHRoaXMuYW1vdW50LCB0aGlzLnVuaXQsIFRpbWVVbml0LkhvdXJzLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHRvdGFsIG51bWJlciBvZiBkYXlzIGluIHRoaXMgRHVyYXRpb25cbiAgICpcbiAgICogQHJldHVybnMgdGhlIHZhbHVlIG9mIHRoaXMgYER1cmF0aW9uYCBleHByZXNzZWQgaW4gRGF5cy5cbiAgICovXG4gIHB1YmxpYyB0b0RheXMob3B0czogVGltZUNvbnZlcnNpb25PcHRpb25zID0ge30pOiBudW1iZXIge1xuICAgIHJldHVybiBjb252ZXJ0KHRoaXMuYW1vdW50LCB0aGlzLnVuaXQsIFRpbWVVbml0LkRheXMsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJU08gODYwMSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHBlcmlvZFxuICAgKlxuICAgKiBAcmV0dXJucyBhIHN0cmluZyBzdGFydGluZyB3aXRoICdQVCcgZGVzY3JpYmluZyB0aGUgcGVyaW9kXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cuaXNvLm9yZy9mci9zdGFuZGFyZC83MDkwNy5odG1sXG4gICAqL1xuICBwdWJsaWMgdG9Jc29TdHJpbmcoKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5hbW91bnQgPT09IDApIHsgcmV0dXJuICdQVDBTJzsgfVxuICAgIHN3aXRjaCAodGhpcy51bml0KSB7XG4gICAgICBjYXNlIFRpbWVVbml0LlNlY29uZHM6IHJldHVybiBgUFQke3RoaXMuZnJhY3Rpb25EdXJhdGlvbignUycsIDYwLCBEdXJhdGlvbi5taW51dGVzKX1gO1xuICAgICAgY2FzZSBUaW1lVW5pdC5NaW51dGVzOiByZXR1cm4gYFBUJHt0aGlzLmZyYWN0aW9uRHVyYXRpb24oJ00nLCA2MCwgRHVyYXRpb24uaG91cnMpfWA7XG4gICAgICBjYXNlIFRpbWVVbml0LkhvdXJzOiByZXR1cm4gYFBUJHt0aGlzLmZyYWN0aW9uRHVyYXRpb24oJ0gnLCAyNCwgRHVyYXRpb24uZGF5cyl9YDtcbiAgICAgIGNhc2UgVGltZVVuaXQuRGF5czogcmV0dXJuIGBQVCR7dGhpcy5hbW91bnR9RGA7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdGltZSB1bml0OiAke3RoaXMudW5pdH1gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHVybiB0aGlzIGR1cmF0aW9uIGludG8gYSBodW1hbi1yZWFkYWJsZSBzdHJpbmdcbiAgICovXG4gIHB1YmxpYyB0b0h1bWFuU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMuYW1vdW50ID09PSAwKSB7IHJldHVybiBmbXRVbml0KDAsIHRoaXMudW5pdCk7IH1cblxuICAgIGxldCBtaWxsaXMgPSBjb252ZXJ0KHRoaXMuYW1vdW50LCB0aGlzLnVuaXQsIFRpbWVVbml0Lk1pbGxpc2Vjb25kcywgeyBpbnRlZ3JhbDogZmFsc2UgfSk7XG4gICAgY29uc3QgcGFydHMgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuXG4gICAgZm9yIChjb25zdCB1bml0IG9mIFtUaW1lVW5pdC5EYXlzLCBUaW1lVW5pdC5Ib3VycywgVGltZVVuaXQuSG91cnMsIFRpbWVVbml0Lk1pbnV0ZXMsIFRpbWVVbml0LlNlY29uZHNdKSB7XG4gICAgICBjb25zdCB3aG9sZUNvdW50ID0gTWF0aC5mbG9vcihjb252ZXJ0KG1pbGxpcywgVGltZVVuaXQuTWlsbGlzZWNvbmRzLCB1bml0LCB7IGludGVncmFsOiBmYWxzZSB9KSk7XG4gICAgICBpZiAod2hvbGVDb3VudCA+IDApIHtcbiAgICAgICAgcGFydHMucHVzaChmbXRVbml0KHdob2xlQ291bnQsIHVuaXQpKTtcbiAgICAgICAgbWlsbGlzIC09IHdob2xlQ291bnQgKiB1bml0LmluTWlsbGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbWFpbmRlciBpbiBtaWxsaXNcbiAgICBpZiAobWlsbGlzID4gMCkge1xuICAgICAgcGFydHMucHVzaChmbXRVbml0KG1pbGxpcywgVGltZVVuaXQuTWlsbGlzZWNvbmRzKSk7XG4gICAgfVxuXG4gICAgLy8gMiBzaWduaWZpY2FudCBwYXJ0cywgdGhhdCdzIHRvdGFsbHkgZW5vdWdoIGZvciBodW1hbnNcbiAgICByZXR1cm4gcGFydHMuc2xpY2UoMCwgMikuam9pbignICcpO1xuXG4gICAgZnVuY3Rpb24gZm10VW5pdChhbW91bnQ6IG51bWJlciwgdW5pdDogVGltZVVuaXQpIHtcbiAgICAgIGlmIChhbW91bnQgPT09IDEpIHtcbiAgICAgICAgLy8gQWxsIG9mIHRoZSBsYWJlbHMgZW5kIGluICdzJ1xuICAgICAgICByZXR1cm4gYCR7YW1vdW50fSAke3VuaXQubGFiZWwuc3Vic3RyaW5nKDAsIHVuaXQubGFiZWwubGVuZ3RoIC0gMSl9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgJHthbW91bnR9ICR7dW5pdC5sYWJlbH1gO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZnJhY3Rpb25EdXJhdGlvbihzeW1ib2w6IHN0cmluZywgbW9kdWx1czogbnVtYmVyLCBuZXh0OiAoYW1vdW50OiBudW1iZXIpID0+IER1cmF0aW9uKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5hbW91bnQgPCBtb2R1bHVzKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5hbW91bnR9JHtzeW1ib2x9YDtcbiAgICB9XG4gICAgY29uc3QgcmVtYWluZGVyID0gdGhpcy5hbW91bnQgJSBtb2R1bHVzO1xuICAgIGNvbnN0IHF1b3RpZW50ID0gbmV4dCgodGhpcy5hbW91bnQgLSByZW1haW5kZXIpIC8gbW9kdWx1cykudG9Jc29TdHJpbmcoKS5zbGljZSgyKTtcbiAgICByZXR1cm4gcmVtYWluZGVyID4gMFxuICAgICAgPyBgJHtxdW90aWVudH0ke3JlbWFpbmRlcn0ke3N5bWJvbH1gXG4gICAgICA6IHF1b3RpZW50O1xuICB9XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgaG93IHRvIGNvbnZlcnQgdGltZSB0byBhIGRpZmZlcmVudCB1bml0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRpbWVDb252ZXJzaW9uT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIGNvbnZlcnNpb25zIGludG8gYSBsYXJnZXIgdGltZSB1bml0IChlLmcuIGBTZWNvbmRzYCB0byBgTWludXRlc2ApIHdpbGwgZmFpbCBpZiB0aGUgcmVzdWx0IGlzIG5vdCBhblxuICAgKiBpbnRlZ2VyLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBpbnRlZ3JhbD86IGJvb2xlYW47XG59XG5cbmNsYXNzIFRpbWVVbml0IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBNaWxsaXNlY29uZHMgPSBuZXcgVGltZVVuaXQoJ21pbGxpcycsIDEpO1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFNlY29uZHMgPSBuZXcgVGltZVVuaXQoJ3NlY29uZHMnLCAxXzAwMCk7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTWludXRlcyA9IG5ldyBUaW1lVW5pdCgnbWludXRlcycsIDYwXzAwMCk7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgSG91cnMgPSBuZXcgVGltZVVuaXQoJ2hvdXJzJywgM182MDBfMDAwKTtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBEYXlzID0gbmV3IFRpbWVVbml0KCdkYXlzJywgODZfNDAwXzAwMCk7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgbGFiZWw6IHN0cmluZywgcHVibGljIHJlYWRvbmx5IGluTWlsbGlzOiBudW1iZXIpIHtcbiAgICAvLyBNQVhfU0FGRV9JTlRFR0VSIGlzIDJeNTMsIHNvIGJ5IHJlcHJlc2VudGluZyBvdXIgZHVyYXRpb24gaW4gbWlsbGlzICh0aGUgbG93ZXN0XG4gICAgLy8gY29tbW9uIHVuaXQpIHRoZSBoaWdoZXN0IGR1cmF0aW9uIHdlIGNhbiByZXByZXNlbnQgaXNcbiAgICAvLyAyXjUzIC8gODYqMTBeNiB+PSAxMDQgKiAxMF42IGRheXMgKGFib3V0IDEwMCBtaWxsaW9uIGRheXMpLlxuICB9XG5cbiAgcHVibGljIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmxhYmVsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnQoYW1vdW50OiBudW1iZXIsIGZyb21Vbml0OiBUaW1lVW5pdCwgdG9Vbml0OiBUaW1lVW5pdCwgeyBpbnRlZ3JhbCA9IHRydWUgfTogVGltZUNvbnZlcnNpb25PcHRpb25zKSB7XG4gIGlmIChmcm9tVW5pdC5pbk1pbGxpcyA9PT0gdG9Vbml0LmluTWlsbGlzKSB7IHJldHVybiBhbW91bnQ7IH1cbiAgY29uc3QgbXVsdGlwbGllciA9IGZyb21Vbml0LmluTWlsbGlzIC8gdG9Vbml0LmluTWlsbGlzO1xuXG4gIGNvbnN0IHZhbHVlID0gYW1vdW50ICogbXVsdGlwbGllcjtcbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSAmJiBpbnRlZ3JhbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJyR7YW1vdW50fSAke2Zyb21Vbml0fScgY2Fubm90IGJlIGNvbnZlcnRlZCBpbnRvIGEgd2hvbGUgbnVtYmVyIG9mICR7dG9Vbml0fS5gKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59Il19

/***/ }),

/***/ 6830:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Helm = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const fs = __nccwpck_require__(7147);
const os = __nccwpck_require__(2037);
const path = __nccwpck_require__(1017);
const yaml = __nccwpck_require__(2569);
const _child_process_1 = __nccwpck_require__(2580);
const include_1 = __nccwpck_require__(4300);
const names_1 = __nccwpck_require__(3948);
const MAX_HELM_BUFFER = 10 * 1024 * 1024;
/**
 * Represents a Helm deployment.
 *
 * Use this construct to import an existing Helm chart and incorporate it into your constructs.
 */
class Helm extends include_1.Include {
    constructor(scope, id, props) {
        var _b, _c;
        const workdir = fs.mkdtempSync(path.join(os.tmpdir(), 'cdk8s-helm-'));
        const args = new Array();
        args.push('template');
        // values
        if (props.values && Object.keys(props.values).length > 0) {
            const valuesPath = path.join(workdir, 'overrides.yaml');
            fs.writeFileSync(valuesPath, yaml.stringify(props.values));
            args.push('-f', valuesPath);
        }
        // custom flags
        if (props.helmFlags) {
            args.push(...props.helmFlags);
        }
        // release name
        // constraints: https://github.com/helm/helm/issues/6006
        const releaseName = (_b = props.releaseName) !== null && _b !== void 0 ? _b : names_1.Names.toDnsLabel(scope, { maxLen: 53, extra: [id] });
        args.push(releaseName);
        // chart
        args.push(props.chart);
        const prog = (_c = props.helmExecutable) !== null && _c !== void 0 ? _c : 'helm';
        const outputFile = renderTemplate(workdir, prog, args);
        super(scope, id, { url: outputFile });
        this.releaseName = releaseName;
    }
}
exports.Helm = Helm;
_a = JSII_RTTI_SYMBOL_1;
Helm[_a] = { fqn: "cdk8s.Helm", version: "2.3.11" };
function renderTemplate(workdir, prog, args) {
    const helm = _child_process_1._child_process.spawnSync(prog, args, {
        maxBuffer: MAX_HELM_BUFFER,
    });
    if (helm.error) {
        const err = helm.error.message;
        if (err.includes('ENOENT')) {
            throw new Error(`unable to execute '${prog}' to render Helm chart. Is it installed on your system?`);
        }
        throw new Error(`error while rendering a helm chart: ${err}`);
    }
    if (helm.status !== 0) {
        throw new Error(helm.stderr.toString());
    }
    const outputFile = path.join(workdir, 'chart.yaml');
    const stdout = helm.stdout;
    fs.writeFileSync(outputFile, stdout);
    return outputFile;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVsbS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9oZWxtLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFFN0IsNkJBQTZCO0FBQzdCLHFEQUFrRDtBQUNsRCx1Q0FBb0M7QUFDcEMsbUNBQWdDO0FBRWhDLE1BQU0sZUFBZSxHQUFHLEVBQUUsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBOEN6Qzs7OztHQUlHO0FBQ0gsTUFBYSxJQUFLLFNBQVEsaUJBQU87SUFNL0IsWUFBWSxLQUFnQixFQUFFLEVBQVUsRUFBRSxLQUFnQjs7UUFDeEQsTUFBTSxPQUFPLEdBQUcsRUFBRSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxhQUFhLENBQUMsQ0FBQyxDQUFDO1FBRXRFLE1BQU0sSUFBSSxHQUFHLElBQUksS0FBSyxFQUFVLENBQUM7UUFDakMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUV0QixTQUFTO1FBQ1QsSUFBSSxLQUFLLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDeEQsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztZQUN4RCxFQUFFLENBQUMsYUFBYSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQzNELElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1NBQzdCO1FBRUQsZUFBZTtRQUNmLElBQUksS0FBSyxDQUFDLFNBQVMsRUFBRTtZQUNuQixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQy9CO1FBRUQsZUFBZTtRQUNmLHdEQUF3RDtRQUN4RCxNQUFNLFdBQVcsU0FBRyxLQUFLLENBQUMsV0FBVyxtQ0FBSSxhQUFLLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzlGLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFdkIsUUFBUTtRQUNSLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXZCLE1BQU0sSUFBSSxTQUFHLEtBQUssQ0FBQyxjQUFjLG1DQUFJLE1BQU0sQ0FBQztRQUM1QyxNQUFNLFVBQVUsR0FBRyxjQUFjLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUV2RCxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDO1FBRXRDLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO0lBQ2pDLENBQUM7O0FBdENILG9CQXVDQzs7O0FBRUQsU0FBUyxjQUFjLENBQUMsT0FBZSxFQUFFLElBQVksRUFBRSxJQUFjO0lBQ25FLE1BQU0sSUFBSSxHQUFHLCtCQUFjLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUU7UUFDaEQsU0FBUyxFQUFFLGVBQWU7S0FDM0IsQ0FBQyxDQUFDO0lBRUgsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1FBQ2QsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUM7UUFDL0IsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQzFCLE1BQU0sSUFBSSxLQUFLLENBQUMsc0JBQXNCLElBQUkseURBQXlELENBQUMsQ0FBQztTQUN0RztRQUVELE1BQU0sSUFBSSxLQUFLLENBQUMsdUNBQXVDLEdBQUcsRUFBRSxDQUFDLENBQUM7S0FDL0Q7SUFFRCxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3JCLE1BQU0sSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO0tBQ3pDO0lBRUQsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDcEQsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUMzQixFQUFFLENBQUMsYUFBYSxDQUFDLFVBQVUsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUNyQyxPQUFPLFVBQVUsQ0FBQztBQUNwQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgb3MgZnJvbSAnb3MnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xuaW1wb3J0ICogYXMgeWFtbCBmcm9tICd5YW1sJztcbmltcG9ydCB7IF9jaGlsZF9wcm9jZXNzIH0gZnJvbSAnLi9fY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgeyBJbmNsdWRlIH0gZnJvbSAnLi9pbmNsdWRlJztcbmltcG9ydCB7IE5hbWVzIH0gZnJvbSAnLi9uYW1lcyc7XG5cbmNvbnN0IE1BWF9IRUxNX0JVRkZFUiA9IDEwICogMTAyNCAqIDEwMjQ7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYEhlbG1gLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEhlbG1Qcm9wcyB7XG4gIC8qKlxuICAgKiBUaGUgY2hhcnQgbmFtZSB0byB1c2UuIEl0IGNhbiBiZSBhIGNoYXJ0IGZyb20gYSBoZWxtIHJlcG9zaXRvcnkgb3IgYSBsb2NhbCBkaXJlY3RvcnkuXG4gICAqXG4gICAqIFRoaXMgbmFtZSBpcyBwYXNzZWQgdG8gYGhlbG0gdGVtcGxhdGVgIGFuZCBoYXMgYWxsIHRoZSByZWxldmFudCBzZW1hbnRpY3MuXG4gICAqXG4gICAqIEBleGFtcGxlIFwiLi9teXNxbFwiXG4gICAqIEBleGFtcGxlIFwiYml0bmFtaS9yZWRpc1wiXG4gICAqL1xuICByZWFkb25seSBjaGFydDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVsZWFzZSBuYW1lLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vaGVsbS5zaC9kb2NzL2ludHJvL3VzaW5nX2hlbG0vI3RocmVlLWJpZy1jb25jZXB0c1xuICAgKiBAZGVmYXVsdCAtIGlmIHVuc3BlY2lmaWVkLCBhIG5hbWUgd2lsbCBiZSBhbGxvY2F0ZWQgYmFzZWQgb24gdGhlIGNvbnN0cnVjdCBwYXRoXG4gICAqL1xuICByZWFkb25seSByZWxlYXNlTmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogVmFsdWVzIHRvIHBhc3MgdG8gdGhlIGNoYXJ0LlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIElmIG5vIHZhbHVlcyBhcmUgc3BlY2lmaWVkLCBjaGFydCB3aWxsIHVzZSB0aGUgZGVmYXVsdHMuXG4gICAqL1xuICByZWFkb25seSB2YWx1ZXM/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xuXG4gIC8qKlxuICAgKiBUaGUgbG9jYWwgaGVsbSBleGVjdXRhYmxlIHRvIHVzZSBpbiBvcmRlciB0byBjcmVhdGUgdGhlIG1hbmlmZXN0IHRoZSBjaGFydC5cbiAgICpcbiAgICogQGRlZmF1bHQgXCJoZWxtXCJcbiAgICovXG4gIHJlYWRvbmx5IGhlbG1FeGVjdXRhYmxlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBZGRpdGlvbmFsIGZsYWdzIHRvIGFkZCB0byB0aGUgYGhlbG1gIGV4ZWN1dGlvbi5cbiAgICpcbiAgICogQGRlZmF1bHQgW11cbiAgICovXG4gIHJlYWRvbmx5IGhlbG1GbGFncz86IHN0cmluZ1tdO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBIZWxtIGRlcGxveW1lbnQuXG4gKlxuICogVXNlIHRoaXMgY29uc3RydWN0IHRvIGltcG9ydCBhbiBleGlzdGluZyBIZWxtIGNoYXJ0IGFuZCBpbmNvcnBvcmF0ZSBpdCBpbnRvIHlvdXIgY29uc3RydWN0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIEhlbG0gZXh0ZW5kcyBJbmNsdWRlIHtcbiAgLyoqXG4gICAqIFRoZSBoZWxtIHJlbGVhc2UgbmFtZS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSByZWxlYXNlTmFtZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBIZWxtUHJvcHMpIHtcbiAgICBjb25zdCB3b3JrZGlyID0gZnMubWtkdGVtcFN5bmMocGF0aC5qb2luKG9zLnRtcGRpcigpLCAnY2RrOHMtaGVsbS0nKSk7XG5cbiAgICBjb25zdCBhcmdzID0gbmV3IEFycmF5PHN0cmluZz4oKTtcbiAgICBhcmdzLnB1c2goJ3RlbXBsYXRlJyk7XG5cbiAgICAvLyB2YWx1ZXNcbiAgICBpZiAocHJvcHMudmFsdWVzICYmIE9iamVjdC5rZXlzKHByb3BzLnZhbHVlcykubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgdmFsdWVzUGF0aCA9IHBhdGguam9pbih3b3JrZGlyLCAnb3ZlcnJpZGVzLnlhbWwnKTtcbiAgICAgIGZzLndyaXRlRmlsZVN5bmModmFsdWVzUGF0aCwgeWFtbC5zdHJpbmdpZnkocHJvcHMudmFsdWVzKSk7XG4gICAgICBhcmdzLnB1c2goJy1mJywgdmFsdWVzUGF0aCk7XG4gICAgfVxuXG4gICAgLy8gY3VzdG9tIGZsYWdzXG4gICAgaWYgKHByb3BzLmhlbG1GbGFncykge1xuICAgICAgYXJncy5wdXNoKC4uLnByb3BzLmhlbG1GbGFncyk7XG4gICAgfVxuXG4gICAgLy8gcmVsZWFzZSBuYW1lXG4gICAgLy8gY29uc3RyYWludHM6IGh0dHBzOi8vZ2l0aHViLmNvbS9oZWxtL2hlbG0vaXNzdWVzLzYwMDZcbiAgICBjb25zdCByZWxlYXNlTmFtZSA9IHByb3BzLnJlbGVhc2VOYW1lID8/IE5hbWVzLnRvRG5zTGFiZWwoc2NvcGUsIHsgbWF4TGVuOiA1MywgZXh0cmE6IFtpZF0gfSk7XG4gICAgYXJncy5wdXNoKHJlbGVhc2VOYW1lKTtcblxuICAgIC8vIGNoYXJ0XG4gICAgYXJncy5wdXNoKHByb3BzLmNoYXJ0KTtcblxuICAgIGNvbnN0IHByb2cgPSBwcm9wcy5oZWxtRXhlY3V0YWJsZSA/PyAnaGVsbSc7XG4gICAgY29uc3Qgb3V0cHV0RmlsZSA9IHJlbmRlclRlbXBsYXRlKHdvcmtkaXIsIHByb2csIGFyZ3MpO1xuXG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7IHVybDogb3V0cHV0RmlsZSB9KTtcblxuICAgIHRoaXMucmVsZWFzZU5hbWUgPSByZWxlYXNlTmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJUZW1wbGF0ZSh3b3JrZGlyOiBzdHJpbmcsIHByb2c6IHN0cmluZywgYXJnczogc3RyaW5nW10pIHtcbiAgY29uc3QgaGVsbSA9IF9jaGlsZF9wcm9jZXNzLnNwYXduU3luYyhwcm9nLCBhcmdzLCB7XG4gICAgbWF4QnVmZmVyOiBNQVhfSEVMTV9CVUZGRVIsXG4gIH0pO1xuXG4gIGlmIChoZWxtLmVycm9yKSB7XG4gICAgY29uc3QgZXJyID0gaGVsbS5lcnJvci5tZXNzYWdlO1xuICAgIGlmIChlcnIuaW5jbHVkZXMoJ0VOT0VOVCcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuYWJsZSB0byBleGVjdXRlICcke3Byb2d9JyB0byByZW5kZXIgSGVsbSBjaGFydC4gSXMgaXQgaW5zdGFsbGVkIG9uIHlvdXIgc3lzdGVtP2ApO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihgZXJyb3Igd2hpbGUgcmVuZGVyaW5nIGEgaGVsbSBjaGFydDogJHtlcnJ9YCk7XG4gIH1cblxuICBpZiAoaGVsbS5zdGF0dXMgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoaGVsbS5zdGRlcnIudG9TdHJpbmcoKSk7XG4gIH1cblxuICBjb25zdCBvdXRwdXRGaWxlID0gcGF0aC5qb2luKHdvcmtkaXIsICdjaGFydC55YW1sJyk7XG4gIGNvbnN0IHN0ZG91dCA9IGhlbG0uc3Rkb3V0O1xuICBmcy53cml0ZUZpbGVTeW5jKG91dHB1dEZpbGUsIHN0ZG91dCk7XG4gIHJldHVybiBvdXRwdXRGaWxlO1xufVxuIl19

/***/ }),

/***/ 4300:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Include = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const constructs_1 = __nccwpck_require__(1963);
const api_object_1 = __nccwpck_require__(4752);
const yaml_1 = __nccwpck_require__(5096);
/**
 * Reads a YAML manifest from a file or a URL and defines all resources as API
 * objects within the defined scope.
 *
 * The names (`metadata.name`) of imported resources will be preserved as-is
 * from the manifest.
 */
class Include extends constructs_1.Construct {
    constructor(scope, id, props) {
        var _b, _c, _d, _e;
        super(scope, id);
        const objects = yaml_1.Yaml.load(props.url);
        let order = 0;
        for (const obj of objects) {
            const objname = (_c = (_b = obj.metadata) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : `object${order++}`;
            // render an id: name[-kind][-namespace]
            const objid = [objname, (_d = obj.kind) === null || _d === void 0 ? void 0 : _d.toLowerCase(), (_e = obj.metadata) === null || _e === void 0 ? void 0 : _e.namespace].filter(x => x).join('-');
            new api_object_1.ApiObject(this, objid, obj);
        }
    }
    /**
     * Returns all the included API objects.
     */
    get apiObjects() {
        return constructs_1.Node.of(this).children.filter(o => o instanceof api_object_1.ApiObject);
    }
}
exports.Include = Include;
_a = JSII_RTTI_SYMBOL_1;
Include[_a] = { fqn: "cdk8s.Include", version: "2.3.11" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5jbHVkZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmNsdWRlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsMkNBQTZDO0FBQzdDLDZDQUF5QztBQUN6QyxpQ0FBOEI7QUFXOUI7Ozs7OztHQU1HO0FBQ0gsTUFBYSxPQUFRLFNBQVEsc0JBQVM7SUFDcEMsWUFBWSxLQUFnQixFQUFFLEVBQVUsRUFBRSxLQUFtQjs7UUFDM0QsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUVqQixNQUFNLE9BQU8sR0FBRyxXQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVyQyxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7UUFDZCxLQUFLLE1BQU0sR0FBRyxJQUFJLE9BQU8sRUFBRTtZQUN6QixNQUFNLE9BQU8sZUFBRyxHQUFHLENBQUMsUUFBUSwwQ0FBRSxJQUFJLG1DQUFJLFNBQVMsS0FBSyxFQUFFLEVBQUUsQ0FBQztZQUV6RCx3Q0FBd0M7WUFDeEMsTUFBTSxLQUFLLEdBQUcsQ0FBQyxPQUFPLFFBQUUsR0FBRyxDQUFDLElBQUksMENBQUUsV0FBVyxVQUFJLEdBQUcsQ0FBQyxRQUFRLDBDQUFFLFNBQVMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNuRyxJQUFJLHNCQUFTLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztTQUNqQztJQUNILENBQUM7SUFFRDs7T0FFRztJQUNILElBQVcsVUFBVTtRQUNuQixPQUFPLGlCQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFlBQVksc0JBQVMsQ0FBZ0IsQ0FBQztJQUNuRixDQUFDOztBQXJCSCwwQkFzQkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb25zdHJ1Y3QsIE5vZGUgfSBmcm9tICdjb25zdHJ1Y3RzJztcbmltcG9ydCB7IEFwaU9iamVjdCB9IGZyb20gJy4vYXBpLW9iamVjdCc7XG5pbXBvcnQgeyBZYW1sIH0gZnJvbSAnLi95YW1sJztcblxuZXhwb3J0IGludGVyZmFjZSBJbmNsdWRlUHJvcHMge1xuICAvKipcbiAgICogTG9jYWwgZmlsZSBwYXRoIG9yIFVSTCB3aGljaCBpbmNsdWRlcyBhIEt1YmVybmV0ZXMgWUFNTCBtYW5pZmVzdC5cbiAgICpcbiAgICogQGV4YW1wbGUgbXltYW5pZmVzdC55YW1sXG4gICAqL1xuICByZWFkb25seSB1cmw6IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZWFkcyBhIFlBTUwgbWFuaWZlc3QgZnJvbSBhIGZpbGUgb3IgYSBVUkwgYW5kIGRlZmluZXMgYWxsIHJlc291cmNlcyBhcyBBUElcbiAqIG9iamVjdHMgd2l0aGluIHRoZSBkZWZpbmVkIHNjb3BlLlxuICpcbiAqIFRoZSBuYW1lcyAoYG1ldGFkYXRhLm5hbWVgKSBvZiBpbXBvcnRlZCByZXNvdXJjZXMgd2lsbCBiZSBwcmVzZXJ2ZWQgYXMtaXNcbiAqIGZyb20gdGhlIG1hbmlmZXN0LlxuICovXG5leHBvcnQgY2xhc3MgSW5jbHVkZSBleHRlbmRzIENvbnN0cnVjdCB7XG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBJbmNsdWRlUHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQpO1xuXG4gICAgY29uc3Qgb2JqZWN0cyA9IFlhbWwubG9hZChwcm9wcy51cmwpO1xuXG4gICAgbGV0IG9yZGVyID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iaiBvZiBvYmplY3RzKSB7XG4gICAgICBjb25zdCBvYmpuYW1lID0gb2JqLm1ldGFkYXRhPy5uYW1lID8/IGBvYmplY3Qke29yZGVyKyt9YDtcblxuICAgICAgLy8gcmVuZGVyIGFuIGlkOiBuYW1lWy1raW5kXVstbmFtZXNwYWNlXVxuICAgICAgY29uc3Qgb2JqaWQgPSBbb2JqbmFtZSwgb2JqLmtpbmQ/LnRvTG93ZXJDYXNlKCksIG9iai5tZXRhZGF0YT8ubmFtZXNwYWNlXS5maWx0ZXIoeCA9PiB4KS5qb2luKCctJyk7XG4gICAgICBuZXcgQXBpT2JqZWN0KHRoaXMsIG9iamlkLCBvYmopO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCB0aGUgaW5jbHVkZWQgQVBJIG9iamVjdHMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGFwaU9iamVjdHMoKTogQXBpT2JqZWN0W10ge1xuICAgIHJldHVybiBOb2RlLm9mKHRoaXMpLmNoaWxkcmVuLmZpbHRlcihvID0+IG8gaW5zdGFuY2VvZiBBcGlPYmplY3QpIGFzIEFwaU9iamVjdFtdO1xuICB9XG59XG4iXX0=

/***/ }),

/***/ 1227:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__nccwpck_require__(4752), exports);
__exportStar(__nccwpck_require__(2297), exports);
__exportStar(__nccwpck_require__(6653), exports);
__exportStar(__nccwpck_require__(8101), exports);
__exportStar(__nccwpck_require__(4333), exports);
__exportStar(__nccwpck_require__(4300), exports);
__exportStar(__nccwpck_require__(5096), exports);
__exportStar(__nccwpck_require__(8041), exports);
__exportStar(__nccwpck_require__(7664), exports);
__exportStar(__nccwpck_require__(3948), exports);
__exportStar(__nccwpck_require__(6830), exports);
__exportStar(__nccwpck_require__(4768), exports);
__exportStar(__nccwpck_require__(9413), exports);
__exportStar(__nccwpck_require__(3764), exports);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsK0NBQTZCO0FBQzdCLDBDQUF3QjtBQUN4QiwrQ0FBNkI7QUFDN0IsNENBQTBCO0FBQzFCLHdDQUFzQjtBQUN0Qiw0Q0FBMEI7QUFDMUIseUNBQXVCO0FBQ3ZCLDZDQUEyQjtBQUMzQix5Q0FBdUI7QUFDdkIsMENBQXdCO0FBQ3hCLHlDQUF1QjtBQUN2QiwrQ0FBNkI7QUFDN0IsNkNBQTJCO0FBQzNCLHlDQUF1QiIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vYXBpLW9iamVjdCc7XG5leHBvcnQgKiBmcm9tICcuL2NoYXJ0JztcbmV4cG9ydCAqIGZyb20gJy4vZGVwZW5kZW5jeSc7XG5leHBvcnQgKiBmcm9tICcuL3Rlc3RpbmcnO1xuZXhwb3J0ICogZnJvbSAnLi9hcHAnO1xuZXhwb3J0ICogZnJvbSAnLi9pbmNsdWRlJztcbmV4cG9ydCAqIGZyb20gJy4veWFtbCc7XG5leHBvcnQgKiBmcm9tICcuL21ldGFkYXRhJztcbmV4cG9ydCAqIGZyb20gJy4vbGF6eSc7XG5leHBvcnQgKiBmcm9tICcuL25hbWVzJztcbmV4cG9ydCAqIGZyb20gJy4vaGVsbSc7XG5leHBvcnQgKiBmcm9tICcuL2pzb24tcGF0Y2gnO1xuZXhwb3J0ICogZnJvbSAnLi9kdXJhdGlvbic7XG5leHBvcnQgKiBmcm9tICcuL3NpemUnOyJdfQ==

/***/ }),

/***/ 4768:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonPatch = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const fjp = __nccwpck_require__(3279);
/**
 * Utility for applying RFC-6902 JSON-Patch to a document.
 *
 * Use the the `JsonPatch.apply(doc, ...ops)` function to apply a set of
 * operations to a JSON document and return the result.
 *
 * Operations can be created using the factory methods `JsonPatch.add()`,
 * `JsonPatch.remove()`, etc.
 *
 * @example
 *
 *const output = JsonPatch.apply(input,
 *  JsonPatch.replace('/world/hi/there', 'goodbye'),
 *  JsonPatch.add('/world/foo/', 'boom'),
 *  JsonPatch.remove('/hello'));
 *
 */
class JsonPatch {
    constructor(operation) {
        this.operation = operation;
    }
    /**
     * Applies a set of JSON-Patch (RFC-6902) operations to `document` and returns the result.
     * @param document The document to patch
     * @param ops The operations to apply
     * @returns The result document
     */
    static apply(document, ...ops) {
        const result = fjp.applyPatch(document, ops.map(o => o._toJson()));
        return result.newDocument;
    }
    /**
     * Adds a value to an object or inserts it into an array. In the case of an
     * array, the value is inserted before the given index. The - character can be
     * used instead of an index to insert at the end of an array.
     *
     * @example JsonPatch.add('/biscuits/1', { "name": "Ginger Nut" })
     */
    static add(path, value) { return new JsonPatch({ op: 'add', path, value }); }
    /**
     * Removes a value from an object or array.
     *
     * @example JsonPatch.remove('/biscuits')
     * @example JsonPatch.remove('/biscuits/0')
     */
    static remove(path) { return new JsonPatch({ op: 'remove', path }); }
    /**
     * Replaces a value. Equivalent to a “remove” followed by an “add”.
     *
     * @example JsonPatch.replace('/biscuits/0/name', 'Chocolate Digestive')
     */
    static replace(path, value) { return new JsonPatch({ op: 'replace', path, value }); }
    /**
     * Copies a value from one location to another within the JSON document. Both
     * from and path are JSON Pointers.
     *
     * @example JsonPatch.copy('/biscuits/0', '/best_biscuit')
     */
    static copy(from, path) { return new JsonPatch({ op: 'copy', from, path }); }
    /**
     * Moves a value from one location to the other. Both from and path are JSON Pointers.
     *
     * @example JsonPatch.move('/biscuits', '/cookies')
     */
    static move(from, path) { return new JsonPatch({ op: 'move', from, path }); }
    /**
     * Tests that the specified value is set in the document. If the test fails,
     * then the patch as a whole should not apply.
     *
     * @example JsonPatch.test('/best_biscuit/name', 'Choco Leibniz')
     */
    static test(path, value) { return new JsonPatch({ op: 'test', path, value }); }
    /**
     * Returns the JSON representation of this JSON patch operation.
     *
     * @internal
     */
    _toJson() {
        return this.operation;
    }
}
exports.JsonPatch = JsonPatch;
_a = JSII_RTTI_SYMBOL_1;
JsonPatch[_a] = { fqn: "cdk8s.JsonPatch", version: "2.3.11" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianNvbi1wYXRjaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9qc29uLXBhdGNoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsdUNBQXVDO0FBRXZDOzs7Ozs7Ozs7Ozs7Ozs7O0dBZ0JHO0FBQ0gsTUFBYSxTQUFTO0lBMkRwQixZQUFxQyxTQUF3QjtRQUF4QixjQUFTLEdBQVQsU0FBUyxDQUFlO0lBQUcsQ0FBQztJQTFEakU7Ozs7O09BS0c7SUFDSSxNQUFNLENBQUMsS0FBSyxDQUFDLFFBQWEsRUFBRSxHQUFHLEdBQWdCO1FBQ3BELE1BQU0sTUFBTSxHQUFHLEdBQUcsQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ25FLE9BQU8sTUFBTSxDQUFDLFdBQVcsQ0FBQztJQUM1QixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFZLEVBQUUsS0FBVSxJQUFJLE9BQU8sSUFBSSxTQUFTLENBQUMsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVqRzs7Ozs7T0FLRztJQUNJLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBWSxJQUFJLE9BQU8sSUFBSSxTQUFTLENBQUMsRUFBRSxFQUFFLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRXBGOzs7O09BSUc7SUFDSSxNQUFNLENBQUMsT0FBTyxDQUFDLElBQVksRUFBRSxLQUFVLElBQUksT0FBTyxJQUFJLFNBQVMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRXpHOzs7OztPQUtHO0lBQ0ksTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFZLEVBQUUsSUFBWSxJQUFJLE9BQU8sSUFBSSxTQUFTLENBQUMsRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVwRzs7OztPQUlHO0lBQ0ksTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFZLEVBQUUsSUFBWSxJQUFJLE9BQU8sSUFBSSxTQUFTLENBQUMsRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVwRzs7Ozs7T0FLRztJQUNJLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBWSxFQUFFLEtBQVUsSUFBSSxPQUFPLElBQUksU0FBUyxDQUFDLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFJbkc7Ozs7T0FJRztJQUNJLE9BQU87UUFDWixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDeEIsQ0FBQzs7QUFwRUgsOEJBcUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZmpwIGZyb20gJ2Zhc3QtanNvbi1wYXRjaCc7XG5cbi8qKlxuICogVXRpbGl0eSBmb3IgYXBwbHlpbmcgUkZDLTY5MDIgSlNPTi1QYXRjaCB0byBhIGRvY3VtZW50LlxuICpcbiAqIFVzZSB0aGUgdGhlIGBKc29uUGF0Y2guYXBwbHkoZG9jLCAuLi5vcHMpYCBmdW5jdGlvbiB0byBhcHBseSBhIHNldCBvZlxuICogb3BlcmF0aW9ucyB0byBhIEpTT04gZG9jdW1lbnQgYW5kIHJldHVybiB0aGUgcmVzdWx0LlxuICpcbiAqIE9wZXJhdGlvbnMgY2FuIGJlIGNyZWF0ZWQgdXNpbmcgdGhlIGZhY3RvcnkgbWV0aG9kcyBgSnNvblBhdGNoLmFkZCgpYCxcbiAqIGBKc29uUGF0Y2gucmVtb3ZlKClgLCBldGMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKmNvbnN0IG91dHB1dCA9IEpzb25QYXRjaC5hcHBseShpbnB1dCxcbiAqICBKc29uUGF0Y2gucmVwbGFjZSgnL3dvcmxkL2hpL3RoZXJlJywgJ2dvb2RieWUnKSxcbiAqICBKc29uUGF0Y2guYWRkKCcvd29ybGQvZm9vLycsICdib29tJyksXG4gKiAgSnNvblBhdGNoLnJlbW92ZSgnL2hlbGxvJykpO1xuICpcbiAqL1xuZXhwb3J0IGNsYXNzIEpzb25QYXRjaCB7XG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgc2V0IG9mIEpTT04tUGF0Y2ggKFJGQy02OTAyKSBvcGVyYXRpb25zIHRvIGBkb2N1bWVudGAgYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cbiAgICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxuICAgKiBAcGFyYW0gb3BzIFRoZSBvcGVyYXRpb25zIHRvIGFwcGx5XG4gICAqIEByZXR1cm5zIFRoZSByZXN1bHQgZG9jdW1lbnRcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXBwbHkoZG9jdW1lbnQ6IGFueSwgLi4ub3BzOiBKc29uUGF0Y2hbXSk6IGFueSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZmpwLmFwcGx5UGF0Y2goZG9jdW1lbnQsIG9wcy5tYXAobyA9PiBvLl90b0pzb24oKSkpO1xuICAgIHJldHVybiByZXN1bHQubmV3RG9jdW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHZhbHVlIHRvIGFuIG9iamVjdCBvciBpbnNlcnRzIGl0IGludG8gYW4gYXJyYXkuIEluIHRoZSBjYXNlIG9mIGFuXG4gICAqIGFycmF5LCB0aGUgdmFsdWUgaXMgaW5zZXJ0ZWQgYmVmb3JlIHRoZSBnaXZlbiBpbmRleC4gVGhlIC0gY2hhcmFjdGVyIGNhbiBiZVxuICAgKiB1c2VkIGluc3RlYWQgb2YgYW4gaW5kZXggdG8gaW5zZXJ0IGF0IHRoZSBlbmQgb2YgYW4gYXJyYXkuXG4gICAqXG4gICAqIEBleGFtcGxlIEpzb25QYXRjaC5hZGQoJy9iaXNjdWl0cy8xJywgeyBcIm5hbWVcIjogXCJHaW5nZXIgTnV0XCIgfSlcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYWRkKHBhdGg6IHN0cmluZywgdmFsdWU6IGFueSkgeyByZXR1cm4gbmV3IEpzb25QYXRjaCh7IG9wOiAnYWRkJywgcGF0aCwgdmFsdWUgfSk7IH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gYW4gb2JqZWN0IG9yIGFycmF5LlxuICAgKlxuICAgKiBAZXhhbXBsZSBKc29uUGF0Y2gucmVtb3ZlKCcvYmlzY3VpdHMnKVxuICAgKiBAZXhhbXBsZSBKc29uUGF0Y2gucmVtb3ZlKCcvYmlzY3VpdHMvMCcpXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlbW92ZShwYXRoOiBzdHJpbmcpIHsgcmV0dXJuIG5ldyBKc29uUGF0Y2goeyBvcDogJ3JlbW92ZScsIHBhdGggfSk7IH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgYSB2YWx1ZS4gRXF1aXZhbGVudCB0byBhIOKAnHJlbW92ZeKAnSBmb2xsb3dlZCBieSBhbiDigJxhZGTigJ0uXG4gICAqXG4gICAqIEBleGFtcGxlIEpzb25QYXRjaC5yZXBsYWNlKCcvYmlzY3VpdHMvMC9uYW1lJywgJ0Nob2NvbGF0ZSBEaWdlc3RpdmUnKVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZXBsYWNlKHBhdGg6IHN0cmluZywgdmFsdWU6IGFueSkgeyByZXR1cm4gbmV3IEpzb25QYXRjaCh7IG9wOiAncmVwbGFjZScsIHBhdGgsIHZhbHVlIH0pOyB9XG5cbiAgLyoqXG4gICAqIENvcGllcyBhIHZhbHVlIGZyb20gb25lIGxvY2F0aW9uIHRvIGFub3RoZXIgd2l0aGluIHRoZSBKU09OIGRvY3VtZW50LiBCb3RoXG4gICAqIGZyb20gYW5kIHBhdGggYXJlIEpTT04gUG9pbnRlcnMuXG4gICAqXG4gICAqIEBleGFtcGxlIEpzb25QYXRjaC5jb3B5KCcvYmlzY3VpdHMvMCcsICcvYmVzdF9iaXNjdWl0JylcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgY29weShmcm9tOiBzdHJpbmcsIHBhdGg6IHN0cmluZykgeyByZXR1cm4gbmV3IEpzb25QYXRjaCh7IG9wOiAnY29weScsIGZyb20sIHBhdGggfSk7IH1cblxuICAvKipcbiAgICogTW92ZXMgYSB2YWx1ZSBmcm9tIG9uZSBsb2NhdGlvbiB0byB0aGUgb3RoZXIuIEJvdGggZnJvbSBhbmQgcGF0aCBhcmUgSlNPTiBQb2ludGVycy5cbiAgICpcbiAgICogQGV4YW1wbGUgSnNvblBhdGNoLm1vdmUoJy9iaXNjdWl0cycsICcvY29va2llcycpXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1vdmUoZnJvbTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpIHsgcmV0dXJuIG5ldyBKc29uUGF0Y2goeyBvcDogJ21vdmUnLCBmcm9tLCBwYXRoIH0pOyB9XG5cbiAgLyoqXG4gICAqIFRlc3RzIHRoYXQgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBzZXQgaW4gdGhlIGRvY3VtZW50LiBJZiB0aGUgdGVzdCBmYWlscyxcbiAgICogdGhlbiB0aGUgcGF0Y2ggYXMgYSB3aG9sZSBzaG91bGQgbm90IGFwcGx5LlxuICAgKlxuICAgKiBAZXhhbXBsZSBKc29uUGF0Y2gudGVzdCgnL2Jlc3RfYmlzY3VpdC9uYW1lJywgJ0Nob2NvIExlaWJuaXonKVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyB0ZXN0KHBhdGg6IHN0cmluZywgdmFsdWU6IGFueSkgeyByZXR1cm4gbmV3IEpzb25QYXRjaCh7IG9wOiAndGVzdCcsIHBhdGgsIHZhbHVlIH0pOyB9XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IG9wZXJhdGlvbjogZmpwLk9wZXJhdGlvbikge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEpTT04gcGF0Y2ggb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHB1YmxpYyBfdG9Kc29uKCk6IGFueSB7XG4gICAgcmV0dXJuIHRoaXMub3BlcmF0aW9uO1xuICB9XG59Il19

/***/ }),

/***/ 7664:
/***/ ((__unused_webpack_module, exports) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Lazy = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
class Lazy {
    constructor(producer) {
        this.producer = producer;
    }
    static any(producer) {
        return new Lazy(producer);
    }
    produce() {
        return this.producer.produce();
    }
}
exports.Lazy = Lazy;
_a = JSII_RTTI_SYMBOL_1;
Lazy[_a] = { fqn: "cdk8s.Lazy", version: "2.3.11" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF6eS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9sYXp5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsTUFBYSxJQUFJO0lBS2YsWUFBcUMsUUFBc0I7UUFBdEIsYUFBUSxHQUFSLFFBQVEsQ0FBYztJQUFHLENBQUM7SUFKeEQsTUFBTSxDQUFDLEdBQUcsQ0FBQyxRQUFzQjtRQUN0QyxPQUFPLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBbUIsQ0FBQztJQUM5QyxDQUFDO0lBSU0sT0FBTztRQUNaLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUNqQyxDQUFDOztBQVRILG9CQVVDIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIExhenkge1xuICBwdWJsaWMgc3RhdGljIGFueShwcm9kdWNlcjogSUFueVByb2R1Y2VyKTogYW55IHtcbiAgICByZXR1cm4gbmV3IExhenkocHJvZHVjZXIpIGFzIHVua25vd24gYXMgYW55O1xuICB9XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHByb2R1Y2VyOiBJQW55UHJvZHVjZXIpIHt9XG5cbiAgcHVibGljIHByb2R1Y2UoKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5wcm9kdWNlci5wcm9kdWNlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJQW55UHJvZHVjZXIge1xuICBwcm9kdWNlKCk6IGFueTtcbn1cblxuXG4iXX0=

/***/ }),

/***/ 8041:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiObjectMetadataDefinition = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const _resolve_1 = __nccwpck_require__(2667);
const _util_1 = __nccwpck_require__(4898);
/**
 * Object metadata.
 */
class ApiObjectMetadataDefinition {
    constructor(options = {}) {
        var _b, _c, _d, _e;
        this.name = options.name;
        this.labels = (_b = options.labels) !== null && _b !== void 0 ? _b : {};
        this.annotations = (_c = options.annotations) !== null && _c !== void 0 ? _c : {};
        this.namespace = options.namespace;
        this.finalizers = (_d = options.finalizers) !== null && _d !== void 0 ? _d : [];
        this.ownerReferences = (_e = options.ownerReferences) !== null && _e !== void 0 ? _e : [];
        this._additionalAttributes = options !== null && options !== void 0 ? options : {};
    }
    /**
     * Add a label.
     *
     * @param key - The key.
     * @param value - The value.
     */
    addLabel(key, value) {
        this.labels[key] = value;
    }
    /**
     * @returns a value of a label or undefined
     * @param key the label
     */
    getLabel(key) {
        return this.labels[key];
    }
    /**
     * Add an annotation.
     *
     * @param key - The key.
     * @param value - The value.
     */
    addAnnotation(key, value) {
        this.annotations[key] = value;
    }
    /**
     * Add one or more finalizers.
     *
     * @param finalizers the finalizers
     */
    addFinalizers(...finalizers) {
        this.finalizers.push(...finalizers);
    }
    /**
     * Add an owner.
     *
     * @param owner the owner
     */
    addOwnerReference(owner) {
        this.ownerReferences.push(owner);
    }
    /**
     * Adds an arbitrary key/value to the object metadata.
     * @param key Metadata key
     * @param value Metadata value
     */
    add(key, value) {
        this._additionalAttributes[key] = value;
    }
    /**
     * Synthesizes a k8s ObjectMeta for this metadata set.
     */
    toJson() {
        const sanitize = (x) => _util_1.sanitizeValue(x, { filterEmptyArrays: true, filterEmptyObjects: true });
        return sanitize(_resolve_1.resolve({
            ...this._additionalAttributes,
            name: this.name,
            namespace: this.namespace,
            annotations: this.annotations,
            finalizers: this.finalizers,
            ownerReferences: this.ownerReferences,
            labels: this.labels,
        }));
    }
}
exports.ApiObjectMetadataDefinition = ApiObjectMetadataDefinition;
_a = JSII_RTTI_SYMBOL_1;
ApiObjectMetadataDefinition[_a] = { fqn: "cdk8s.ApiObjectMetadataDefinition", version: "2.3.11" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWV0YWRhdGEuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvbWV0YWRhdGEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSx5Q0FBcUM7QUFDckMsbUNBQXdDO0FBcUd4Qzs7R0FFRztBQUNILE1BQWEsMkJBQTJCO0lBeUN0QyxZQUFZLFVBQTZCLEVBQUc7O1FBQzFDLElBQUksQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQztRQUN6QixJQUFJLENBQUMsTUFBTSxTQUFHLE9BQU8sQ0FBQyxNQUFNLG1DQUFJLEVBQUcsQ0FBQztRQUNwQyxJQUFJLENBQUMsV0FBVyxTQUFHLE9BQU8sQ0FBQyxXQUFXLG1DQUFJLEVBQUcsQ0FBQztRQUM5QyxJQUFJLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUM7UUFDbkMsSUFBSSxDQUFDLFVBQVUsU0FBRyxPQUFPLENBQUMsVUFBVSxtQ0FBSSxFQUFFLENBQUM7UUFDM0MsSUFBSSxDQUFDLGVBQWUsU0FBRyxPQUFPLENBQUMsZUFBZSxtQ0FBSSxFQUFFLENBQUM7UUFDckQsSUFBSSxDQUFDLHFCQUFxQixHQUFHLE9BQU8sYUFBUCxPQUFPLGNBQVAsT0FBTyxHQUFJLEVBQUcsQ0FBQztJQUM5QyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxRQUFRLENBQUMsR0FBVyxFQUFFLEtBQWE7UUFDeEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7T0FHRztJQUNJLFFBQVEsQ0FBQyxHQUFXO1FBQ3pCLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUMxQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxhQUFhLENBQUMsR0FBVyxFQUFFLEtBQWE7UUFDN0MsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUM7SUFDaEMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxhQUFhLENBQUMsR0FBRyxVQUFvQjtRQUMxQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksaUJBQWlCLENBQUMsS0FBcUI7UUFDNUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxHQUFHLENBQUMsR0FBVyxFQUFFLEtBQVU7UUFDaEMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUMxQyxDQUFDO0lBRUQ7O09BRUc7SUFDSSxNQUFNO1FBQ1gsTUFBTSxRQUFRLEdBQUcsQ0FBQyxDQUFNLEVBQUUsRUFBRSxDQUFDLHFCQUFhLENBQUMsQ0FBQyxFQUFFLEVBQUUsaUJBQWlCLEVBQUUsSUFBSSxFQUFFLGtCQUFrQixFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7UUFDckcsT0FBTyxRQUFRLENBQUMsa0JBQU8sQ0FBQztZQUN0QixHQUFHLElBQUksQ0FBQyxxQkFBcUI7WUFDN0IsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO1lBQ2YsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTO1lBQ3pCLFdBQVcsRUFBRSxJQUFJLENBQUMsV0FBVztZQUM3QixVQUFVLEVBQUUsSUFBSSxDQUFDLFVBQVU7WUFDM0IsZUFBZSxFQUFFLElBQUksQ0FBQyxlQUFlO1lBQ3JDLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTTtTQUNwQixDQUFDLENBQUMsQ0FBQztJQUNOLENBQUM7O0FBeEhILGtFQXlIQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlc29sdmUgfSBmcm9tICcuL19yZXNvbHZlJztcbmltcG9ydCB7IHNhbml0aXplVmFsdWUgfSBmcm9tICcuL191dGlsJztcblxuLyoqXG4gKiBNZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyBvYmplY3QuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXBpT2JqZWN0TWV0YWRhdGEge1xuICAvKipcbiAgICogVGhlIHVuaXF1ZSwgbmFtZXNwYWNlLWdsb2JhbCwgbmFtZSBvZiB0aGlzIG9iamVjdCBpbnNpZGUgdGhlIEt1YmVybmV0ZXNcbiAgICogY2x1c3Rlci5cbiAgICpcbiAgICogTm9ybWFsbHksIHlvdSBzaG91bGRuJ3Qgc3BlY2lmeSBuYW1lcyBmb3Igb2JqZWN0cyBhbmQgbGV0IHRoZSBDREsgZ2VuZXJhdGVcbiAgICogYSBuYW1lIGZvciB5b3UgdGhhdCBpcyBhcHBsaWNhdGlvbi11bmlxdWUuIFRoZSBuYW1lcyBDREsgZ2VuZXJhdGVzIGFyZVxuICAgKiBjb21wb3NlZCBmcm9tIHRoZSBjb25zdHJ1Y3QgcGF0aCBjb21wb25lbnRzLCBzZXBhcmF0ZWQgYnkgZG90cyBhbmQgYSBzdWZmaXhcbiAgICogdGhhdCBpcyBiYXNlZCBvbiBhIGhhc2ggb2YgdGhlIGVudGlyZSBwYXRoLCB0byBlbnN1cmUgdW5pcXVlbmVzcy5cbiAgICpcbiAgICogWW91IGNhbiBzdXBwbHkgY3VzdG9tIG5hbWUgYWxsb2NhdGlvbiBsb2dpYyBieSBvdmVycmlkaW5nIHRoZVxuICAgKiBgY2hhcnQuZ2VuZXJhdGVPYmplY3ROYW1lYCBtZXRob2QuXG4gICAqXG4gICAqIElmIHlvdSB1c2UgYW4gZXhwbGljaXQgbmFtZSBoZXJlLCBiZWFyIGluIG1pbmQgdGhhdCB0aGlzIHJlZHVjZXMgdGhlXG4gICAqIGNvbXBvc2FiaWxpdHkgb2YgeW91ciBjb25zdHJ1Y3QgYmVjYXVzZSBpdCB3b24ndCBiZSBwb3NzaWJsZSB0byBpbmNsdWRlXG4gICAqIG1vcmUgdGhhbiBvbmUgaW5zdGFuY2UgaW4gYW55IGFwcC4gVGhlcmVmb3JlIGl0IGlzIGhpZ2hseSByZWNvbW1lbmRlZCB0b1xuICAgKiBsZWF2ZSB0aGlzIHVuc3BlY2lmaWVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGFuIGFwcC11bmlxdWUgbmFtZSBnZW5lcmF0ZWQgYnkgdGhlIGNoYXJ0XG4gICAqL1xuICByZWFkb25seSBuYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBbm5vdGF0aW9ucyBpcyBhbiB1bnN0cnVjdHVyZWQga2V5IHZhbHVlIG1hcCBzdG9yZWQgd2l0aCBhIHJlc291cmNlIHRoYXQgbWF5IGJlIHNldCBieSBleHRlcm5hbCB0b29scyB0byBzdG9yZSBhbmQgcmV0cmlldmUgYXJiaXRyYXJ5IG1ldGFkYXRhLiBUaGV5IGFyZSBub3QgcXVlcnlhYmxlIGFuZCBzaG91bGQgYmVcbiAgICogcHJlc2VydmVkIHdoZW4gbW9kaWZ5aW5nIG9iamVjdHMuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL2t1YmVybmV0ZXMuaW8vZG9jcy91c2VyLWd1aWRlL2Fubm90YXRpb25zXG4gICAqIEBkZWZhdWx0IC0gTm8gYW5ub3RhdGlvbnMuXG4gICAqL1xuICByZWFkb25seSBhbm5vdGF0aW9ucz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG5cbiAgLyoqXG4gICAqIE1hcCBvZiBzdHJpbmcga2V5cyBhbmQgdmFsdWVzIHRoYXQgY2FuIGJlIHVzZWQgdG8gb3JnYW5pemUgYW5kIGNhdGVnb3JpemUgKHNjb3BlIGFuZCBzZWxlY3QpIG9iamVjdHMuXG4gICAqIE1heSBtYXRjaCBzZWxlY3RvcnMgb2YgcmVwbGljYXRpb24gY29udHJvbGxlcnMgYW5kIHNlcnZpY2VzLlxuICAgKlxuICAgKiBAc2VlIGh0dHA6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvdXNlci1ndWlkZS9sYWJlbHNcbiAgICogQGRlZmF1bHQgLSBObyBsYWJlbHMuXG4gICAqL1xuICByZWFkb25seSBsYWJlbHM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXG4gIC8qKlxuICAgKiBOYW1lc3BhY2UgZGVmaW5lcyB0aGUgc3BhY2Ugd2l0aGluIGVhY2ggbmFtZSBtdXN0IGJlIHVuaXF1ZS4gQW4gZW1wdHkgbmFtZXNwYWNlIGlzIGVxdWl2YWxlbnQgdG8gdGhlIFwiZGVmYXVsdFwiIG5hbWVzcGFjZSwgYnV0IFwiZGVmYXVsdFwiIGlzIHRoZSBjYW5vbmljYWwgcmVwcmVzZW50YXRpb24uXG4gICAqIE5vdCBhbGwgb2JqZWN0cyBhcmUgcmVxdWlyZWQgdG8gYmUgc2NvcGVkIHRvIGEgbmFtZXNwYWNlIC0gdGhlIHZhbHVlIG9mIHRoaXMgZmllbGQgZm9yIHRob3NlIG9iamVjdHMgd2lsbCBiZSBlbXB0eS4gTXVzdCBiZSBhIEROU19MQUJFTC4gQ2Fubm90IGJlIHVwZGF0ZWQuIE1vcmUgaW5mbzogaHR0cDovL2t1YmVybmV0ZXMuaW8vZG9jcy91c2VyLWd1aWRlL25hbWVzcGFjZXNcbiAgICpcbiAgICogQGRlZmF1bHQgdW5kZWZpbmVkICh3aWxsIGJlIGFzc2lnbmVkIHRvIHRoZSAnZGVmYXVsdCcgbmFtZXNwYWNlKVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZXNwYWNlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBOYW1lc3BhY2VkIGtleXMgdGhhdCB0ZWxsIEt1YmVybmV0ZXMgdG8gd2FpdCB1bnRpbCBzcGVjaWZpYyBjb25kaXRpb25zIGFyZVxuICAgKiBtZXQgYmVmb3JlIGl0IGZ1bGx5IGRlbGV0ZXMgcmVzb3VyY2VzIG1hcmtlZCBmb3IgZGVsZXRpb24uXG4gICAqXG4gICAqIE11c3QgYmUgZW1wdHkgYmVmb3JlIHRoZSBvYmplY3QgaXMgZGVsZXRlZCBmcm9tIHRoZSByZWdpc3RyeS4gRWFjaCBlbnRyeSBpc1xuICAgKiBhbiBpZGVudGlmaWVyIGZvciB0aGUgcmVzcG9uc2libGUgY29tcG9uZW50IHRoYXQgd2lsbCByZW1vdmUgdGhlIGVudHJ5IGZyb21cbiAgICogdGhlIGxpc3QuIElmIHRoZSBkZWxldGlvblRpbWVzdGFtcCBvZiB0aGUgb2JqZWN0IGlzIG5vbi1uaWwsIGVudHJpZXMgaW5cbiAgICogdGhpcyBsaXN0IGNhbiBvbmx5IGJlIHJlbW92ZWQuIEZpbmFsaXplcnMgbWF5IGJlIHByb2Nlc3NlZCBhbmQgcmVtb3ZlZCBpblxuICAgKiBhbnkgb3JkZXIuICBPcmRlciBpcyBOT1QgZW5mb3JjZWQgYmVjYXVzZSBpdCBpbnRyb2R1Y2VzIHNpZ25pZmljYW50IHJpc2sgb2ZcbiAgICogc3R1Y2sgZmluYWxpemVycy4gZmluYWxpemVycyBpcyBhIHNoYXJlZCBmaWVsZCwgYW55IGFjdG9yIHdpdGggcGVybWlzc2lvblxuICAgKiBjYW4gcmVvcmRlciBpdC4gSWYgdGhlIGZpbmFsaXplciBsaXN0IGlzIHByb2Nlc3NlZCBpbiBvcmRlciwgdGhlbiB0aGlzIGNhblxuICAgKiBsZWFkIHRvIGEgc2l0dWF0aW9uIGluIHdoaWNoIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIHRoZSBmaXJzdFxuICAgKiBmaW5hbGl6ZXIgaW4gdGhlIGxpc3QgaXMgd2FpdGluZyBmb3IgYSBzaWduYWwgKGZpZWxkIHZhbHVlLCBleHRlcm5hbFxuICAgKiBzeXN0ZW0sIG9yIG90aGVyKSBwcm9kdWNlZCBieSBhIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgYSBmaW5hbGl6ZXIgbGF0ZXJcbiAgICogaW4gdGhlIGxpc3QsIHJlc3VsdGluZyBpbiBhIGRlYWRsb2NrLiBXaXRob3V0IGVuZm9yY2VkIG9yZGVyaW5nIGZpbmFsaXplcnNcbiAgICogYXJlIGZyZWUgdG8gb3JkZXIgYW1vbmdzdCB0aGVtc2VsdmVzIGFuZCBhcmUgbm90IHZ1bG5lcmFibGUgdG8gb3JkZXJpbmdcbiAgICogY2hhbmdlcyBpbiB0aGUgbGlzdC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2t1YmVybmV0ZXMuaW8vZG9jcy9jb25jZXB0cy9vdmVydmlldy93b3JraW5nLXdpdGgtb2JqZWN0cy9maW5hbGl6ZXJzL1xuICAgKiBAZGVmYXVsdCAtIE5vIGZpbmFsaXplcnMuXG4gICAqL1xuICByZWFkb25seSBmaW5hbGl6ZXJzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIExpc3Qgb2Ygb2JqZWN0cyBkZXBlbmRlZCBieSB0aGlzIG9iamVjdC4gSWYgQUxMIG9iamVjdHMgaW4gdGhlIGxpc3QgaGF2ZVxuICAgKiBiZWVuIGRlbGV0ZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuIElmIHRoaXMgb2JqZWN0IGlzXG4gICAqIG1hbmFnZWQgYnkgYSBjb250cm9sbGVyLCB0aGVuIGFuIGVudHJ5IGluIHRoaXMgbGlzdCB3aWxsIHBvaW50IHRvIHRoaXNcbiAgICogY29udHJvbGxlciwgd2l0aCB0aGUgY29udHJvbGxlciBmaWVsZCBzZXQgdG8gdHJ1ZS4gVGhlcmUgY2Fubm90IGJlIG1vcmVcbiAgICogdGhhbiBvbmUgbWFuYWdpbmcgY29udHJvbGxlci5cbiAgICpcbiAgICogS3ViZXJuZXRlcyBzZXRzIHRoZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGF1dG9tYXRpY2FsbHkgZm9yIG9iamVjdHMgdGhhdCBhcmVcbiAgICogZGVwZW5kZW50cyBvZiBvdGhlciBvYmplY3RzIGxpa2UgUmVwbGljYVNldHMsIERhZW1vblNldHMsIERlcGxveW1lbnRzLCBKb2JzXG4gICAqIGFuZCBDcm9uSm9icywgYW5kIFJlcGxpY2F0aW9uQ29udHJvbGxlcnMuIFlvdSBjYW4gYWxzbyBjb25maWd1cmUgdGhlc2VcbiAgICogcmVsYXRpb25zaGlwcyBtYW51YWxseSBieSBjaGFuZ2luZyB0aGUgdmFsdWUgb2YgdGhpcyBmaWVsZC4gSG93ZXZlciwgeW91XG4gICAqIHVzdWFsbHkgZG9uJ3QgbmVlZCB0byBhbmQgY2FuIGFsbG93IEt1YmVybmV0ZXMgdG8gYXV0b21hdGljYWxseSBtYW5hZ2UgdGhlXG4gICAqIHJlbGF0aW9uc2hpcHMuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvb3ZlcnZpZXcvd29ya2luZy13aXRoLW9iamVjdHMvb3duZXJzLWRlcGVuZGVudHMvXG4gICAqIEBkZWZhdWx0IC0gYXV0b21hdGljYWxseSBzZXQgYnkgS3ViZXJuZXRlc1xuICAgKi9cbiAgcmVhZG9ubHkgb3duZXJSZWZlcmVuY2VzPzogT3duZXJSZWZlcmVuY2VbXTtcblxuICAvKipcbiAgICogQWRkaXRpb25hbCBtZXRhZGF0YSBhdHRyaWJ1dGVzLlxuICAgKi9cbiAgcmVhZG9ubHkgW2tleTogc3RyaW5nXTogYW55O1xufVxuXG4vKipcbiAqIE9iamVjdCBtZXRhZGF0YS5cbiAqL1xuZXhwb3J0IGNsYXNzIEFwaU9iamVjdE1ldGFkYXRhRGVmaW5pdGlvbiB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgQVBJIG9iamVjdC5cbiAgICpcbiAgICogSWYgYSBuYW1lIGlzIHNwZWNpZmllZCBpbiBgbWV0YWRhdGEubmFtZWAgdGhpcyB3aWxsIGJlIHRoZSBuYW1lIHJldHVybmVkLlxuICAgKiBPdGhlcndpc2UsIGEgbmFtZSB3aWxsIGJlIGdlbmVyYXRlZCBieSBjYWxsaW5nXG4gICAqIGBDaGFydC5vZih0aGlzKS5nZW5lcmF0ZWRPYmplY3ROYW1lKHRoaXMpYCwgd2hpY2ggYnkgZGVmYXVsdCB1c2VzIHRoZVxuICAgKiBjb25zdHJ1Y3QgcGF0aCB0byBnZW5lcmF0ZSBhIEROUy1jb21wYXRpYmxlIG5hbWUgZm9yIHRoZSByZXNvdXJjZS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBuYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0J3MgbmFtZXNwYWNlLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IG5hbWVzcGFjZT86IHN0cmluZztcblxuICAvKipcbiAgICogTGFiZWxzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG9iamVjdC5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgbGFiZWxzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXG4gIC8qKlxuICAgKiBBbm5vdGF0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhpcyBvYmplY3QuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGFubm90YXRpb25zOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXG4gIC8qKlxuICAgKiBGaW5hbGl6ZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG9iamVjdC5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgZmluYWxpemVyczogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIE93bmVyIHJlZmVyZW5jZXMgc2V0IGZvciB0aGlzIG9iamVjdC5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgb3duZXJSZWZlcmVuY2VzOiBPd25lclJlZmVyZW5jZVtdO1xuXG4gIC8qKlxuICAgKiBBZGRpdGlvbmFsIG1ldGFkYXRhIGF0dHJpYnV0ZXMgcGFzc2VkIHRocm91Z2ggYG9wdGlvbnNgLlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBfYWRkaXRpb25hbEF0dHJpYnV0ZXM6IHsgW2tleTogc3RyaW5nXTogYW55IH07XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogQXBpT2JqZWN0TWV0YWRhdGEgPSB7IH0pIHtcbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgdGhpcy5sYWJlbHMgPSBvcHRpb25zLmxhYmVscyA/PyB7IH07XG4gICAgdGhpcy5hbm5vdGF0aW9ucyA9IG9wdGlvbnMuYW5ub3RhdGlvbnMgPz8geyB9O1xuICAgIHRoaXMubmFtZXNwYWNlID0gb3B0aW9ucy5uYW1lc3BhY2U7XG4gICAgdGhpcy5maW5hbGl6ZXJzID0gb3B0aW9ucy5maW5hbGl6ZXJzID8/IFtdO1xuICAgIHRoaXMub3duZXJSZWZlcmVuY2VzID0gb3B0aW9ucy5vd25lclJlZmVyZW5jZXMgPz8gW107XG4gICAgdGhpcy5fYWRkaXRpb25hbEF0dHJpYnV0ZXMgPSBvcHRpb25zID8/IHsgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBsYWJlbC5cbiAgICpcbiAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZS5cbiAgICovXG4gIHB1YmxpYyBhZGRMYWJlbChrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMubGFiZWxzW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBhIHZhbHVlIG9mIGEgbGFiZWwgb3IgdW5kZWZpbmVkXG4gICAqIEBwYXJhbSBrZXkgdGhlIGxhYmVsXG4gICAqL1xuICBwdWJsaWMgZ2V0TGFiZWwoa2V5OiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLmxhYmVsc1trZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBhbm5vdGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleS5cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlLlxuICAgKi9cbiAgcHVibGljIGFkZEFubm90YXRpb24oa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLmFubm90YXRpb25zW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgb25lIG9yIG1vcmUgZmluYWxpemVycy5cbiAgICpcbiAgICogQHBhcmFtIGZpbmFsaXplcnMgdGhlIGZpbmFsaXplcnNcbiAgICovXG4gIHB1YmxpYyBhZGRGaW5hbGl6ZXJzKC4uLmZpbmFsaXplcnM6IHN0cmluZ1tdKSB7XG4gICAgdGhpcy5maW5hbGl6ZXJzLnB1c2goLi4uZmluYWxpemVycyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIG93bmVyLlxuICAgKlxuICAgKiBAcGFyYW0gb3duZXIgdGhlIG93bmVyXG4gICAqL1xuICBwdWJsaWMgYWRkT3duZXJSZWZlcmVuY2Uob3duZXI6IE93bmVyUmVmZXJlbmNlKSB7XG4gICAgdGhpcy5vd25lclJlZmVyZW5jZXMucHVzaChvd25lcik7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBhcmJpdHJhcnkga2V5L3ZhbHVlIHRvIHRoZSBvYmplY3QgbWV0YWRhdGEuXG4gICAqIEBwYXJhbSBrZXkgTWV0YWRhdGEga2V5XG4gICAqIEBwYXJhbSB2YWx1ZSBNZXRhZGF0YSB2YWx1ZVxuICAgKi9cbiAgcHVibGljIGFkZChrZXk6IHN0cmluZywgdmFsdWU6IGFueSkge1xuICAgIHRoaXMuX2FkZGl0aW9uYWxBdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW50aGVzaXplcyBhIGs4cyBPYmplY3RNZXRhIGZvciB0aGlzIG1ldGFkYXRhIHNldC5cbiAgICovXG4gIHB1YmxpYyB0b0pzb24oKSB7XG4gICAgY29uc3Qgc2FuaXRpemUgPSAoeDogYW55KSA9PiBzYW5pdGl6ZVZhbHVlKHgsIHsgZmlsdGVyRW1wdHlBcnJheXM6IHRydWUsIGZpbHRlckVtcHR5T2JqZWN0czogdHJ1ZSB9KTtcbiAgICByZXR1cm4gc2FuaXRpemUocmVzb2x2ZSh7XG4gICAgICAuLi50aGlzLl9hZGRpdGlvbmFsQXR0cmlidXRlcyxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG5hbWVzcGFjZTogdGhpcy5uYW1lc3BhY2UsXG4gICAgICBhbm5vdGF0aW9uczogdGhpcy5hbm5vdGF0aW9ucyxcbiAgICAgIGZpbmFsaXplcnM6IHRoaXMuZmluYWxpemVycyxcbiAgICAgIG93bmVyUmVmZXJlbmNlczogdGhpcy5vd25lclJlZmVyZW5jZXMsXG4gICAgICBsYWJlbHM6IHRoaXMubGFiZWxzLFxuICAgIH0pKTtcbiAgfVxufVxuXG4vKipcbiAqIE93bmVyUmVmZXJlbmNlIGNvbnRhaW5zIGVub3VnaCBpbmZvcm1hdGlvbiB0byBsZXQgeW91IGlkZW50aWZ5IGFuIG93bmluZ1xuICogb2JqZWN0LiBBbiBvd25pbmcgb2JqZWN0IG11c3QgYmUgaW4gdGhlIHNhbWUgbmFtZXNwYWNlIGFzIHRoZSBkZXBlbmRlbnQsIG9yXG4gKiBiZSBjbHVzdGVyLXNjb3BlZCwgc28gdGhlcmUgaXMgbm8gbmFtZXNwYWNlIGZpZWxkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE93bmVyUmVmZXJlbmNlIHtcbiAgLyoqXG4gICAqIEFQSSB2ZXJzaW9uIG9mIHRoZSByZWZlcmVudC5cbiAgICovXG4gIHJlYWRvbmx5IGFwaVZlcnNpb246IHN0cmluZztcblxuICAvKipcbiAgICogSWYgdHJ1ZSwgQU5EIGlmIHRoZSBvd25lciBoYXMgdGhlIFwiZm9yZWdyb3VuZERlbGV0aW9uXCIgZmluYWxpemVyLCB0aGVuIHRoZVxuICAgKiBvd25lciBjYW5ub3QgYmUgZGVsZXRlZCBmcm9tIHRoZSBrZXktdmFsdWUgc3RvcmUgdW50aWwgdGhpcyByZWZlcmVuY2UgaXNcbiAgICogcmVtb3ZlZC4gRGVmYXVsdHMgdG8gZmFsc2UuIFRvIHNldCB0aGlzIGZpZWxkLCBhIHVzZXIgbmVlZHMgXCJkZWxldGVcIlxuICAgKiBwZXJtaXNzaW9uIG9mIHRoZSBvd25lciwgb3RoZXJ3aXNlIDQyMiAoVW5wcm9jZXNzYWJsZSBFbnRpdHkpIHdpbGwgYmVcbiAgICogcmV0dXJuZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlLiBUbyBzZXQgdGhpcyBmaWVsZCwgYSB1c2VyIG5lZWRzIFwiZGVsZXRlXCIgcGVybWlzc2lvbiBvZiB0aGVcbiAgICogb3duZXIsIG90aGVyd2lzZSA0MjIgKFVucHJvY2Vzc2FibGUgRW50aXR5KSB3aWxsIGJlIHJldHVybmVkLlxuICAgKi9cbiAgcmVhZG9ubHkgYmxvY2tPd25lckRlbGV0aW9uPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSWYgdHJ1ZSwgdGhpcyByZWZlcmVuY2UgcG9pbnRzIHRvIHRoZSBtYW5hZ2luZyBjb250cm9sbGVyLlxuICAgKi9cbiAgcmVhZG9ubHkgY29udHJvbGxlcj86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEtpbmQgb2YgdGhlIHJlZmVyZW50LlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0Lms4cy5pby9jb21tdW5pdHkvY29udHJpYnV0b3JzL2RldmVsL3NpZy1hcmNoaXRlY3R1cmUvYXBpLWNvbnZlbnRpb25zLm1kI3R5cGVzLWtpbmRzXG4gICAqL1xuICByZWFkb25seSBraW5kOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIHJlZmVyZW50LlxuICAgKlxuICAgKiBAc2VlIGh0dHA6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvdXNlci1ndWlkZS9pZGVudGlmaWVycyNuYW1lc1xuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBVSUQgb2YgdGhlIHJlZmVyZW50LlxuICAgKlxuICAgKiBAc2VlIGh0dHA6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvdXNlci1ndWlkZS9pZGVudGlmaWVycyN1aWRzXG4gICAqL1xuICByZWFkb25seSB1aWQ6IHN0cmluZztcblxufVxuIl19

/***/ }),

/***/ 3948:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Names = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const crypto = __nccwpck_require__(6113);
const constructs_1 = __nccwpck_require__(1963);
const MAX_LEN = 63;
const VALIDATE = /^[0-9a-z-]+$/;
const VALIDATE_LABEL_VALUE = /^(([0-9a-zA-Z][0-9a-zA-Z-_.]*)?[0-9a-zA-Z])?$/;
const HASH_LEN = 8;
/**
 * Utilities for generating unique and stable names.
 */
class Names {
    /* istanbul ignore next */
    constructor() {
        return;
    }
    /**
     * Generates a unique and stable name compatible DNS_LABEL from RFC-1123 from
     * a path.
     *
     * The generated name will:
     *  - contain at most 63 characters
     *  - contain only lowercase alphanumeric characters or ‘-’
     *  - start with an alphanumeric character
     *  - end with an alphanumeric character
     *
     * The generated name will have the form:
     *  <comp0>-<comp1>-..-<compN>-<short-hash>
     *
     * Where <comp> are the path components (assuming they are is separated by
     * "/").
     *
     * Note that if the total length is longer than 63 characters, we will trim
     * the first components since the last components usually encode more meaning.
     *
     * @link https://tools.ietf.org/html/rfc1123
     *
     * @param scope The construct for which to render the DNS label
     * @param options Name options
     * @throws if any of the components do not adhere to naming constraints or
     * length.
     */
    static toDnsLabel(scope, options = {}) {
        var _b, _c, _d, _e;
        const maxLen = (_b = options.maxLen) !== null && _b !== void 0 ? _b : MAX_LEN;
        const delim = (_c = options.delimiter) !== null && _c !== void 0 ? _c : '-';
        const include_hash = (_d = options.includeHash) !== null && _d !== void 0 ? _d : true;
        if (maxLen < HASH_LEN && include_hash) {
            throw new Error(`minimum max length for object names is ${HASH_LEN} (required for hash)`);
        }
        const node = constructs_1.Node.of(scope);
        let components = node.path.split('/');
        components.push(...(_e = options.extra) !== null && _e !== void 0 ? _e : []);
        // special case: if we only have one component in our path and it adheres to DNS_NAME, we don't decorate it
        if (components.length === 1 && VALIDATE.test(components[0]) && components[0].length <= maxLen) {
            return components[0];
        }
        // okay, now we need to normalize all components to adhere to DNS_NAME and append the hash of the full path.
        components = components.map(c => normalizeToDnsName(c, maxLen));
        if (include_hash) {
            components.push(calcHash(node, HASH_LEN));
        }
        return toHumanForm(components, delim, maxLen);
    }
    /**
     * Generates a unique and stable name compatible label key name segment and
     * label value from a path.
     *
     * The name segment is required and must be 63 characters or less, beginning
     * and ending with an alphanumeric character ([a-z0-9A-Z]) with dashes (-),
     * underscores (_), dots (.), and alphanumerics between.
     *
     * Valid label values must be 63 characters or less and must be empty or
     * begin and end with an alphanumeric character ([a-z0-9A-Z]) with dashes
     * (-), underscores (_), dots (.), and alphanumerics between.
     *
     * The generated name will have the form:
     *  <comp0><delim><comp1><delim>..<delim><compN><delim><short-hash>
     *
     * Where <comp> are the path components (assuming they are is separated by
     * "/").
     *
     * Note that if the total length is longer than 63 characters, we will trim
     * the first components since the last components usually encode more meaning.
     *
     * @link https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set
     *
     * @param scope The construct for which to render the DNS label
     * @param options Name options
     * @throws if any of the components do not adhere to naming constraints or
     * length.
     */
    static toLabelValue(scope, options = {}) {
        var _b, _c, _d, _e;
        const maxLen = (_b = options.maxLen) !== null && _b !== void 0 ? _b : MAX_LEN;
        const delim = (_c = options.delimiter) !== null && _c !== void 0 ? _c : '-';
        const include_hash = (_d = options.includeHash) !== null && _d !== void 0 ? _d : true;
        if (maxLen < HASH_LEN && include_hash) {
            throw new Error(`minimum max length for label is ${HASH_LEN} (required for hash)`);
        }
        if (/[^0-9a-zA-Z-_.]/.test(delim)) {
            throw new Error('delim should not contain "[^0-9a-zA-Z-_.]"');
        }
        const node = constructs_1.Node.of(scope);
        let components = node.path.split('/');
        components.push(...(_e = options.extra) !== null && _e !== void 0 ? _e : []);
        // special case: if we only have one component in our path and it adheres to DNS_NAME, we don't decorate it
        if (components.length === 1 && VALIDATE_LABEL_VALUE.test(components[0]) && components[0].length <= maxLen) {
            return components[0];
        }
        // okay, now we need to normalize all components to adhere to label and append the hash of the full path.
        components = components.map(c => normalizeToLabelValue(c, maxLen));
        if (include_hash) {
            components.push(calcHash(node, HASH_LEN));
        }
        const result = toHumanForm(components, delim, maxLen);
        // slicing might let '-', '_', '.' be in the start of the result.
        return result.replace(/^[^0-9a-zA-Z]+/, '');
    }
}
exports.Names = Names;
_a = JSII_RTTI_SYMBOL_1;
Names[_a] = { fqn: "cdk8s.Names", version: "2.3.11" };
function omitDuplicates(value, index, components) {
    return value !== components[index - 1];
}
function omitDefaultChild(value, _, __) {
    return value.toLowerCase() !== 'resource' && value.toLowerCase() !== 'default';
}
function toHumanForm(components, delim, maxLen) {
    return components.reverse()
        .filter(omitDuplicates)
        .join('/')
        .slice(0, maxLen)
        .split('/')
        .reverse()
        .filter(x => x)
        .join(delim)
        .split(delim)
        .filter(x => x)
        .filter(omitDefaultChild)
        .join(delim);
}
function normalizeToDnsName(c, maxLen) {
    return c
        .toLocaleLowerCase() // lower case
        .replace(/[^0-9a-zA-Z-_.]/g, '') // remove non-allowed characters
        .substr(0, maxLen); // trim to maxLength
}
function calcHash(node, maxLen) {
    if (process.env.CDK8S_LEGACY_HASH) {
        const hash = crypto.createHash('sha256');
        hash.update(node.path);
        return hash.digest('hex').slice(0, maxLen);
    }
    return node.addr.substring(0, HASH_LEN);
}
function normalizeToLabelValue(c, maxLen) {
    return c
        .replace(/[^0-9a-zA-Z-_.]/g, '') // remove non-allowed characters
        .substr(0, maxLen); // trim to maxLength
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmFtZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvbmFtZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxpQ0FBaUM7QUFDakMsMkNBQTZDO0FBRTdDLE1BQU0sT0FBTyxHQUFHLEVBQUUsQ0FBQztBQUNuQixNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUM7QUFDaEMsTUFBTSxvQkFBb0IsR0FBRywrQ0FBK0MsQ0FBQztBQUM3RSxNQUFNLFFBQVEsR0FBRyxDQUFDLENBQUM7QUErQm5COztHQUVHO0FBQ0gsTUFBYSxLQUFLO0lBcUhoQiwwQkFBMEI7SUFDMUI7UUFDRSxPQUFPO0lBQ1QsQ0FBQztJQXZIRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXlCRztJQUNJLE1BQU0sQ0FBQyxVQUFVLENBQUMsS0FBZ0IsRUFBRSxVQUF1QixFQUFHOztRQUNuRSxNQUFNLE1BQU0sU0FBRyxPQUFPLENBQUMsTUFBTSxtQ0FBSSxPQUFPLENBQUM7UUFDekMsTUFBTSxLQUFLLFNBQUcsT0FBTyxDQUFDLFNBQVMsbUNBQUksR0FBRyxDQUFDO1FBQ3ZDLE1BQU0sWUFBWSxTQUFHLE9BQU8sQ0FBQyxXQUFXLG1DQUFJLElBQUksQ0FBQztRQUVqRCxJQUFJLE1BQU0sR0FBRyxRQUFRLElBQUksWUFBWSxFQUFFO1lBQ3JDLE1BQU0sSUFBSSxLQUFLLENBQUMsMENBQTBDLFFBQVEsc0JBQXNCLENBQUMsQ0FBQztTQUMzRjtRQUVELE1BQU0sSUFBSSxHQUFHLGlCQUFJLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRTVCLElBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3RDLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBRyxPQUFPLENBQUMsS0FBSyxtQ0FBSSxFQUFFLENBQUMsQ0FBQztRQUV4QywyR0FBMkc7UUFDM0csSUFBSSxVQUFVLENBQUMsTUFBTSxLQUFL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Q0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7S0FDNUM7SUFFRCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztBQUMxQyxDQUFDO0FBRUQsU0FBUyxxQkFBcUIsQ0FBQyxDQUFTLEVBQUUsTUFBYztJQUN0RCxPQUFPLENBQUM7U0FDTCxPQUFPLENBQUMsa0JBQWtCLEVBQUUsRUFBRSxDQUFDLENBQUMsZ0NBQWdDO1NBQ2hFLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxvQkFBb0I7QUFDNUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgQ29uc3RydWN0LCBOb2RlIH0gZnJvbSAnY29uc3RydWN0cyc7XG5cbmNvbnN0IE1BWF9MRU4gPSA2MztcbmNvbnN0IFZBTElEQVRFID0gL15bMC05YS16LV0rJC87XG5jb25zdCBWQUxJREFURV9MQUJFTF9WQUxVRSA9IC9eKChbMC05YS16QS1aXVswLTlhLXpBLVotXy5dKik/WzAtOWEtekEtWl0pPyQvO1xuY29uc3QgSEFTSF9MRU4gPSA4O1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIG5hbWUgZ2VuZXJhdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOYW1lT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBNYXhpbXVtIGFsbG93ZWQgbGVuZ3RoIGZvciB0aGUgbmFtZS5cbiAgICogQGRlZmF1bHQgNjNcbiAgICovXG4gIHJlYWRvbmx5IG1heExlbj86IG51bWJlcjtcblxuICAvKipcbiAgICogRXh0cmEgY29tcG9uZW50cyB0byBpbmNsdWRlIGluIHRoZSBuYW1lLlxuICAgKiBAZGVmYXVsdCBbXSB1c2UgdGhlIGNvbnN0cnVjdCBwYXRoIGNvbXBvbmVudHNcbiAgICovXG4gIHJlYWRvbmx5IGV4dHJhPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIERlbGltaXRlciB0byB1c2UgYmV0d2VlbiBjb21wb25lbnRzLlxuICAgKiBAZGVmYXVsdCBcIi1cIlxuICAgKi9cbiAgcmVhZG9ubHkgZGVsaW1pdGVyPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBJbmNsdWRlIGEgc2hvcnQgaGFzaCBhcyBsYXN0IHBhcnQgb2YgdGhlIG5hbWUuXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IGluY2x1ZGVIYXNoPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBVdGlsaXRpZXMgZm9yIGdlbmVyYXRpbmcgdW5pcXVlIGFuZCBzdGFibGUgbmFtZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBOYW1lcyB7XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgYW5kIHN0YWJsZSBuYW1lIGNvbXBhdGlibGUgRE5TX0xBQkVMIGZyb20gUkZDLTExMjMgZnJvbVxuICAgKiBhIHBhdGguXG4gICAqXG4gICAqIFRoZSBnZW5lcmF0ZWQgbmFtZSB3aWxsOlxuICAgKiAgLSBjb250YWluIGF0IG1vc3QgNjMgY2hhcmFjdGVyc1xuICAgKiAgLSBjb250YWluIG9ubHkgbG93ZXJjYXNlIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIG9yIOKAmC3igJlcbiAgICogIC0gc3RhcnQgd2l0aCBhbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVyXG4gICAqICAtIGVuZCB3aXRoIGFuIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJcbiAgICpcbiAgICogVGhlIGdlbmVyYXRlZCBuYW1lIHdpbGwgaGF2ZSB0aGUgZm9ybTpcbiAgICogIDxjb21wMD4tPGNvbXAxPi0uLi08Y29tcE4+LTxzaG9ydC1oYXNoPlxuICAgKlxuICAgKiBXaGVyZSA8Y29tcD4gYXJlIHRoZSBwYXRoIGNvbXBvbmVudHMgKGFzc3VtaW5nIHRoZXkgYXJlIGlzIHNlcGFyYXRlZCBieVxuICAgKiBcIi9cIikuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBpZiB0aGUgdG90YWwgbGVuZ3RoIGlzIGxvbmdlciB0aGFuIDYzIGNoYXJhY3RlcnMsIHdlIHdpbGwgdHJpbVxuICAgKiB0aGUgZmlyc3QgY29tcG9uZW50cyBzaW5jZSB0aGUgbGFzdCBjb21wb25lbnRzIHVzdWFsbHkgZW5jb2RlIG1vcmUgbWVhbmluZy5cbiAgICpcbiAgICogQGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzExMjNcbiAgICpcbiAgICogQHBhcmFtIHNjb3BlIFRoZSBjb25zdHJ1Y3QgZm9yIHdoaWNoIHRvIHJlbmRlciB0aGUgRE5TIGxhYmVsXG4gICAqIEBwYXJhbSBvcHRpb25zIE5hbWUgb3B0aW9uc1xuICAgKiBAdGhyb3dzIGlmIGFueSBvZiB0aGUgY29tcG9uZW50cyBkbyBub3QgYWRoZXJlIHRvIG5hbWluZyBjb25zdHJhaW50cyBvclxuICAgKiBsZW5ndGguXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHRvRG5zTGFiZWwoc2NvcGU6IENvbnN0cnVjdCwgb3B0aW9uczogTmFtZU9wdGlvbnMgPSB7IH0pIHtcbiAgICBjb25zdCBtYXhMZW4gPSBvcHRpb25zLm1heExlbiA/PyBNQVhfTEVOO1xuICAgIGNvbnN0IGRlbGltID0gb3B0aW9ucy5kZWxpbWl0ZXIgPz8gJy0nO1xuICAgIGNvbnN0IGluY2x1ZGVfaGFzaCA9IG9wdGlvbnMuaW5jbHVkZUhhc2ggPz8gdHJ1ZTtcblxuICAgIGlmIChtYXhMZW4gPCBIQVNIX0xFTiAmJiBpbmNsdWRlX2hhc2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbWluaW11bSBtYXggbGVuZ3RoIGZvciBvYmplY3QgbmFtZXMgaXMgJHtIQVNIX0xFTn0gKHJlcXVpcmVkIGZvciBoYXNoKWApO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGUgPSBOb2RlLm9mKHNjb3BlKTtcblxuICAgIGxldCBjb21wb25lbnRzID0gbm9kZS5wYXRoLnNwbGl0KCcvJyk7XG4gICAgY29tcG9uZW50cy5wdXNoKC4uLm9wdGlvbnMuZXh0cmEgPz8gW10pO1xuXG4gICAgLy8gc3BlY2lhbCBjYXNlOiBpZiB3ZSBvbmx5IGhhdmUgb25lIGNvbXBvbmVudCBpbiBvdXIgcGF0aCBhbmQgaXQgYWRoZXJlcyB0byBETlNfTkFNRSwgd2UgZG9uJ3QgZGVjb3JhdGUgaXRcbiAgICBpZiAoY29tcG9uZW50cy5sZW5ndGggPT09IDEgJiYgVkFMSURBVEUudGVzdChjb21wb25lbnRzWzBdKSAmJiBjb21wb25lbnRzWzBdLmxlbmd0aCA8PSBtYXhMZW4pIHtcbiAgICAgIHJldHVybiBjb21wb25lbnRzWzBdO1xuICAgIH1cblxuICAgIC8vIG9rYXksIG5vdyB3ZSBuZWVkIHRvIG5vcm1hbGl6ZSBhbGwgY29tcG9uZW50cyB0byBhZGhlcmUgdG8gRE5TX05BTUUgYW5kIGFwcGVuZCB0aGUgaGFzaCBvZiB0aGUgZnVsbCBwYXRoLlxuICAgIGNvbXBvbmVudHMgPSBjb21wb25lbnRzLm1hcChjID0+IG5vcm1hbGl6ZVRvRG5zTmFtZShjLCBtYXhMZW4pKTtcbiAgICBpZiAoaW5jbHVkZV9oYXNoKSB7XG4gICAgICBjb21wb25lbnRzLnB1c2goY2FsY0hhc2gobm9kZSwgSEFTSF9MRU4pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9IdW1hbkZvcm0oY29tcG9uZW50cywgZGVsaW0sIG1heExlbik7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgdW5pcXVlIGFuZCBzdGFibGUgbmFtZSBjb21wYXRpYmxlIGxhYmVsIGtleSBuYW1lIHNlZ21lbnQgYW5kXG4gICAqIGxhYmVsIHZhbHVlIGZyb20gYSBwYXRoLlxuICAgKlxuICAgKiBUaGUgbmFtZSBzZWdtZW50IGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIDYzIGNoYXJhY3RlcnMgb3IgbGVzcywgYmVnaW5uaW5nXG4gICAqIGFuZCBlbmRpbmcgd2l0aCBhbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVyIChbYS16MC05QS1aXSkgd2l0aCBkYXNoZXMgKC0pLFxuICAgKiB1bmRlcnNjb3JlcyAoXyksIGRvdHMgKC4pLCBhbmQgYWxwaGFudW1lcmljcyBiZXR3ZWVuLlxuICAgKlxuICAgKiBWYWxpZCBsYWJlbCB2YWx1ZXMgbXVzdCBiZSA2MyBjaGFyYWN0ZXJzIG9yIGxlc3MgYW5kIG11c3QgYmUgZW1wdHkgb3JcbiAgICogYmVnaW4gYW5kIGVuZCB3aXRoIGFuIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXIgKFthLXowLTlBLVpdKSB3aXRoIGRhc2hlc1xuICAgKiAoLSksIHVuZGVyc2NvcmVzIChfKSwgZG90cyAoLiksIGFuZCBhbHBoYW51bWVyaWNzIGJldHdlZW4uXG4gICAqXG4gICAqIFRoZSBnZW5lcmF0ZWQgbmFtZSB3aWxsIGhhdmUgdGhlIGZvcm06XG4gICAqICA8Y29tcDA+PGRlbGltPjxjb21wMT48ZGVsaW0+Li48ZGVsaW0+PGNvbXBOPjxkZWxpbT48c2hvcnQtaGFzaD5cbiAgICpcbiAgICogV2hlcmUgPGNvbXA+IGFyZSB0aGUgcGF0aCBjb21wb25lbnRzIChhc3N1bWluZyB0aGV5IGFyZSBpcyBzZXBhcmF0ZWQgYnlcbiAgICogXCIvXCIpLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgaWYgdGhlIHRvdGFsIGxlbmd0aCBpcyBsb25nZXIgdGhhbiA2MyBjaGFyYWN0ZXJzLCB3ZSB3aWxsIHRyaW1cbiAgICogdGhlIGZpcnN0IGNvbXBvbmVudHMgc2luY2UgdGhlIGxhc3QgY29tcG9uZW50cyB1c3VhbGx5IGVuY29kZSBtb3JlIG1lYW5pbmcuXG4gICAqXG4gICAqIEBsaW5rIGh0dHBzOi8va3ViZXJuZXRlcy5pby9kb2NzL2NvbmNlcHRzL292ZXJ2aWV3L3dvcmtpbmctd2l0aC1vYmplY3RzL2xhYmVscy8jc3ludGF4LWFuZC1jaGFyYWN0ZXItc2V0XG4gICAqXG4gICAqIEBwYXJhbSBzY29wZSBUaGUgY29uc3RydWN0IGZvciB3aGljaCB0byByZW5kZXIgdGhlIEROUyBsYWJlbFxuICAgKiBAcGFyYW0gb3B0aW9ucyBOYW1lIG9wdGlvbnNcbiAgICogQHRocm93cyBpZiBhbnkgb2YgdGhlIGNvbXBvbmVudHMgZG8gbm90IGFkaGVyZSB0byBuYW1pbmcgY29uc3RyYWludHMgb3JcbiAgICogbGVuZ3RoLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyB0b0xhYmVsVmFsdWUoc2NvcGU6IENvbnN0cnVjdCwgb3B0aW9uczogTmFtZU9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG1heExlbiA9IG9wdGlvbnMubWF4TGVuID8/IE1BWF9MRU47XG4gICAgY29uc3QgZGVsaW0gPSBvcHRpb25zLmRlbGltaXRlciA/PyAnLSc7XG4gICAgY29uc3QgaW5jbHVkZV9oYXNoID0gb3B0aW9ucy5pbmNsdWRlSGFzaCA/PyB0cnVlO1xuXG4gICAgaWYgKG1heExlbiA8IEhBU0hfTEVOICYmIGluY2x1ZGVfaGFzaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaW5pbXVtIG1heCBsZW5ndGggZm9yIGxhYmVsIGlzICR7SEFTSF9MRU59IChyZXF1aXJlZCBmb3IgaGFzaClgKTtcbiAgICB9XG5cbiAgICBpZiAoL1teMC05YS16QS1aLV8uXS8udGVzdChkZWxpbSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGVsaW0gc2hvdWxkIG5vdCBjb250YWluIFwiW14wLTlhLXpBLVotXy5dXCInKTtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlID0gTm9kZS5vZihzY29wZSk7XG4gICAgbGV0IGNvbXBvbmVudHMgPSBub2RlLnBhdGguc3BsaXQoJy8nKTtcbiAgICBjb21wb25lbnRzLnB1c2goLi4ub3B0aW9ucy5leHRyYSA/PyBbXSk7XG5cbiAgICAvLyBzcGVjaWFsIGNhc2U6IGlmIHdlIG9ubHkgaGF2ZSBvbmUgY29tcG9uZW50IGluIG91ciBwYXRoIGFuZCBpdCBhZGhlcmVzIHRvIEROU19OQU1FLCB3ZSBkb24ndCBkZWNvcmF0ZSBpdFxuICAgIGlmIChjb21wb25lbnRzLmxlbmd0aCA9PT0gMSAmJiBWQUxJREFURV9MQUJFTF9WQUxVRS50ZXN0KGNvbXBvbmVudHNbMF0pICYmIGNvbXBvbmVudHNbMF0ubGVuZ3RoIDw9IG1heExlbikge1xuICAgICAgcmV0dXJuIGNvbXBvbmVudHNbMF07XG4gICAgfVxuXG4gICAgLy8gb2theSwgbm93IHdlIG5lZWQgdG8gbm9ybWFsaXplIGFsbCBjb21wb25lbnRzIHRvIGFkaGVyZSB0byBsYWJlbCBhbmQgYXBwZW5kIHRoZSBoYXNoIG9mIHRoZSBmdWxsIHBhdGguXG4gICAgY29tcG9uZW50cyA9IGNvbXBvbmVudHMubWFwKGMgPT4gbm9ybWFsaXplVG9MYWJlbFZhbHVlKGMsIG1heExlbikpO1xuICAgIGlmIChpbmNsdWRlX2hhc2gpIHtcbiAgICAgIGNvbXBvbmVudHMucHVzaChjYWxjSGFzaChub2RlLCBIQVNIX0xFTikpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IHRvSHVtYW5Gb3JtKGNvbXBvbmVudHMsIGRlbGltLCBtYXhMZW4pO1xuXG4gICAgLy8gc2xpY2luZyBtaWdodCBsZXQgJy0nLCAnXycsICcuJyBiZSBpbiB0aGUgc3RhcnQgb2YgdGhlIHJlc3VsdC5cbiAgICByZXR1cm4gcmVzdWx0LnJlcGxhY2UoL15bXjAtOWEtekEtWl0rLywgJycpO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gb21pdER1cGxpY2F0ZXModmFsdWU6IHN0cmluZywgaW5kZXg6IG51bWJlciwgY29tcG9uZW50czogc3RyaW5nW10pIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBjb21wb25lbnRzW2luZGV4LTFdO1xufVxuXG5mdW5jdGlvbiBvbWl0RGVmYXVsdENoaWxkKHZhbHVlOiBzdHJpbmcsIF86IG51bWJlciwgX186IHN0cmluZ1tdKSB7XG4gIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpICE9PSAncmVzb3VyY2UnICYmIHZhbHVlLnRvTG93ZXJDYXNlKCkgIT09ICdkZWZhdWx0Jztcbn1cblxuZnVuY3Rpb24gdG9IdW1hbkZvcm0oY29tcG9uZW50czogc3RyaW5nW10sIGRlbGltOiBzdHJpbmcsIG1heExlbjogbnVtYmVyKSB7XG4gIHJldHVybiBjb21wb25lbnRzLnJldmVyc2UoKVxuICAgIC5maWx0ZXIob21pdER1cGxpY2F0ZXMpXG4gICAgLmpvaW4oJy8nKVxuICAgIC5zbGljZSgwLCBtYXhMZW4pXG4gICAgLnNwbGl0KCcvJylcbiAgICAucmV2ZXJzZSgpXG4gICAgLmZpbHRlcih4ID0+IHgpXG4gICAgLmpvaW4oZGVsaW0pXG4gICAgLnNwbGl0KGRlbGltKVxuICAgIC5maWx0ZXIoeCA9PiB4KVxuICAgIC5maWx0ZXIob21pdERlZmF1bHRDaGlsZClcbiAgICAuam9pbihkZWxpbSk7XG5cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVG9EbnNOYW1lKGM6IHN0cmluZywgbWF4TGVuOiBudW1iZXIpIHtcbiAgcmV0dXJuIGNcbiAgICAudG9Mb2NhbGVMb3dlckNhc2UoKSAvLyBsb3dlciBjYXNlXG4gICAgLnJlcGxhY2UoL1teMC05YS16QS1aLV8uXS9nLCAnJykgLy8gcmVtb3ZlIG5vbi1hbGxvd2VkIGNoYXJhY3RlcnNcbiAgICAuc3Vic3RyKDAsIG1heExlbik7IC8vIHRyaW0gdG8gbWF4TGVuZ3RoXG59XG5cbmZ1bmN0aW9uIGNhbGNIYXNoKG5vZGU6IE5vZGUsIG1heExlbjogbnVtYmVyKSB7XG4gIGlmIChwcm9jZXNzLmVudi5DREs4U19MRUdBQ1lfSEFTSCkge1xuICAgIGNvbnN0IGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2Jyk7XG4gICAgaGFzaC51cGRhdGUobm9kZS5wYXRoKTtcbiAgICByZXR1cm4gaGFzaC5kaWdlc3QoJ2hleCcpLnNsaWNlKDAsIG1heExlbik7XG4gIH1cblxuICByZXR1cm4gbm9kZS5hZGRyLnN1YnN0cmluZygwLCBIQVNIX0xFTik7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvTGFiZWxWYWx1ZShjOiBzdHJpbmcsIG1heExlbjogbnVtYmVyKSB7XG4gIHJldHVybiBjXG4gICAgLnJlcGxhY2UoL1teMC05YS16QS1aLV8uXS9nLCAnJykgLy8gcmVtb3ZlIG5vbi1hbGxvd2VkIGNoYXJhY3RlcnNcbiAgICAuc3Vic3RyKDAsIG1heExlbik7IC8vIHRyaW0gdG8gbWF4TGVuZ3RoXG59XG4iXX0=

/***/ }),

/***/ 3764:
/***/ ((__unused_webpack_module, exports) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SizeRoundingBehavior = exports.Size = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
/**
 * Represents the amount of digital storage.
 *
 * The amount can be specified either as a literal value (e.g: `10`) which
 * cannot be negative.
 *
 * When the amount is passed as a token, unit conversion is not possible.
 */
class Size {
    constructor(amount, unit) {
        if (amount < 0) {
            throw new Error(`Storage amounts cannot be negative. Received: ${amount}`);
        }
        this.amount = amount;
        this.unit = unit;
    }
    /**
     * Create a Storage representing an amount kibibytes.
     * 1 KiB = 1024 bytes
     */
    static kibibytes(amount) {
        return new Size(amount, StorageUnit.Kibibytes);
    }
    /**
     * Create a Storage representing an amount mebibytes.
     * 1 MiB = 1024 KiB
     */
    static mebibytes(amount) {
        return new Size(amount, StorageUnit.Mebibytes);
    }
    /**
     * Create a Storage representing an amount gibibytes.
     * 1 GiB = 1024 MiB
     */
    static gibibytes(amount) {
        return new Size(amount, StorageUnit.Gibibytes);
    }
    /**
     * Create a Storage representing an amount tebibytes.
     * 1 TiB = 1024 GiB
     */
    static tebibytes(amount) {
        return new Size(amount, StorageUnit.Tebibytes);
    }
    /**
     * Create a Storage representing an amount pebibytes.
     * 1 PiB = 1024 TiB
     */
    static pebibyte(amount) {
        return new Size(amount, StorageUnit.Pebibytes);
    }
    /**
     * Return this storage as a total number of kibibytes.
     */
    toKibibytes(opts = {}) {
        return convert(this.amount, this.unit, StorageUnit.Kibibytes, opts);
    }
    /**
     * Return this storage as a total number of mebibytes.
     */
    toMebibytes(opts = {}) {
        return convert(this.amount, this.unit, StorageUnit.Mebibytes, opts);
    }
    /**
     * Return this storage as a total number of gibibytes.
     */
    toGibibytes(opts = {}) {
        return convert(this.amount, this.unit, StorageUnit.Gibibytes, opts);
    }
    /**
     * Return this storage as a total number of tebibytes.
     */
    toTebibytes(opts = {}) {
        return convert(this.amount, this.unit, StorageUnit.Tebibytes, opts);
    }
    /**
     * Return this storage as a total number of pebibytes.
     */
    toPebibytes(opts = {}) {
        return convert(this.amount, this.unit, StorageUnit.Pebibytes, opts);
    }
}
exports.Size = Size;
_a = JSII_RTTI_SYMBOL_1;
Size[_a] = { fqn: "cdk8s.Size", version: "2.3.11" };
/**
 * Rounding behaviour when converting between units of `Size`.
 */
var SizeRoundingBehavior;
(function (SizeRoundingBehavior) {
    /** Fail the conversion if the result is not an integer. */
    SizeRoundingBehavior[SizeRoundingBehavior["FAIL"] = 0] = "FAIL";
    /** If the result is not an integer, round it to the closest integer less than the result */
    SizeRoundingBehavior[SizeRoundingBehavior["FLOOR"] = 1] = "FLOOR";
    /** Don't round. Return even if the result is a fraction. */
    SizeRoundingBehavior[SizeRoundingBehavior["NONE"] = 2] = "NONE";
})(SizeRoundingBehavior = exports.SizeRoundingBehavior || (exports.SizeRoundingBehavior = {}));
class StorageUnit {
    constructor(label, inKibiBytes) {
        this.label = label;
        this.inKibiBytes = inKibiBytes;
        // MAX_SAFE_INTEGER is 2^53, so by representing storage in kibibytes,
        // the highest storage we can represent is 8 exbibytes.
    }
    toString() {
        return this.label;
    }
}
StorageUnit.Kibibytes = new StorageUnit('kibibytes', 1);
StorageUnit.Mebibytes = new StorageUnit('mebibytes', 1024);
StorageUnit.Gibibytes = new StorageUnit('gibibytes', 1024 * 1024);
StorageUnit.Tebibytes = new StorageUnit('tebibytes', 1024 * 1024 * 1024);
StorageUnit.Pebibytes = new StorageUnit('pebibytes', 1024 * 1024 * 1024 * 1024);
function convert(amount, fromUnit, toUnit, options = {}) {
    var _b;
    const rounding = (_b = options.rounding) !== null && _b !== void 0 ? _b : SizeRoundingBehavior.FAIL;
    if (fromUnit.inKibiBytes === toUnit.inKibiBytes) {
        return amount;
    }
    const multiplier = fromUnit.inKibiBytes / toUnit.inKibiBytes;
    const value = amount * multiplier;
    switch (rounding) {
        case SizeRoundingBehavior.NONE:
            return value;
        case SizeRoundingBehavior.FLOOR:
            return Math.floor(value);
        default:
        case SizeRoundingBehavior.FAIL:
            if (!Number.isInteger(value)) {
                throw new Error(`'${amount} ${fromUnit}' cannot be converted into a whole number of ${toUnit}.`);
            }
            return value;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2l6ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9zaXplLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Ozs7R0FPRztBQUNILE1BQWEsSUFBSTtJQTRDZixZQUFvQixNQUFjLEVBQUUsSUFBaUI7UUFDbkQsSUFBSSxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ2QsTUFBTSxJQUFJLEtBQUssQ0FBQyxpREFBaUQsTUFBTSxFQUFFLENBQUMsQ0FBQztTQUM1RTtRQUNELElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0lBQ25CLENBQUM7SUFqREQ7OztPQUdHO0lBQ0ksTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFjO1FBQ3BDLE9BQU8sSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFjO1FBQ3BDLE9BQU8sSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFjO1FBQ3BDLE9BQU8sSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFjO1FBQ3BDLE9BQU8sSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFjO1FBQ25DLE9BQU8sSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNqRCxD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QixDQUFDLElBQUk7WUFDNUIsT0FBTyxLQUFLLENBQUM7UUFDZixLQUFLLG9CQUFvQixDQUFDLEtBQUs7WUFDN0IsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzNCLFFBQVE7UUFDUixLQUFLLG9CQUFvQixDQUFDLElBQUk7WUFDNUIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEVBQUU7Z0JBQzVCLE1BQU0sSUFBSSxLQUFLLENBQUMsSUFBSSxNQUFNLElBQUksUUFBUSxnREFBZ0QsTUFBTSxHQUFHLENBQUMsQ0FBQzthQUNsRztZQUNELE9BQU8sS0FBSyxDQUFDO0tBQ2hCO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIGRpZ2l0YWwgc3RvcmFnZS5cbiAqXG4gKiBUaGUgYW1vdW50IGNhbiBiZSBzcGVjaWZpZWQgZWl0aGVyIGFzIGEgbGl0ZXJhbCB2YWx1ZSAoZS5nOiBgMTBgKSB3aGljaFxuICogY2Fubm90IGJlIG5lZ2F0aXZlLlxuICpcbiAqIFdoZW4gdGhlIGFtb3VudCBpcyBwYXNzZWQgYXMgYSB0b2tlbiwgdW5pdCBjb252ZXJzaW9uIGlzIG5vdCBwb3NzaWJsZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFNpemUge1xuICAvKipcbiAgICogQ3JlYXRlIGEgU3RvcmFnZSByZXByZXNlbnRpbmcgYW4gYW1vdW50IGtpYmlieXRlcy5cbiAgICogMSBLaUIgPSAxMDI0IGJ5dGVzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGtpYmlieXRlcyhhbW91bnQ6IG51bWJlcik6IFNpemUge1xuICAgIHJldHVybiBuZXcgU2l6ZShhbW91bnQsIFN0b3JhZ2VVbml0LktpYmlieXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgU3RvcmFnZSByZXByZXNlbnRpbmcgYW4gYW1vdW50IG1lYmlieXRlcy5cbiAgICogMSBNaUIgPSAxMDI0IEtpQlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtZWJpYnl0ZXMoYW1vdW50OiBudW1iZXIpOiBTaXplIHtcbiAgICByZXR1cm4gbmV3IFNpemUoYW1vdW50LCBTdG9yYWdlVW5pdC5NZWJpYnl0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIFN0b3JhZ2UgcmVwcmVzZW50aW5nIGFuIGFtb3VudCBnaWJpYnl0ZXMuXG4gICAqIDEgR2lCID0gMTAyNCBNaUJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZ2liaWJ5dGVzKGFtb3VudDogbnVtYmVyKTogU2l6ZSB7XG4gICAgcmV0dXJuIG5ldyBTaXplKGFtb3VudCwgU3RvcmFnZVVuaXQuR2liaWJ5dGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBTdG9yYWdlIHJlcHJlc2VudGluZyBhbiBhbW91bnQgdGViaWJ5dGVzLlxuICAgKiAxIFRpQiA9IDEwMjQgR2lCXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHRlYmlieXRlcyhhbW91bnQ6IG51bWJlcik6IFNpemUge1xuICAgIHJldHVybiBuZXcgU2l6ZShhbW91bnQsIFN0b3JhZ2VVbml0LlRlYmlieXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgU3RvcmFnZSByZXByZXNlbnRpbmcgYW4gYW1vdW50IHBlYmlieXRlcy5cbiAgICogMSBQaUIgPSAxMDI0IFRpQlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBwZWJpYnl0ZShhbW91bnQ6IG51bWJlcik6IFNpemUge1xuICAgIHJldHVybiBuZXcgU2l6ZShhbW91bnQsIFN0b3JhZ2VVbml0LlBlYmlieXRlcyk7XG4gIH1cblxuICBwcml2YXRlIHJlYWRvbmx5IGFtb3VudDogbnVtYmVyO1xuICBwcml2YXRlIHJlYWRvbmx5IHVuaXQ6IFN0b3JhZ2VVbml0O1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoYW1vdW50OiBudW1iZXIsIHVuaXQ6IFN0b3JhZ2VVbml0KSB7XG4gICAgaWYgKGFtb3VudCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU3RvcmFnZSBhbW91bnRzIGNhbm5vdCBiZSBuZWdhdGl2ZS4gUmVjZWl2ZWQ6ICR7YW1vdW50fWApO1xuICAgIH1cbiAgICB0aGlzLmFtb3VudCA9IGFtb3VudDtcbiAgICB0aGlzLnVuaXQgPSB1bml0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGlzIHN0b3JhZ2UgYXMgYSB0b3RhbCBudW1iZXIgb2Yga2liaWJ5dGVzLlxuICAgKi9cbiAgcHVibGljIHRvS2liaWJ5dGVzKG9wdHM6IFNpemVDb252ZXJzaW9uT3B0aW9ucyA9IHt9KTogbnVtYmVyIHtcbiAgICByZXR1cm4gY29udmVydCh0aGlzLmFtb3VudCwgdGhpcy51bml0LCBTdG9yYWdlVW5pdC5LaWJpYnl0ZXMsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGlzIHN0b3JhZ2UgYXMgYSB0b3RhbCBudW1iZXIgb2YgbWViaWJ5dGVzLlxuICAgKi9cbiAgcHVibGljIHRvTWViaWJ5dGVzKG9wdHM6IFNpemVDb252ZXJzaW9uT3B0aW9ucyA9IHt9KTogbnVtYmVyIHtcbiAgICByZXR1cm4gY29udmVydCh0aGlzLmFtb3VudCwgdGhpcy51bml0LCBTdG9yYWdlVW5pdC5NZWJpYnl0ZXMsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGlzIHN0b3JhZ2UgYXMgYSB0b3RhbCBudW1iZXIgb2YgZ2liaWJ5dGVzLlxuICAgKi9cbiAgcHVibGljIHRvR2liaWJ5dGVzKG9wdHM6IFNpemVDb252ZXJzaW9uT3B0aW9ucyA9IHt9KTogbnVtYmVyIHtcbiAgICByZXR1cm4gY29udmVydCh0aGlzLmFtb3VudCwgdGhpcy51bml0LCBTdG9yYWdlVW5pdC5HaWJpYnl0ZXMsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGlzIHN0b3JhZ2UgYXMgYSB0b3RhbCBudW1iZXIgb2YgdGViaWJ5dGVzLlxuICAgKi9cbiAgcHVibGljIHRvVGViaWJ5dGVzKG9wdHM6IFNpemVDb252ZXJzaW9uT3B0aW9ucyA9IHt9KTogbnVtYmVyIHtcbiAgICByZXR1cm4gY29udmVydCh0aGlzLmFtb3VudCwgdGhpcy51bml0LCBTdG9yYWdlVW5pdC5UZWJpYnl0ZXMsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGlzIHN0b3JhZ2UgYXMgYSB0b3RhbCBudW1iZXIgb2YgcGViaWJ5dGVzLlxuICAgKi9cbiAgcHVibGljIHRvUGViaWJ5dGVzKG9wdHM6IFNpemVDb252ZXJzaW9uT3B0aW9ucyA9IHt9KTogbnVtYmVyIHtcbiAgICByZXR1cm4gY29udmVydCh0aGlzLmFtb3VudCwgdGhpcy51bml0LCBTdG9yYWdlVW5pdC5QZWJpYnl0ZXMsIG9wdHMpO1xuICB9XG59XG5cbi8qKlxuICogUm91bmRpbmcgYmVoYXZpb3VyIHdoZW4gY29udmVydGluZyBiZXR3ZWVuIHVuaXRzIG9mIGBTaXplYC5cbiAqL1xuZXhwb3J0IGVudW0gU2l6ZVJvdW5kaW5nQmVoYXZpb3Ige1xuICAvKiogRmFpbCB0aGUgY29udmVyc2lvbiBpZiB0aGUgcmVzdWx0IGlzIG5vdCBhbiBpbnRlZ2VyLiAqL1xuICBGQUlMLFxuICAvKiogSWYgdGhlIHJlc3VsdCBpcyBub3QgYW4gaW50ZWdlciwgcm91bmQgaXQgdG8gdGhlIGNsb3Nlc3QgaW50ZWdlciBsZXNzIHRoYW4gdGhlIHJlc3VsdCAqL1xuICBGTE9PUixcbiAgLyoqIERvbid0IHJvdW5kLiBSZXR1cm4gZXZlbiBpZiB0aGUgcmVzdWx0IGlzIGEgZnJhY3Rpb24uICovXG4gIE5PTkUsXG5cbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBob3cgdG8gY29udmVydCB0aW1lIHRvIGEgZGlmZmVyZW50IHVuaXQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2l6ZUNvbnZlcnNpb25PcHRpb25zIHtcbiAgLyoqXG4gICAqIEhvdyBjb252ZXJzaW9ucyBzaG91bGQgYmVoYXZlIHdoZW4gaXQgZW5jb3VudGVycyBhIG5vbi1pbnRlZ2VyIHJlc3VsdFxuICAgKiBAZGVmYXVsdCBTaXplUm91bmRpbmdCZWhhdmlvci5GQUlMXG4gICAqL1xuICByZWFkb25seSByb3VuZGluZz86IFNpemVSb3VuZGluZ0JlaGF2aW9yO1xufVxuXG5jbGFzcyBTdG9yYWdlVW5pdCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgS2liaWJ5dGVzID0gbmV3IFN0b3JhZ2VVbml0KCdraWJpYnl0ZXMnLCAxKTtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBNZWJpYnl0ZXMgPSBuZXcgU3RvcmFnZVVuaXQoJ21lYmlieXRlcycsIDEwMjQpO1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdpYmlieXRlcyA9IG5ldyBTdG9yYWdlVW5pdCgnZ2liaWJ5dGVzJywgMTAyNCAqIDEwMjQpO1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFRlYmlieXRlcyA9IG5ldyBTdG9yYWdlVW5pdCgndGViaWJ5dGVzJywgMTAyNCAqIDEwMjQgKiAxMDI0KTtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBQZWJpYnl0ZXMgPSBuZXcgU3RvcmFnZVVuaXQoJ3BlYmlieXRlcycsIDEwMjQgKiAxMDI0ICogMTAyNCAqIDEwMjQpO1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGxhYmVsOiBzdHJpbmcsIHB1YmxpYyByZWFkb25seSBpbktpYmlCeXRlczogbnVtYmVyKSB7XG4gICAgLy8gTUFYX1NBRkVfSU5URUdFUiBpcyAyXjUzLCBzbyBieSByZXByZXNlbnRpbmcgc3RvcmFnZSBpbiBraWJpYnl0ZXMsXG4gICAgLy8gdGhlIGhpZ2hlc3Qgc3RvcmFnZSB3ZSBjYW4gcmVwcmVzZW50IGlzIDggZXhiaWJ5dGVzLlxuICB9XG5cbiAgcHVibGljIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmxhYmVsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnQoYW1vdW50OiBudW1iZXIsIGZyb21Vbml0OiBTdG9yYWdlVW5pdCwgdG9Vbml0OiBTdG9yYWdlVW5pdCwgb3B0aW9uczogU2l6ZUNvbnZlcnNpb25PcHRpb25zID0ge30pIHtcbiAgY29uc3Qgcm91bmRpbmcgPSBvcHRpb25zLnJvdW5kaW5nID8/IFNpemVSb3VuZGluZ0JlaGF2aW9yLkZBSUw7XG4gIGlmIChmcm9tVW5pdC5pbktpYmlCeXRlcyA9PT0gdG9Vbml0LmluS2liaUJ5dGVzKSB7IHJldHVybiBhbW91bnQ7IH1cblxuICBjb25zdCBtdWx0aXBsaWVyID0gZnJvbVVuaXQuaW5LaWJpQnl0ZXMgLyB0b1VuaXQuaW5LaWJpQnl0ZXM7XG4gIGNvbnN0IHZhbHVlID0gYW1vdW50ICogbXVsdGlwbGllcjtcbiAgc3dpdGNoIChyb3VuZGluZykge1xuICAgIGNhc2UgU2l6ZVJvdW5kaW5nQmVoYXZpb3IuTk9ORTpcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjYXNlIFNpemVSb3VuZGluZ0JlaGF2aW9yLkZMT09SOlxuICAgICAgcmV0dXJuIE1hdGguZmxvb3IodmFsdWUpO1xuICAgIGRlZmF1bHQ6XG4gICAgY2FzZSBTaXplUm91bmRpbmdCZWhhdmlvci5GQUlMOlxuICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCcke2Ftb3VudH0gJHtmcm9tVW5pdH0nIGNhbm5vdCBiZSBjb252ZXJ0ZWQgaW50byBhIHdob2xlIG51bWJlciBvZiAke3RvVW5pdH0uYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn0iXX0=

/***/ }),

/***/ 8101:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Testing = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const fs = __nccwpck_require__(7147);
const os = __nccwpck_require__(2037);
const path = __nccwpck_require__(1017);
const app_1 = __nccwpck_require__(4333);
const chart_1 = __nccwpck_require__(2297);
/**
 * Testing utilities for cdk8s applications.
 */
class Testing {
    /* istanbul ignore next */
    constructor() {
        return;
    }
    /**
     * Returns an app for testing with the following properties:
     * - Output directory is a temp dir.
     */
    static app(props) {
        var _b;
        let outdir;
        if (props) {
            outdir = (_b = props.outdir) !== null && _b !== void 0 ? _b : fs.mkdtempSync(path.join(os.tmpdir(), 'cdk8s.outdir.'));
        }
        else {
            outdir = fs.mkdtempSync(path.join(os.tmpdir(), 'cdk8s.outdir.'));
        }
        return new app_1.App({ outdir, ...props });
    }
    /**
     * @returns a Chart that can be used for tests
     */
    static chart() {
        return new chart_1.Chart(this.app(), 'test');
    }
    /**
     * Returns the Kubernetes manifest synthesized from this chart.
     */
    static synth(chart) {
        return chart.toJson();
    }
}
exports.Testing = Testing;
_a = JSII_RTTI_SYMBOL_1;
Testing[_a] = { fqn: "cdk8s.Testing", version: "2.3.11" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdGluZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy90ZXN0aW5nLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0IsK0JBQXNDO0FBQ3RDLG1DQUFnQztBQUVoQzs7R0FFRztBQUNILE1BQWEsT0FBTztJQTZCbEIsMEJBQTBCO0lBQzFCO1FBQ0UsT0FBTztJQUNULENBQUM7SUEvQkQ7OztPQUdHO0lBQ0ksTUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFnQjs7UUFDaEMsSUFBSSxNQUFjLENBQUM7UUFDbkIsSUFBSSxLQUFLLEVBQUU7WUFDVCxNQUFNLFNBQUcsS0FBSyxDQUFDLE1BQU0sbUNBQUksRUFBRSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxlQUFlLENBQUMsQ0FBQyxDQUFDO1NBQ2xGO2FBQU07WUFDTCxNQUFNLEdBQUcsRUFBRSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxlQUFlLENBQUMsQ0FBQyxDQUFDO1NBQ2xFO1FBQ0QsT0FBTyxJQUFJLFNBQUcsQ0FBQyxFQUFFLE1BQU0sRUFBRSxHQUFHLEtBQUssRUFBRSxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVEOztPQUVHO0lBQ0ksTUFBTSxDQUFDLEtBQUs7UUFDakIsT0FBTyxJQUFJLGFBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVEOztPQUVHO0lBQ0ksTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFZO1FBQzlCLE9BQU8sS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ3hCLENBQUM7O0FBM0JILDBCQWlDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIG9zIGZyb20gJ29zJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBBcHAsIEFwcFByb3BzIH0gZnJvbSAnLi9hcHAnO1xuaW1wb3J0IHsgQ2hhcnQgfSBmcm9tICcuL2NoYXJ0JztcblxuLyoqXG4gKiBUZXN0aW5nIHV0aWxpdGllcyBmb3IgY2RrOHMgYXBwbGljYXRpb25zLlxuICovXG5leHBvcnQgY2xhc3MgVGVzdGluZyB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFwcCBmb3IgdGVzdGluZyB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogLSBPdXRwdXQgZGlyZWN0b3J5IGlzIGEgdGVtcCBkaXIuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFwcChwcm9wcz86IEFwcFByb3BzKSB7XG4gICAgbGV0IG91dGRpcjogc3RyaW5nO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgb3V0ZGlyID0gcHJvcHMub3V0ZGlyID8/IGZzLm1rZHRlbXBTeW5jKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ2NkazhzLm91dGRpci4nKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dGRpciA9IGZzLm1rZHRlbXBTeW5jKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ2NkazhzLm91dGRpci4nKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXBwKHsgb3V0ZGlyLCAuLi5wcm9wcyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBhIENoYXJ0IHRoYXQgY2FuIGJlIHVzZWQgZm9yIHRlc3RzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNoYXJ0KCkge1xuICAgIHJldHVybiBuZXcgQ2hhcnQodGhpcy5hcHAoKSwgJ3Rlc3QnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBLdWJlcm5ldGVzIG1hbmlmZXN0IHN5bnRoZXNpemVkIGZyb20gdGhpcyBjaGFydC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgc3ludGgoY2hhcnQ6IENoYXJ0KTogYW55W10ge1xuICAgIHJldHVybiBjaGFydC50b0pzb24oKTtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XG4gICAgcmV0dXJuO1xuICB9XG59XG4iXX0=

/***/ }),

/***/ 5096:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Yaml = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const child_process_1 = __nccwpck_require__(2081);
const fs = __nccwpck_require__(7147);
const os = __nccwpck_require__(2037);
const path = __nccwpck_require__(1017);
const YAML = __nccwpck_require__(2569);
const MAX_DOWNLOAD_BUFFER = 10 * 1024 * 1024;
// Set default YAML schema to 1.1. This ensures saved YAML is backward compatible with other parsers, such as PyYAML
// It also ensures that octal numbers in the form `0775` will be parsed
// correctly on YAML load. (see https://github.com/eemeli/yaml/issues/205)
YAML.defaultOptions.version = '1.1';
/**
 * YAML utilities.
 */
class Yaml {
    /**
     * Utility class.
     */
    constructor() {
        return;
    }
    /**
     * @deprecated use `stringify(doc[, doc, ...])`
     */
    static formatObjects(docs) {
        return this.stringify(...docs);
    }
    /**
     * Saves a set of objects as a multi-document YAML file.
     * @param filePath The output path
     * @param docs The set of objects
     */
    static save(filePath, docs) {
        const data = this.stringify(...docs);
        fs.writeFileSync(filePath, data, { encoding: 'utf8' });
    }
    /**
     * Stringify a document (or multiple documents) into YAML
     *
     * We convert undefined values to null, but ignore any documents that are
     * undefined.
     *
     * @param docs A set of objects to convert to YAML
     * @returns a YAML string. Multiple docs are separated by `---`.
     */
    static stringify(...docs) {
        return docs.map(r => r === undefined ? '\n' : YAML.stringify(r, { keepUndefined: true, lineWidth: 0 })).join('---\n');
    }
    /**
     * Saves a set of YAML documents into a temp file (in /tmp)
     *
     * @returns the path to the temporary file
     * @param docs the set of documents to save
     */
    static tmp(docs) {
        const tmpdir = fs.mkdtempSync(path.join(os.tmpdir(), 'cdk8s-'));
        const filePath = path.join(tmpdir, 'temp.yaml');
        Yaml.save(filePath, docs);
        return filePath;
    }
    /**
     * Downloads a set of YAML documents (k8s manifest for example) from a URL or
     * a file and returns them as javascript objects.
     *
     * Empty documents are filtered out.
     *
     * @param urlOrFile a URL of a file path to load from
     * @returns an array of objects, each represents a document inside the YAML
     */
    static load(urlOrFile) {
        const body = loadurl(urlOrFile);
        const objects = YAML.parseAllDocuments(body);
        const result = new Array();
        for (const obj of objects.map(x => x.toJSON())) {
            // skip empty documents
            if (obj === undefined) {
                continue;
            }
            if (obj === null) {
                continue;
            }
            if (Array.isArray(obj) && obj.length === 0) {
                continue;
            }
            if (typeof (obj) === 'object' && Object.keys(obj).length === 0) {
                continue;
            }
            result.push(obj);
        }
        return result;
    }
}
exports.Yaml = Yaml;
_a = JSII_RTTI_SYMBOL_1;
Yaml[_a] = { fqn: "cdk8s.Yaml", version: "2.3.11" };
/**
 * Loads a url (or file) and returns the contents.
 * This method spawns a child process in order to perform an http call synchronously.
 */
function loadurl(url) {
    const script = __nccwpck_require__.ab + "_loadurl.js";
    return child_process_1.execFileSync(process.execPath, [__nccwpck_require__.ab + "_loadurl.js", url], {
        encoding: 'utf-8',
        maxBuffer: MAX_DOWNLOAD_BUFFER,
    }).toString();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWFtbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy95YW1sLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsaURBQTZDO0FBQzdDLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUU3QixNQUFNLG1CQUFtQixHQUFHLEVBQUUsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBRTdDLG9IQUFvSDtBQUNwSCx1RUFBdUU7QUFDdkUsMEVBQTBFO0FBQzFFLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztBQUVwQzs7R0FFRztBQUNILE1BQWEsSUFBSTtJQTBFZjs7T0FFRztJQUNIO1FBQ0UsT0FBTztJQUNULENBQUM7SUE5RUQ7O09BRUc7SUFDSSxNQUFNLENBQUMsYUFBYSxDQUFDLElBQVc7UUFDckMsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQWdCLEVBQUUsSUFBVztRQUM5QyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7UUFDckMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7SUFDekQsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0ksTUFBTSxDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQVc7UUFDcEMsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUNiLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLGFBQWEsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQ3ZGLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ2xCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBVztRQUMzQixNQUFNLE1BQU0sR0FBRyxFQUFFLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDaEUsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFDaEQsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDMUIsT0FBTyxRQUFRLENBQUM7SUFDbEIsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0ksTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFpQjtRQUNsQyxNQUFNLElBQUksR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFaEMsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzdDLE1BQU0sTUFBTSxHQUFHLElBQUksS0FBSyxFQUFPLENBQUM7UUFFaEMsS0FBSyxNQUFNLEdBQUcsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUU7WUFDOUMsdUJBQXVCO1lBQ3ZCLElBQUksR0FBRyxLQUFLLFNBQVMsRUFBRTtnQkFBRSxTQUFTO2FBQUU7WUFDcEMsSUFBSSxHQUFHLEtBQUssSUFBSSxFQUFFO2dCQUFFLFNBQVM7YUFBRTtZQUMvQixJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7Z0JBQUUsU0FBUzthQUFFO1lBQ3pELElBQUksT0FBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLFFBQVEsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7Z0JBQUUsU0FBUzthQUFFO1lBRTVFLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDbEI7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDOztBQXhFSCxvQkFnRkM7OztBQUVEOzs7R0FHRztBQUNILFNBQVMsT0FBTyxDQUFDLEdBQVc7SUFDMUIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsYUFBYSxDQUFDLENBQUM7SUFDbkQsT0FBTyw0QkFBWSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEVBQUU7UUFDbkQsUUFBUSxFQUFFLE9BQU87UUFDakIsU0FBUyxFQUFFLG1CQUFtQjtLQUMvQixDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7QUFDaEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4ZWNGaWxlU3luYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgb3MgZnJvbSAnb3MnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIFlBTUwgZnJvbSAneWFtbCc7XG5cbmNvbnN0IE1BWF9ET1dOTE9BRF9CVUZGRVIgPSAxMCAqIDEwMjQgKiAxMDI0O1xuXG4vLyBTZXQgZGVmYXVsdCBZQU1MIHNjaGVtYSB0byAxLjEuIFRoaXMgZW5zdXJlcyBzYXZlZCBZQU1MIGlzIGJhY2t3YXJkIGNvbXBhdGlibGUgd2l0aCBvdGhlciBwYXJzZXJzLCBzdWNoIGFzIFB5WUFNTFxuLy8gSXQgYWxzbyBlbnN1cmVzIHRoYXQgb2N0YWwgbnVtYmVycyBpbiB0aGUgZm9ybSBgMDc3NWAgd2lsbCBiZSBwYXJzZWRcbi8vIGNvcnJlY3RseSBvbiBZQU1MIGxvYWQuIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VlbWVsaS95YW1sL2lzc3Vlcy8yMDUpXG5ZQU1MLmRlZmF1bHRPcHRpb25zLnZlcnNpb24gPSAnMS4xJztcblxuLyoqXG4gKiBZQU1MIHV0aWxpdGllcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFlhbWwge1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBzdHJpbmdpZnkoZG9jWywgZG9jLCAuLi5dKWBcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZm9ybWF0T2JqZWN0cyhkb2NzOiBhbnlbXSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KC4uLmRvY3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhdmVzIGEgc2V0IG9mIG9iamVjdHMgYXMgYSBtdWx0aS1kb2N1bWVudCBZQU1MIGZpbGUuXG4gICAqIEBwYXJhbSBmaWxlUGF0aCBUaGUgb3V0cHV0IHBhdGhcbiAgICogQHBhcmFtIGRvY3MgVGhlIHNldCBvZiBvYmplY3RzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHNhdmUoZmlsZVBhdGg6IHN0cmluZywgZG9jczogYW55W10pIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5zdHJpbmdpZnkoLi4uZG9jcyk7XG4gICAgZnMud3JpdGVGaWxlU3luYyhmaWxlUGF0aCwgZGF0YSwgeyBlbmNvZGluZzogJ3V0ZjgnIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0cmluZ2lmeSBhIGRvY3VtZW50IChvciBtdWx0aXBsZSBkb2N1bWVudHMpIGludG8gWUFNTFxuICAgKlxuICAgKiBXZSBjb252ZXJ0IHVuZGVmaW5lZCB2YWx1ZXMgdG8gbnVsbCwgYnV0IGlnbm9yZSBhbnkgZG9jdW1lbnRzIHRoYXQgYXJlXG4gICAqIHVuZGVmaW5lZC5cbiAgICpcbiAgICogQHBhcmFtIGRvY3MgQSBzZXQgb2Ygb2JqZWN0cyB0byBjb252ZXJ0IHRvIFlBTUxcbiAgICogQHJldHVybnMgYSBZQU1MIHN0cmluZy4gTXVsdGlwbGUgZG9jcyBhcmUgc2VwYXJhdGVkIGJ5IGAtLS1gLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBzdHJpbmdpZnkoLi4uZG9jczogYW55W10pIHtcbiAgICByZXR1cm4gZG9jcy5tYXAoXG4gICAgICByID0+IHIgPT09IHVuZGVmaW5lZCA/ICdcXG4nIDogWUFNTC5zdHJpbmdpZnkociwgeyBrZWVwVW5kZWZpbmVkOiB0cnVlLCBsaW5lV2lkdGg6IDAgfSksXG4gICAgKS5qb2luKCctLS1cXG4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlcyBhIHNldCBvZiBZQU1MIGRvY3VtZW50cyBpbnRvIGEgdGVtcCBmaWxlIChpbiAvdG1wKVxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgcGF0aCB0byB0aGUgdGVtcG9yYXJ5IGZpbGVcbiAgICogQHBhcmFtIGRvY3MgdGhlIHNldCBvZiBkb2N1bWVudHMgdG8gc2F2ZVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyB0bXAoZG9jczogYW55W10pOiBzdHJpbmcge1xuICAgIGNvbnN0IHRtcGRpciA9IGZzLm1rZHRlbXBTeW5jKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ2NkazhzLScpKTtcbiAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGguam9pbih0bXBkaXIsICd0ZW1wLnlhbWwnKTtcbiAgICBZYW1sLnNhdmUoZmlsZVBhdGgsIGRvY3MpO1xuICAgIHJldHVybiBmaWxlUGF0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEb3dubG9hZHMgYSBzZXQgb2YgWUFNTCBkb2N1bWVudHMgKGs4cyBtYW5pZmVzdCBmb3IgZXhhbXBsZSkgZnJvbSBhIFVSTCBvclxuICAgKiBhIGZpbGUgYW5kIHJldHVybnMgdGhlbSBhcyBqYXZhc2NyaXB0IG9iamVjdHMuXG4gICAqXG4gICAqIEVtcHR5IGRvY3VtZW50cyBhcmUgZmlsdGVyZWQgb3V0LlxuICAgKlxuICAgKiBAcGFyYW0gdXJsT3JGaWxlIGEgVVJMIG9mIGEgZmlsZSBwYXRoIHRvIGxvYWQgZnJvbVxuICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzLCBlYWNoIHJlcHJlc2VudHMgYSBkb2N1bWVudCBpbnNpZGUgdGhlIFlBTUxcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbG9hZCh1cmxPckZpbGU6IHN0cmluZyk6IGFueVtdIHtcbiAgICBjb25zdCBib2R5ID0gbG9hZHVybCh1cmxPckZpbGUpO1xuXG4gICAgY29uc3Qgb2JqZWN0cyA9IFlBTUwucGFyc2VBbGxEb2N1bWVudHMoYm9keSk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5PGFueT4oKTtcblxuICAgIGZvciAoY29uc3Qgb2JqIG9mIG9iamVjdHMubWFwKHggPT4geC50b0pTT04oKSkpIHtcbiAgICAgIC8vIHNraXAgZW1wdHkgZG9jdW1lbnRzXG4gICAgICBpZiAob2JqID09PSB1bmRlZmluZWQpIHsgY29udGludWU7IH1cbiAgICAgIGlmIChvYmogPT09IG51bGwpIHsgY29udGludWU7IH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikgJiYgb2JqLmxlbmd0aCA9PT0gMCkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKHR5cGVvZihvYmopID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMCkgeyBjb250aW51ZTsgfVxuXG4gICAgICByZXN1bHQucHVzaChvYmopO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0eSBjbGFzcy5cbiAgICovXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XG4gICAgcmV0dXJuO1xuICB9XG59XG5cbi8qKlxuICogTG9hZHMgYSB1cmwgKG9yIGZpbGUpIGFuZCByZXR1cm5zIHRoZSBjb250ZW50cy5cbiAqIFRoaXMgbWV0aG9kIHNwYXducyBhIGNoaWxkIHByb2Nlc3MgaW4gb3JkZXIgdG8gcGVyZm9ybSBhbiBodHRwIGNhbGwgc3luY2hyb25vdXNseS5cbiAqL1xuZnVuY3Rpb24gbG9hZHVybCh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHNjcmlwdCA9IHBhdGguam9pbihfX2Rpcm5hbWUsICdfbG9hZHVybC5qcycpO1xuICByZXR1cm4gZXhlY0ZpbGVTeW5jKHByb2Nlc3MuZXhlY1BhdGgsIFtzY3JpcHQsIHVybF0sIHtcbiAgICBlbmNvZGluZzogJ3V0Zi04JyxcbiAgICBtYXhCdWZmZXI6IE1BWF9ET1dOTE9BRF9CVUZGRVIsXG4gIH0pLnRvU3RyaW5nKCk7XG59XG4iXX0=

/***/ }),

/***/ 8551:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
var areEquals = __nccwpck_require__(1194);
var helpers_1 = __nccwpck_require__(5460);
exports.JsonPatchError = helpers_1.PatchError;
exports.deepClone = helpers_1._deepClone;
/* We use a Javascript hash to store each
 function. Each hash entry (property) uses
 the operation identifiers specified in rfc6902.
 In this way, we can map each patch operation
 to its dedicated function in efficient way.
 */
/* The operations applicable to an object */
var objOps = {
    add: function (obj, key, document) {
        obj[key] = this.value;
        return { newDocument: document };
    },
    remove: function (obj, key, document) {
        var removed = obj[key];
        delete obj[key];
        return { newDocument: document, removed: removed };
    },
    replace: function (obj, key, document) {
        var removed = obj[key];
        obj[key] = this.value;
        return { newDocument: document, removed: removed };
    },
    move: function (obj, key, document) {
        /* in case move target overwrites an existing value,
        return the removed value, this can be taxing performance-wise,
        and is potentially unneeded */
        var removed = getValueByPointer(document, this.path);
        if (removed) {
            removed = helpers_1._deepClone(removed);
        }
        var originalValue = applyOperation(document, { op: "remove", path: this.from }).removed;
        applyOperation(document, { op: "add", path: this.path, value: originalValue });
        return { newDocument: document, removed: removed };
    },
    copy: function (obj, key, document) {
        var valueToCopy = getValueByPointer(document, this.from);
        // enforce copy by value so further operations don't affect source (see issue #177)
        applyOperation(document, { op: "add", path: this.path, value: helpers_1._deepClone(valueToCopy) });
        return { newDocument: document };
    },
    test: function (obj, key, document) {
        return { newDocument: document, test: areEquals(obj[key], this.value) };
    },
    _get: function (obj, key, document) {
        this.value = obj[key];
        return { newDocument: document };
    }
};
/* The operations applicable to an array. Many are the same as for the object */
var arrOps = {
    add: function (arr, i, document) {
        if (helpers_1.isInteger(i)) {
            arr.splice(i, 0, this.value);
        }
        else { // array props
            arr[i] = this.value;
        }
        // this may be needed when using '-' in an array
        return { newDocument: document, index: i };
    },
    remove: function (arr, i, document) {
        var removedList = arr.splice(i, 1);
        return { newDocument: document, removed: removedList[0] };
    },
    replace: function (arr, i, document) {
        var removed = arr[i];
        arr[i] = this.value;
        return { newDocument: document, removed: removed };
    },
    move: objOps.move,
    copy: objOps.copy,
    test: objOps.test,
    _get: objOps._get
};
/**
 * Retrieves a value from a JSON document by a JSON pointer.
 * Returns the value.
 *
 * @param document The document to get the value from
 * @param pointer an escaped JSON pointer
 * @return The retrieved value
 */
function getValueByPointer(document, pointer) {
    if (pointer == '') {
        return document;
    }
    var getOriginalDestination = { op: "_get", path: pointer };
    applyOperation(document, getOriginalDestination);
    return getOriginalDestination.value;
}
exports.getValueByPointer = getValueByPointer;
/**
 * Apply a single JSON Patch Operation on a JSON document.
 * Returns the {newDocument, result} of the operation.
 * It modifies the `document` and `operation` objects - it gets the values by reference.
 * If you would like to avoid touching your values, clone them:
 * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.
 *
 * @param document The document to patch
 * @param operation The operation to apply
 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
 * @param mutateDocument Whether to mutate the original document or clone it before applying
 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
 * @return `{newDocument, result}` after the operation
 */
function applyOperation(document, operation, validateOperation, mutateDocument, banPrototypeModifications, index) {
    if (validateOperation === void 0) { validateOperation = false; }
    if (mutateDocument === void 0) { mutateDocument = true; }
    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }
    if (index === void 0) { index = 0; }
    if (validateOperation) {
        if (typeof validateOperation == 'function') {
            validateOperation(operation, 0, document, operation.path);
        }
        else {
            validator(operation, 0);
        }
    }
    /* ROOT OPERATIONS */
    if (operation.path === "") {
        var returnValue = { newDocument: document };
        if (operation.op === 'add') {
            returnValue.newDocument = operation.value;
            return returnValue;
        }
        else if (operation.op === 'replace') {
            returnValue.newDocument = operation.value;
            returnValue.removed = document; //document we removed
            return returnValue;
        }
        else if (operation.op === 'move' || operation.op === 'copy') { // it's a move or copy to root
            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field
            if (operation.op === 'move') { // report removed item
                returnValue.removed = document;
            }
            return returnValue;
        }
        else if (operation.op === 'test') {
            returnValue.test = areEquals(document, operation.value);
            if (returnValue.test === false) {
                throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
            }
            returnValue.newDocument = document;
            return returnValue;
        }
        else if (operation.op === 'remove') { // a remove on root
            returnValue.removed = document;
            returnValue.newDocument = null;
            return returnValue;
        }
        else if (operation.op === '_get') {
            operation.value = document;
            return returnValue;
        }
        else { /* bad operation */
            if (validateOperation) {
                throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
            }
            else {
                return returnValue;
            }
        }
    } /* END ROOT OPERATIONS */
    else {
        if (!mutateDocument) {
            document = helpers_1._deepClone(document);
        }
        var path = operation.path || "";
        var keys = path.split('/');
        var obj = document;
        var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift
        var len = keys.length;
        var existingPathFragment = undefined;
        var key = void 0;
        var validateFunction = void 0;
        if (typeof validateOperation == 'function') {
            validateFunction = validateOperation;
        }
        else {
            validateFunction = validator;
        }
        while (true) {
            key = keys[t];
            if (banPrototypeModifications && key == '__proto__') {
                throw new TypeError('JSON-Patch: modifying `__proto__` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README');
            }
            if (validateOperation) {
                if (existingPathFragment === undefined) {
                    if (obj[key] === undefined) {
                        existingPathFragment = keys.slice(0, t).join('/');
                    }
                    else if (t == len - 1) {
                        existingPathFragment = operation.path;
                    }
                    if (existingPathFragment !== undefined) {
                        validateFunction(operation, 0, document, existingPathFragment);
                    }
                }
            }
            t++;
            if (Array.isArray(obj)) {
                if (key === '-') {
                    key = obj.length;
                }
                else {
                    if (validateOperation && !helpers_1.isInteger(key)) {
                        throw new exports.JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document);
                    } // only parse key when it's an integer for `arr.prop` to work
                    else if (helpers_1.isInteger(key)) {
                        key = ~~key;
                    }
                }
                if (t >= len) {
                    if (validateOperation && operation.op === "add" && key > obj.length) {
                        throw new exports.JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document);
                    }
                    var returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch
                    if (returnValue.test === false) {
                        throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
                    }
                    return returnValue;
                }
            }
            else {
                if (key && key.indexOf('~') != -1) {
                    key = helpers_1.unescapePathComponent(key);
                }
                if (t >= len) {
                    var returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch
                    if (returnValue.test === false) {
                        throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
                    }
                    return returnValue;
                }
            }
            obj = obj[key];
        }
    }
}
exports.applyOperation = applyOperation;
/**
 * Apply a full JSON Patch array on a JSON document.
 * Returns the {newDocument, result} of the patch.
 * It modifies the `document` object and `patch` - it gets the values by reference.
 * If you would like to avoid touching your values, clone them:
 * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.
 *
 * @param document The document to patch
 * @param patch The patch to apply
 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
 * @param mutateDocument Whether to mutate the original document or clone it before applying
 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
 * @return An array of `{newDocument, result}` after the patch
 */
function applyPatch(document, patch, validateOperation, mutateDocument, banPrototypeModifications) {
    if (mutateDocument === void 0) { mutateDocument = true; }
    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }
    if (validateOperation) {
        if (!Array.isArray(patch)) {
            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
        }
    }
    if (!mutateDocument) {
        document = helpers_1._deepClone(document);
    }
    var results = new Array(patch.length);
    for (var i = 0, length_1 = patch.length; i < length_1; i++) {
        // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`
        results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);
        document = results[i].newDocument; // in case root was replaced
    }
    results.newDocument = document;
    return results;
}
exports.applyPatch = applyPatch;
/**
 * Apply a single JSON Patch Operation on a JSON document.
 * Returns the updated document.
 * Suitable as a reducer.
 *
 * @param document The document to patch
 * @param operation The operation to apply
 * @return The updated document
 */
function applyReducer(document, operation, index) {
    var operationResult = applyOperation(document, operation);
    if (operationResult.test === false) { // failed test
        throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
    }
    return operationResult.newDocument;
}
exports.applyReducer = applyReducer;
/**
 * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.
 * @param {object} operation - operation object (patch)
 * @param {number} index - index of operation in the sequence
 * @param {object} [document] - object where the operation is supposed to be applied
 * @param {string} [existingPathFragment] - comes along with `document`
 */
function validator(operation, index, document, existingPathFragment) {
    if (typeof operation !== 'object' || operation === null || Array.isArray(operation)) {
        throw new exports.JsonPatchError('Operation is not an object', 'OPERATION_NOT_AN_OBJECT', index, operation, document);
    }
    else if (!objOps[operation.op]) {
        throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
    }
    else if (typeof operation.path !== 'string') {
        throw new exports.JsonPatchError('Operation `path` property is not a string', 'OPERATION_PATH_INVALID', index, operation, document);
    }
    else if (operation.path.indexOf('/') !== 0 && operation.path.length > 0) {
        // paths that aren't empty string should start with "/"
        throw new exports.JsonPatchError('Operation `path` property must start with "/"', 'OPERATION_PATH_INVALID', index, operation, document);
    }
    else if ((operation.op === 'move' || operation.op === 'copy') && typeof operation.from !== 'string') {
        throw new exports.JsonPatchError('Operation `from` property is not present (applicable in `move` and `copy` operations)', 'OPERATION_FROM_REQUIRED', index, operation, document);
    }
    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && operation.value === undefined) {
        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_REQUIRED', index, operation, document);
    }
    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && helpers_1.hasUndefined(operation.value)) {
        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED', index, operation, document);
    }
    else if (document) {
        if (operation.op == "add") {
            var pathLen = operation.path.split("/").length;
            var existingPathLen = existingPathFragment.split("/").length;
            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
                throw new exports.JsonPatchError('Cannot perform an `add` operation at the desired path', 'OPERATION_PATH_CANNOT_ADD', index, operation, document);
            }
        }
        else if (operation.op === 'replace' || operation.op === 'remove' || operation.op === '_get') {
            if (operation.path !== existingPathFragment) {
                throw new exports.JsonPatchError('Cannot perform the operation at a path that does not exist', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);
            }
        }
        else if (operation.op === 'move' || operation.op === 'copy') {
            var existingValue = { op: "_get", path: operation.from, value: undefined };
            var error = validate([existingValue], document);
            if (error && error.name === 'OPERATION_PATH_UNRESOLVABLE') {
                throw new exports.JsonPatchError('Cannot perform the operation from a path that does not exist', 'OPERATION_FROM_UNRESOLVABLE', index, operation, document);
            }
        }
    }
}
exports.validator = validator;
/**
 * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.
 * If error is encountered, returns a JsonPatchError object
 * @param sequence
 * @param document
 * @returns {JsonPatchError|undefined}
 */
function validate(sequence, document, externalValidator) {
    try {
        if (!Array.isArray(sequence)) {
            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
        }
        if (document) {
            //clone document and sequence so that we can safely try applying operations
            applyPatch(helpers_1._deepClone(document), helpers_1._deepClone(sequence), externalValidator || true);
        }
        else {
            externalValidator = externalValidator || validator;
            for (var i = 0; i < sequence.length; i++) {
                externalValidator(sequence[i], i, document, undefined);
            }
        }
    }
    catch (e) {
        if (e instanceof exports.JsonPatchError) {
            return e;
        }
        else {
            throw e;
        }
    }
}
exports.validate = validate;
/**
 * Default export for backwards compat
 */
exports["default"] = {
    JsonPatchError: exports.JsonPatchError,
    deepClone: exports.deepClone,
    getValueByPointer: getValueByPointer,
    applyOperation: applyOperation,
    applyPatch: applyPatch,
    applyReducer: applyReducer,
    validator: validator,
    validate: validate
};


/***/ }),

/***/ 3279:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017 Joachim Wester
 * MIT license
 */
var helpers_1 = __nccwpck_require__(5460);
var core_1 = __nccwpck_require__(8551);
/* export all core functions and types */
var core_2 = __nccwpck_require__(8551);
exports.applyOperation = core_2.applyOperation;
exports.applyPatch = core_2.applyPatch;
exports.applyReducer = core_2.applyReducer;
exports.getValueByPointer = core_2.getValueByPointer;
exports.validate = core_2.validate;
exports.validator = core_2.validator;
/* export some helpers */
var helpers_2 = __nccwpck_require__(5460);
exports.JsonPatchError = helpers_2.PatchError;
exports.deepClone = helpers_2._deepClone;
exports.escapePathComponent = helpers_2.escapePathComponent;
exports.unescapePathComponent = helpers_2.unescapePathComponent;
var beforeDict = new WeakMap();
var Mirror = /** @class */ (function () {
    function Mirror(obj) {
        this.observers = new Map();
        this.obj = obj;
    }
    return Mirror;
}());
var ObserverInfo = /** @class */ (function () {
    function ObserverInfo(callback, observer) {
        this.callback = callback;
        this.observer = observer;
    }
    return ObserverInfo;
}());
function getMirror(obj) {
    return beforeDict.get(obj);
}
function getObserverFromMirror(mirror, callback) {
    return mirror.observers.get(callback);
}
function removeObserverFromMirror(mirror, observer) {
    mirror.observers.delete(observer.callback);
}
/**
 * Detach an observer from an object
 */
function unobserve(root, observer) {
    observer.unobserve();
}
exports.unobserve = unobserve;
/**
 * Observes changes made to an object, which can then be retrieved using generate
 */
function observe(obj, callback) {
    var patches = [];
    var observer;
    var mirror = getMirror(obj);
    if (!mirror) {
        mirror = new Mirror(obj);
        beforeDict.set(obj, mirror);
    }
    else {
        var observerInfo = getObserverFromMirror(mirror, callback);
        observer = observerInfo && observerInfo.observer;
    }
    if (observer) {
        return observer;
    }
    observer = {};
    mirror.value = helpers_1._deepClone(obj);
    if (callback) {
        observer.callback = callback;
        observer.next = null;
        var dirtyCheck = function () {
            generate(observer);
        };
        var fastCheck = function () {
            clearTimeout(observer.next);
            observer.next = setTimeout(dirtyCheck);
        };
        if (typeof window !== 'undefined') { //not Node
            window.addEventListener('mouseup', fastCheck);
            window.addEventListener('keyup', fastCheck);
            window.addEventListener('mousedown', fastCheck);
            window.addEventListener('keydown', fastCheck);
            window.addEventListener('change', fastCheck);
        }
    }
    observer.patches = patches;
    observer.object = obj;
    observer.unobserve = function () {
        generate(observer);
        clearTimeout(observer.next);
        removeObserverFromMirror(mirror, observer);
        if (typeof window !== 'undefined') {
            window.removeEventListener('mouseup', fastCheck);
            window.removeEventListener('keyup', fastCheck);
            window.removeEventListener('mousedown', fastCheck);
            window.removeEventListener('keydown', fastCheck);
            window.removeEventListener('change', fastCheck);
        }
    };
    mirror.observers.set(callback, new ObserverInfo(callback, observer));
    return observer;
}
exports.observe = observe;
/**
 * Generate an array of patches from an observer
 */
function generate(observer, invertible) {
    if (invertible === void 0) { invertible = false; }
    var mirror = beforeDict.get(observer.object);
    _generate(mirror.value, observer.object, observer.patches, "", invertible);
    if (observer.patches.length) {
        core_1.applyPatch(mirror.value, observer.patches);
    }
    var temp = observer.patches;
    if (temp.length > 0) {
        observer.patches = [];
        if (observer.callback) {
            observer.callback(temp);
        }
    }
    return temp;
}
exports.generate = generate;
// Dirty check if obj is different from mirror, generate patches and update mirror
function _generate(mirror, obj, patches, path, invertible) {
    if (obj === mirror) {
        return;
    }
    if (typeof obj.toJSON === "function") {
        obj = obj.toJSON();
    }
    var newKeys = helpers_1._objectKeys(obj);
    var oldKeys = helpers_1._objectKeys(mirror);
    var changed = false;
    var deleted = false;
    //if ever "move" operation is implemented here, make sure this test runs OK: "should not generate the same patch twice (move)"
    for (var t = oldKeys.length - 1; t >= 0; t--) {
        var key = oldKeys[t];
        var oldVal = mirror[key];
        if (helpers_1.hasOwnProperty(obj, key) && !(obj[key] === undefined && oldVal !== undefined && Array.isArray(obj) === false)) {
            var newVal = obj[key];
            if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null) {
                _generate(oldVal, newVal, patches, path + "/" + helpers_1.escapePathComponent(key), invertible);
            }
            else {
                if (oldVal !== newVal) {
                    changed = true;
                    if (invertible) {
                        patches.push({ op: "test", path: path + "/" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(oldVal) });
                    }
                    patches.push({ op: "replace", path: path + "/" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(newVal) });
                }
            }
        }
        else if (Array.isArray(mirror) === Array.isArray(obj)) {
            if (invertible) {
                patches.push({ op: "test", path: path + "/" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(oldVal) });
            }
            patches.push({ op: "remove", path: path + "/" + helpers_1.escapePathComponent(key) });
            deleted = true; // property has been deleted
        }
        else {
            if (invertible) {
                patches.push({ op: "test", path: path, value: mirror });
            }
            patches.push({ op: "replace", path: path, value: obj });
            changed = true;
        }
    }
    if (!deleted && newKeys.length == oldKeys.length) {
        return;
    }
    for (var t = 0; t < newKeys.length; t++) {
        var key = newKeys[t];
        if (!helpers_1.hasOwnProperty(mirror, key) && obj[key] !== undefined) {
            patches.push({ op: "add", path: path + "/" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(obj[key]) });
        }
    }
}
/**
 * Create an array of patches from the differences in two objects
 */
function compare(tree1, tree2, invertible) {
    if (invertible === void 0) { invertible = false; }
    var patches = [];
    _generate(tree1, tree2, patches, '', invertible);
    return patches;
}
exports.compare = compare;
/**
 * Default export for backwards compat
 */
// import just to re-export as default
var core = __nccwpck_require__(8551);
var helpers_3 = __nccwpck_require__(5460);
exports["default"] = __assign({}, core, { 
    // duplex
    unobserve: unobserve,
    observe: observe,
    generate: generate,
    compare: compare,
    // helpers
    JsonPatchError: helpers_3.PatchError, deepClone: helpers_1._deepClone, escapePathComponent: helpers_1.escapePathComponent,
    unescapePathComponent: helpers_3.unescapePathComponent });


/***/ }),

/***/ 5460:
/***/ (function(__unused_webpack_module, exports) {

/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017 Joachim Wester
 * MIT license
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key) {
    return _hasOwnProperty.call(obj, key);
}
exports.hasOwnProperty = hasOwnProperty;
function _objectKeys(obj) {
    if (Array.isArray(obj)) {
        var keys = new Array(obj.length);
        for (var k = 0; k < keys.length; k++) {
            keys[k] = "" + k;
        }
        return keys;
    }
    if (Object.keys) {
        return Object.keys(obj);
    }
    var keys = [];
    for (var i in obj) {
        if (hasOwnProperty(obj, i)) {
            keys.push(i);
        }
    }
    return keys;
}
exports._objectKeys = _objectKeys;
;
/**
* Deeply clone the object.
* https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)
* @param  {any} obj value to clone
* @return {any} cloned obj
*/
function _deepClone(obj) {
    switch (typeof obj) {
        case "object":
            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5
        case "undefined":
            return null; //this is how JSON.stringify behaves for array items
        default:
            return obj; //no need to clone primitives
    }
}
exports._deepClone = _deepClone;
//3x faster than cached /^\d+$/.test(str)
function isInteger(str) {
    var i = 0;
    var len = str.length;
    var charCode;
    while (i < len) {
        charCode = str.charCodeAt(i);
        if (charCode >= 48 && charCode <= 57) {
            i++;
            continue;
        }
        return false;
    }
    return true;
}
exports.isInteger = isInteger;
/**
* Escapes a json pointer path
* @param path The raw pointer
* @return the Escaped path
*/
function escapePathComponent(path) {
    if (path.indexOf('/') === -1 && path.indexOf('~') === -1)
        return path;
    return path.replace(/~/g, '~0').replace(/\//g, '~1');
}
exports.escapePathComponent = escapePathComponent;
/**
 * Unescapes a json pointer path
 * @param path The escaped pointer
 * @return The unescaped path
 */
function unescapePathComponent(path) {
    return path.replace(/~1/g, '/').replace(/~0/g, '~');
}
exports.unescapePathComponent = unescapePathComponent;
function _getPathRecursive(root, obj) {
    var found;
    for (var key in root) {
        if (hasOwnProperty(root, key)) {
            if (root[key] === obj) {
                return escapePathComponent(key) + '/';
            }
            else if (typeof root[key] === 'object') {
                found = _getPathRecursive(root[key], obj);
                if (found != '') {
                    return escapePathComponent(key) + '/' + found;
                }
            }
        }
    }
    return '';
}
exports._getPathRecursive = _getPathRecursive;
function getPath(root, obj) {
    if (root === obj) {
        return '/';
    }
    var path = _getPathRecursive(root, obj);
    if (path === '') {
        throw new Error("Object not found in root");
    }
    return '/' + path;
}
exports.getPath = getPath;
/**
* Recursively checks whether an object has any undefined values inside.
*/
function hasUndefined(obj) {
    if (obj === undefined) {
        return true;
    }
    if (obj) {
        if (Array.isArray(obj)) {
            for (var i = 0, len = obj.length; i < len; i++) {
                if (hasUndefined(obj[i])) {
                    return true;
                }
            }
        }
        else if (typeof obj === "object") {
            var objKeys = _objectKeys(obj);
            var objKeysLength = objKeys.length;
            for (var i = 0; i < objKeysLength; i++) {
                if (hasUndefined(obj[objKeys[i]])) {
                    return true;
                }
            }
        }
    }
    return false;
}
exports.hasUndefined = hasUndefined;
function patchErrorMessageFormatter(message, args) {
    var messageParts = [message];
    for (var key in args) {
        var value = typeof args[key] === 'object' ? JSON.stringify(args[key], null, 2) : args[key]; // pretty print
        if (typeof value !== 'undefined') {
            messageParts.push(key + ": " + value);
        }
    }
    return messageParts.join('\n');
}
var PatchError = /** @class */ (function (_super) {
    __extends(PatchError, _super);
    function PatchError(message, name, index, operation, tree) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree })) || this;
        _this.name = name;
        _this.index = index;
        _this.operation = operation;
        _this.tree = tree;
        Object.setPrototypeOf(_this, _newTarget.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359
        _this.message = patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree });
        return _this;
    }
    return PatchError;
}(Error));
exports.PatchError = PatchError;


/***/ }),

/***/ 1194:
/***/ ((module) => {



var isArray = Array.isArray;
var keyList = Object.keys;
var hasProp = Object.prototype.hasOwnProperty;

module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    var arrA = isArray(a)
      , arrB = isArray(b)
      , i
      , length
      , key;

    if (arrA && arrB) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }

    if (arrA != arrB) return false;

    var dateA = a instanceof Date
      , dateB = b instanceof Date;
    if (dateA != dateB) return false;
    if (dateA && dateB) return a.getTime() == b.getTime();

    var regexpA = a instanceof RegExp
      , regexpB = b instanceof RegExp;
    if (regexpA != regexpB) return false;
    if (regexpA && regexpB) return a.toString() == b.toString();

    var keys = keyList(a);
    length = keys.length;

    if (length !== keyList(b).length)
      return false;

    for (i = length; i-- !== 0;)
      if (!hasProp.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      key = keys[i];
      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  return a!==a && b!==b;
};


/***/ }),

/***/ 3928:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConstructOrder = exports.Construct = exports.Node = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const dependency_1 = __nccwpck_require__(6915);
const stack_trace_1 = __nccwpck_require__(7553);
const uniqueid_1 = __nccwpck_require__(5550);
const CONSTRUCT_SYM = Symbol.for('constructs.Construct');
/**
 * Represents the construct node in the scope tree.
 */
class Node {
    constructor(host, scope, id) {
        this.host = host;
        this._locked = false; // if this is "true", addChild will fail
        this._children = {};
        this._context = {};
        this._metadata = new Array();
        this._dependencies = new Set();
        this._validations = new Array();
        id = id !== null && id !== void 0 ? id : ''; // if undefined, convert to empty string
        this.id = sanitizeId(id);
        this.scope = scope;
        if (scope && !this.id) {
            throw new Error('Only root constructs may have an empty ID');
        }
        // add to parent scope
        scope === null || scope === void 0 ? void 0 : scope.node.addChild(host, this.id);
    }
    /**
     * Returns the node associated with a construct.
     * @param construct the construct
     *
     * @deprecated use `construct.node` instead
     */
    static of(construct) {
        return construct.node;
    }
    /**
     * The full, absolute path of this construct in the tree.
     *
     * Components are separated by '/'.
     */
    get path() {
        const components = this.scopes.filter(c => c.node.id).map(c => c.node.id);
        return components.join(Node.PATH_SEP);
    }
    /**
     * Returns an opaque tree-unique address for this construct.
     *
     * Addresses are 42 characters hexadecimal strings. They begin with "c8"
     * followed by 40 lowercase hexadecimal characters (0-9a-f).
     *
     * Addresses are calculated using a SHA-1 of the components of the construct
     * path.
     *
     * To enable refactorings of construct trees, constructs with the ID `Default`
     * will be excluded from the calculation. In those cases constructs in the
     * same tree may have the same addreess.
     *
     * @example c83a2846e506bcc5f10682b564084bca2d275709ee
     */
    get addr() {
        if (!this._addr) {
            this._addr = uniqueid_1.addressOf(this.scopes.map(c => Node.of(c).id));
        }
        return this._addr;
    }
    /**
     * Return a direct child by id, or undefined
     *
     * @param id Identifier of direct child
     * @returns the child if found, or undefined
     */
    tryFindChild(id) {
        return this._children[sanitizeId(id)];
    }
    /**
     * Return a direct child by id
     *
     * Throws an error if the child is not found.
     *
     * @param id Identifier of direct child
     * @returns Child with the given id.
     */
    findChild(id) {
        const ret = this.tryFindChild(id);
        if (!ret) {
            throw new Error(`No child with id: '${id}'`);
        }
        return ret;
    }
    /**
     * Returns the child construct that has the id `Default` or `Resource"`.
     * This is usually the construct that provides the bulk of the underlying functionality.
     * Useful for modifications of the underlying construct that are not available at the higher levels.
     *
     * @throws if there is more than one child
     * @returns a construct or undefined if there is no default child
     */
    get defaultChild() {
        if (this._defaultChild !== undefined) {
            return this._defaultChild;
        }
        const resourceChild = this.tryFindChild('Resource');
        const defaultChild = this.tryFindChild('Default');
        if (resourceChild && defaultChild) {
            throw new Error(`Cannot determine default child for ${this.path}. There is both a child with id "Resource" and id "Default"`);
        }
        return defaultChild || resourceChild;
    }
    /**
     * Override the defaultChild property.
     *
     * This should only be used in the cases where the correct
     * default child is not named 'Resource' or 'Default' as it
     * should be.
     *
     * If you set this to undefined, the default behavior of finding
     * the child named 'Resource' or 'Default' will be used.
     */
    set defaultChild(value) {
        this._defaultChild = value;
    }
    /**
     * All direct children of this construct.
     */
    get children() {
        return Object.values(this._children);
    }
    /**
     * Return this construct and all of its children in the given order
     */
    findAll(order = ConstructOrder.PREORDER) {
        const ret = new Array();
        visit(this.host);
        return ret;
        function visit(c) {
            if (order === ConstructOrder.PREORDER) {
                ret.push(c);
            }
            for (const child of c.node.children) {
                visit(child);
            }
            if (order === ConstructOrder.POSTORDER) {
                ret.push(c);
            }
        }
    }
    /**
     * This can be used to set contextual values.
     * Context must be set before any children are added, since children may consult context info during construction.
     * If the key already exists, it will be overridden.
     * @param key The context key
     * @param value The context value
     */
    setContext(key, value) {
        if (this.children.length > 0) {
            const names = this.children.map(c => c.node.id);
            throw new Error('Cannot set context after children have been added: ' + names.join(','));
        }
        this._context[key] = value;
    }
    /**
     * Retrieves a value from tree context.
     *
     * Context is usually initialized at the root, but can be overridden at any point in the tree.
     *
     * @param key The context key
     * @returns The context value or `undefined` if there is no context value for thie key.
     */
    tryGetContext(key) {
        const value = this._context[key];
        if (value !== undefined) {
            return value;
        }
        return this.scope && this.scope.node.tryGetContext(key);
    }
    /**
     * An immutable array of metadata objects associated with this construct.
     * This can be used, for example, to implement support for deprecation notices, source mapping, etc.
     */
    get metadata() {
        return [...this._metadata];
    }
    /**
     * Adds a metadata entry to this construct.
     * Entries are arbitrary values and will also include a stack trace to allow tracing back to
     * the code location for when the entry was added. It can be used, for example, to include source
     * mapping in CloudFormation templates to improve diagnostics.
     *
     * @param type a string denoting the type of metadata
     * @param data the value of the metadata (can be a Token). If null/undefined, metadata will not be added.
     * @param options options
     */
    addMetadata(type, data, options = {}) {
        var _c, _d;
        if (data == null) {
            return;
        }
        const shouldTrace = (_c = options.stackTrace) !== null && _c !== void 0 ? _c : false;
        const trace = shouldTrace ? stack_trace_1.captureStackTrace((_d = options.traceFromFunction) !== null && _d !== void 0 ? _d : this.addMetadata) : undefined;
        this._metadata.push({ type, data, trace });
    }
    /**
     * All parent scopes of this construct.
     *
     * @returns a list of parent scopes. The last element in the list will always
     * be the current construct and the first element will be the root of the
     * tree.
     */
    get scopes() {
        const ret = new Array();
        let curr = this.host;
        while (curr) {
            ret.unshift(curr);
            curr = curr.node.scope;
        }
        return ret;
    }
    /**
     * Returns the root of the construct tree.
     * @returns The root of the construct tree.
     */
    get root() {
        return this.scopes[0];
    }
    /**
     * Returns true if this construct or the scopes in which it is defined are
     * locked.
     */
    get locked() {
        if (this._locked) {
            return true;
        }
        if (this.scope && this.scope.node.locked) {
            return true;
        }
        return false;
    }
    /**
     * Add an ordering dependency on another construct.
     *
     * An `IDependable`
     */
    addDependency(...deps) {
        for (const d of deps) {
            this._dependencies.add(d);
        }
    }
    /**
     * Return all dependencies registered on this node (non-recursive).
     */
    get dependencies() {
        const result = new Array();
        for (const dep of this._dependencies) {
            for (const root of dependency_1.Dependable.of(dep).dependencyRoots) {
                result.push(root);
            }
        }
        return result;
    }
    /**
     * Remove the child with the given name, if present.
     *
     * @returns Whether a child with the given name was deleted.
     * @experimental
     */
    tryRemoveChild(childName) {
        if (!(childName in this._children)) {
            return false;
        }
        delete this._children[childName];
        return true;
    }
    /**
     * Adds a validation to this construct.
     *
     * When `node.validate()` is called, the `validate()` method will be called on
     * all validations and all errors will be returned.
     *
     * @param validation The validation object
     */
    addValidation(validation) {
        this._validations.push(validation);
    }
    /**
     * Validates this construct.
     *
     * Invokes the `validate()` method on all validations added through
     * `addValidation()`.
     *
     * @returns an array of validation error messages associated with this
     * construct.
     */
    validate() {
        const deprecated = ['validate', 'onValidate', 'synthesize', 'onSynthesize', 'prepare', 'onPrepare'];
        for (const method of deprecated) {
            if (typeof (this.host[method]) === 'function') {
                throw new Error(`the construct "${this.path}" has a "${method}()" method which is no longer supported. Use "construct.node.addValidation()" to add validations to a construct`);
            }
        }
        const errors = new Array();
        for (const v of this._validations) {
            errors.push(...v.validate());
        }
        return errors;
    }
    /**
     * Locks this construct from allowing more children to be added. After this
     * call, no more children can be added to this construct or to any children.
     */
    lock() {
        this._locked = true;
    }
    /**
     * Adds a child construct to this node.
     *
     * @param child The child construct
     * @param childName The type name of the child construct.
     * @returns The resolved path part name of the child
     */
    addChild(child, childName) {
        var _c;
        if (this.locked) {
            // special error if root is locked
            if (!this.path) {
                throw new Error('Cannot add children during synthesis');
            }
            throw new Error(`Cannot add children to "${this.path}" during synthesis`);
        }
        if (childName in this._children) {
            const name = (_c = this.id) !== null && _c !== void 0 ? _c : '';
            const typeName = this.host.constructor.name;
            throw new Error(`There is already a Construct with name '${childName}' in ${typeName}${name.length > 0 ? ' [' + name + ']' : ''}`);
        }
        if (!childName && this.id) {
            throw new Error(`cannot add a nameless construct to the named scope: ${this.path}`);
        }
        this._children[childName] = child;
        if (Object.keys(this._children).length > 1 && Object.keys(this._children).filter(x => !x).length > 0) {
            throw new Error('only a single construct is allowed in a scope if it has an empty name');
        }
    }
}
exports.Node = Node;
_a = JSII_RTTI_SYMBOL_1;
Node[_a] = { fqn: "constructs.Node", version: "10.1.23" };
/**
 * Separator used to delimit construct path components.
 */
Node.PATH_SEP = '/';
/**
 * Represents the building block of the construct graph.
 *
 * All constructs besides the root construct must be created within the scope of
 * another construct.
 */
class Construct {
    /**
     * Creates a new construct node.
     *
     * @param scope The scope in which to define this construct
     * @param id The scoped construct ID. Must be unique amongst siblings. If
     * the ID includes a path separator (`/`), then it will be replaced by double
     * dash `--`.
     * @param options Options
     */
    constructor(scope, id) {
        this.node = new Node(this, scope, id);
        // implement IDependable privately
        dependency_1.Dependable.implement(this, {
            dependencyRoots: [this],
        });
    }
    /**
     * Checks if `x` is a construct.
     *
     * Use this method instead of `instanceof` to properly detect `Construct`
     * instances, even when the construct library is symlinked.
     *
     * Explanation: in JavaScript, multiple copies of the `constructs` library on
     * disk are seen as independent, completely different libraries. As a
     * consequence, the class `Construct` in each copy of the `constructs` library
     * is seen as a different class, and an instance of one class will not test as
     * `instanceof` the other class. `npm install` will not create installations
     * like this, but users may manually symlink construct libraries together or
     * use a monorepo tool: in those cases, multiple copies of the `constructs`
     * library can be accidentally installed, and `instanceof` will behave
     * unpredictably. It is safest to avoid using `instanceof`, and using
     * this type-testing method instead.
     *
     * @returns true if `x` is an object created from a class which extends `Construct`.
     * @param x Any object
     */
    static isConstruct(x) {
        return x && typeof x === 'object' && x[CONSTRUCT_SYM];
    }
    /**
     * Returns a string representation of this construct.
     */
    toString() {
        return this.node.path || '<root>';
    }
}
exports.Construct = Construct;
_b = JSII_RTTI_SYMBOL_1;
Construct[_b] = { fqn: "constructs.Construct", version: "10.1.23" };
/**
 * In what order to return constructs
 */
var ConstructOrder;
(function (ConstructOrder) {
    /**
     * Depth-first, pre-order
     */
    ConstructOrder[ConstructOrder["PREORDER"] = 0] = "PREORDER";
    /**
     * Depth-first, post-order (leaf nodes first)
     */
    ConstructOrder[ConstructOrder["POSTORDER"] = 1] = "POSTORDER";
})(ConstructOrder = exports.ConstructOrder || (exports.ConstructOrder = {}));
const PATH_SEP_REGEX = new RegExp(`${Node.PATH_SEP}`, 'g');
/**
 * Return a sanitized version of an arbitrary string, so it can be used as an ID
 */
function sanitizeId(id) {
    // Escape path seps as double dashes
    return id.replace(PATH_SEP_REGEX, '--');
}
// Mark all instances of 'Construct'
Object.defineProperty(Construct.prototype, CONSTRUCT_SYM, {
    value: true,
    enumerable: false,
    writable: false,
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uc3RydWN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2NvbnN0cnVjdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLDZDQUF1RDtBQUV2RCx1REFBMEQ7QUFDMUQsaURBQStDO0FBRS9DLE1BQU0sYUFBYSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsc0JBQXNCLENBQUMsQ0FBQztBQVl6RDs7R0FFRztBQUNILE1BQWEsSUFBSTtJQXVDZixZQUFvQyxJQUFlLEVBQUUsS0FBaUIsRUFBRSxFQUFVO1FBQTlDLFNBQUksR0FBSixJQUFJLENBQVc7UUFUM0MsWUFBTyxHQUFHLEtBQUssQ0FBQyxDQUFDLHdDQUF3QztRQUNoRCxjQUFTLEdBQWlDLEVBQUcsQ0FBQztRQUM5QyxhQUFRLEdBQTJCLEVBQUcsQ0FBQztRQUN2QyxjQUFTLEdBQUcsSUFBSSxLQUFLLEVBQWlCLENBQUM7UUFDdkMsa0JBQWEsR0FBRyxJQUFJLEdBQUcsRUFBZSxDQUFDO1FBRXZDLGlCQUFZLEdBQUcsSUFBSSxLQUFLLEVBQWUsQ0FBQztRQUl2RCxFQUFFLEdBQUcsRUFBRSxhQUFGLEVBQUUsY0FBRixFQUFFLEdBQUksRUFBRSxDQUFDLENBQUMsd0NBQXdDO1FBRXZELElBQUksQ0FBQyxFQUFFLEdBQUcsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3pCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBRW5CLElBQUksS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUNyQixNQUFNLElBQUksS0FBSyxDQUFDLDJDQUEyQyxDQUFDLENBQUM7U0FDOUQ7UUFFRCxzQkFBc0I7UUFDdEIsS0FBSyxhQUFMLEtBQUssdUJBQUwsS0FBSyxDQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7SUFDdEMsQ0FBQztJQTdDRDs7Ozs7T0FLRztJQUNJLE1BQU0sQ0FBQyxFQUFFLENB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RztBQUNILElBQVksY0FVWDtBQVZELFdBQVksY0FBYztJQUN4Qjs7T0FFRztJQUNILDJEQUFRLENBQUE7SUFFUjs7T0FFRztJQUNILDZEQUFTLENBQUE7QUFDWCxDQUFDLEVBVlcsY0FBYyxHQUFkLHNCQUFjLEtBQWQsc0JBQWMsUUFVekI7QUFpQkQsTUFBTSxjQUFjLEdBQUcsSUFBSSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFFM0Q7O0dBRUc7QUFDSCxTQUFTLFVBQVUsQ0FBQyxFQUFVO0lBQzVCLG9DQUFvQztJQUNwQyxPQUFPLEVBQUUsQ0FBQyxPQUFPLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQzFDLENBQUM7QUFzQkQsb0NBQW9DO0FBQ3BDLE1BQU0sQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLFNBQVMsRUFBRSxhQUFhLEVBQUU7SUFDeEQsS0FBSyxFQUFFLElBQUk7SUFDWCxVQUFVLEVBQUUsS0FBSztJQUNqQixRQUFRLEVBQUUsS0FBSztDQUNoQixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZXBlbmRhYmxlLCBJRGVwZW5kYWJsZSB9IGZyb20gJy4vZGVwZW5kZW5jeSc7XG5pbXBvcnQgeyBNZXRhZGF0YUVudHJ5IH0gZnJvbSAnLi9tZXRhZGF0YSc7XG5pbXBvcnQgeyBjYXB0dXJlU3RhY2tUcmFjZSB9IGZyb20gJy4vcHJpdmF0ZS9zdGFjay10cmFjZSc7XG5pbXBvcnQgeyBhZGRyZXNzT2YgfSBmcm9tICcuL3ByaXZhdGUvdW5pcXVlaWQnO1xuXG5jb25zdCBDT05TVFJVQ1RfU1lNID0gU3ltYm9sLmZvcignY29uc3RydWN0cy5Db25zdHJ1Y3QnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY29uc3RydWN0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElDb25zdHJ1Y3QgZXh0ZW5kcyBJRGVwZW5kYWJsZSB7XG4gIC8qKlxuICAgKiBUaGUgdHJlZSBub2RlLlxuICAgKi9cbiAgcmVhZG9ubHkgbm9kZTogTm9kZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjb25zdHJ1Y3Qgbm9kZSBpbiB0aGUgc2NvcGUgdHJlZS5cbiAqL1xuZXhwb3J0IGNsYXNzIE5vZGUge1xuICAvKipcbiAgICogU2VwYXJhdG9yIHVzZWQgdG8gZGVsaW1pdCBjb25zdHJ1Y3QgcGF0aCBjb21wb25lbnRzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBQQVRIX1NFUCA9ICcvJztcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbm9kZSBhc3NvY2lhdGVkIHdpdGggYSBjb25zdHJ1Y3QuXG4gICAqIEBwYXJhbSBjb25zdHJ1Y3QgdGhlIGNvbnN0cnVjdFxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGNvbnN0cnVjdC5ub2RlYCBpbnN0ZWFkXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG9mKGNvbnN0cnVjdDogSUNvbnN0cnVjdCk6IE5vZGUge1xuICAgIHJldHVybiBjb25zdHJ1Y3Qubm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzY29wZSBpbiB3aGljaCB0aGlzIGNvbnN0cnVjdCBpcyBkZWZpbmVkLlxuICAgKlxuICAgKiBUaGUgdmFsdWUgaXMgYHVuZGVmaW5lZGAgYXQgdGhlIHJvb3Qgb2YgdGhlIGNvbnN0cnVjdCBzY29wZSB0cmVlLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHNjb3BlPzogSUNvbnN0cnVjdDtcblxuICAvKipcbiAgICogVGhlIGlkIG9mIHRoaXMgY29uc3RydWN0IHdpdGhpbiB0aGUgY3VycmVudCBzY29wZS5cbiAgICpcbiAgICogVGhpcyBpcyBhIGEgc2NvcGUtdW5pcXVlIGlkLiBUbyBvYnRhaW4gYW4gYXBwLXVuaXF1ZSBpZCBmb3IgdGhpcyBjb25zdHJ1Y3QsIHVzZSBgYWRkcmAuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgaWQ6IHN0cmluZztcblxuICBwcml2YXRlIF9sb2NrZWQgPSBmYWxzZTsgLy8gaWYgdGhpcyBpcyBcInRydWVcIiwgYWRkQ2hpbGQgd2lsbCBmYWlsXG4gIHByaXZhdGUgcmVhZG9ubHkgX2NoaWxkcmVuOiB7IFtpZDogc3RyaW5nXTogSUNvbnN0cnVjdCB9ID0geyB9O1xuICBwcml2YXRlIHJlYWRvbmx5IF9jb250ZXh0OiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0geyB9O1xuICBwcml2YXRlIHJlYWRvbmx5IF9tZXRhZGF0YSA9IG5ldyBBcnJheTxNZXRhZGF0YUVudHJ5PigpO1xuICBwcml2YXRlIHJlYWRvbmx5IF9kZXBlbmRlbmNpZXMgPSBuZXcgU2V0PElEZXBlbmRhYmxlPigpO1xuICBwcml2YXRlIF9kZWZhdWx0Q2hpbGQ6IElDb25zdHJ1Y3QgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgX3ZhbGlkYXRpb25zID0gbmV3IEFycmF5PElWYWxpZGF0aW9uPigpO1xuICBwcml2YXRlIF9hZGRyPzogc3RyaW5nOyAvLyBjYWNoZVxuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGhvc3Q6IENvbnN0cnVjdCwgc2NvcGU6IElDb25zdHJ1Y3QsIGlkOiBzdHJpbmcpIHtcbiAgICBpZCA9IGlkID8/ICcnOyAvLyBpZiB1bmRlZmluZWQsIGNvbnZlcnQgdG8gZW1wdHkgc3RyaW5nXG5cbiAgICB0aGlzLmlkID0gc2FuaXRpemVJZChpZCk7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuXG4gICAgaWYgKHNjb3BlICYmICF0aGlzLmlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgcm9vdCBjb25zdHJ1Y3RzIG1heSBoYXZlIGFuIGVtcHR5IElEJyk7XG4gICAgfVxuXG4gICAgLy8gYWRkIHRvIHBhcmVudCBzY29wZVxuICAgIHNjb3BlPy5ub2RlLmFkZENoaWxkKGhvc3QsIHRoaXMuaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBmdWxsLCBhYnNvbHV0ZSBwYXRoIG9mIHRoaXMgY29uc3RydWN0IGluIHRoZSB0cmVlLlxuICAgKlxuICAgKiBDb21wb25lbnRzIGFyZSBzZXBhcmF0ZWQgYnkgJy8nLlxuICAgKi9cbiAgcHVibGljIGdldCBwYXRoKCk6IHN0cmluZyB7XG4gICAgY29uc3QgY29tcG9uZW50cyA9IHRoaXMuc2NvcGVzLmZpbHRlcihjID0+IGMubm9kZS5pZCkubWFwKGMgPT4gYy5ub2RlLmlkKTtcbiAgICByZXR1cm4gY29tcG9uZW50cy5qb2luKE5vZGUuUEFUSF9TRVApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb3BhcXVlIHRyZWUtdW5pcXVlIGFkZHJlc3MgZm9yIHRoaXMgY29uc3RydWN0LlxuICAgKlxuICAgKiBBZGRyZXNzZXMgYXJlIDQyIGNoYXJhY3RlcnMgaGV4YWRlY2ltYWwgc3RyaW5ncy4gVGhleSBiZWdpbiB3aXRoIFwiYzhcIlxuICAgKiBmb2xsb3dlZCBieSA0MCBsb3dlcmNhc2UgaGV4YWRlY2ltYWwgY2hhcmFjdGVycyAoMC05YS1mKS5cbiAgICpcbiAgICogQWRkcmVzc2VzIGFyZSBjYWxjdWxhdGVkIHVzaW5nIGEgU0hBLTEgb2YgdGhlIGNvbXBvbmVudHMgb2YgdGhlIGNvbnN0cnVjdFxuICAgKiBwYXRoLlxuICAgKlxuICAgKiBUbyBlbmFibGUgcmVmYWN0b3JpbmdzIG9mIGNvbnN0cnVjdCB0cmVlcywgY29uc3RydWN0cyB3aXRoIHRoZSBJRCBgRGVmYXVsdGBcbiAgICogd2lsbCBiZSBleGNsdWRlZCBmcm9tIHRoZSBjYWxjdWxhdGlvbi4gSW4gdGhvc2UgY2FzZXMgY29uc3RydWN0cyBpbiB0aGVcbiAgICogc2FtZSB0cmVlIG1heSBoYXZlIHRoZSBzYW1lIGFkZHJlZXNzLlxuICAgKlxuICAgKiBAZXhhbXBsZSBjODNhMjg0NmU1MDZiY2M1ZjEwNjgyYjU2NDA4NGJjYTJkMjc1NzA5ZWVcbiAgICovXG4gIHB1YmxpYyBnZXQgYWRkcigpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5fYWRkcikge1xuICAgICAgdGhpcy5fYWRkciA9IGFkZHJlc3NPZih0aGlzLnNjb3Blcy5tYXAoYyA9PiBOb2RlLm9mKGMpLmlkKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2FkZHI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgZGlyZWN0IGNoaWxkIGJ5IGlkLCBvciB1bmRlZmluZWRcbiAgICpcbiAgICogQHBhcmFtIGlkIElkZW50aWZpZXIgb2YgZGlyZWN0IGNoaWxkXG4gICAqIEByZXR1cm5zIHRoZSBjaGlsZCBpZiBmb3VuZCwgb3IgdW5kZWZpbmVkXG4gICAqL1xuICBwdWJsaWMgdHJ5RmluZENoaWxkKGlkOiBzdHJpbmcpOiBJQ29uc3RydWN0IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW5bc2FuaXRpemVJZChpZCldO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGRpcmVjdCBjaGlsZCBieSBpZFxuICAgKlxuICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGNoaWxkIGlzIG5vdCBmb3VuZC5cbiAgICpcbiAgICogQHBhcmFtIGlkIElkZW50aWZpZXIgb2YgZGlyZWN0IGNoaWxkXG4gICAqIEByZXR1cm5zIENoaWxkIHdpdGggdGhlIGdpdmVuIGlkLlxuICAgKi9cbiAgcHVibGljIGZpbmRDaGlsZChpZDogc3RyaW5nKTogSUNvbnN0cnVjdCB7XG4gICAgY29uc3QgcmV0ID0gdGhpcy50cnlGaW5kQ2hpbGQoaWQpO1xuICAgIGlmICghcmV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNoaWxkIHdpdGggaWQ6ICcke2lkfSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjaGlsZCBjb25zdHJ1Y3QgdGhhdCBoYXMgdGhlIGlkIGBEZWZhdWx0YCBvciBgUmVzb3VyY2VcImAuXG4gICAqIFRoaXMgaXMgdXN1YWxseSB0aGUgY29uc3RydWN0IHRoYXQgcHJvdmlkZXMgdGhlIGJ1bGsgb2YgdGhlIHVuZGVybHlpbmcgZnVuY3Rpb25hbGl0eS5cbiAgICogVXNlZnVsIGZvciBtb2RpZmljYXRpb25zIG9mIHRoZSB1bmRlcmx5aW5nIGNvbnN0cnVjdCB0aGF0IGFyZSBub3QgYXZhaWxhYmxlIGF0IHRoZSBoaWdoZXIgbGV2ZWxzLlxuICAgKlxuICAgKiBAdGhyb3dzIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgY2hpbGRcbiAgICogQHJldHVybnMgYSBjb25zdHJ1Y3Qgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIGRlZmF1bHQgY2hpbGRcbiAgICovXG4gIHB1YmxpYyBnZXQgZGVmYXVsdENoaWxkKCk6IElDb25zdHJ1Y3QgfCB1bmRlZmluZWQge1xuICAgIGlmICh0aGlzLl9kZWZhdWx0Q2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRDaGlsZDtcbiAgICB9XG5cbiAgICBjb25zdCByZXNvdXJjZUNoaWxkID0gdGhpcy50cnlGaW5kQ2hpbGQoJ1Jlc291cmNlJyk7XG4gICAgY29uc3QgZGVmYXVsdENoaWxkID0gdGhpcy50cnlGaW5kQ2hpbGQoJ0RlZmF1bHQnKTtcbiAgICBpZiAocmVzb3VyY2VDaGlsZCAmJiBkZWZhdWx0Q2hpbGQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGRldGVybWluZSBkZWZhdWx0IGNoaWxkIGZvciAke3RoaXMucGF0aH0uIFRoZXJlIGlzIGJvdGggYSBjaGlsZCB3aXRoIGlkIFwiUmVzb3VyY2VcIiBhbmQgaWQgXCJEZWZhdWx0XCJgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmYXVsdENoaWxkIHx8IHJlc291cmNlQ2hpbGQ7XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIGRlZmF1bHRDaGlsZCBwcm9wZXJ0eS5cbiAgICpcbiAgICogVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIGluIHRoZSBjYXNlcyB3aGVyZSB0aGUgY29ycmVjdFxuICAgKiBkZWZhdWx0IGNoaWxkIGlzIG5vdCBuYW1lZCAnUmVzb3VyY2UnIG9yICdEZWZhdWx0JyBhcyBpdFxuICAgKiBzaG91bGQgYmUuXG4gICAqXG4gICAqIElmIHlvdSBzZXQgdGhpcyB0byB1bmRlZmluZWQsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGZpbmRpbmdcbiAgICogdGhlIGNoaWxkIG5hbWVkICdSZXNvdXJjZScgb3IgJ0RlZmF1bHQnIHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIHB1YmxpYyBzZXQgZGVmYXVsdENoaWxkKHZhbHVlOiBJQ29uc3RydWN0IHwgdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5fZGVmYXVsdENoaWxkID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQWxsIGRpcmVjdCBjaGlsZHJlbiBvZiB0aGlzIGNvbnN0cnVjdC5cbiAgICovXG4gIHB1YmxpYyBnZXQgY2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fY2hpbGRyZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGlzIGNvbnN0cnVjdCBhbmQgYWxsIG9mIGl0cyBjaGlsZHJlbiBpbiB0aGUgZ2l2ZW4gb3JkZXJcbiAgICovXG4gIHB1YmxpYyBmaW5kQWxsKG9yZGVyOiBDb25zdHJ1Y3RPcmRlciA9IENvbnN0cnVjdE9yZGVyLlBSRU9SREVSKTogSUNvbnN0cnVjdFtdIHtcbiAgICBjb25zdCByZXQgPSBuZXcgQXJyYXk8SUNvbnN0cnVjdD4oKTtcbiAgICB2aXNpdCh0aGlzLmhvc3QpO1xuICAgIHJldHVybiByZXQ7XG5cbiAgICBmdW5jdGlvbiB2aXNpdChjOiBJQ29uc3RydWN0KSB7XG4gICAgICBpZiAob3JkZXIgPT09IENvbnN0cnVjdE9yZGVyLlBSRU9SREVSKSB7XG4gICAgICAgIHJldC5wdXNoKGMpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGMubm9kZS5jaGlsZHJlbikge1xuICAgICAgICB2aXNpdChjaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcmRlciA9PT0gQ29uc3RydWN0T3JkZXIuUE9TVE9SREVSKSB7XG4gICAgICAgIHJldC5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIHNldCBjb250ZXh0dWFsIHZhbHVlcy5cbiAgICogQ29udGV4dCBtdXN0IGJlIHNldCBiZWZvcmUgYW55IGNoaWxkcmVuIGFyZSBhZGRlZCwgc2luY2UgY2hpbGRyZW4gbWF5IGNvbnN1bHQgY29udGV4dCBpbmZvIGR1cmluZyBjb25zdHJ1Y3Rpb24uXG4gICAqIElmIHRoZSBrZXkgYWxyZWFkeSBleGlzdHMsIGl0IHdpbGwgYmUgb3ZlcnJpZGRlbi5cbiAgICogQHBhcmFtIGtleSBUaGUgY29udGV4dCBrZXlcbiAgICogQHBhcmFtIHZhbHVlIFRoZSBjb250ZXh0IHZhbHVlXG4gICAqL1xuICBwdWJsaWMgc2V0Q29udGV4dChrZXk6IHN0cmluZywgdmFsdWU6IGFueSkge1xuICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG5hbWVzID0gdGhpcy5jaGlsZHJlbi5tYXAoYyA9PiBjLm5vZGUuaWQpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IGNvbnRleHQgYWZ0ZXIgY2hpbGRyZW4gaGF2ZSBiZWVuIGFkZGVkOiAnICsgbmFtZXMuam9pbignLCcpKTtcbiAgICB9XG4gICAgdGhpcy5fY29udGV4dFtrZXldID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgdmFsdWUgZnJvbSB0cmVlIGNvbnRleHQuXG4gICAqXG4gICAqIENvbnRleHQgaXMgdXN1YWxseSBpbml0aWFsaXplZCBhdCB0aGUgcm9vdCwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGF0IGFueSBwb2ludCBpbiB0aGUgdHJlZS5cbiAgICpcbiAgICogQHBhcmFtIGtleSBUaGUgY29udGV4dCBrZXlcbiAgICogQHJldHVybnMgVGhlIGNvbnRleHQgdmFsdWUgb3IgYHVuZGVmaW5lZGAgaWYgdGhlcmUgaXMgbm8gY29udGV4dCB2YWx1ZSBmb3IgdGhpZSBrZXkuXG4gICAqL1xuICBwdWJsaWMgdHJ5R2V0Q29udGV4dChrZXk6IHN0cmluZyk6IGFueSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLl9jb250ZXh0W2tleV07XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHsgcmV0dXJuIHZhbHVlOyB9XG5cbiAgICByZXR1cm4gdGhpcy5zY29wZSAmJiB0aGlzLnNjb3BlLm5vZGUudHJ5R2V0Q29udGV4dChrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGltbXV0YWJsZSBhcnJheSBvZiBtZXRhZGF0YSBvYmplY3RzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbnN0cnVjdC5cbiAgICogVGhpcyBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIHRvIGltcGxlbWVudCBzdXBwb3J0IGZvciBkZXByZWNhdGlvbiBub3RpY2VzLCBzb3VyY2UgbWFwcGluZywgZXRjLlxuICAgKi9cbiAgcHVibGljIGdldCBtZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuX21ldGFkYXRhXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbWV0YWRhdGEgZW50cnkgdG8gdGhpcyBjb25zdHJ1Y3QuXG4gICAqIEVudHJpZXMgYXJlIGFyYml0cmFyeSB2YWx1ZXMgYW5kIHdpbGwgYWxzbyBpbmNsdWRlIGEgc3RhY2sgdHJhY2UgdG8gYWxsb3cgdHJhY2luZyBiYWNrIHRvXG4gICAqIHRoZSBjb2RlIGxvY2F0aW9uIGZvciB3aGVuIHRoZSBlbnRyeSB3YXMgYWRkZWQuIEl0IGNhbiBiZSB1c2VkLCBmb3IgZXhhbXBsZSwgdG8gaW5jbHVkZSBzb3VyY2VcbiAgICogbWFwcGluZyBpbiBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZXMgdG8gaW1wcm92ZSBkaWFnbm9zdGljcy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgYSBzdHJpbmcgZGVub3RpbmcgdGhlIHR5cGUgb2YgbWV0YWRhdGFcbiAgICogQHBhcmFtIGRhdGEgdGhlIHZhbHVlIG9mIHRoZSBtZXRhZGF0YSAoY2FuIGJlIGEgVG9rZW4pLiBJZiBudWxsL3VuZGVmaW5lZCwgbWV0YWRhdGEgd2lsbCBub3QgYmUgYWRkZWQuXG4gICAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbnNcbiAgICovXG4gIHB1YmxpYyBhZGRNZXRhZGF0YSh0eXBlOiBzdHJpbmcsIGRhdGE6IGFueSwgb3B0aW9uczogTWV0YWRhdGFPcHRpb25zID0geyB9KTogdm9pZCB7XG4gICAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNob3VsZFRyYWNlID0gb3B0aW9ucy5zdGFja1RyYWNlID8/IGZhbHNlO1xuICAgIGNvbnN0IHRyYWNlID0gc2hvdWxkVHJhY2UgPyBjYXB0dXJlU3RhY2tUcmFjZShvcHRpb25zLnRyYWNlRnJvbUZ1bmN0aW9uID8/IHRoaXMuYWRkTWV0YWRhdGEpIDogdW5kZWZpbmVkO1xuICAgIHRoaXMuX21ldGFkYXRhLnB1c2goeyB0eXBlLCBkYXRhLCB0cmFjZSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGwgcGFyZW50IHNjb3BlcyBvZiB0aGlzIGNvbnN0cnVjdC5cbiAgICpcbiAgICogQHJldHVybnMgYSBsaXN0IG9mIHBhcmVudCBzY29wZXMuIFRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIGxpc3Qgd2lsbCBhbHdheXNcbiAgICogYmUgdGhlIGN1cnJlbnQgY29uc3RydWN0IGFuZCB0aGUgZmlyc3QgZWxlbWVudCB3aWxsIGJlIHRoZSByb290IG9mIHRoZVxuICAgKiB0cmVlLlxuICAgKi9cbiAgcHVibGljIGdldCBzY29wZXMoKTogSUNvbnN0cnVjdFtdIHtcbiAgICBjb25zdCByZXQgPSBuZXcgQXJyYXk8SUNvbnN0cnVjdD4oKTtcblxuICAgIGxldCBjdXJyOiBJQ29uc3RydWN0IHwgdW5kZWZpbmVkID0gdGhpcy5ob3N0O1xuICAgIHdoaWxlIChjdXJyKSB7XG4gICAgICByZXQudW5zaGlmdChjdXJyKTtcbiAgICAgIGN1cnIgPSBjdXJyLm5vZGUuc2NvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb290IG9mIHRoZSBjb25zdHJ1Y3QgdHJlZS5cbiAgICogQHJldHVybnMgVGhlIHJvb3Qgb2YgdGhlIGNvbnN0cnVjdCB0cmVlLlxuICAgKi9cbiAgcHVibGljIGdldCByb290KCkge1xuICAgIHJldHVybiB0aGlzLnNjb3Blc1swXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjb25zdHJ1Y3Qgb3IgdGhlIHNjb3BlcyBpbiB3aGljaCBpdCBpcyBkZWZpbmVkIGFyZVxuICAgKiBsb2NrZWQuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGxvY2tlZCgpIHtcbiAgICBpZiAodGhpcy5fbG9ja2VkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zY29wZSAmJiB0aGlzLnNjb3BlLm5vZGUubG9ja2VkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIG9yZGVyaW5nIGRlcGVuZGVuY3kgb24gYW5vdGhlciBjb25zdHJ1Y3QuXG4gICAqXG4gICAqIEFuIGBJRGVwZW5kYWJsZWBcbiAgICovXG4gIHB1YmxpYyBhZGREZXBlbmRlbmN5KC4uLmRlcHM6IElEZXBlbmRhYmxlW10pIHtcbiAgICBmb3IgKGNvbnN0IGQgb2YgZGVwcykge1xuICAgICAgdGhpcy5fZGVwZW5kZW5jaWVzLmFkZChkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFsbCBkZXBlbmRlbmNpZXMgcmVnaXN0ZXJlZCBvbiB0aGlzIG5vZGUgKG5vbi1yZWN1cnNpdmUpLlxuICAgKi9cbiAgcHVibGljIGdldCBkZXBlbmRlbmNpZXMoKTogSUNvbnN0cnVjdFtdIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXk8SUNvbnN0cnVjdD4oKTtcbiAgICBmb3IgKGNvbnN0IGRlcCBvZiB0aGlzLl9kZXBlbmRlbmNpZXMpIHtcbiAgICAgIGZvciAoY29uc3Qgcm9vdCBvZiBEZXBlbmRhYmxlLm9mKGRlcCkuZGVwZW5kZW5jeVJvb3RzKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHJvb3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBjaGlsZCB3aXRoIHRoZSBnaXZlbiBuYW1lLCBpZiBwcmVzZW50LlxuICAgKlxuICAgKiBAcmV0dXJucyBXaGV0aGVyIGEgY2hpbGQgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB3YXMgZGVsZXRlZC5cbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgcHVibGljIHRyeVJlbW92ZUNoaWxkKGNoaWxkTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKCEoY2hpbGROYW1lIGluIHRoaXMuX2NoaWxkcmVuKSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBkZWxldGUgdGhpcy5fY2hpbGRyZW5bY2hpbGROYW1lXTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgdmFsaWRhdGlvbiB0byB0aGlzIGNvbnN0cnVjdC5cbiAgICpcbiAgICogV2hlbiBgbm9kZS52YWxpZGF0ZSgpYCBpcyBjYWxsZWQsIHRoZSBgdmFsaWRhdGUoKWAgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIG9uXG4gICAqIGFsbCB2YWxpZGF0aW9ucyBhbmQgYWxsIGVycm9ycyB3aWxsIGJlIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsaWRhdGlvbiBUaGUgdmFsaWRhdGlvbiBvYmplY3RcbiAgICovXG4gIHB1YmxpYyBhZGRWYWxpZGF0aW9uKHZhbGlkYXRpb246IElWYWxpZGF0aW9uKSB7XG4gICAgdGhpcy5fdmFsaWRhdGlvbnMucHVzaCh2YWxpZGF0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhpcyBjb25zdHJ1Y3QuXG4gICAqXG4gICAqIEludm9rZXMgdGhlIGB2YWxpZGF0ZSgpYCBtZXRob2Qgb24gYWxsIHZhbGlkYXRpb25zIGFkZGVkIHRocm91Z2hcbiAgICogYGFkZFZhbGlkYXRpb24oKWAuXG4gICAqXG4gICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIHZhbGlkYXRpb24gZXJyb3IgbWVzc2FnZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXNcbiAgICogY29uc3RydWN0LlxuICAgKi9cbiAgcHVibGljIHZhbGlkYXRlKCk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBkZXByZWNhdGVkID0gWyd2YWxpZGF0ZScsICdvblZhbGlkYXRlJywgJ3N5bnRoZXNpemUnLCAnb25TeW50aGVzaXplJywgJ3ByZXBhcmUnLCAnb25QcmVwYXJlJ107XG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2YgZGVwcmVjYXRlZCkge1xuICAgICAgaWYgKHR5cGVvZigodGhpcy5ob3N0IGFzIGFueSlbbWV0aG9kXSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0aGUgY29uc3RydWN0IFwiJHt0aGlzLnBhdGh9XCIgaGFzIGEgXCIke21ldGhvZH0oKVwiIG1ldGhvZCB3aGljaCBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBVc2UgXCJjb25zdHJ1Y3Qubm9kZS5hZGRWYWxpZGF0aW9uKClcIiB0byBhZGQgdmFsaWRhdGlvbnMgdG8gYSBjb25zdHJ1Y3RgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBlcnJvcnMgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuICAgIGZvciAoY29uc3QgdiBvZiB0aGlzLl92YWxpZGF0aW9ucykge1xuICAgICAgZXJyb3JzLnB1c2goLi4udi52YWxpZGF0ZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3JzO1xuICB9XG5cbiAgLyoqXG4gICAqIExvY2tzIHRoaXMgY29uc3RydWN0IGZyb20gYWxsb3dpbmcgbW9yZSBjaGlsZHJlbiB0byBiZSBhZGRlZC4gQWZ0ZXIgdGhpc1xuICAgKiBjYWxsLCBubyBtb3JlIGNoaWxkcmVuIGNhbiBiZSBhZGRlZCB0byB0aGlzIGNvbnN0cnVjdCBvciB0byBhbnkgY2hpbGRyZW4uXG4gICAqL1xuICBwdWJsaWMgbG9jaygpIHtcbiAgICB0aGlzLl9sb2NrZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGlsZCBjb25zdHJ1Y3QgdG8gdGhpcyBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gY2hpbGQgVGhlIGNoaWxkIGNvbnN0cnVjdFxuICAgKiBAcGFyYW0gY2hpbGROYW1lIFRoZSB0eXBlIG5hbWUgb2YgdGhlIGNoaWxkIGNvbnN0cnVjdC5cbiAgICogQHJldHVybnMgVGhlIHJlc29sdmVkIHBhdGggcGFydCBuYW1lIG9mIHRoZSBjaGlsZFxuICAgKi9cbiAgcHJpdmF0ZSBhZGRDaGlsZChjaGlsZDogQ29uc3RydWN0LCBjaGlsZE5hbWU6IHN0cmluZykge1xuICAgIGlmICh0aGlzLmxvY2tlZCkge1xuXG4gICAgICAvLyBzcGVjaWFsIGVycm9yIGlmIHJvb3QgaXMgbG9ja2VkXG4gICAgICBpZiAoIXRoaXMucGF0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgY2hpbGRyZW4gZHVyaW5nIHN5bnRoZXNpcycpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBhZGQgY2hpbGRyZW4gdG8gXCIke3RoaXMucGF0aH1cIiBkdXJpbmcgc3ludGhlc2lzYCk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkTmFtZSBpbiB0aGlzLl9jaGlsZHJlbikge1xuICAgICAgY29uc3QgbmFtZSA9IHRoaXMuaWQgPz8gJyc7XG4gICAgICBjb25zdCB0eXBlTmFtZSA9IHRoaXMuaG9zdC5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBhbHJlYWR5IGEgQ29uc3RydWN0IHdpdGggbmFtZSAnJHtjaGlsZE5hbWV9JyBpbiAke3R5cGVOYW1lfSR7bmFtZS5sZW5ndGggPiAwID8gJyBbJyArIG5hbWUgKyAnXScgOiAnJ31gKTtcbiAgICB9XG5cbiAgICBpZiAoIWNoaWxkTmFtZSAmJiB0aGlzLmlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBhZGQgYSBuYW1lbGVzcyBjb25zdHJ1Y3QgdG8gdGhlIG5hbWVkIHNjb3BlOiAke3RoaXMucGF0aH1gKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jaGlsZHJlbltjaGlsZE5hbWVdID0gY2hpbGQ7XG5cbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fY2hpbGRyZW4pLmxlbmd0aCA+IDEgJiYgT2JqZWN0LmtleXModGhpcy5fY2hpbGRyZW4pLmZpbHRlcih4ID0+ICF4KS5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29ubHkgYSBzaW5nbGUgY29uc3RydWN0IGlzIGFsbG93ZWQgaW4gYSBzY29wZSBpZiBpdCBoYXMgYW4gZW1wdHkgbmFtZScpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGJ1aWxkaW5nIGJsb2NrIG9mIHRoZSBjb25zdHJ1Y3QgZ3JhcGguXG4gKlxuICogQWxsIGNvbnN0cnVjdHMgYmVzaWRlcyB0aGUgcm9vdCBjb25zdHJ1Y3QgbXVzdCBiZSBjcmVhdGVkIHdpdGhpbiB0aGUgc2NvcGUgb2ZcbiAqIGFub3RoZXIgY29uc3RydWN0LlxuICovXG5leHBvcnQgY2xhc3MgQ29uc3RydWN0IGltcGxlbWVudHMgSUNvbnN0cnVjdCB7XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHhgIGlzIGEgY29uc3RydWN0LlxuICAgKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgaW5zdGVhZCBvZiBgaW5zdGFuY2VvZmAgdG8gcHJvcGVybHkgZGV0ZWN0IGBDb25zdHJ1Y3RgXG4gICAqIGluc3RhbmNlcywgZXZlbiB3aGVuIHRoZSBjb25zdHJ1Y3QgbGlicmFyeSBpcyBzeW1saW5rZWQuXG4gICAqXG4gICAqIEV4cGxhbmF0aW9uOiBpbiBKYXZhU2NyaXB0LCBtdWx0aXBsZSBjb3BpZXMgb2YgdGhlIGBjb25zdHJ1Y3RzYCBsaWJyYXJ5IG9uXG4gICAqIGRpc2sgYXJlIHNlZW4gYXMgaW5kZXBlbmRlbnQsIGNvbXBsZXRlbHkgZGlmZmVyZW50IGxpYnJhcmllcy4gQXMgYVxuICAgKiBjb25zZXF1ZW5jZSwgdGhlIGNsYXNzIGBDb25zdHJ1Y3RgIGluIGVhY2ggY29weSBvZiB0aGUgYGNvbnN0cnVjdHNgIGxpYnJhcnlcbiAgICogaXMgc2VlbiBhcyBhIGRpZmZlcmVudCBjbGFzcywgYW5kIGFuIGluc3RhbmNlIG9mIG9uZSBjbGFzcyB3aWxsIG5vdCB0ZXN0IGFzXG4gICAqIGBpbnN0YW5jZW9mYCB0aGUgb3RoZXIgY2xhc3MuIGBucG0gaW5zdGFsbGAgd2lsbCBub3QgY3JlYXRlIGluc3RhbGxhdGlvbnNcbiAgICogbGlrZSB0aGlzLCBidXQgdXNlcnMgbWF5IG1hbnVhbGx5IHN5bWxpbmsgY29uc3RydWN0IGxpYnJhcmllcyB0b2dldGhlciBvclxuICAgKiB1c2UgYSBtb25vcmVwbyB0b29sOiBpbiB0aG9zZSBjYXNlcywgbXVsdGlwbGUgY29waWVzIG9mIHRoZSBgY29uc3RydWN0c2BcbiAgICogbGlicmFyeSBjYW4gYmUgYWNjaWRlbnRhbGx5IGluc3RhbGxlZCwgYW5kIGBpbnN0YW5jZW9mYCB3aWxsIGJlaGF2ZVxuICAgKiB1bnByZWRpY3RhYmx5LiBJdCBpcyBzYWZlc3QgdG8gYXZvaWQgdXNpbmcgYGluc3RhbmNlb2ZgLCBhbmQgdXNpbmdcbiAgICogdGhpcyB0eXBlLXRlc3RpbmcgbWV0aG9kIGluc3RlYWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgYHhgIGlzIGFuIG9iamVjdCBjcmVhdGVkIGZyb20gYSBjbGFzcyB3aGljaCBleHRlbmRzIGBDb25zdHJ1Y3RgLlxuICAgKiBAcGFyYW0geCBBbnkgb2JqZWN0XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGlzQ29uc3RydWN0KHg6IGFueSk6IHggaXMgQ29uc3RydWN0IHtcbiAgICByZXR1cm4geCAmJiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeFtDT05TVFJVQ1RfU1lNXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdHJlZSBub2RlLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IG5vZGU6IE5vZGU7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29uc3RydWN0IG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSBzY29wZSBUaGUgc2NvcGUgaW4gd2hpY2ggdG8gZGVmaW5lIHRoaXMgY29uc3RydWN0XG4gICAqIEBwYXJhbSBpZCBUaGUgc2NvcGVkIGNvbnN0cnVjdCBJRC4gTXVzdCBiZSB1bmlxdWUgYW1vbmdzdCBzaWJsaW5ncy4gSWZcbiAgICogdGhlIElEIGluY2x1ZGVzIGEgcGF0aCBzZXBhcmF0b3IgKGAvYCksIHRoZW4gaXQgd2lsbCBiZSByZXBsYWNlZCBieSBkb3VibGVcbiAgICogZGFzaCBgLS1gLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nKSB7XG4gICAgdGhpcy5ub2RlID0gbmV3IE5vZGUodGhpcywgc2NvcGUsIGlkKTtcblxuICAgIC8vIGltcGxlbWVudCBJRGVwZW5kYWJsZSBwcml2YXRlbHlcbiAgICBEZXBlbmRhYmxlLmltcGxlbWVudCh0aGlzLCB7XG4gICAgICBkZXBlbmRlbmN5Um9vdHM6IFt0aGlzXSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29uc3RydWN0LlxuICAgKi9cbiAgcHVibGljIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUucGF0aCB8fCAnPHJvb3Q+JztcbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudCB0aGlzIGludGVyZmFjZSBpbiBvcmRlciBmb3IgdGhlIGNvbnN0cnVjdCB0byBiZSBhYmxlIHRvIHZhbGlkYXRlIGl0c2VsZi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJVmFsaWRhdGlvbiB7XG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGUgY3VycmVudCBjb25zdHJ1Y3QuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBpbXBsZW1lbnRlZCBieSBkZXJpdmVkIGNvbnN0cnVjdHMgaW4gb3JkZXIgdG8gcGVyZm9ybVxuICAgKiB2YWxpZGF0aW9uIGxvZ2ljLiBJdCBpcyBjYWxsZWQgb24gYWxsIGNvbnN0cnVjdHMgYmVmb3JlIHN5bnRoZXNpcy5cbiAgICpcbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvciBtZXNzYWdlcywgb3IgYW4gZW1wdHkgYXJyYXkgaWYgdGhlcmUgdGhlIGNvbnN0cnVjdCBpcyB2YWxpZC5cbiAgICovXG4gIHZhbGlkYXRlKCk6IHN0cmluZ1tdO1xufVxuXG4vKipcbiAqIEluIHdoYXQgb3JkZXIgdG8gcmV0dXJuIGNvbnN0cnVjdHNcbiAqL1xuZXhwb3J0IGVudW0gQ29uc3RydWN0T3JkZXIge1xuICAvKipcbiAgICogRGVwdGgtZmlyc3QsIHByZS1vcmRlclxuICAgKi9cbiAgUFJFT1JERVIsXG5cbiAgLyoqXG4gICAqIERlcHRoLWZpcnN0LCBwb3N0LW9yZGVyIChsZWFmIG5vZGVzIGZpcnN0KVxuICAgKi9cbiAgUE9TVE9SREVSXG59XG5cbi8qKlxuICogSW1wbGVtZW50IHRoaXMgaW50ZXJmYWNlIGluIG9yZGVyIGZvciB0aGUgY29uc3RydWN0IHRvIGJlIGFibGUgdG8gdmFsaWRhdGUgaXRzZWxmLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElWYWxpZGF0aW9uIHtcbiAgLyoqXG4gICAqIFZhbGlkYXRlIHRoZSBjdXJyZW50IGNvbnN0cnVjdC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgY2FuIGJlIGltcGxlbWVudGVkIGJ5IGRlcml2ZWQgY29uc3RydWN0cyBpbiBvcmRlciB0byBwZXJmb3JtXG4gICAqIHZhbGlkYXRpb24gbG9naWMuIEl0IGlzIGNhbGxlZCBvbiBhbGwgY29uc3RydWN0cyBiZWZvcmUgc3ludGhlc2lzLlxuICAgKlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB2YWxpZGF0aW9uIGVycm9yIG1lc3NhZ2VzLCBvciBhbiBlbXB0eSBhcnJheSBpZiB0aGVyZSB0aGUgY29uc3RydWN0IGlzIHZhbGlkLlxuICAgKi9cbiAgdmFsaWRhdGUoKTogc3RyaW5nW107XG59XG5cbmNvbnN0IFBBVEhfU0VQX1JFR0VYID0gbmV3IFJlZ0V4cChgJHtOb2RlLlBBVEhfU0VQfWAsICdnJyk7XG5cbi8qKlxuICogUmV0dXJuIGEgc2FuaXRpemVkIHZlcnNpb24gb2YgYW4gYXJiaXRyYXJ5IHN0cmluZywgc28gaXQgY2FuIGJlIHVzZWQgYXMgYW4gSURcbiAqL1xuZnVuY3Rpb24gc2FuaXRpemVJZChpZDogc3RyaW5nKSB7XG4gIC8vIEVzY2FwZSBwYXRoIHNlcHMgYXMgZG91YmxlIGRhc2hlc1xuICByZXR1cm4gaWQucmVwbGFjZShQQVRIX1NFUF9SRUdFWCwgJy0tJyk7XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYGNvbnN0cnVjdC5hZGRNZXRhZGF0YSgpYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNZXRhZGF0YU9wdGlvbnMge1xuICAvKipcbiAgICogSW5jbHVkZSBzdGFjayB0cmFjZSB3aXRoIG1ldGFkYXRhIGVudHJ5LlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgc3RhY2tUcmFjZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEEgSmF2YVNjcmlwdCBmdW5jdGlvbiB0byBiZWdpbiB0cmFjaW5nIGZyb20uXG4gICAqXG4gICAqIFRoaXMgb3B0aW9uIGlzIGlnbm9yZWQgdW5sZXNzIGBzdGFja1RyYWNlYCBpcyBgdHJ1ZWAuXG4gICAqXG4gICAqIEBkZWZhdWx0IGFkZE1ldGFkYXRhKClcbiAgICovXG4gIHJlYWRvbmx5IHRyYWNlRnJvbUZ1bmN0aW9uPzogYW55O1xufVxuXG4vLyBNYXJrIGFsbCBpbnN0YW5jZXMgb2YgJ0NvbnN0cnVjdCdcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3QucHJvdG90eXBlLCBDT05TVFJVQ1RfU1lNLCB7XG4gIHZhbHVlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxufSk7Il19

/***/ }),

/***/ 6915:
/***/ ((__unused_webpack_module, exports) => {


var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Dependable = exports.DependencyGroup = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
/**
 * A set of constructs to be used as a dependable
 *
 * This class can be used when a set of constructs which are disjoint in the
 * construct tree needs to be combined to be used as a single dependable.
 *
 * @experimental
 */
class DependencyGroup {
    constructor(...deps) {
        this._deps = new Array();
        const self = this;
        Dependable.implement(this, {
            get dependencyRoots() {
                const result = new Array();
                for (const d of self._deps) {
                    result.push(...Dependable.of(d).dependencyRoots);
                }
                return result;
            },
        });
        this.add(...deps);
    }
    /**
     * Add a construct to the dependency roots
     */
    add(...scopes) {
        this._deps.push(...scopes);
    }
}
exports.DependencyGroup = DependencyGroup;
_a = JSII_RTTI_SYMBOL_1;
DependencyGroup[_a] = { fqn: "constructs.DependencyGroup", version: "10.1.23" };
const DEPENDABLE_SYMBOL = Symbol.for('@aws-cdk/core.DependableTrait');
/**
 * Trait for IDependable
 *
 * Traits are interfaces that are privately implemented by objects. Instead of
 * showing up in the public interface of a class, they need to be queried
 * explicitly. This is used to implement certain framework features that are
 * not intended to be used by Construct consumers, and so should be hidden
 * from accidental use.
 *
 * @example
 *
 * // Usage
 * const roots = DependableTrait.get(construct).dependencyRoots;
 *
 * // Definition
 * DependableTrait.implement(construct, {
 *   get dependencyRoots() { return []; }
 * });
 *
 * @experimental
 */
class Dependable {
    /**
     * Turn any object into an IDependable.
     */
    static implement(instance, trait) {
        // I would also like to reference classes (to cut down on the list of objects
        // we need to manage), but we can't do that either since jsii doesn't have the
        // concept of a class reference.
        instance[DEPENDABLE_SYMBOL] = trait;
    }
    /**
     * Return the matching Dependable for the given class instance.
     */
    static of(instance) {
        const ret = instance[DEPENDABLE_SYMBOL];
        if (!ret) {
            throw new Error(`${instance} does not implement IDependable. Use "Dependable.implement()" to implement`);
        }
        return ret;
    }
    /**
     * Return the matching Dependable for the given class instance.
     * @deprecated use `of`
     */
    static get(instance) {
        return this.of(instance);
    }
}
exports.Dependable = Dependable;
_b = JSII_RTTI_SYMBOL_1;
Dependable[_b] = { fqn: "constructs.Dependable", version: "10.1.23" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwZW5kZW5jeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9kZXBlbmRlbmN5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBaUJBOzs7Ozs7O0dBT0c7QUFDSCxNQUFhLGVBQWU7SUFHMUIsWUFBWSxHQUFHLElBQW1CO1FBRmpCLFVBQUssR0FBRyxJQUFJLEtBQUssRUFBZSxDQUFDO1FBR2hELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUVsQixVQUFVLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRTtZQUN6QixJQUFJLGVBQWU7Z0JBQ2pCLE1BQU0sTUFBTSxHQUFHLElBQUksS0FBSyxFQUFjLENBQUM7Z0JBQ3ZDLEtBQUssTUFBTSxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtvQkFDMUIsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUM7aUJBQ2xEO2dCQUNELE9BQU8sTUFBTSxDQUFDO1lBQ2hCLENBQUM7U0FDRixDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7SUFDcEIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksR0FBRyxDQUFDLEdBQUcsTUFBcUI7UUFDakMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQztJQUM3QixDQUFDOztBQXhCSCwwQ0F5QkM7OztBQUVELE1BQU0saUJBQWlCLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO0FBRXRFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW9CRztBQUNILE1BQXNCLFVBQVU7SUFDOUI7O09BRUc7SUFDSSxNQUFNLENBQUMsU0FBUyxDQUFDLFFBQXFCLEVBQUUsS0FBaUI7UUFDOUQsNkVBQTZFO1FBQzdFLDhFQUE4RTtRQUM5RSxnQ0FBZ0M7UUFDL0IsUUFBZ0IsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUMvQyxDQUFDO0lBRUQ7O09BRUc7SUFDSSxNQUFNLENBQUMsRUFBRSxDQUFDLFFBQXFCO1FBQ3BDLE1BQU0sR0FBRyxHQUFJLFFBQWdCLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUNqRCxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ1IsTUFBTSxJQUFJLEtBQUssQ0FBQyxHQUFHLFFBQVEsNEVBQTRFLENBQUMsQ0FBQztTQUMxRztRQUNELE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztJQUVEOzs7T0FHRztJQUNJLE1BQU0sQ0FBQyxHQUFHLENBQUMsUUFBcUI7UUFDckMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzNCLENBQUM7O0FBNUJILGdDQXFDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElDb25zdHJ1Y3QgfSBmcm9tICcuL2NvbnN0cnVjdCc7XG5cbi8qKlxuICogVHJhaXQgbWFya2VyIGZvciBjbGFzc2VzIHRoYXQgY2FuIGJlIGRlcGVuZGVkIHVwb25cbiAqXG4gKiBUaGUgcHJlc2VuY2Ugb2YgdGhpcyBpbnRlcmZhY2UgaW5kaWNhdGVzIHRoYXQgYW4gb2JqZWN0IGhhc1xuICogYW4gYElEZXBlbmRhYmxlVHJhaXRgIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFRoaXMgaW50ZXJmYWNlIGNhbiBiZSB1c2VkIHRvIHRha2UgYW4gKG9yZGVyaW5nKSBkZXBlbmRlbmN5IG9uIGEgc2V0IG9mXG4gKiBjb25zdHJ1Y3RzLiBBbiBvcmRlcmluZyBkZXBlbmRlbmN5IGltcGxpZXMgdGhhdCB0aGUgcmVzb3VyY2VzIHJlcHJlc2VudGVkIGJ5XG4gKiB0aG9zZSBjb25zdHJ1Y3RzIGFyZSBkZXBsb3llZCBiZWZvcmUgdGhlIHJlc291cmNlcyBkZXBlbmRpbmcgT04gdGhlbSBhcmVcbiAqIGRlcGxveWVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElEZXBlbmRhYmxlIHtcbiAgLy8gRW1wdHksIHRoaXMgaW50ZXJmYWNlIGlzIGEgdHJhaXQgbWFya2VyXG59XG5cbi8qKlxuICogQSBzZXQgb2YgY29uc3RydWN0cyB0byBiZSB1c2VkIGFzIGEgZGVwZW5kYWJsZVxuICpcbiAqIFRoaXMgY2xhc3MgY2FuIGJlIHVzZWQgd2hlbiBhIHNldCBvZiBjb25zdHJ1Y3RzIHdoaWNoIGFyZSBkaXNqb2ludCBpbiB0aGVcbiAqIGNvbnN0cnVjdCB0cmVlIG5lZWRzIHRvIGJlIGNvbWJpbmVkIHRvIGJlIHVzZWQgYXMgYSBzaW5nbGUgZGVwZW5kYWJsZS5cbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBjbGFzcyBEZXBlbmRlbmN5R3JvdXAgaW1wbGVtZW50cyBJRGVwZW5kYWJsZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgX2RlcHMgPSBuZXcgQXJyYXk8SURlcGVuZGFibGU+KCk7XG5cbiAgY29uc3RydWN0b3IoLi4uZGVwczogSURlcGVuZGFibGVbXSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgRGVwZW5kYWJsZS5pbXBsZW1lbnQodGhpcywge1xuICAgICAgZ2V0IGRlcGVuZGVuY3lSb290cygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5PElDb25zdHJ1Y3Q+KCk7XG4gICAgICAgIGZvciAoY29uc3QgZCBvZiBzZWxmLl9kZXBzKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goLi4uRGVwZW5kYWJsZS5vZihkKS5kZXBlbmRlbmN5Um9vdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgdGhpcy5hZGQoLi4uZGVwcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgY29uc3RydWN0IHRvIHRoZSBkZXBlbmRlbmN5IHJvb3RzXG4gICAqL1xuICBwdWJsaWMgYWRkKC4uLnNjb3BlczogSURlcGVuZGFibGVbXSkge1xuICAgIHRoaXMuX2RlcHMucHVzaCguLi5zY29wZXMpO1xuICB9XG59XG5cbmNvbnN0IERFUEVOREFCTEVfU1lNQk9MID0gU3ltYm9sLmZvcignQGF3cy1jZGsvY29yZS5EZXBlbmRhYmxlVHJhaXQnKTtcblxuLyoqXG4gKiBUcmFpdCBmb3IgSURlcGVuZGFibGVcbiAqXG4gKiBUcmFpdHMgYXJlIGludGVyZmFjZXMgdGhhdCBhcmUgcHJpdmF0ZWx5IGltcGxlbWVudGVkIGJ5IG9iamVjdHMuIEluc3RlYWQgb2ZcbiAqIHNob3dpbmcgdXAgaW4gdGhlIHB1YmxpYyBpbnRlcmZhY2Ugb2YgYSBjbGFzcywgdGhleSBuZWVkIHRvIGJlIHF1ZXJpZWRcbiAqIGV4cGxpY2l0bHkuIFRoaXMgaXMgdXNlZCB0byBpbXBsZW1lbnQgY2VydGFpbiBmcmFtZXdvcmsgZmVhdHVyZXMgdGhhdCBhcmVcbiAqIG5vdCBpbnRlbmRlZCB0byBiZSB1c2VkIGJ5IENvbnN0cnVjdCBjb25zdW1lcnMsIGFuZCBzbyBzaG91bGQgYmUgaGlkZGVuXG4gKiBmcm9tIGFjY2lkZW50YWwgdXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gVXNhZ2VcbiAqIGNvbnN0IHJvb3RzID0gRGVwZW5kYWJsZVRyYWl0LmdldChjb25zdHJ1Y3QpLmRlcGVuZGVuY3lSb290cztcbiAqXG4gKiAvLyBEZWZpbml0aW9uXG4gKiBEZXBlbmRhYmxlVHJhaXQuaW1wbGVtZW50KGNvbnN0cnVjdCwge1xuICogICBnZXQgZGVwZW5kZW5jeVJvb3RzKCkgeyByZXR1cm4gW107IH1cbiAqIH0pO1xuICpcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIERlcGVuZGFibGUge1xuICAvKipcbiAgICogVHVybiBhbnkgb2JqZWN0IGludG8gYW4gSURlcGVuZGFibGUuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGltcGxlbWVudChpbnN0YW5jZTogSURlcGVuZGFibGUsIHRyYWl0OiBEZXBlbmRhYmxlKSB7XG4gICAgLy8gSSB3b3VsZCBhbHNvIGxpa2UgdG8gcmVmZXJlbmNlIGNsYXNzZXMgKHRvIGN1dCBkb3duIG9uIHRoZSBsaXN0IG9mIG9iamVjdHNcbiAgICAvLyB3ZSBuZWVkIHRvIG1hbmFnZSksIGJ1dCB3ZSBjYW4ndCBkbyB0aGF0IGVpdGhlciBzaW5jZSBqc2lpIGRvZXNuJ3QgaGF2ZSB0aGVcbiAgICAvLyBjb25jZXB0IG9mIGEgY2xhc3MgcmVmZXJlbmNlLlxuICAgIChpbnN0YW5jZSBhcyBhbnkpW0RFUEVOREFCTEVfU1lNQk9MXSA9IHRyYWl0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWF0Y2hpbmcgRGVwZW5kYWJsZSBmb3IgdGhlIGdpdmVuIGNsYXNzIGluc3RhbmNlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBvZihpbnN0YW5jZTogSURlcGVuZGFibGUpOiBEZXBlbmRhYmxlIHtcbiAgICBjb25zdCByZXQgPSAoaW5zdGFuY2UgYXMgYW55KVtERVBFTkRBQkxFX1NZTUJPTF07XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtpbnN0YW5jZX0gZG9lcyBub3QgaW1wbGVtZW50IElEZXBlbmRhYmxlLiBVc2UgXCJEZXBlbmRhYmxlLmltcGxlbWVudCgpXCIgdG8gaW1wbGVtZW50YCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBtYXRjaGluZyBEZXBlbmRhYmxlIGZvciB0aGUgZ2l2ZW4gY2xhc3MgaW5zdGFuY2UuXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgb2ZgXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdldChpbnN0YW5jZTogSURlcGVuZGFibGUpOiBEZXBlbmRhYmxlIHtcbiAgICByZXR1cm4gdGhpcy5vZihpbnN0YW5jZSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHNldCBvZiBjb25zdHJ1Y3RzIHRoYXQgZm9ybSB0aGUgcm9vdCBvZiB0aGlzIGRlcGVuZGFibGVcbiAgICpcbiAgICogQWxsIHJlc291cmNlcyB1bmRlciBhbGwgcmV0dXJuZWQgY29uc3RydWN0cyBhcmUgaW5jbHVkZWQgaW4gdGhlIG9yZGVyaW5nXG4gICAqIGRlcGVuZGVuY3kuXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgZGVwZW5kZW5jeVJvb3RzOiBJQ29uc3RydWN0W107XG59XG4iXX0=

/***/ }),

/***/ 1963:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__nccwpck_require__(3928), exports);
__exportStar(__nccwpck_require__(1523), exports);
__exportStar(__nccwpck_require__(6915), exports);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsOENBQTRCO0FBQzVCLDZDQUEyQjtBQUMzQiwrQ0FBNkIiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2NvbnN0cnVjdCc7XG5leHBvcnQgKiBmcm9tICcuL21ldGFkYXRhJztcbmV4cG9ydCAqIGZyb20gJy4vZGVwZW5kZW5jeSc7Il19

/***/ }),

/***/ 1523:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWV0YWRhdGEuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvbWV0YWRhdGEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQW4gZW50cnkgaW4gdGhlIGNvbnN0cnVjdCBtZXRhZGF0YSB0YWJsZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNZXRhZGF0YUVudHJ5IHtcbiAgLyoqXG4gICAqIFRoZSBtZXRhZGF0YSBlbnRyeSB0eXBlLlxuICAgKi9cbiAgcmVhZG9ubHkgdHlwZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZGF0YS5cbiAgICovXG4gIHJlYWRvbmx5IGRhdGE6IGFueTtcblxuICAvKipcbiAgICogU3RhY2sgdHJhY2UgYXQgdGhlIHBvaW50IG9mIGFkZGluZyB0aGUgbWV0YWRhdGEuXG4gICAqXG4gICAqIE9ubHkgYXZhaWxhYmxlIGlmIGBhZGRNZXRhZGF0YSgpYCBpcyBjYWxsZWQgd2l0aCBgc3RhY2tUcmFjZTogdHJ1ZWAuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gbm8gdHJhY2UgaW5mb3JtYXRpb25cbiAgICovXG4gIHJlYWRvbmx5IHRyYWNlPzogc3RyaW5nW107XG59XG4iXX0=

/***/ }),

/***/ 7553:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.captureStackTrace = void 0;
// tslint:disable-next-line:ban-types
function captureStackTrace(below) {
    below = below || captureStackTrace; // hide myself if nothing else
    const object = { stack: '' };
    const previousLimit = Error.stackTraceLimit;
    try {
        Error.stackTraceLimit = Number.MAX_SAFE_INTEGER;
        Error.captureStackTrace(object, below);
    }
    finally {
        Error.stackTraceLimit = previousLimit;
    }
    if (!object.stack) {
        return [];
    }
    return object.stack.split('\n').slice(1).map(s => s.replace(/^\s*at\s+/, ''));
}
exports.captureStackTrace = captureStackTrace;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhY2stdHJhY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcHJpdmF0ZS9zdGFjay10cmFjZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxxQ0FBcUM7QUFDckMsU0FBZ0IsaUJBQWlCLENBQUMsS0FBZ0I7SUFDaEQsS0FBSyxHQUFHLEtBQUssSUFBSSxpQkFBaUIsQ0FBQyxDQUFDLDhCQUE4QjtJQUNsRSxNQUFNLE1BQU0sR0FBRyxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsQ0FBQztJQUM3QixNQUFNLGFBQWEsR0FBRyxLQUFLLENBQUMsZUFBZSxDQUFDO0lBQzVDLElBQUk7UUFDRixLQUFLLENBQUMsZUFBZSxHQUFHLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztRQUNoRCxLQUFLLENBQUMsaUJBQWlCLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO0tBQ3hDO1lBQVM7UUFDUixLQUFLLENBQUMsZUFBZSxHQUFHLGFBQWEsQ0FBQztLQUN2QztJQUNELElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFO1FBQ2pCLE9BQU8sRUFBRSxDQUFDO0tBQ1g7SUFDRCxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ2hGLENBQUM7QUFkRCw4Q0FjQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpiYW4tdHlwZXNcbmV4cG9ydCBmdW5jdGlvbiBjYXB0dXJlU3RhY2tUcmFjZShiZWxvdz86IEZ1bmN0aW9uKTogc3RyaW5nW10ge1xuICBiZWxvdyA9IGJlbG93IHx8IGNhcHR1cmVTdGFja1RyYWNlOyAvLyBoaWRlIG15c2VsZiBpZiBub3RoaW5nIGVsc2VcbiAgY29uc3Qgb2JqZWN0ID0geyBzdGFjazogJycgfTtcbiAgY29uc3QgcHJldmlvdXNMaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdDtcbiAgdHJ5IHtcbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShvYmplY3QsIGJlbG93KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBwcmV2aW91c0xpbWl0O1xuICB9XG4gIGlmICghb2JqZWN0LnN0YWNrKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBvYmplY3Quc3RhY2suc3BsaXQoJ1xcbicpLnNsaWNlKDEpLm1hcChzID0+IHMucmVwbGFjZSgvXlxccyphdFxccysvLCAnJykpO1xufVxuIl19

/***/ }),

/***/ 5550:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addressOf = void 0;
const crypto = __nccwpck_require__(6113);
/**
 * Resources with this ID are complete hidden from the logical ID calculation.
 */
const HIDDEN_ID = 'Default';
/**
 * Calculates the construct uid based on path components.
 *
 * Components named `Default` (case sensitive) are excluded from uid calculation
 * to allow tree refactorings.
 *
 * @param components path components
 */
function addressOf(components) {
    const hash = crypto.createHash('sha1');
    for (const c of components) {
        // skip components called "Default" to enable refactorings
        if (c === HIDDEN_ID) {
            continue;
        }
        hash.update(c);
        hash.update('\n');
    }
    // prefix with "c8" so to ensure it starts with non-digit.
    return 'c8' + hash.digest('hex');
}
exports.addressOf = addressOf;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW5pcXVlaWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcHJpdmF0ZS91bmlxdWVpZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxpQ0FBaUM7QUFFakM7O0dBRUc7QUFDSCxNQUFNLFNBQVMsR0FBRyxTQUFTLENBQUM7QUFFNUI7Ozs7Ozs7R0FPRztBQUNILFNBQWdCLFNBQVMsQ0FBQyxVQUFvQjtJQUM1QyxNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3ZDLEtBQUssTUFBTSxDQUFDLElBQUksVUFBVSxFQUFFO1FBQzFCLDBEQUEwRDtRQUMxRCxJQUFJLENBQUMsS0FBSyxTQUFTLEVBQUU7WUFBRSxTQUFTO1NBQUU7UUFFbEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNmLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDbkI7SUFFRCwwREFBMEQ7SUFDMUQsT0FBTyxJQUFJLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNuQyxDQUFDO0FBWkQsOEJBWUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjcnlwdG8gZnJvbSAnY3J5cHRvJztcblxuLyoqXG4gKiBSZXNvdXJjZXMgd2l0aCB0aGlzIElEIGFyZSBjb21wbGV0ZSBoaWRkZW4gZnJvbSB0aGUgbG9naWNhbCBJRCBjYWxjdWxhdGlvbi5cbiAqL1xuY29uc3QgSElEREVOX0lEID0gJ0RlZmF1bHQnO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGNvbnN0cnVjdCB1aWQgYmFzZWQgb24gcGF0aCBjb21wb25lbnRzLlxuICpcbiAqIENvbXBvbmVudHMgbmFtZWQgYERlZmF1bHRgIChjYXNlIHNlbnNpdGl2ZSkgYXJlIGV4Y2x1ZGVkIGZyb20gdWlkIGNhbGN1bGF0aW9uXG4gKiB0byBhbGxvdyB0cmVlIHJlZmFjdG9yaW5ncy5cbiAqXG4gKiBAcGFyYW0gY29tcG9uZW50cyBwYXRoIGNvbXBvbmVudHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZHJlc3NPZihjb21wb25lbnRzOiBzdHJpbmdbXSkge1xuICBjb25zdCBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKTtcbiAgZm9yIChjb25zdCBjIG9mIGNvbXBvbmVudHMpIHtcbiAgICAvLyBza2lwIGNvbXBvbmVudHMgY2FsbGVkIFwiRGVmYXVsdFwiIHRvIGVuYWJsZSByZWZhY3RvcmluZ3NcbiAgICBpZiAoYyA9PT0gSElEREVOX0lEKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBoYXNoLnVwZGF0ZShjKTtcbiAgICBoYXNoLnVwZGF0ZSgnXFxuJyk7XG4gIH1cblxuICAvLyBwcmVmaXggd2l0aCBcImM4XCIgc28gdG8gZW5zdXJlIGl0IHN0YXJ0cyB3aXRoIG5vbi1kaWdpdC5cbiAgcmV0dXJuICdjOCcgKyBoYXNoLmRpZ2VzdCgnaGV4Jyk7XG59XG4iXX0=

/***/ }),

/***/ 4294:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(4219);


/***/ }),

/***/ 4219:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var net = __nccwpck_require__(1808);
var tls = __nccwpck_require__(4404);
var http = __nccwpck_require__(3685);
var https = __nccwpck_require__(5687);
var events = __nccwpck_require__(2361);
var assert = __nccwpck_require__(9491);
var util = __nccwpck_require__(3837);


exports.httpOverHttp = httpOverHttp;
exports.httpsOverHttp = httpsOverHttp;
exports.httpOverHttps = httpOverHttps;
exports.httpsOverHttps = httpsOverHttps;


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  return agent;
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  return agent;
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}


function TunnelingAgent(options) {
  var self = this;
  self.options = options || {};
  self.proxyOptions = self.options.proxy || {};
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
  self.requests = [];
  self.sockets = [];

  self.on('free', function onFree(socket, host, port, localAddress) {
    var options = toOptions(host, port, localAddress);
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i];
      if (pending.host === options.host && pending.port === options.port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1);
        pending.request.onSocket(socket);
        return;
      }
    }
    socket.destroy();
    self.removeSocket(socket);
  });
}
util.inherits(TunnelingAgent, events.EventEmitter);

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
  var self = this;
  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push(options);
    return;
  }

  // If we are under maxSockets create a new one.
  self.createSocket(options, function(socket) {
    socket.on('free', onFree);
    socket.on('close', onCloseOrRemove);
    socket.on('agentRemove', onCloseOrRemove);
    req.onSocket(socket);

    function onFree() {
      self.emit('free', socket, options);
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket);
      socket.removeListener('free', onFree);
      socket.removeListener('close', onCloseOrRemove);
      socket.removeListener('agentRemove', onCloseOrRemove);
    }
  });
};

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this;
  var placeholder = {};
  self.sockets.push(placeholder);

  var connectOptions = mergeOptions({}, self.proxyOptions, {
    method: 'CONNECT',
    path: options.host + ':' + options.port,
    agent: false,
    headers: {
      host: options.host + ':' + options.port
    }
  });
  if (options.localAddress) {
    connectOptions.localAddress = options.localAddress;
  }
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {};
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth).toString('base64');
  }

  debug('making CONNECT request');
  var connectReq = self.request(connectOptions);
  connectReq.useChunkedEncodingByDefault = false; // for v0.6
  connectReq.once('response', onResponse); // for v0.6
  connectReq.once('upgrade', onUpgrade);   // for v0.6
  connectReq.once('connect', onConnect);   // for v0.7 or later
  connectReq.once('error', onError);
  connectReq.end();

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true;
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head);
    });
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners();
    socket.removeAllListeners();

    if (res.statusCode !== 200) {
      debug('tunneling socket could not be established, statusCode=%d',
        res.statusCode);
      socket.destroy();
      var error = new Error('tunneling socket could not be established, ' +
        'statusCode=' + res.statusCode);
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    if (head.length > 0) {
      debug('got illegal response body from proxy');
      socket.destroy();
      var error = new Error('got illegal response body from proxy');
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    debug('tunneling connection has established');
    self.sockets[self.sockets.indexOf(placeholder)] = socket;
    return cb(socket);
  }

  function onError(cause) {
    connectReq.removeAllListeners();

    debug('tunneling socket could not be established, cause=%s\n',
          cause.message, cause.stack);
    var error = new Error('tunneling socket could not be established, ' +
                          'cause=' + cause.message);
    error.code = 'ECONNRESET';
    options.request.emit('error', error);
    self.removeSocket(placeholder);
  }
};

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) {
    return;
  }
  this.sockets.splice(pos, 1);

  var pending = this.requests.shift();
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket) {
      pending.request.onSocket(socket);
    });
  }
};

function createSecureSocket(options, cb) {
  var self = this;
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    var hostHeader = options.request.getHeader('host');
    var tlsOptions = mergeOptions({}, self.options, {
      socket: socket,
      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
    });

    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, tlsOptions);
    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
    cb(secureSocket);
  });
}


function toOptions(host, port, localAddress) {
  if (typeof host === 'string') { // since v0.10
    return {
      host: host,
      port: port,
      localAddress: localAddress
    };
  }
  return host; // for v0.11 or later
}

function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i];
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides);
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j];
        if (overrides[k] !== undefined) {
          target[k] = overrides[k];
        }
      }
    }
  }
  return target;
}


var debug;
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0];
    } else {
      args.unshift('TUNNEL:');
    }
    console.error.apply(console, args);
  }
} else {
  debug = function() {};
}
exports.debug = debug; // for test


/***/ }),

/***/ 9491:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("assert");

/***/ }),

/***/ 2081:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("child_process");

/***/ }),

/***/ 6113:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("crypto");

/***/ }),

/***/ 2361:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("events");

/***/ }),

/***/ 7147:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("fs");

/***/ }),

/***/ 3685:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("http");

/***/ }),

/***/ 5687:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("https");

/***/ }),

/***/ 1808:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("net");

/***/ }),

/***/ 2037:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("os");

/***/ }),

/***/ 1017:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("path");

/***/ }),

/***/ 4404:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("tls");

/***/ }),

/***/ 3837:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("util");

/***/ }),

/***/ 6430:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Node = __nccwpck_require__(9464);
var Scalar = __nccwpck_require__(3229);
var resolveBlockMap = __nccwpck_require__(4787);
var resolveBlockSeq = __nccwpck_require__(8970);
var resolveFlowCollection = __nccwpck_require__(5363);

function composeCollection(CN, ctx, token, tagToken, onError) {
    let coll;
    switch (token.type) {
        case 'block-map': {
            coll = resolveBlockMap.resolveBlockMap(CN, ctx, token, onError);
            break;
        }
        case 'block-seq': {
            coll = resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError);
            break;
        }
        case 'flow-collection': {
            coll = resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError);
            break;
        }
    }
    if (!tagToken)
        return coll;
    const tagName = ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));
    if (!tagName)
        return coll;
    // Cast needed due to: https://github.com/Microsoft/TypeScript/issues/3841
    const Coll = coll.constructor;
    if (tagName === '!' || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
    }
    const expType = Node.isMap(coll) ? 'map' : 'seq';
    let tag = ctx.schema.tags.find(t => t.collection === expType && t.tag === tagName);
    if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
            tag = kt;
        }
        else {
            onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);
            coll.tag = tagName;
            return coll;
        }
    }
    const res = tag.resolve(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options);
    const node = Node.isNode(res)
        ? res
        : new Scalar.Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag === null || tag === void 0 ? void 0 : tag.format)
        node.format = tag.format;
    return node;
}

exports.composeCollection = composeCollection;


/***/ }),

/***/ 1341:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Document = __nccwpck_require__(5663);
var composeNode = __nccwpck_require__(8769);
var resolveEnd = __nccwpck_require__(392);
var resolveProps = __nccwpck_require__(8134);

function composeDoc(options, directives, { offset, start, value, end }, onError) {
    const opts = Object.assign({ directives }, options);
    const doc = new Document.Document(undefined, opts);
    const ctx = {
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
    };
    const props = resolveProps.resolveProps(start, {
        indicator: 'doc-start',
        next: value || (end === null || end === void 0 ? void 0 : end[0]),
        offset,
        onError,
        startOnNewline: true
    });
    if (props.found) {
        doc.directives.marker = true;
        if (value &&
            (value.type === 'block-map' || value.type === 'block-seq') &&
            !props.hasNewline)
            onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');
    }
    doc.contents = value
        ? composeNode.composeNode(ctx, value, props, onError)
        : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
    if (re.comment)
        doc.comment = re.comment;
    doc.range = [offset, contentEnd, re.offset];
    return doc;
}

exports.composeDoc = composeDoc;


/***/ }),

/***/ 8769:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Alias = __nccwpck_require__(2484);
var composeCollection = __nccwpck_require__(6430);
var composeScalar = __nccwpck_require__(4065);
var resolveEnd = __nccwpck_require__(392);
var utilEmptyScalarPosition = __nccwpck_require__(2423);

const CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
    const { spaceBefore, comment, anchor, tag } = props;
    let node;
    switch (token.type) {
        case 'alias':
            node = composeAlias(ctx, token, onError);
            if (anchor || tag)
                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');
            break;
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'block-scalar':
            node = composeScalar.composeScalar(ctx, token, tag, onError);
            if (anchor)
                node.anchor = anchor.source.substring(1);
            break;
        case 'block-map':
        case 'block-seq':
        case 'flow-collection':
            node = composeCollection.composeCollection(CN, ctx, token, tag, onError);
            if (anchor)
                node.anchor = anchor.source.substring(1);
            break;
        default:
            console.log(token);
            throw new Error(`Unsupporten token type: ${token.type}`);
    }
    if (anchor && node.anchor === '')
        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
    if (spaceBefore)
        node.spaceBefore = true;
    if (comment) {
        if (token.type === 'scalar' && token.source === '')
            node.comment = comment;
        else
            node.commentBefore = comment;
    }
    return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag }, onError) {
    const token = {
        type: 'scalar',
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ''
    };
    const node = composeScalar.composeScalar(ctx, token, tag, onError);
    if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === '')
            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
    }
    if (spaceBefore)
        node.spaceBefore = true;
    if (comment)
        node.comment = comment;
    return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
    const alias = new Alias.Alias(source.substring(1));
    if (alias.source === '')
        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [offset, valueEnd, re.offset];
    if (re.comment)
        alias.comment = re.comment;
    return alias;
}

exports.composeEmptyNode = composeEmptyNode;
exports.composeNode = composeNode;


/***/ }),

/***/ 4065:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Node = __nccwpck_require__(9464);
var Scalar = __nccwpck_require__(3229);
var resolveBlockScalar = __nccwpck_require__(221);
var resolveFlowScalar = __nccwpck_require__(7231);

function composeScalar(ctx, token, tagToken, onError) {
    const { value, type, comment, range } = token.type === 'block-scalar'
        ? resolveBlockScalar.resolveBlockScalar(token, ctx.options.strict, onError)
        : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken
        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))
        : null;
    const tag = tagToken && tagName
        ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError)
        : findScalarTagByTest(ctx.schema, value, token.type === 'scalar');
    let scalar;
    try {
        const res = tag.resolve(value, msg => onError(tagToken || token, 'TAG_RESOLVE_FAILED', msg), ctx.options);
        scalar = Node.isScalar(res) ? res : new Scalar.Scalar(res);
    }
    catch (error) {
        onError(tagToken || token, 'TAG_RESOLVE_FAILED', error.message);
        scalar = new Scalar.Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type)
        scalar.type = type;
    if (tagName)
        scalar.tag = tagName;
    if (tag.format)
        scalar.format = tag.format;
    if (comment)
        scalar.comment = comment;
    return scalar;
}
function findScalarTagByName(schema, value, tagName, tagToken, onError) {
    var _a;
    if (tagName === '!')
        return schema[Node.SCALAR]; // non-specific tag
    const matchWithTest = [];
    for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
            if (tag.default && tag.test)
                matchWithTest.push(tag);
            else
                return tag;
        }
    }
    for (const tag of matchWithTest)
        if ((_a = tag.test) === null || _a === void 0 ? void 0 : _a.test(value))
            return tag;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
        // Ensure that the known tag is available for stringifying,
        // but does not get used by default.
        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));
        return kt;
    }
    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');
    return schema[Node.SCALAR];
}
function findScalarTagByTest(schema, value, apply) {
    var _a;
    if (apply) {
        for (const tag of schema.tags) {
            if (tag.default && ((_a = tag.test) === null || _a === void 0 ? void 0 : _a.test(value)))
                return tag;
        }
    }
    return schema[Node.SCALAR];
}

exports.composeScalar = composeScalar;


/***/ }),

/***/ 2920:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var directives = __nccwpck_require__(1348);
var Document = __nccwpck_require__(5663);
var errors = __nccwpck_require__(9043);
var Node = __nccwpck_require__(9464);
var options = __nccwpck_require__(5281);
var composeDoc = __nccwpck_require__(1341);
var resolveEnd = __nccwpck_require__(392);

function getErrorPos(src) {
    if (typeof src === 'number')
        return [src, src + 1];
    if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
    const { offset, source } = src;
    return [offset, offset + (typeof source === 'string' ? source.length : 1)];
}
function parsePrelude(prelude) {
    var _a;
    let comment = '';
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0; i < prelude.length; ++i) {
        const source = prelude[i];
        switch (source[0]) {
            case '#':
                comment +=
                    (comment === '' ? '' : afterEmptyLine ? '\n\n' : '\n') +
                        (source.substring(1) || ' ');
                atComment = true;
                afterEmptyLine = false;
                break;
            case '%':
                if (((_a = prelude[i + 1]) === null || _a === void 0 ? void 0 : _a[0]) !== '#')
                    i += 1;
                atComment = false;
                break;
            default:
                // This may be wrong after doc-end, but in that case it doesn't matter
                if (!atComment)
                    afterEmptyLine = true;
                atComment = false;
        }
    }
    return { comment, afterEmptyLine };
}
/**
 * Compose a stream of CST nodes into a stream of YAML Documents.
 *
 * ```ts
 * import { Composer, Parser } from 'yaml'
 *
 * const src: string = ...
 * const tokens = new Parser().parse(src)
 * const docs = new Composer().compose(tokens)
 * ```
 */
class Composer {
    constructor(options$1 = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
            const pos = getErrorPos(source);
            if (warning)
                this.warnings.push(new errors.YAMLWarning(pos, code, message));
            else
                this.errors.push(new errors.YAMLParseError(pos, code, message));
        };
        this.directives = new directives.Directives({
            version: options$1.version || options.defaultOptions.version
        });
        this.options = options$1;
    }
    decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        //console.log({ dc: doc.comment, prelude, comment })
        if (comment) {
            const dc = doc.contents;
            if (afterDoc) {
                doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment;
            }
            else if (afterEmptyLine || doc.directives.marker || !dc) {
                doc.commentBefore = comment;
            }
            else if (Node.isCollection(dc) && !dc.flow && dc.items.length > 0) {
                let it = dc.items[0];
                if (Node.isPair(it))
                    it = it.key;
                const cb = it.commentBefore;
                it.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
            else {
                const cb = dc.commentBefore;
                dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
        }
        if (afterDoc) {
            Array.prototype.push.apply(doc.errors, this.errors);
            Array.prototype.push.apply(doc.warnings, this.warnings);
        }
        else {
            doc.errors = this.errors;
            doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
    }
    /**
     * Current stream status information.
     *
     * Mostly useful at the end of input for an empty stream.
     */
    streamInfo() {
        return {
            comment: parsePrelude(this.prelude).comment,
            directives: this.directives,
            errors: this.errors,
            warnings: this.warnings
        };
    }
    /**
     * Compose tokens into documents.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
            yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
    }
    /** Advance the composer by one CST token. */
    *next(token) {
        if (process.env.LOG_STREAM)
            console.dir(token, { depth: null });
        switch (token.type) {
            case 'directive':
                this.directives.add(token.source, (offset, message, warning) => {
                    const pos = getErrorPos(token);
                    pos[0] += offset;
                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);
                });
                this.prelude.push(token.source);
                this.atDirectives = true;
                break;
            case 'document': {
                const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
                if (this.atDirectives && !doc.directives.marker)
                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end indicator line');
                this.decorate(doc, false);
                if (this.doc)
                    yield this.doc;
                this.doc = doc;
                this.atDirectives = false;
                break;
            }
            case 'byte-order-mark':
            case 'space':
                break;
            case 'comment':
            case 'newline':
                this.prelude.push(token.source);
                break;
            case 'error': {
                const msg = token.source
                    ? `${token.message}: ${JSON.stringify(token.source)}`
                    : token.message;
                const error = new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);
                if (this.atDirectives || !this.doc)
                    this.errors.push(error);
                else
                    this.doc.errors.push(error);
                break;
            }
            case 'doc-end': {
                if (!this.doc) {
                    const msg = 'Unexpected doc-end without preceding document';
                    this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));
                    break;
                }
                const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
                this.decorate(this.doc, true);
                if (end.comment) {
                    const dc = this.doc.comment;
                    this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
                }
                this.doc.range[2] = end.offset;
                break;
            }
            default:
                this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));
        }
    }
    /**
     * Call at end of input to yield any remaining document.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
            this.decorate(this.doc, true);
            yield this.doc;
            this.doc = null;
        }
        else if (forceDoc) {
            const opts = Object.assign({ directives: this.directives }, this.options);
            const doc = new Document.Document(undefined, opts);
            if (this.atDirectives)
                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');
            doc.range = [0, endOffset, endOffset];
            this.decorate(doc, false);
            yield doc;
        }
    }
}

exports.Composer = Composer;


/***/ }),

/***/ 4787:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Pair = __nccwpck_require__(5456);
var YAMLMap = __nccwpck_require__(5505);
var resolveProps = __nccwpck_require__(8134);
var utilContainsNewline = __nccwpck_require__(2387);
var utilMapIncludes = __nccwpck_require__(9138);

const startColMsg = 'All mapping items must start at the same column';
function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError) {
    var _a;
    const map = new YAMLMap.YAMLMap(ctx.schema);
    let offset = bm.offset;
    for (const { start, key, sep, value } of bm.items) {
        // key properties
        const keyProps = resolveProps.resolveProps(start, {
            indicator: 'explicit-key-ind',
            next: key || (sep === null || sep === void 0 ? void 0 : sep[0]),
            offset,
            onError,
            startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
            if (key) {
                if (key.type === 'block-seq')
                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');
                else if ('indent' in key && key.indent !== bm.indent)
                    onError(offset, 'BAD_INDENT', startColMsg);
            }
            if (!keyProps.anchor && !keyProps.tag && !sep) {
                // TODO: assert being at last item?
                if (keyProps.comment) {
                    if (map.comment)
                        map.comment += '\n' + keyProps.comment;
                    else
                        map.comment = keyProps.comment;
                }
                continue;
            }
        }
        else if (((_a = keyProps.found) === null || _a === void 0 ? void 0 : _a.indent) !== bm.indent)
            onError(offset, 'BAD_INDENT', startColMsg);
        if (implicitKey && utilContainsNewline.containsNewline(key))
            onError(key, // checked by containsNewline()
            'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');
        // key value
        const keyStart = keyProps.end;
        const keyNode = key
            ? composeNode(ctx, key, keyProps, onError)
            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
        // value properties
        const valueProps = resolveProps.resolveProps(sep || [], {
            indicator: 'map-value-ind',
            next: value,
            offset: keyNode.range[2],
            onError,
            startOnNewline: !key || key.type === 'block-scalar'
        });
        offset = valueProps.end;
        if (valueProps.found) {
            if (implicitKey) {
                if ((value === null || value === void 0 ? void 0 : value.type) === 'block-map' && !valueProps.hasNewline)
                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');
                if (ctx.options.strict &&
                    keyProps.start < valueProps.found.offset - 1024)
                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');
            }
            // value value
            const valueNode = value
                ? composeNode(ctx, value, valueProps, onError)
                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
            offset = valueNode.range[2];
            map.items.push(new Pair.Pair(keyNode, valueNode));
        }
        else {
            // key with no value
            if (implicitKey)
                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');
            if (valueProps.comment) {
                if (keyNode.comment)
                    keyNode.comment += '\n' + valueProps.comment;
                else
                    keyNode.comment = valueProps.comment;
            }
            map.items.push(new Pair.Pair(keyNode));
        }
    }
    map.range = [bm.offset, offset, offset];
    return map;
}

exports.resolveBlockMap = resolveBlockMap;


/***/ }),

/***/ 221:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Scalar = __nccwpck_require__(3229);

function resolveBlockScalar(scalar, strict, onError) {
    const start = scalar.offset;
    const header = parseBlockScalarHeader(scalar, strict, onError);
    if (!header)
        return { value: '', type: null, comment: '', range: [start, start, start] };
    const type = header.mode === '>' ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines(scalar.source) : [];
    // determine the end of content & start of chomping
    let chompStart = lines.length;
    for (let i = lines.length - 1; i >= 0; --i) {
        const content = lines[i][1];
        if (content === '' || content === '\r')
            chompStart = i;
        else
            break;
    }
    // shortcut for empty contents
    if (!scalar.source || chompStart === 0) {
        const value = header.chomp === '+' ? lines.map(line => line[0]).join('\n') : '';
        let end = start + header.length;
        if (scalar.source)
            end += scalar.source.length;
        return { value, type, comment: header.comment, range: [start, end, end] };
    }
    // find the indentation level to trim from start
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0; i < chompStart; ++i) {
        const [indent, content] = lines[i];
        if (content === '' || content === '\r') {
            if (header.indent === 0 && indent.length > trimIndent)
                trimIndent = indent.length;
        }
        else {
            if (indent.length < trimIndent) {
                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';
                onError(offset + indent.length, 'MISSING_CHAR', message);
            }
            if (header.indent === 0)
                trimIndent = indent.length;
            contentStart = i;
            break;
        }
        offset += indent.length + content.length + 1;
    }
    let value = '';
    let sep = '';
    let prevMoreIndented = false;
    // leading whitespace is kept intact
    for (let i = 0; i < contentStart; ++i)
        value += lines[i][0].slice(trimIndent) + '\n';
    for (let i = contentStart; i < chompStart; ++i) {
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === '\r';
        if (crlf)
            content = content.slice(0, -1);
        /* istanbul ignore if already caught in lexer */
        if (content && indent.length < trimIndent) {
            const src = header.indent
                ? 'explicit indentation indicator'
                : 'first line';
            const message = `Block scalar lines must not be less indented than their ${src}`;
            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);
            indent = '';
        }
        if (type === Scalar.Scalar.BLOCK_LITERAL) {
            value += sep + indent.slice(trimIndent) + content;
            sep = '\n';
        }
        else if (indent.length > trimIndent || content[0] === '\t') {
            // more-indented content within a folded block
            if (sep === ' ')
                sep = '\n';
            else if (!prevMoreIndented && sep === '\n')
                sep = '\n\n';
            value += sep + indent.slice(trimIndent) + content;
            sep = '\n';
            prevMoreIndented = true;
        }
        else if (content === '') {
            // empty line
            if (sep === '\n')
                value += '\n';
            else
                sep = '\n';
        }
        else {
            value += sep + content;
            sep = ' ';
            prevMoreIndented = false;
        }
    }
    switch (header.chomp) {
        case '-':
            break;
        case '+':
            for (let i = chompStart; i < lines.length; ++i)
                value += '\n' + lines[i][0].slice(trimIndent);
            if (value[value.length - 1] !== '\n')
                value += '\n';
            break;
        default:
            value += '\n';
    }
    const end = start + header.length + scalar.source.length;
    return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
    /* istanbul ignore if should not happen */
    if (props[0].type !== 'block-scalar-header') {
        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');
        return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = '';
    let error = -1;
    for (let i = 1; i < source.length; ++i) {
        const ch = source[i];
        if (!chomp && (ch === '-' || ch === '+'))
            chomp = ch;
        else {
            const n = Number(ch);
            if (!indent && n)
                indent = n;
            else if (error === -1)
                error = offset + i;
        }
    }
    if (error !== -1)
        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = '';
    let length = source.length;
    for (let i = 1; i < props.length; ++i) {
        const token = props[i];
        switch (token.type) {
            case 'space':
                hasSpace = true;
            // fallthrough
            case 'newline':
                length += token.source.length;
                break;
            case 'comment':
                if (strict && !hasSpace) {
                    const message = 'Comments must be separated from other tokens by white space characters';
                    onError(token, 'MISSING_CHAR', message);
                }
                length += token.source.length;
                comment = token.source.substring(1);
                break;
            case 'error':
                onError(token, 'UNEXPECTED_TOKEN', token.message);
                length += token.source.length;
                break;
            /* istanbul ignore next should not happen */
            default: {
                const message = `Unexpected token in block scalar header: ${token.type}`;
                onError(token, 'UNEXPECTED_TOKEN', message);
                const ts = token.source;
                if (ts && typeof ts === 'string')
                    length += ts.length;
            }
        }
    }
    return { mode, indent, chomp, comment, length };
}
/** @returns Array of lines split up as `[indent, content]` */
function splitLines(source) {
    const split = source.split(/\n( *)/);
    const first = split[0];
    const m = first.match(/^( *)/);
    const line0 = m && m[1] ? [m[1], first.slice(m[1].length)] : ['', first];
    const lines = [line0];
    for (let i = 1; i < split.length; i += 2)
        lines.push([split[i], split[i + 1]]);
    return lines;
}

exports.resolveBlockScalar = resolveBlockScalar;


/***/ }),

/***/ 8970:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var YAMLSeq = __nccwpck_require__(4967);
var resolveProps = __nccwpck_require__(8134);

function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError) {
    const seq = new YAMLSeq.YAMLSeq(ctx.schema);
    let offset = bs.offset;
    for (const { start, value } of bs.items) {
        const props = resolveProps.resolveProps(start, {
            indicator: 'seq-item-ind',
            next: value,
            offset,
            onError,
            startOnNewline: true
        });
        offset = props.end;
        if (!props.found) {
            if (props.anchor || props.tag || value) {
                if (value && value.type === 'block-seq')
                    onError(offset, 'BAD_INDENT', 'All sequence items must start at the same column');
                else
                    onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');
            }
            else {
                // TODO: assert being at last item?
                if (props.comment)
                    seq.comment = props.comment;
                continue;
            }
        }
        const node = value
            ? composeNode(ctx, value, props, onError)
            : composeEmptyNode(ctx, offset, start, null, props, onError);
        offset = node.range[2];
        seq.items.push(node);
    }
    seq.range = [bs.offset, offset, offset];
    return seq;
}

exports.resolveBlockSeq = resolveBlockSeq;


/***/ }),

/***/ 392:
/***/ ((__unused_webpack_module, exports) => {



function resolveEnd(end, offset, reqSpace, onError) {
    let comment = '';
    if (end) {
        let hasSpace = false;
        let sep = '';
        for (const token of end) {
            const { source, type } = token;
            switch (type) {
                case 'space':
                    hasSpace = true;
                    break;
                case 'comment': {
                    if (reqSpace && !hasSpace)
                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                    const cb = source.substring(1) || ' ';
                    if (!comment)
                        comment = cb;
                    else
                        comment += sep + cb;
                    sep = '';
                    break;
                }
                case 'newline':
                    if (comment)
                        sep += source;
                    hasSpace = true;
                    break;
                default:
                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);
            }
            offset += source.length;
        }
    }
    return { comment, offset };
}

exports.resolveEnd = resolveEnd;


/***/ }),

/***/ 5363:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Node = __nccwpck_require__(9464);
var Pair = __nccwpck_require__(5456);
var YAMLMap = __nccwpck_require__(5505);
var YAMLSeq = __nccwpck_require__(4967);
var resolveEnd = __nccwpck_require__(392);
var resolveProps = __nccwpck_require__(8134);
var utilContainsNewline = __nccwpck_require__(2387);
var utilMapIncludes = __nccwpck_require__(9138);

const blockMsg = 'Block collections are not allowed within flow collections';
const isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');
function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError) {
    const isMap = fc.start.source === '{';
    const fcName = isMap ? 'flow map' : 'flow sequence';
    const coll = isMap
        ? new YAMLMap.YAMLMap(ctx.schema)
        : new YAMLSeq.YAMLSeq(ctx.schema);
    coll.flow = true;
    let offset = fc.offset;
    for (let i = 0; i < fc.items.length; ++i) {
        const { start, key, sep, value } = fc.items[i];
        const props = resolveProps.resolveProps(start, {
            flow: fcName,
            indicator: 'explicit-key-ind',
            next: key || (sep === null || sep === void 0 ? void 0 : sep[0]),
            offset,
            onError,
            startOnNewline: false
        });
        if (!props.found) {
            if (!props.anchor && !props.tag && !sep && !value) {
                if (i === 0 && props.comma)
                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
                else if (i < fc.items.length - 1)
                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);
                if (props.comment) {
                    if (coll.comment)
                        coll.comment += '\n' + props.comment;
                    else
                        coll.comment = props.comment;
                }
                continue;
            }
            if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
                onError(key, // checked by containsNewline()
                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
        }
        if (i === 0) {
            if (props.comma)
                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
        }
        else {
            if (!props.comma)
                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);
            if (props.comment) {
                let prevItemComment = '';
                loop: for (const st of start) {
                    switch (st.type) {
                        case 'comma':
                        case 'space':
                            break;
                        case 'comment':
                            prevItemComment = st.source.substring(1);
                            break loop;
                        default:
                            break loop;
                    }
                }
                if (prevItemComment) {
                    let prev = coll.items[coll.items.length - 1];
                    if (Node.isPair(prev))
                        prev = prev.value || prev.key;
                    if (prev.comment)
                        prev.comment += '\n' + prevItemComment;
                    else
                        prev.comment = prevItemComment;
                    props.comment = props.comment.substring(prevItemComment.length + 1);
                }
            }
        }
        if (!isMap && !sep && !props.found) {
            // item is a value in a seq
            // → key & sep are empty, start does not include ? or :
            const valueNode = value
                ? composeNode(ctx, value, props, onError)
                : composeEmptyNode(ctx, props.end, sep, null, props, onError);
            coll.items.push(valueNode);
            offset = valueNode.range[2];
            if (isBlock(value))
                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
        }
        else {
            // item is a key+value pair
            // key value
            const keyStart = props.end;
            const keyNode = key
                ? composeNode(ctx, key, props, onError)
                : composeEmptyNode(ctx, keyStart, start, null, props, onError);
            if (isBlock(key))
                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);
            // value properties
            const valueProps = resolveProps.resolveProps(sep || [], {
                flow: fcName,
                indicator: 'map-value-ind',
                next: value,
                offset: keyNode.range[2],
                onError,
                startOnNewline: false
            });
            if (valueProps.found) {
                if (!isMap && !props.found && ctx.options.strict) {
                    if (sep)
                        for (const st of sep) {
                            if (st === valueProps.found)
                                break;
                            if (st.type === 'newline') {
                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
                                break;
                            }
                        }
                    if (props.start < valueProps.found.offset - 1024)
                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');
                }
            }
            else if (value) {
                if ('source' in value && value.source && value.source[0] === ':')
                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);
                else
                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);
            }
            // value value
            const valueNode = value
                ? composeNode(ctx, value, valueProps, onError)
                : valueProps.found
                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)
                    : null;
            if (valueNode) {
                if (isBlock(value))
                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
            }
            else if (valueProps.comment) {
                if (keyNode.comment)
                    keyNode.comment += '\n' + valueProps.comment;
                else
                    keyNode.comment = valueProps.comment;
            }
            const pair = new Pair.Pair(keyNode, valueNode);
            if (isMap) {
                const map = coll;
                if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
                map.items.push(pair);
            }
            else {
                const map = new YAMLMap.YAMLMap(ctx.schema);
                map.flow = true;
                map.items.push(pair);
                coll.items.push(map);
            }
            offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
    }
    const expectedEnd = isMap ? '}' : ']';
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
    else {
        onError(offset + 1, 'MISSING_CHAR', `Expected ${fcName} to end with ${expectedEnd}`);
        if (ce && ce.source.length !== 1)
            ee.unshift(ce);
    }
    if (ee.length > 0) {
        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
            if (coll.comment)
                coll.comment += '\n' + end.comment;
            else
                coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
    }
    else {
        coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
}

exports.resolveFlowCollection = resolveFlowCollection;


/***/ }),

/***/ 7231:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Scalar = __nccwpck_require__(3229);
var resolveEnd = __nccwpck_require__(392);

function resolveFlowScalar(scalar, strict, onError) {
    const { offset, type, source, end } = scalar;
    let _type;
    let value;
    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
    switch (type) {
        case 'scalar':
            _type = Scalar.Scalar.PLAIN;
            value = plainValue(source, _onError);
            break;
        case 'single-quoted-scalar':
            _type = Scalar.Scalar.QUOTE_SINGLE;
            value = singleQuotedValue(source, _onError);
            break;
        case 'double-quoted-scalar':
            _type = Scalar.Scalar.QUOTE_DOUBLE;
            value = doubleQuotedValue(source, _onError);
            break;
        /* istanbul ignore next should not happen */
        default:
            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);
            return {
                value: '',
                type: null,
                comment: '',
                range: [offset, offset + source.length, offset + source.length]
            };
    }
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
    return {
        value,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
    };
}
function plainValue(source, onError) {
    let badChar = '';
    switch (source[0]) {
        /* istanbul ignore next should not happen */
        case '\t':
            badChar = 'a tab character';
            break;
        case ',':
            badChar = 'flow indicator character ,';
            break;
        case '%':
            badChar = 'directive indicator character %';
            break;
        case '|':
        case '>': {
            badChar = `block scalar indicator ${source[0]}`;
            break;
        }
        case '@':
        case '`': {
            badChar = `reserved character ${source[0]}`;
            break;
        }
    }
    if (badChar)
        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);
    return foldLines(source);
}
function singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1)
        onError(source.length, 'MISSING_CHAR', "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
    /**
     * The negative lookbehind here and in the `re` RegExp is to
     * prevent causing a polynomial search time in certain cases.
     *
     * The try-catch is for Safari, which doesn't support this yet:
     * https://caniuse.com/js-regexp-lookbehind
     */
    let first, line;
    try {
        first = new RegExp('(.*?)(?<![ \t])[ \t]*\r?\n', 'sy');
        line = new RegExp('[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n', 'sy');
    }
    catch (_) {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match)
        return source;
    let res = match[1];
    let sep = ' ';
    let pos = first.lastIndex;
    line.lastIndex = pos;
    while ((match = line.exec(source))) {
        if (match[1] === '') {
            if (sep === '\n')
                res += sep;
            else
                sep = '\n';
        }
        else {
            res += sep + match[1];
            sep = ' ';
        }
        pos = line.lastIndex;
    }
    const last = /[ \t]*(.*)/sy;
    last.lastIndex = pos;
    match = last.exec(source);
    return res + sep + ((match && match[1]) || '');
}
function doubleQuotedValue(source, onError) {
    let res = '';
    for (let i = 1; i < source.length - 1; ++i) {
        const ch = source[i];
        if (ch === '\r' && source[i + 1] === '\n')
            continue;
        if (ch === '\n') {
            const { fold, offset } = foldNewline(source, i);
            res += fold;
            i = offset;
        }
        else if (ch === '\\') {
            let next = source[++i];
            const cc = escapeCodes[next];
            if (cc)
                res += cc;
            else if (next === '\n') {
                // skip escaped newlines, but still trim the following line
                next = source[i + 1];
                while (next === ' ' || next === '\t')
                    next = source[++i + 1];
            }
            else if (next === 'x' || next === 'u' || next === 'U') {
                const length = { x: 2, u: 4, U: 8 }[next];
                res += parseCharCode(source, i + 1, length, onError);
                i += length;
            }
            else {
                const raw = source.substr(i - 1, 2);
                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
                res += raw;
            }
        }
        else if (ch === ' ' || ch === '\t') {
            // trim trailing whitespace
            const wsStart = i;
            let next = source[i + 1];
            while (next === ' ' || next === '\t')
                next = source[++i + 1];
            if (next !== '\n')
                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        }
        else {
            res += ch;
        }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
        onError(source.length, 'MISSING_CHAR', 'Missing closing "quote');
    return res;
}
/**
 * Fold a single newline into a space, multiple newlines to N - 1 newlines.
 * Presumes `source[offset] === '\n'`
 */
function foldNewline(source, offset) {
    let fold = '';
    let ch = source[offset + 1];
    while (ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r') {
        if (ch === '\r' && source[offset + 2] !== '\n')
            break;
        if (ch === '\n')
            fold += '\n';
        offset += 1;
        ch = source[offset + 1];
    }
    if (!fold)
        fold = ' ';
    return { fold, offset };
}
const escapeCodes = {
    '0': '\0',
    a: '\x07',
    b: '\b',
    e: '\x1b',
    f: '\f',
    n: '\n',
    r: '\r',
    t: '\t',
    v: '\v',
    N: '\u0085',
    _: '\u00a0',
    L: '\u2028',
    P: '\u2029',
    ' ': ' ',
    '"': '"',
    '/': '/',
    '\\': '\\',
    '\t': '\t'
};
function parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
        return raw;
    }
    return String.fromCodePoint(code);
}

exports.resolveFlowScalar = resolveFlowScalar;


/***/ }),

/***/ 8134:
/***/ ((__unused_webpack_module, exports) => {



function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = '';
    let commentSep = '';
    let hasNewline = false;
    let reqSpace = false;
    let anchor = null;
    let tag = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens) {
        if (reqSpace) {
            if (token.type !== 'space' &&
                token.type !== 'newline' &&
                token.type !== 'comma')
                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
            reqSpace = false;
        }
        switch (token.type) {
            case 'space':
                // At the doc level, tabs at line start may be parsed
                // as leading white space rather than indentation.
                // In a flow collection, only the parser handles indent.
                if (!flow &&
                    atNewline &&
                    indicator !== 'doc-start' &&
                    token.source[0] === '\t')
                    onError(token, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');
                hasSpace = true;
                break;
            case 'comment': {
                if (!hasSpace)
                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                const cb = token.source.substring(1) || ' ';
                if (!comment)
                    comment = cb;
                else
                    comment += commentSep + cb;
                commentSep = '';
                atNewline = false;
                break;
            }
            case 'newline':
                if (atNewline) {
                    if (comment)
                        comment += token.source;
                    else
                        spaceBefore = true;
                }
                else
                    commentSep += token.source;
                atNewline = true;
                hasNewline = true;
                hasSpace = true;
                break;
            case 'anchor':
                if (anchor)
                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');
                anchor = token;
                if (start === null)
                    start = token.offset;
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            case 'tag': {
                if (tag)
                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');
                tag = token;
                if (start === null)
                    start = token.offset;
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            }
            case indicator:
                // Could here handle preceding comments differently
                if (anchor || tag)
                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);
                found = token;
                atNewline = false;
                hasSpace = false;
                break;
            case 'comma':
                if (flow) {
                    if (comma)
                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);
                    comma = token;
                    atNewline = false;
                    hasSpace = false;
                    break;
                }
            // else fallthrough
            default:
                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);
                atNewline = false;
                hasSpace = false;
        }
    }
    const last = tokens[tokens.length - 1];
    const end = last ? last.offset + last.source.length : offset;
    if (reqSpace &&
        next &&
        next.type !== 'space' &&
        next.type !== 'newline' &&
        next.type !== 'comma' &&
        (next.type !== 'scalar' || next.source !== ''))
        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
    return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        anchor,
        tag,
        end,
        start: start !== null && start !== void 0 ? start : end
    };
}

exports.resolveProps = resolveProps;


/***/ }),

/***/ 2387:
/***/ ((__unused_webpack_module, exports) => {



function containsNewline(key) {
    if (!key)
        return null;
    switch (key.type) {
        case 'alias':
        case 'scalar':
        case 'double-quoted-scalar':
        case 'single-quoted-scalar':
            if (key.source.includes('\n'))
                return true;
            if (key.end)
                for (const st of key.end)
                    if (st.type === 'newline')
                        return true;
            return false;
        case 'flow-collection':
            for (const it of key.items) {
                for (const st of it.start)
                    if (st.type === 'newline')
                        return true;
                if (it.sep)
                    for (const st of it.sep)
                        if (st.type === 'newline')
                            return true;
                if (containsNewline(it.key) || containsNewline(it.value))
                    return true;
            }
            return false;
        default:
            return true;
    }
}

exports.containsNewline = containsNewline;


/***/ }),

/***/ 2423:
/***/ ((__unused_webpack_module, exports) => {



function emptyScalarPosition(offset, before, pos) {
    if (before) {
        if (pos === null)
            pos = before.length;
        for (let i = pos - 1; i >= 0; --i) {
            let st = before[i];
            switch (st.type) {
                case 'space':
                case 'comment':
                case 'newline':
                    offset -= st.source.length;
                    continue;
            }
            // Technically, an empty scalar is immediately after the last non-empty
            // node, but it's more useful to place it after any whitespace.
            st = before[++i];
            while ((st === null || st === void 0 ? void 0 : st.type) === 'space') {
                offset += st.source.length;
                st = before[++i];
            }
            break;
        }
    }
    return offset;
}

exports.emptyScalarPosition = emptyScalarPosition;


/***/ }),

/***/ 9138:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Node = __nccwpck_require__(9464);

function mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
        return false;
    const isEqual = typeof uniqueKeys === 'function'
        ? uniqueKeys
        : (a, b) => a === b ||
            (Node.isScalar(a) &&
                Node.isScalar(b) &&
                a.value === b.value &&
                !(a.value === '<<' && ctx.schema.merge));
    return items.some(pair => isEqual(pair.key, search));
}

exports.mapIncludes = mapIncludes;


/***/ }),

/***/ 5663:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Alias = __nccwpck_require__(2484);
var Collection = __nccwpck_require__(7381);
var Node = __nccwpck_require__(9464);
var Pair = __nccwpck_require__(5456);
var toJS = __nccwpck_require__(7346);
var options = __nccwpck_require__(5281);
var Schema = __nccwpck_require__(187);
var stringify = __nccwpck_require__(7354);
var stringifyDocument = __nccwpck_require__(7351);
var anchors = __nccwpck_require__(793);
var applyReviver = __nccwpck_require__(7909);
var createNode = __nccwpck_require__(9718);
var directives = __nccwpck_require__(1348);

class Document {
    constructor(value, replacer, options$1) {
        /** A comment before this Document */
        this.commentBefore = null;
        /** A comment immediately after this Document */
        this.comment = null;
        /** Errors encountered during parsing. */
        this.errors = [];
        /** Warnings encountered during parsing. */
        this.warnings = [];
        Object.defineProperty(this, Node.NODE_TYPE, { value: Node.DOC });
        let _replacer = null;
        if (typeof replacer === 'function' || Array.isArray(replacer)) {
            _replacer = replacer;
        }
        else if (options$1 === undefined && replacer) {
            options$1 = replacer;
            replacer = undefined;
        }
        const opt = Object.assign({}, options.defaultOptions, options$1);
        this.options = opt;
        let { version } = opt;
        if (options$1 === null || options$1 === void 0 ? void 0 : options$1.directives) {
            this.directives = options$1.directives.atDocument();
            if (this.directives.yaml.explicit)
                version = this.directives.yaml.version;
        }
        else
            this.directives = new directives.Directives({ version });
        this.setSchema(version, options$1);
        if (value === undefined)
            this.contents = null;
        else {
            this.contents = this.createNode(value, _replacer, options$1);
        }
    }
    /** Adds a value to the document. */
    add(value) {
        if (assertCollection(this.contents))
            this.contents.add(value);
    }
    /** Adds a value to the document. */
    addIn(path, value) {
        if (assertCollection(this.contents))
            this.contents.addIn(path, value);
    }
    /**
     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
     *
     * If `node` already has an anchor, `name` is ignored.
     * Otherwise, the `node.anchor` value will be set to `name`,
     * or if an anchor with that name is already present in the document,
     * `name` will be used as a prefix for a new unique anchor.
     * If `name` is undefined, the generated anchor will use 'a' as a prefix.
     */
    createAlias(node, name) {
        if (!node.anchor) {
            const prev = anchors.anchorNames(this);
            node.anchor =
                !name || prev.has(name) ? anchors.findNewAnchor(name || 'a', prev) : name;
        }
        return new Alias.Alias(node.anchor);
    }
    createNode(value, replacer, options) {
        let _replacer = undefined;
        if (typeof replacer === 'function') {
            value = replacer.call({ '': value }, '', value);
            _replacer = replacer;
        }
        else if (Array.isArray(replacer)) {
            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;
            const asStr = replacer.filter(keyToStr).map(String);
            if (asStr.length > 0)
                replacer = replacer.concat(asStr);
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const { anchorPrefix, flow, keepUndefined, onTagObj, tag } = options || {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, anchorPrefix || 'a');
        const ctx = {
            keepUndefined: keepUndefined !== null && keepUndefined !== void 0 ? keepUndefined : false,
            onAnchor,
            onTagObj,
            replacer: _replacer,
            schema: this.schema,
            sourceObjects
        };
        const node = createNode.createNode(value, tag, ctx);
        if (flow && Node.isCollection(node))
            node.flow = true;
        setAnchors();
        return node;
    }
    /**
     * Convert a key and a value into a `Pair` using the current schema,
     * recursively wrapping all values as `Scalar` or `Collection` nodes.
     */
    createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair.Pair(k, v);
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        if (Collection.isEmptyPath(path)) {
            if (this.contents == null)
                return false;
            this.contents = null;
            return true;
        }
        return assertCollection(this.contents)
            ? this.contents.deleteIn(path)
            : false;
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    get(key, keepScalar) {
        return Node.isCollection(this.contents)
            ? this.contents.get(key, keepScalar)
            : undefined;
    }
    /**
     * Returns item at `path`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        if (Collection.isEmptyPath(path))
            return !keepScalar && Node.isScalar(this.contents)
                ? this.contents.value
                : this.contents;
        return Node.isCollection(this.contents)
            ? this.contents.getIn(path, keepScalar)
            : undefined;
    }
    /**
     * Checks if the document includes a value with the key `key`.
     */
    has(key) {
        return Node.isCollection(this.contents) ? this.contents.has(key) : false;
    }
    /**
     * Checks if the document includes a value at `path`.
     */
    hasIn(path) {
        if (Collection.isEmptyPath(path))
            return this.contents !== undefined;
        return Node.isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    set(key, value) {
        if (this.contents == null) {
            this.contents = Collection.collectionFromPath(this.schema, [key], value);
        }
        else if (assertCollection(this.contents)) {
            this.contents.set(key, value);
        }
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path, value) {
        if (Collection.isEmptyPath(path))
            this.contents = value;
        else if (this.contents == null) {
            this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
        }
        else if (assertCollection(this.contents)) {
            this.contents.setIn(path, value);
        }
    }
    /**
     * Change the YAML version and schema used by the document.
     *
     * Overrides all previously set schema options
     */
    setSchema(version, options) {
        let _options;
        switch (String(version)) {
            case '1.1':
                this.directives.yaml.version = '1.1';
                _options = Object.assign({ merge: true, resolveKnownTags: false, schema: 'yaml-1.1' }, options);
                break;
            case '1.2':
                this.directives.yaml.version = '1.2';
                _options = Object.assign({ merge: false, resolveKnownTags: true, schema: 'core' }, options);
                break;
            default: {
                const sv = JSON.stringify(version);
                throw new Error(`Expected '1.1' or '1.2' as version, but found: ${sv}`);
            }
        }
        this.schema = new Schema.Schema(_options);
    }
    // json & jsonArg are only used from toJSON()
    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
            anchors: new Map(),
            doc: this,
            keep: !json,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100,
            stringify: stringify.stringify
        };
        const res = toJS.toJS(this.contents, jsonArg || '', ctx);
        if (typeof onAnchor === 'function')
            for (const { count, res } of ctx.anchors.values())
                onAnchor(res, count);
        return typeof reviver === 'function'
            ? applyReviver.applyReviver(reviver, { '': res }, '', res)
            : res;
    }
    /**
     * A JSON representation of the document `contents`.
     *
     * @param jsonArg Used by `JSON.stringify` to indicate the array index or
     *   property name.
     */
    toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
    }
    /** A YAML representation of the document. */
    toString(options = {}) {
        if (this.errors.length > 0)
            throw new Error('Document with errors cannot be stringified');
        if ('indent' in options &&
            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
            const s = JSON.stringify(options.indent);
            throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options);
    }
}
function assertCollection(contents) {
    if (Node.isCollection(contents))
        return true;
    throw new Error('Expected a YAML collection as document contents');
}

exports.Document = Document;


/***/ }),

/***/ 793:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Node = __nccwpck_require__(9464);
var visit = __nccwpck_require__(3774);

/**
 * Verify that the input string is a valid anchor.
 *
 * Will throw on errors.
 */
function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
    }
    return true;
}
function anchorNames(root) {
    const anchors = new Set();
    visit.visit(root, {
        Value(_key, node) {
            if (node.anchor)
                anchors.add(node.anchor);
        }
    });
    return anchors;
}
/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */
function findNewAnchor(prefix, exclude) {
    for (let i = 1; true; ++i) {
        const name = `${prefix}${i}`;
        if (!exclude.has(name))
            return name;
    }
}
function createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map();
    let prevAnchors = null;
    return {
        onAnchor(source) {
            aliasObjects.push(source);
            if (!prevAnchors)
                prevAnchors = anchorNames(doc);
            const anchor = findNewAnchor(prefix, prevAnchors);
            prevAnchors.add(anchor);
            return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors() {
            for (const source of aliasObjects) {
                const ref = sourceObjects.get(source);
                if (typeof ref === 'object' &&
                    ref.anchor &&
                    (Node.isScalar(ref.node) || Node.isCollection(ref.node))) {
                    ref.node.anchor = ref.anchor;
                }
                else {
                    const error = new Error('Failed to resolve repeated object (this should not happen)');
                    error.source = source;
                    throw error;
                }
            }
        },
        sourceObjects
    };
}

exports.anchorIsValid = anchorIsValid;
exports.anchorNames = anchorNames;
exports.createNodeAnchors = createNodeAnchors;
exports.findNewAnchor = findNewAnchor;


/***/ }),

/***/ 7909:
/***/ ((__unused_webpack_module, exports) => {



/**
 * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,
 * in section 24.5.1.1 "Runtime Semantics: InternalizeJSONProperty" of the
 * 2021 edition: https://tc39.es/ecma262/#sec-json.parse
 *
 * Includes extensions for handling Map and Set objects.
 */
function applyReviver(reviver, obj, key, val) {
    if (val && typeof val === 'object') {
        if (Array.isArray(val)) {
            for (let i = 0, len = val.length; i < len; ++i) {
                const v0 = val[i];
                const v1 = applyReviver(reviver, val, String(i), v0);
                if (v1 === undefined)
                    delete val[i];
                else if (v1 !== v0)
                    val[i] = v1;
            }
        }
        else if (val instanceof Map) {
            for (const k of Array.from(val.keys())) {
                const v0 = val.get(k);
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === undefined)
                    val.delete(k);
                else if (v1 !== v0)
                    val.set(k, v1);
            }
        }
        else if (val instanceof Set) {
            for (const v0 of Array.from(val)) {
                const v1 = applyReviver(reviver, val, v0, v0);
                if (v1 === undefined)
                    val.delete(v0);
                else if (v1 !== v0) {
                    val.delete(v0);
                    val.add(v1);
                }
            }
        }
        else {
            for (const [k, v0] of Object.entries(val)) {
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === undefined)
                    delete val[k];
                else if (v1 !== v0)
                    val[k] = v1;
            }
        }
    }
    return reviver.call(obj, key, val);
}

exports.applyReviver = applyReviver;


/***/ }),

/***/ 9718:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Alias = __nccwpck_require__(2484);
var Node = __nccwpck_require__(9464);
var Scalar = __nccwpck_require__(3229);

const defaultTagPrefix = 'tag:yaml.org,2002:';
function findTagObject(value, tagName, tags) {
    if (tagName) {
        const match = tags.filter(t => t.tag === tagName);
        const tagObj = match.find(t => !t.format) || match[0];
        if (!tagObj)
            throw new Error(`Tag ${tagName} not found`);
        return tagObj;
    }
    return tags.find(t => t.identify && t.identify(value) && !t.format);
}
function createNode(value, tagName, ctx) {
    var _a, _b;
    if (Node.isNode(value))
        return value;
    if (Node.isPair(value)) {
        const map = (_b = (_a = ctx.schema[Node.MAP]).createNode) === null || _b === void 0 ? void 0 : _b.call(_a, ctx.schema, null, ctx);
        map.items.push(value);
        return map;
    }
    if (value instanceof String ||
        value instanceof Number ||
        value instanceof Boolean ||
        (typeof BigInt === 'function' && value instanceof BigInt) // not supported everywhere
    ) {
        // https://tc39.es/ecma262/#sec-serializejsonproperty
        value = value.valueOf();
    }
    const { onAnchor, onTagObj, schema, sourceObjects } = ctx;
    // Detect duplicate references to the same object & use Alias nodes for all
    // after first. The `ref` wrapper allows for circular references to resolve.
    let ref = undefined;
    if (value && typeof value === 'object') {
        ref = sourceObjects.get(value);
        if (ref) {
            if (!ref.anchor)
                ref.anchor = onAnchor(value);
            return new Alias.Alias(ref.anchor);
        }
        else {
            ref = { anchor: null, node: null };
            sourceObjects.set(value, ref);
        }
    }
    if (tagName && tagName.startsWith('!!'))
        tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
        if (value && typeof value.toJSON === 'function')
            value = value.toJSON();
        if (!value || typeof value !== 'object') {
            const node = new Scalar.Scalar(value);
            if (ref)
                ref.node = node;
            return node;
        }
        tagObj =
            value instanceof Map
                ? schema[Node.MAP]
                : Symbol.iterator in Object(value)
                    ? schema[Node.SEQ]
                    : schema[Node.MAP];
    }
    if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
    }
    const node = (tagObj === null || tagObj === void 0 ? void 0 : tagObj.createNode)
        ? tagObj.createNode(ctx.schema, value, ctx)
        : new Scalar.Scalar(value);
    if (tagName)
        node.tag = tagName;
    if (ref)
        ref.node = node;
    return node;
}

exports.createNode = createNode;


/***/ }),

/***/ 1348:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Node = __nccwpck_require__(9464);
var visit = __nccwpck_require__(3774);

const escapeChars = {
    '!': '%21',
    ',': '%2C',
    '[': '%5B',
    ']': '%5D',
    '{': '%7B',
    '}': '%7D'
};
const escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, ch => escapeChars[ch]);
class Directives {
    constructor(yaml, tags) {
        /**
         * The directives-end/doc-start marker `---`. If `null`, a marker may still be
         * included in the document's stringified representation.
         */
        this.marker = null;
        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, Directives.defaultTags, tags);
    }
    /**
     * During parsing, get a Directives instance for the current document and
     * update the stream state according to the current version's spec.
     */
    atDocument() {
        const res = new Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
            case '1.1':
                this.atNextDocument = true;
                break;
            case '1.2':
                this.atNextDocument = false;
                this.yaml = {
                    explicit: Directives.defaultYaml.explicit,
                    version: '1.2'
                };
                this.tags = Object.assign({}, Directives.defaultTags);
                break;
        }
        return res;
    }
    /**
     * @param onError - May be called even if the action was successful
     * @returns `true` on success
     */
    add(line, onError) {
        if (this.atNextDocument) {
            this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };
            this.tags = Object.assign({}, Directives.defaultTags);
            this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
            case '%TAG': {
                if (parts.length !== 2) {
                    onError(0, '%TAG directive should contain exactly two parts');
                    if (parts.length < 2)
                        return false;
                }
                const [handle, prefix] = parts;
                this.tags[handle] = prefix;
                return true;
            }
            case '%YAML': {
                this.yaml.explicit = true;
                if (parts.length < 1) {
                    onError(0, '%YAML directive should contain exactly one part');
                    return false;
                }
                const [version] = parts;
                if (version === '1.1' || version === '1.2') {
                    this.yaml.version = version;
                    return true;
                }
                else {
                    onError(6, `Unsupported YAML version ${version}`, true);
                    return false;
                }
            }
            default:
                onError(0, `Unknown directive ${name}`, true);
                return false;
        }
    }
    /**
     * Resolves a tag, matching handles to those defined in %TAG directives.
     *
     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
     *   `'!local'` tag, or `null` if unresolvable.
     */
    tagName(source, onError) {
        if (source === '!')
            return '!'; // non-specific tag
        if (source[0] !== '!') {
            onError(`Not a valid tag: ${source}`);
            return null;
        }
        if (source[1] === '<') {
            const verbatim = source.slice(2, -1);
            if (verbatim === '!' || verbatim === '!!') {
                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
                return null;
            }
            if (source[source.length - 1] !== '>')
                onError('Verbatim tags must end with a >');
            return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);
        if (!suffix)
            onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix)
            return prefix + decodeURIComponent(suffix);
        if (handle === '!')
            return source; // local tag
        onError(`Could not resolve tag: ${source}`);
        return null;
    }
    /**
     * Given a fully resolved tag, returns its printable string form,
     * taking into account current tag prefixes and defaults.
     */
    tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
            if (tag.startsWith(prefix))
                return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === '!' ? tag : `!<${tag}>`;
    }
    toString(doc) {
        const lines = this.yaml.explicit
            ? [`%YAML ${this.yaml.version || '1.2'}`]
            : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && Node.isNode(doc.contents)) {
            const tags = {};
            visit.visit(doc.contents, (_key, node) => {
                if (Node.isNode(node) && node.tag)
                    tags[node.tag] = true;
            });
            tagNames = Object.keys(tags);
        }
        else
            tagNames = [];
        for (const [handle, prefix] of tagEntries) {
            if (handle === '!!' && prefix === 'tag:yaml.org,2002:')
                continue;
            if (!doc || tagNames.some(tn => tn.startsWith(prefix)))
                lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join('\n');
    }
}
Directives.defaultYaml = { explicit: false, version: '1.2' };
Directives.defaultTags = { '!!': 'tag:yaml.org,2002:' };

exports.Directives = Directives;


/***/ }),

/***/ 9043:
/***/ ((__unused_webpack_module, exports) => {



class YAMLError extends Error {
    constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
    }
}
class YAMLParseError extends YAMLError {
    constructor(pos, code, message) {
        super('YAMLParseError', pos, code, message);
    }
}
class YAMLWarning extends YAMLError {
    constructor(pos, code, message) {
        super('YAMLWarning', pos, code, message);
    }
}
const prettifyError = (src, lc) => (error) => {
    if (error.pos[0] === -1)
        return;
    error.linePos = error.pos.map(pos => lc.linePos(pos));
    const { line, col } = error.linePos[0];
    error.message += ` at line ${line}, column ${col}`;
    let ci = col - 1;
    let lineStr = src
        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])
        .replace(/[\n\r]+$/, '');
    // Trim to max 80 chars, keeping col position near the middle
    if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = '…' + lineStr.substring(trimStart);
        ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + '…';
    // Include previous line in context if pointing at line start
    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        // Regexp won't match if start is trimmed
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
            prev = prev.substring(0, 79) + '…\n';
        lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
            count = Math.min(end.col - col, 80 - ci);
        }
        const pointer = ' '.repeat(ci) + '^'.repeat(count);
        error.message += `:\n\n${lineStr}\n${pointer}\n`;
    }
};

exports.YAMLError = YAMLError;
exports.YAMLParseError = YAMLParseError;
exports.YAMLWarning = YAMLWarning;
exports.prettifyError = prettifyError;


/***/ }),

/***/ 2569:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var composer = __nccwpck_require__(2920);
var Document = __nccwpck_require__(5663);
var Schema = __nccwpck_require__(187);
var errors = __nccwpck_require__(9043);
var Alias = __nccwpck_require__(2484);
var Node = __nccwpck_require__(9464);
var Pair = __nccwpck_require__(5456);
var Scalar = __nccwpck_require__(3229);
var YAMLMap = __nccwpck_require__(5505);
var YAMLSeq = __nccwpck_require__(4967);
var options = __nccwpck_require__(5281);
var cst = __nccwpck_require__(4415);
var lexer = __nccwpck_require__(6074);
var lineCounter = __nccwpck_require__(8257);
var parser = __nccwpck_require__(2270);
var publicApi = __nccwpck_require__(2963);
var visit = __nccwpck_require__(3774);



exports.Composer = composer.Composer;
exports.Document = Document.Document;
exports.Schema = Schema.Schema;
exports.YAMLError = errors.YAMLError;
exports.YAMLParseError = errors.YAMLParseError;
exports.YAMLWarning = errors.YAMLWarning;
exports.Alias = Alias.Alias;
exports.isAlias = Node.isAlias;
exports.isCollection = Node.isCollection;
exports.isDocument = Node.isDocument;
exports.isMap = Node.isMap;
exports.isNode = Node.isNode;
exports.isPair = Node.isPair;
exports.isScalar = Node.isScalar;
exports.isSeq = Node.isSeq;
exports.Pair = Pair.Pair;
exports.Scalar = Scalar.Scalar;
exports.YAMLMap = YAMLMap.YAMLMap;
exports.YAMLSeq = YAMLSeq.YAMLSeq;
exports.defaultOptions = options.defaultOptions;
exports.CST = cst;
exports.Lexer = lexer.Lexer;
exports.LineCounter = lineCounter.LineCounter;
exports.Parser = parser.Parser;
exports.parse = publicApi.parse;
exports.parseAllDocuments = publicApi.parseAllDocuments;
exports.parseDocument = publicApi.parseDocument;
exports.stringify = publicApi.stringify;
exports.visit = visit.visit;


/***/ }),

/***/ 1728:
/***/ ((__unused_webpack_module, exports) => {



function debug(logLevel, ...messages) {
    if (logLevel === 'debug')
        console.log(...messages);
}
function warn(logLevel, warning) {
    if (logLevel === 'debug' || logLevel === 'warn') {
        if (typeof process !== 'undefined' && process.emitWarning)
            process.emitWarning(warning);
        else
            console.warn(warning);
    }
}

exports.debug = debug;
exports.warn = warn;


/***/ }),

/***/ 2484:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var anchors = __nccwpck_require__(793);
var visit = __nccwpck_require__(3774);
var Node = __nccwpck_require__(9464);

class Alias extends Node.NodeBase {
    constructor(source) {
        super(Node.ALIAS);
        this.source = source;
        Object.defineProperty(this, 'tag', {
            set() {
                throw new Error('Alias nodes cannot have tags');
            }
        });
    }
    /**
     * Resolve the value of this alias within `doc`, finding the last
     * instance of the `source` anchor before this node.
     */
    resolve(doc) {
        let found = undefined;
        visit.visit(doc, {
            Node: (_key, node) => {
                if (node === this)
                    return visit.visit.BREAK;
                if (node.anchor === this.source)
                    found = node;
            }
        });
        return found;
    }
    toJSON(_arg, ctx) {
        if (!ctx)
            return { source: this.source };
        const { anchors, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc);
        if (!source) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new ReferenceError(msg);
        }
        const data = anchors.get(source);
        /* istanbul ignore if */
        if (!data || data.res === undefined) {
            const msg = 'This should not happen: Alias anchor was not resolved?';
            throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
            data.count += 1;
            if (data.aliasCount === 0)
                data.aliasCount = getAliasCount(doc, source, anchors);
            if (data.count * data.aliasCount > maxAliasCount) {
                const msg = 'Excessive alias count indicates a resource exhaustion attack';
                throw new ReferenceError(msg);
            }
        }
        return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
            anchors.anchorIsValid(this.source);
            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                throw new Error(msg);
            }
            if (ctx.implicitKey)
                return `${src} `;
        }
        return src;
    }
}
function getAliasCount(doc, node, anchors) {
    if (Node.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors && source && anchors.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
    }
    else if (Node.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
            const c = getAliasCount(doc, item, anchors);
            if (c > count)
                count = c;
        }
        return count;
    }
    else if (Node.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors);
        const vc = getAliasCount(doc, node.value, anchors);
        return Math.max(kc, vc);
    }
    return 1;
}

exports.Alias = Alias;


/***/ }),

/***/ 7381:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var createNode = __nccwpck_require__(9718);
var Node = __nccwpck_require__(9464);

function collectionFromPath(schema, path, value) {
    let v = value;
    for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {
            const a = [];
            a[k] = v;
            v = a;
        }
        else {
            const o = {};
            Object.defineProperty(o, typeof k === 'symbol' ? k : String(k), {
                value: v,
                writable: true,
                enumerable: true,
                configurable: true
            });
            v = o;
        }
    }
    return createNode.createNode(v, undefined, {
        onAnchor() {
            throw new Error('Repeated objects are not supported here');
        },
        schema,
        sourceObjects: new Map()
    });
}
// null, undefined, or an empty non-string iterable (e.g. [])
const isEmptyPath = (path) => path == null ||
    (typeof path === 'object' && !!path[Symbol.iterator]().next().done);
class Collection extends Node.NodeBase {
    constructor(type, schema) {
        super(type);
        Object.defineProperty(this, 'schema', {
            value: schema,
            configurable: true,
            enumerable: false,
            writable: true
        });
    }
    /**
     * Adds a value to the collection. For `!!map` and `!!omap` the value must
     * be a Pair instance or a `{ key, value }` object, which may not have a key
     * that already exists in the map.
     */
    addIn(path, value) {
        if (isEmptyPath(path))
            this.add(value);
        else {
            const [key, ...rest] = path;
            const node = this.get(key, true);
            if (Node.isCollection(node))
                node.addIn(rest, value);
            else if (node === undefined && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
            else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
    /**
     * Removes a value from the collection.
     * @returns `true` if the item was found and removed.
     */
    deleteIn([key, ...rest]) {
        if (rest.length === 0)
            return this.delete(key);
        const node = this.get(key, true);
        if (Node.isCollection(node))
            return node.deleteIn(rest);
        else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn([key, ...rest], keepScalar) {
        const node = this.get(key, true);
        if (rest.length === 0)
            return !keepScalar && Node.isScalar(node) ? node.value : node;
        else
            return Node.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
    }
    hasAllNullValues(allowScalar) {
        return this.items.every(node => {
            if (!Node.isPair(node))
                return false;
            const n = node.value;
            return (n == null ||
                (allowScalar &&
                    Node.isScalar(n) &&
                    n.value == null &&
                    !n.commentBefore &&
                    !n.comment &&
                    !n.tag));
        });
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     */
    hasIn([key, ...rest]) {
        if (rest.length === 0)
            return this.has(key);
        const node = this.get(key, true);
        return Node.isCollection(node) ? node.hasIn(rest) : false;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn([key, ...rest], value) {
        if (rest.length === 0) {
            this.set(key, value);
        }
        else {
            const node = this.get(key, true);
            if (Node.isCollection(node))
                node.setIn(rest, value);
            else if (node === undefined && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
            else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
}
Collection.maxFlowStringSingleLineLength = 60;

exports.Collection = Collection;
exports.collectionFromPath = collectionFromPath;
exports.isEmptyPath = isEmptyPath;


/***/ }),

/***/ 9464:
/***/ ((__unused_webpack_module, exports) => {



const ALIAS = Symbol.for('yaml.alias');
const DOC = Symbol.for('yaml.document');
const MAP = Symbol.for('yaml.map');
const PAIR = Symbol.for('yaml.pair');
const SCALAR = Symbol.for('yaml.scalar');
const SEQ = Symbol.for('yaml.seq');
const NODE_TYPE = Symbol.for('yaml.node.type');
const isAlias = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;
const isDocument = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;
const isMap = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;
const isPair = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;
const isScalar = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR;
const isSeq = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;
function isCollection(node) {
    if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
            case MAP:
            case SEQ:
                return true;
        }
    return false;
}
function isNode(node) {
    if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
            case ALIAS:
            case MAP:
            case SCALAR:
            case SEQ:
                return true;
        }
    return false;
}
const hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
class NodeBase {
    constructor(type) {
        Object.defineProperty(this, NODE_TYPE, { value: type });
    }
}

exports.ALIAS = ALIAS;
exports.DOC = DOC;
exports.MAP = MAP;
exports.NODE_TYPE = NODE_TYPE;
exports.NodeBase = NodeBase;
exports.PAIR = PAIR;
exports.SCALAR = SCALAR;
exports.SEQ = SEQ;
exports.hasAnchor = hasAnchor;
exports.isAlias = isAlias;
exports.isCollection = isCollection;
exports.isDocument = isDocument;
exports.isMap = isMap;
exports.isNode = isNode;
exports.isPair = isPair;
exports.isScalar = isScalar;
exports.isSeq = isSeq;


/***/ }),

/***/ 5456:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var createNode = __nccwpck_require__(9718);
var stringifyPair = __nccwpck_require__(1156);
var addPairToJSMap = __nccwpck_require__(5255);
var Node = __nccwpck_require__(9464);

function createPair(key, value, ctx) {
    const k = createNode.createNode(key, undefined, ctx);
    const v = createNode.createNode(value, undefined, ctx);
    return new Pair(k, v);
}
class Pair {
    constructor(key, value = null) {
        Object.defineProperty(this, Node.NODE_TYPE, { value: Node.PAIR });
        this.key = key;
        this.value = value;
    }
    toJSON(_, ctx) {
        const pair = ctx && ctx.mapAsMap ? new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
        return ctx && ctx.doc
            ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep)
            : JSON.stringify(this);
    }
}

exports.Pair = Pair;
exports.createPair = createPair;


/***/ }),

/***/ 3229:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Node = __nccwpck_require__(9464);
var toJS = __nccwpck_require__(7346);

const isScalarValue = (value) => !value || (typeof value !== 'function' && typeof value !== 'object');
class Scalar extends Node.NodeBase {
    constructor(value) {
        super(Node.SCALAR);
        this.value = value;
    }
    toJSON(arg, ctx) {
        return ctx && ctx.keep ? this.value : toJS.toJS(this.value, arg, ctx);
    }
    toString() {
        return String(this.value);
    }
}
Scalar.BLOCK_FOLDED = 'BLOCK_FOLDED';
Scalar.BLOCK_LITERAL = 'BLOCK_LITERAL';
Scalar.PLAIN = 'PLAIN';
Scalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';
Scalar.QUOTE_SINGLE = 'QUOTE_SINGLE';

exports.Scalar = Scalar;
exports.isScalarValue = isScalarValue;


/***/ }),

/***/ 5505:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var stringifyCollection = __nccwpck_require__(7842);
var addPairToJSMap = __nccwpck_require__(5255);
var Collection = __nccwpck_require__(7381);
var Node = __nccwpck_require__(9464);
var Pair = __nccwpck_require__(5456);
var Scalar = __nccwpck_require__(3229);

function findPair(items, key) {
    const k = Node.isScalar(key) ? key.value : key;
    for (const it of items) {
        if (Node.isPair(it)) {
            if (it.key === key || it.key === k)
                return it;
            if (Node.isScalar(it.key) && it.key.value === k)
                return it;
        }
    }
    return undefined;
}
class YAMLMap extends Collection.Collection {
    constructor(schema) {
        super(Node.MAP, schema);
        this.items = [];
    }
    static get tagName() {
        return 'tag:yaml.org,2002:map';
    }
    /**
     * Adds a value to the collection.
     *
     * @param overwrite - If not set `true`, using a key that is already in the
     *   collection will throw. Otherwise, overwrites the previous value.
     */
    add(pair, overwrite) {
        let _pair;
        if (Node.isPair(pair))
            _pair = pair;
        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {
            // In TypeScript, this never happens.
            _pair = new Pair.Pair(pair, pair.value);
        }
        else
            _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema && this.schema.sortMapEntries;
        if (prev) {
            if (!overwrite)
                throw new Error(`Key ${_pair.key} already set`);
            // For scalars, keep the old node & its comments and anchors
            if (Node.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
                prev.value.value = _pair.value;
            else
                prev.value = _pair.value;
        }
        else if (sortEntries) {
            const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);
            if (i === -1)
                this.items.push(_pair);
            else
                this.items.splice(i, 0, _pair);
        }
        else {
            this.items.push(_pair);
        }
    }
    delete(key) {
        const it = findPair(this.items, key);
        if (!it)
            return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it && it.value;
        return !keepScalar && Node.isScalar(node) ? node.value : node;
    }
    has(key) {
        return !!findPair(this.items, key);
    }
    set(key, value) {
        this.add(new Pair.Pair(key, value), true);
    }
    /**
     * @param ctx - Conversion context, originally set in Document#toJS()
     * @param {Class} Type - If set, forces the returned collection type
     * @returns Instance of Type, Map, or Object
     */
    toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};
        if (ctx && ctx.onCreate)
            ctx.onCreate(map);
        for (const item of this.items)
            addPairToJSMap.addPairToJSMap(ctx, map, item);
        return map;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        for (const item of this.items) {
            if (!Node.isPair(item))
                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
            ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
            blockItem: n => n.str,
            flowChars: { start: '{', end: '}' },
            itemIndent: ctx.indent || '',
            onChompKeep,
            onComment
        });
    }
}

exports.YAMLMap = YAMLMap;
exports.findPair = findPair;


/***/ }),

/***/ 4967:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var stringifyCollection = __nccwpck_require__(7842);
var Collection = __nccwpck_require__(7381);
var Node = __nccwpck_require__(9464);
var Scalar = __nccwpck_require__(3229);
var toJS = __nccwpck_require__(7346);

class YAMLSeq extends Collection.Collection {
    constructor(schema) {
        super(Node.SEQ, schema);
        this.items = [];
    }
    static get tagName() {
        return 'tag:yaml.org,2002:seq';
    }
    add(value) {
        this.items.push(value);
    }
    /**
     * Removes a value from the collection.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     *
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     */
    get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return undefined;
        const it = this.items[idx];
        return !keepScalar && Node.isScalar(it) ? it.value : it;
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     */
    has(key) {
        const idx = asItemIndex(key);
        return typeof idx === 'number' && idx < this.items.length;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     *
     * If `key` does not contain a representation of an integer, this will throw.
     * It may be wrapped in a `Scalar`.
     */
    set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (Node.isScalar(prev) && Scalar.isScalarValue(value))
            prev.value = value;
        else
            this.items[idx] = value;
    }
    toJSON(_, ctx) {
        const seq = [];
        if (ctx && ctx.onCreate)
            ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
            seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
            blockItem: n => (n.comment ? n.str : `- ${n.str}`),
            flowChars: { start: '[', end: ']' },
            itemIndent: (ctx.indent || '') + '  ',
            onChompKeep,
            onComment
        });
    }
}
function asItemIndex(key) {
    let idx = Node.isScalar(key) ? key.value : key;
    if (idx && typeof idx === 'string')
        idx = Number(idx);
    return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0
        ? idx
        : null;
}

exports.YAMLSeq = YAMLSeq;


/***/ }),

/***/ 5255:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var log = __nccwpck_require__(1728);
var stringify = __nccwpck_require__(7354);
var Node = __nccwpck_require__(9464);
var Scalar = __nccwpck_require__(3229);
var toJS = __nccwpck_require__(7346);

const MERGE_KEY = '<<';
function addPairToJSMap(ctx, map, { key, value }) {
    if (ctx && ctx.doc.schema.merge && isMergeKey(key)) {
        if (Node.isSeq(value))
            for (const it of value.items)
                mergeToJSMap(ctx, map, it);
        else if (Array.isArray(value))
            for (const it of value)
                mergeToJSMap(ctx, map, it);
        else
            mergeToJSMap(ctx, map, value);
    }
    else {
        const jsKey = toJS.toJS(key, '', ctx);
        if (map instanceof Map) {
            map.set(jsKey, toJS.toJS(value, jsKey, ctx));
        }
        else if (map instanceof Set) {
            map.add(jsKey);
        }
        else {
            const stringKey = stringifyKey(key, jsKey, ctx);
            const jsValue = toJS.toJS(value, stringKey, ctx);
            if (stringKey in map)
                Object.defineProperty(map, stringKey, {
                    value: jsValue,
                    writable: true,
                    enumerable: true,
                    configurable: true
                });
            else
                map[stringKey] = jsValue;
        }
    }
    return map;
}
const isMergeKey = (key) => key === MERGE_KEY ||
    (Node.isScalar(key) &&
        key.value === MERGE_KEY &&
        (!key.type || key.type === Scalar.Scalar.PLAIN));
// If the value associated with a merge key is a single mapping node, each of
// its key/value pairs is inserted into the current mapping, unless the key
// already exists in it. If the value associated with the merge key is a
// sequence, then this sequence is expected to contain mapping nodes and each
// of these nodes is merged in turn according to its order in the sequence.
// Keys in mapping nodes earlier in the sequence override keys specified in
// later mapping nodes. -- http://yaml.org/type/merge.html
function mergeToJSMap(ctx, map, value) {
    const source = ctx && Node.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!Node.isMap(source))
        throw new Error('Merge sources must be maps or map aliases');
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value] of srcMap) {
        if (map instanceof Map) {
            if (!map.has(key))
                map.set(key, value);
        }
        else if (map instanceof Set) {
            map.add(key);
        }
        else if (!Object.prototype.hasOwnProperty.call(map, key)) {
            Object.defineProperty(map, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
            });
        }
    }
    return map;
}
function stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
        return '';
    if (typeof jsKey !== 'object')
        return String(jsKey);
    if (Node.isNode(key) && ctx && ctx.doc) {
        const strCtx = stringify.createStringifyContext(ctx.doc, {});
        strCtx.anchors = new Set();
        for (const node of ctx.anchors.keys())
            strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
            let jsonStr = JSON.stringify(strKey);
            if (jsonStr.length > 40)
                jsonStr = jsonStr.substring(0, 36) + '..."';
            log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
            ctx.mapKeyWarned = true;
        }
        return strKey;
    }
    return JSON.stringify(jsKey);
}

exports.addPairToJSMap = addPairToJSMap;


/***/ }),

/***/ 7346:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Node = __nccwpck_require__(9464);

/**
 * Recursively convert any node or its contents to native JavaScript
 *
 * @param value - The input value
 * @param arg - If `value` defines a `toJSON()` method, use this
 *   as its first argument
 * @param ctx - Conversion context, originally set in Document#toJS(). If
 *   `{ keep: true }` is not set, output should be suitable for JSON
 *   stringification.
 */
function toJS(value, arg, ctx) {
    if (Array.isArray(value))
        return value.map((v, i) => toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === 'function') {
        if (!ctx || !Node.hasAnchor(value))
            return value.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: undefined };
        ctx.anchors.set(value, data);
        ctx.onCreate = res => {
            data.res = res;
            delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate)
            ctx.onCreate(res);
        return res;
    }
    if (typeof value === 'bigint' && !(ctx && ctx.keep))
        return Number(value);
    return value;
}

exports.toJS = toJS;


/***/ }),

/***/ 5281:
/***/ ((__unused_webpack_module, exports) => {



/**
 * `yaml` defines document-specific options in three places: as an argument of
 * parse, create and stringify calls, in the values of `YAML.defaultOptions`,
 * and in the version-dependent `YAML.Document.defaults` object. Values set in
 * `YAML.defaultOptions` override version-dependent defaults, and argument
 * options override both.
 */
const defaultOptions = {
    intAsBigInt: false,
    logLevel: 'warn',
    prettyErrors: true,
    strict: true,
    uniqueKeys: true,
    version: '1.2'
};

exports.defaultOptions = defaultOptions;


/***/ }),

/***/ 7540:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var resolveBlockScalar = __nccwpck_require__(221);
var resolveFlowScalar = __nccwpck_require__(7231);
var errors = __nccwpck_require__(9043);
var stringifyString = __nccwpck_require__(3833);

/**
 * If `token` is a CST flow or block scalar, determine its string value and a few other attributes.
 * Otherwise, return `null`.
 */
function resolveAsScalar(token, strict = true, onError) {
    if (token) {
        const _onError = (pos, code, message) => {
            const offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
            if (onError)
                onError(offset, code, message);
            else
                throw new errors.YAMLParseError([offset, offset + 1], code, message);
        };
        switch (token.type) {
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
            case 'block-scalar':
                return resolveBlockScalar.resolveBlockScalar(token, strict, _onError);
        }
    }
    return null;
}
/**
 * Create a new scalar token with `value`
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.indent The indent level of the token.
 * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.
 * @param context.offset The offset position of the token.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */
function createScalarToken(value, context) {
    var _a;
    const { implicitKey = false, indent, inFlow = false, offset = -1, type = 'PLAIN' } = context;
    const source = stringifyString.stringifyString({ type, value }, {
        implicitKey,
        indent: indent > 0 ? ' '.repeat(indent) : '',
        inFlow,
        options: { lineWidth: -1 }
    });
    const end = (_a = context.end) !== null && _a !== void 0 ? _a : [
        { type: 'newline', offset: -1, indent, source: '\n' }
    ];
    switch (source[0]) {
        case '|':
        case '>': {
            const he = source.indexOf('\n');
            const head = source.substring(0, he);
            const body = source.substring(he + 1) + '\n';
            const props = [
                { type: 'block-scalar-header', offset, indent, source: head }
            ];
            if (!addEndtoBlockProps(props, end))
                props.push({ type: 'newline', offset: -1, indent, source: '\n' });
            return { type: 'block-scalar', offset, indent, props, source: body };
        }
        case '"':
            return { type: 'double-quoted-scalar', offset, indent, source, end };
        case "'":
            return { type: 'single-quoted-scalar', offset, indent, source, end };
        default:
            return { type: 'scalar', offset, indent, source, end };
    }
}
/**
 * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.
 *
 * Best efforts are made to retain any comments previously associated with the `token`,
 * though all contents within a collection's `items` will be overwritten.
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.afterKey In most cases, values after a key should have an additional level of indentation.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */
function setScalarValue(token, value, context = {}) {
    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
    let indent = 'indent' in token ? token.indent : null;
    if (afterKey && typeof indent === 'number')
        indent += 2;
    if (!type)
        switch (token.type) {
            case 'single-quoted-scalar':
                type = 'QUOTE_SINGLE';
                break;
            case 'double-quoted-scalar':
                type = 'QUOTE_DOUBLE';
                break;
            case 'block-scalar': {
                const header = token.props[0];
                if (header.type !== 'block-scalar-header')
                    throw new Error('Invalid block scalar header');
                type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';
                break;
            }
            default:
                type = 'PLAIN';
        }
    const source = stringifyString.stringifyString({ type, value }, {
        implicitKey: implicitKey || indent === null,
        indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',
        inFlow,
        options: { lineWidth: -1 }
    });
    switch (source[0]) {
        case '|':
        case '>':
            setBlockScalarValue(token, source);
            break;
        case '"':
            setFlowScalarValue(token, source, 'double-quoted-scalar');
            break;
        case "'":
            setFlowScalarValue(token, source, 'single-quoted-scalar');
            break;
        default:
            setFlowScalarValue(token, source, 'scalar');
    }
}
function setBlockScalarValue(token, source) {
    const he = source.indexOf('\n');
    const head = source.substring(0, he);
    const body = source.substring(he + 1) + '\n';
    if (token.type === 'block-scalar') {
        const header = token.props[0];
        if (header.type !== 'block-scalar-header')
            throw new Error('Invalid block scalar header');
        header.source = head;
        token.source = body;
    }
    else {
        const { offset } = token;
        const indent = 'indent' in token ? token.indent : -1;
        const props = [
            { type: 'block-scalar-header', offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined))
            props.push({ type: 'newline', offset: -1, indent, source: '\n' });
        for (const key of Object.keys(token))
            if (key !== 'type' && key !== 'offset')
                delete token[key];
        Object.assign(token, { type: 'block-scalar', indent, props, source: body });
    }
}
/** @returns `true` if last token is a newline */
function addEndtoBlockProps(props, end) {
    if (end)
        for (const st of end)
            switch (st.type) {
                case 'space':
                case 'comment':
                    props.push(st);
                    break;
                case 'newline':
                    props.push(st);
                    return true;
            }
    return false;
}
function setFlowScalarValue(token, source, type) {
    switch (token.type) {
        case 'scalar':
        case 'double-quoted-scalar':
        case 'single-quoted-scalar':
            token.type = type;
            token.source = source;
            break;
        case 'block-scalar': {
            const end = token.props.slice(1);
            let oa = source.length;
            if (token.props[0].type === 'block-scalar-header')
                oa -= token.props[0].source.length;
            for (const tok of end)
                tok.offset += oa;
            delete token.props;
            Object.assign(token, { type, source, end });
            break;
        }
        case 'block-map':
        case 'block-seq': {
            const offset = token.offset + source.length;
            const nl = { type: 'newline', offset, indent: token.indent, source: '\n' };
            delete token.items;
            Object.assign(token, { type, source, end: [nl] });
            break;
        }
        default: {
            const indent = 'indent' in token ? token.indent : -1;
            const end = 'end' in token && Array.isArray(token.end)
                ? token.end.filter(st => st.type === 'space' ||
                    st.type === 'comment' ||
                    st.type === 'newline')
                : [];
            for (const key of Object.keys(token))
                if (key !== 'type' && key !== 'offset')
                    delete token[key];
            Object.assign(token, { type, indent, source, end });
        }
    }
}

exports.createScalarToken = createScalarToken;
exports.resolveAsScalar = resolveAsScalar;
exports.setScalarValue = setScalarValue;


/***/ }),

/***/ 9843:
/***/ ((__unused_webpack_module, exports) => {



/**
 * Stringify a CST document, token, or collection item
 *
 * Fair warning: This applies no validation whatsoever, and
 * simply concatenates the sources in their logical order.
 */
const stringify = (cst) => 'type' in cst ? stringifyToken(cst) : stringifyItem(cst);
function stringifyToken(token) {
    switch (token.type) {
        case 'block-scalar': {
            let res = '';
            for (const tok of token.props)
                res += stringifyToken(tok);
            return res + token.source;
        }
        case 'block-map':
        case 'block-seq': {
            let res = '';
            for (const item of token.items)
                res += stringifyItem(item);
            return res;
        }
        case 'flow-collection': {
            let res = token.start.source;
            for (const item of token.items)
                res += stringifyItem(item);
            for (const st of token.end)
                res += st.source;
            return res;
        }
        case 'document': {
            let res = stringifyItem(token);
            if (token.end)
                for (const st of token.end)
                    res += st.source;
            return res;
        }
        default: {
            let res = token.source;
            if ('end' in token && token.end)
                for (const st of token.end)
                    res += st.source;
            return res;
        }
    }
}
function stringifyItem({ start, key, sep, value }) {
    let res = '';
    for (const st of start)
        res += st.source;
    if (key)
        res += stringifyToken(key);
    if (sep)
        for (const st of sep)
            res += st.source;
    if (value)
        res += stringifyToken(value);
    return res;
}

exports.stringify = stringify;


/***/ }),

/***/ 2171:
/***/ ((__unused_webpack_module, exports) => {



const BREAK = Symbol('break visit');
const SKIP = Symbol('skip children');
const REMOVE = Symbol('remove item');
/**
 * Apply a visitor to a CST document or item.
 *
 * Walks through the tree (depth-first) starting from the root, calling a
 * `visitor` function with two arguments when entering each item:
 *   - `item`: The current item, which included the following members:
 *     - `start: SourceToken[]` – Source tokens before the key or value,
 *       possibly including its anchor or tag.
 *     - `key?: Token | null` – Set for pair values. May then be `null`, if
 *       the key before the `:` separator is empty.
 *     - `sep?: SourceToken[]` – Source tokens between the key and the value,
 *       which should include the `:` map value indicator if `value` is set.
 *     - `value?: Token` – The value of a sequence item, or of a map pair.
 *   - `path`: The steps from the root to the current node, as an array of
 *     `['key' | 'value', number]` tuples.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this token, continue with
 *      next sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current item, then continue with the next one
 *   - `number`: Set the index of the next step. This is useful especially if
 *     the index of the current token has changed.
 *   - `function`: Define the next visitor for this item. After the original
 *     visitor is called on item entry, next visitors are called after handling
 *     a non-empty `key` and when exiting the item.
 */
function visit(cst, visitor) {
    if ('type' in cst && cst.type === 'document')
        cst = { start: cst.start, value: cst.value };
    _visit(Object.freeze([]), cst, visitor);
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visit.BREAK = BREAK;
/** Do not visit the children of the current item */
visit.SKIP = SKIP;
/** Remove the current item */
visit.REMOVE = REMOVE;
/** Find the item at `path` from `cst` as the root */
visit.itemAtPath = (cst, path) => {
    let item = cst;
    for (const [field, index] of path) {
        const tok = item && item[field];
        if (tok && 'items' in tok) {
            item = tok.items[index];
        }
        else
            return undefined;
    }
    return item;
};
/**
 * Get the immediate parent collection of the item at `path` from `cst` as the root.
 *
 * Throws an error if the collection is not found, which should never happen if the item itself exists.
 */
visit.parentCollection = (cst, path) => {
    const parent = visit.itemAtPath(cst, path.slice(0, -1));
    const field = path[path.length - 1][0];
    const coll = parent && parent[field];
    if (coll && 'items' in coll)
        return coll;
    throw new Error('Parent collection not found');
};
function _visit(path, item, visitor) {
    let ctrl = visitor(item, path);
    if (typeof ctrl === 'symbol')
        return ctrl;
    for (const field of ['key', 'value']) {
        const token = item[field];
        if (token && 'items' in token) {
            for (let i = 0; i < token.items.length; ++i) {
                const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    token.items.splice(i, 1);
                    i -= 1;
                }
            }
            if (typeof ctrl === 'function' && field === 'key')
                ctrl = ctrl(item, path);
        }
    }
    return typeof ctrl === 'function' ? ctrl(item, path) : ctrl;
}

exports.visit = visit;


/***/ }),

/***/ 4415:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var cstScalar = __nccwpck_require__(7540);
var cstStringify = __nccwpck_require__(9843);
var cstVisit = __nccwpck_require__(2171);

/** The byte order mark */
const BOM = '\u{FEFF}';
/** Start of doc-mode */
const DOCUMENT = '\x02'; // C0: Start of Text
/** Unexpected end of flow-mode */
const FLOW_END = '\x18'; // C0: Cancel
/** Next token is a scalar value */
const SCALAR = '\x1f'; // C0: Unit Separator
/** @returns `true` if `token` is a flow or block collection */
const isCollection = (token) => !!token && 'items' in token;
/** @returns `true` if `token` is a flow or block scalar; not an alias */
const isScalar = (token) => !!token &&
    (token.type === 'scalar' ||
        token.type === 'single-quoted-scalar' ||
        token.type === 'double-quoted-scalar' ||
        token.type === 'block-scalar');
/* istanbul ignore next */
/** Get a printable representation of a lexer token */
function prettyToken(token) {
    switch (token) {
        case BOM:
            return '<BOM>';
        case DOCUMENT:
            return '<DOC>';
        case FLOW_END:
            return '<FLOW_END>';
        case SCALAR:
            return '<SCALAR>';
        default:
            return JSON.stringify(token);
    }
}
/** Identify the type of a lexer token. May return `null` for unknown tokens. */
function tokenType(source) {
    switch (source) {
        case BOM:
            return 'byte-order-mark';
        case DOCUMENT:
            return 'doc-mode';
        case FLOW_END:
            return 'flow-error-end';
        case SCALAR:
            return 'scalar';
        case '---':
            return 'doc-start';
        case '...':
            return 'doc-end';
        case '':
        case '\n':
        case '\r\n':
            return 'newline';
        case '-':
            return 'seq-item-ind';
        case '?':
            return 'explicit-key-ind';
        case ':':
            return 'map-value-ind';
        case '{':
            return 'flow-map-start';
        case '}':
            return 'flow-map-end';
        case '[':
            return 'flow-seq-start';
        case ']':
            return 'flow-seq-end';
        case ',':
            return 'comma';
    }
    switch (source[0]) {
        case ' ':
        case '\t':
            return 'space';
        case '#':
            return 'comment';
        case '%':
            return 'directive-line';
        case '*':
            return 'alias';
        case '&':
            return 'anchor';
        case '!':
            return 'tag';
        case "'":
            return 'single-quoted-scalar';
        case '"':
            return 'double-quoted-scalar';
        case '|':
        case '>':
            return 'block-scalar-header';
    }
    return null;
}

exports.createScalarToken = cstScalar.createScalarToken;
exports.resolveAsScalar = cstScalar.resolveAsScalar;
exports.setScalarValue = cstScalar.setScalarValue;
exports.stringify = cstStringify.stringify;
exports.visit = cstVisit.visit;
exports.BOM = BOM;
exports.DOCUMENT = DOCUMENT;
exports.FLOW_END = FLOW_END;
exports.SCALAR = SCALAR;
exports.isCollection = isCollection;
exports.isScalar = isScalar;
exports.prettyToken = prettyToken;
exports.tokenType = tokenType;


/***/ }),

/***/ 6074:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var cst = __nccwpck_require__(4415);

/*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/
function isEmpty(ch) {
    switch (ch) {
        case undefined:
        case ' ':
        case '\n':
        case '\r':
        case '\t':
            return true;
        default:
            return false;
    }
}
const hexDigits = '0123456789ABCDEFabcdef'.split('');
const tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split('');
const invalidFlowScalarChars = ',[]{}'.split('');
const invalidAnchorChars = ' ,[]{}\n\r\t'.split('');
const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
/**
 * Splits an input string into lexical tokens, i.e. smaller strings that are
 * easily identifiable by `tokens.tokenType()`.
 *
 * Lexing starts always in a "stream" context. Incomplete input may be buffered
 * until a complete token can be emitted.
 *
 * In addition to slices of the original input, the following control characters
 * may also be emitted:
 *
 * - `\x02` (Start of Text): A document starts with the next token
 * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
 * - `\x1f` (Unit Separator): Next token is a scalar value
 * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
 */
class Lexer {
    constructor() {
        /**
         * Flag indicating whether the end of the current buffer marks the end of
         * all input
         */
        this.atEnd = false;
        /**
         * Explicit indent set in block scalar header, as an offset from the current
         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
         * explicitly set.
         */
        this.blockScalarIndent = -1;
        /**
         * Block scalars that include a + (keep) chomping indicator in their header
         * include trailing empty lines, which are otherwise excluded from the
         * scalar's contents.
         */
        this.blockScalarKeep = false;
        /** Current input */
        this.buffer = '';
        /**
         * Flag noting whether the map value indicator : can immediately follow this
         * node within a flow context.
         */
        this.flowKey = false;
        /** Count of surrounding flow collection levels. */
        this.flowLevel = 0;
        /**
         * Minimum level of indentation required for next lines to be parsed as a
         * part of the current scalar value.
         */
        this.indentNext = 0;
        /** Indentation level of the current line. */
        this.indentValue = 0;
        /** Stores the state of the lexer if reaching the end of incpomplete input */
        this.next = null;
        /** A pointer to `buffer`; the current position of the lexer. */
        this.pos = 0;
    }
    /**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */
    *lex(source, incomplete = false) {
        if (source)
            this.buffer = this.buffer ? this.buffer + source : source;
        this.atEnd = !incomplete;
        let next = this.next || 'stream';
        while (next && (incomplete || this.hasChars(1)))
            next = yield* this.parseNext(next);
    }
    atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === ' ' || ch === '\t')
            ch = this.buffer[++i];
        if (!ch || ch === '#' || ch === '\n')
            return true;
        if (ch === '\r')
            return this.buffer[i + 1] === '\n';
        return false;
    }
    charAt(n) {
        return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
            let indent = 0;
            while (ch === ' ')
                ch = this.buffer[++indent + offset];
            if (ch === '\r') {
                const next = this.buffer[indent + offset + 1];
                if (next === '\n' || (!next && !this.atEnd))
                    return offset + indent + 1;
            }
            return ch === '\n' || indent >= this.indentNext || (!ch && !this.atEnd)
                ? offset + indent
                : -1;
        }
        if (ch === '-' || ch === '.') {
            const dt = this.buffer.substr(offset, 3);
            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))
                return -1;
        }
        return offset;
    }
    getLine() {
        let end = this.buffer.indexOf('\n', this.pos);
        if (end === -1)
            return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === '\r')
            end -= 1;
        return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
        return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.next = state;
        return null;
    }
    peek(n) {
        return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
        switch (next) {
            case 'stream':
                return yield* this.parseStream();
            case 'line-start':
                return yield* this.parseLineStart();
            case 'block-start':
                return yield* this.parseBlockStart();
            case 'doc':
                return yield* this.parseDocument();
            case 'flow':
                return yield* this.parseFlowCollection();
            case 'quoted-scalar':
                return yield* this.parseQuotedScalar();
            case 'block-scalar':
                return yield* this.parseBlockScalar();
            case 'plain-scalar':
                return yield* this.parsePlainScalar();
        }
    }
    *parseStream() {
        let line = this.getLine();
        if (line === null)
            return this.setNext('stream');
        if (line[0] === cst.BOM) {
            yield* this.pushCount(1);
            line = line.substring(1);
        }
        if (line[0] === '%') {
            let dirEnd = line.length;
            const cs = line.indexOf('#');
            if (cs !== -1) {
                const ch = line[cs - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd = cs - 1;
            }
            while (true) {
                const ch = line[dirEnd - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd -= 1;
                else
                    break;
            }
            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
            yield* this.pushCount(line.length - n); // possible comment
            this.pushNewline();
            return 'stream';
        }
        if (this.atLineEnd()) {
            const sp = yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - sp);
            yield* this.pushNewline();
            return 'stream';
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
    }
    *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
            return this.setNext('line-start');
        if (ch === '-' || ch === '.') {
            if (!this.atEnd && !this.hasChars(4))
                return this.setNext('line-start');
            const s = this.peek(3);
            if (s === '---' && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                this.indentValue = 0;
                this.indentNext = 0;
                return 'doc';
            }
            else if (s === '...' && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                return 'stream';
            }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
            this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
            return this.setNext('block-start');
        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {
            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
            this.indentNext = this.indentValue + 1;
            this.indentValue += n;
            return yield* this.parseBlockStart();
        }
        return 'doc';
    }
    *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
            return this.setNext('doc');
        let n = yield* this.pushIndicators();
        switch (line[n]) {
            case '#':
                yield* this.pushCount(line.length - n);
            // fallthrough
            case undefined:
                yield* this.pushNewline();
                return yield* this.parseLineStart();
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel = 1;
                return 'flow';
            case '}':
            case ']':
                // this is an error
                yield* this.pushCount(1);
                return 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'doc';
            case '"':
            case "'":
                return yield* this.parseQuotedScalar();
            case '|':
            case '>':
                n += yield* this.parseBlockScalarHeader();
                n += yield* this.pushSpaces(true);
                yield* this.pushCount(line.length - n);
                yield* this.pushNewline();
                return yield* this.parseBlockScalar();
            default:
                return yield* this.parsePlainScalar();
        }
    }
    *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
            nl = yield* this.pushNewline();
            sp = yield* this.pushSpaces(true);
            if (nl > 0)
                this.indentValue = indent = sp;
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
            return this.setNext('flow');
        if ((indent !== -1 && indent < this.indentNext) ||
            (indent === 0 &&
                (line.startsWith('---') || line.startsWith('...')) &&
                isEmpty(line[3]))) {
            // Allowing for the terminal ] or } at the same (rather than greater)
            // indent level as the initial [ or { is technically invalid, but
            // failing here would be surprising to users.
            const atFlowEndMarker = indent === this.indentNext - 1 &&
                this.flowLevel === 1 &&
                (line[0] === ']' || line[0] === '}');
            if (!atFlowEndMarker) {
                // this is an error
                this.flowLevel = 0;
                yield cst.FLOW_END;
                return yield* this.parseLineStart();
            }
        }
        let n = 0;
        while (line[n] === ',')
            n += (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
        n += yield* this.pushIndicators();
        switch (line[n]) {
            case undefined:
                return 'flow';
            case '#':
                yield* this.pushCount(line.length - n);
                return 'flow';
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel += 1;
                return 'flow';
            case '}':
            case ']':
                yield* this.pushCount(1);
                this.flowKey = true;
                this.flowLevel -= 1;
                return this.flowLevel ? 'flow' : 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'flow';
            case '"':
            case "'":
                this.flowKey = true;
                return yield* this.parseQuotedScalar();
            case ':': {
                const next = this.charAt(1);
                if (this.flowKey || isEmpty(next) || next === ',') {
                    yield* this.pushCount(1);
                    yield* this.pushSpaces(true);
                    return 'flow';
                }
            }
            // fallthrough
            default:
                this.flowKey = false;
                return yield* this.parsePlainScalar();
        }
    }
    *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
            while (end !== -1 && this.buffer[end + 1] === "'")
                end = this.buffer.indexOf("'", end + 2);
        }
        else {
            // double-quote
            while (end !== -1) {
                let n = 0;
                while (this.buffer[end - 1 - n] === '\\')
                    n += 1;
                if (n % 2 === 0)
                    break;
                end = this.buffer.indexOf('"', end + 1);
            }
        }
        let nl = this.buffer.indexOf('\n', this.pos);
        if (nl !== -1 && nl < end) {
            while (nl !== -1 && nl < end) {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = this.buffer.indexOf('\n', cs);
            }
            if (nl !== -1 && nl < end) {
                // this is an error caused by an unexpected unindent
                end = nl - 1;
            }
        }
        if (end === -1) {
            if (!this.atEnd)
                return this.setNext('quoted-scalar');
            end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? 'flow' : 'doc';
    }
    *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
            const ch = this.buffer[++i];
            if (ch === '+')
                this.blockScalarKeep = true;
            else if (ch > '0' && ch <= '9')
                this.blockScalarIndent = Number(ch) - 1;
            else if (ch !== '-')
                break;
        }
        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');
    }
    *parseBlockScalar() {
        let nl = this.pos - 1; // may be -1 if this.pos === 0
        let indent = 0;
        let ch;
        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {
            switch (ch) {
                case ' ':
                    indent += 1;
                    break;
                case '\n':
                    nl = i;
                    indent = 0;
                    break;
                case '\r': {
                    const next = this.buffer[i + 1];
                    if (!next && !this.atEnd)
                        return this.setNext('block-scalar');
                    if (next === '\n')
                        break;
                } // fallthrough
                default:
                    break loop;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('block-scalar');
        if (indent >= this.indentNext) {
            if (this.blockScalarIndent === -1)
                this.indentNext = indent;
            else
                this.indentNext += this.blockScalarIndent;
            do {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = this.buffer.indexOf('\n', cs);
            } while (nl !== -1);
            if (nl === -1) {
                if (!this.atEnd)
                    return this.setNext('block-scalar');
                nl = this.buffer.length;
            }
        }
        if (!this.blockScalarKeep) {
            do {
                let i = nl - 1;
                let ch = this.buffer[i];
                if (ch === '\r')
                    ch = this.buffer[--i];
                while (ch === ' ' || ch === '\t')
                    ch = this.buffer[--i];
                if (ch === '\n' && i >= this.pos)
                    nl = i;
                else
                    break;
            } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while ((ch = this.buffer[++i])) {
            if (ch === ':') {
                const next = this.buffer[i + 1];
                if (isEmpty(next) || (inFlow && next === ','))
                    break;
                end = i;
            }
            else if (isEmpty(ch)) {
                const next = this.buffer[i + 1];
                if (next === '#' || (inFlow && invalidFlowScalarChars.includes(next)))
                    break;
                if (ch === '\r') {
                    if (next === '\n') {
                        i += 1;
                        ch = '\n';
                    }
                    else
                        end = i;
                }
                if (ch === '\n') {
                    const cs = this.continueScalar(i + 1);
                    if (cs === -1)
                        break;
                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'
                }
            }
            else {
                if (inFlow && invalidFlowScalarChars.includes(ch))
                    break;
                end = i;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('plain-scalar');
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? 'flow' : 'doc';
    }
    *pushCount(n) {
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos += n;
            return n;
        }
        return 0;
    }
    *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
            yield s;
            this.pos += s.length;
            return s.length;
        }
        else if (allowEmpty)
            yield '';
        return 0;
    }
    *pushIndicators() {
        switch (this.charAt(0)) {
            case '!':
                return ((yield* this.pushTag()) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '&':
                return ((yield* this.pushUntil(isNotAnchorChar)) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case ':':
            case '?': // this is an error outside flow collections
            case '-': // this is an error
                if (isEmpty(this.charAt(1))) {
                    if (this.flowLevel === 0)
                        this.indentNext = this.indentValue + 1;
                    return ((yield* this.pushCount(1)) +
                        (yield* this.pushSpaces(true)) +
                        (yield* this.pushIndicators()));
                }
        }
        return 0;
    }
    *pushTag() {
        if (this.charAt(1) === '<') {
            let i = this.pos + 2;
            let ch = this.buffer[i];
            while (!isEmpty(ch) && ch !== '>')
                ch = this.buffer[++i];
            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);
        }
        else {
            let i = this.pos + 1;
            let ch = this.buffer[i];
            while (ch) {
                if (tagChars.includes(ch))
                    ch = this.buffer[++i];
                else if (ch === '%' &&
                    hexDigits.includes(this.buffer[i + 1]) &&
                    hexDigits.includes(this.buffer[i + 2])) {
                    ch = this.buffer[(i += 3)];
                }
                else
                    break;
            }
            return yield* this.pushToIndex(i, false);
        }
    }
    *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === '\n')
            return yield* this.pushCount(1);
        else if (ch === '\r' && this.charAt(1) === '\n')
            return yield* this.pushCount(2);
        else
            return 0;
    }
    *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
            ch = this.buffer[++i];
        } while (ch === ' ' || (allowTabs && ch === '\t'));
        const n = i - this.pos;
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos = i;
        }
        return n;
    }
    *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
            ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
    }
}

exports.Lexer = Lexer;


/***/ }),

/***/ 8257:
/***/ ((__unused_webpack_module, exports) => {



/**
 * Tracks newlines during parsing in order to provide an efficient API for
 * determining the one-indexed `{ line, col }` position for any offset
 * within the input.
 */
class LineCounter {
    constructor() {
        this.lineStarts = [];
        /**
         * Should be called in ascending order. Otherwise, call
         * `lineCounter.lineStarts.sort()` before calling `linePos()`.
         */
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        /**
         * Performs a binary search and returns the 1-indexed { line, col }
         * position of `offset`. If `line === 0`, `addNewLine` has never been
         * called or `offset` is before the first known newline.
         */
        this.linePos = (offset) => {
            let low = 0;
            let high = this.lineStarts.length;
            while (low < high) {
                const mid = (low + high) >> 1; // Math.floor((low + high) / 2)
                if (this.lineStarts[mid] < offset)
                    low = mid + 1;
                else
                    high = mid;
            }
            if (this.lineStarts[low] === offset)
                return { line: low + 1, col: 1 };
            if (low === 0)
                return { line: 0, col: offset };
            const start = this.lineStarts[low - 1];
            return { line: low, col: offset - start + 1 };
        };
    }
}

exports.LineCounter = LineCounter;


/***/ }),

/***/ 2270:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var cst = __nccwpck_require__(4415);
var lexer = __nccwpck_require__(6074);

function includesToken(list, type) {
    for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
            return true;
    return false;
}
function includesNonEmpty(list) {
    for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
            case 'space':
            case 'comment':
            case 'newline':
                break;
            default:
                return true;
        }
    }
    return false;
}
function isFlowToken(token) {
    switch (token === null || token === void 0 ? void 0 : token.type) {
        case 'alias':
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'flow-collection':
            return true;
        default:
            return false;
    }
}
function getPrevProps(parent) {
    switch (parent.type) {
        case 'document':
            return parent.start;
        case 'block-map': {
            const it = parent.items[parent.items.length - 1];
            return it.sep || it.start;
        }
        case 'block-seq':
            return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
            return [];
    }
}
/** Note: May modify input array */
function getFirstKeyStartProps(prev) {
    var _a;
    if (prev.length === 0)
        return [];
    let i = prev.length;
    loop: while (--i >= 0) {
        switch (prev[i].type) {
            case 'doc-start':
            case 'explicit-key-ind':
            case 'map-value-ind':
            case 'seq-item-ind':
            case 'newline':
                break loop;
        }
    }
    while (((_a = prev[++i]) === null || _a === void 0 ? void 0 : _a.type) === 'space') {
        /* loop */
    }
    return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
    if (fc.start.type === 'flow-seq-start') {
        for (const it of fc.items) {
            if (it.sep &&
                !it.value &&
                !includesToken(it.start, 'explicit-key-ind') &&
                !includesToken(it.sep, 'map-value-ind')) {
                if (it.key)
                    it.value = it.key;
                delete it.key;
                if (isFlowToken(it.value)) {
                    if (it.value.end)
                        Array.prototype.push.apply(it.value.end, it.sep);
                    else
                        it.value.end = it.sep;
                }
                else
                    Array.prototype.push.apply(it.start, it.sep);
                delete it.sep;
            }
        }
    }
}
/**
 * A YAML concrete syntax tree (CST) parser
 *
 * ```ts
 * const src: string = ...
 * for (const token of new Parser().parse(src)) {
 *   // token: Token
 * }
 * ```
 *
 * To use the parser with a user-provided lexer:
 *
 * ```ts
 * function* parse(source: string, lexer: Lexer) {
 *   const parser = new Parser()
 *   for (const lexeme of lexer.lex(source))
 *     yield* parser.next(lexeme)
 *   yield* parser.end()
 * }
 *
 * const src: string = ...
 * const lexer = new Lexer()
 * for (const token of parse(src, lexer)) {
 *   // token: Token
 * }
 * ```
 */
class Parser {
    /**
     * @param onNewLine - If defined, called separately with the start position of
     *   each new line (in `parse()`, including the start of input).
     */
    constructor(onNewLine) {
        /** If true, space and sequence indicators count as indentation */
        this.atNewLine = true;
        /** If true, next token is a scalar value */
        this.atScalar = false;
        /** Current indentation level */
        this.indent = 0;
        /** Current offset since the start of parsing */
        this.offset = 0;
        /** On the same line with a block map key */
        this.onKeyLine = false;
        /** Top indicates the node that's currently being built */
        this.stack = [];
        /** The source of the current token, set in parse() */
        this.source = '';
        /** The type of the current token, set in parse() */
        this.type = '';
        // Must be defined after `next()`
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
    }
    /**
     * Parse `source` as a YAML stream.
     * If `incomplete`, a part of the last line may be left as a buffer for the next call.
     *
     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
     *
     * @returns A generator of tokens representing each directive, document, and other structure.
     */
    *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
            this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
            yield* this.next(lexeme);
        if (!incomplete)
            yield* this.end();
    }
    /**
     * Advance the parser by the `source` of one lexical token.
     */
    *next(source) {
        this.source = source;
        if (process.env.LOG_TOKENS)
            console.log('|', cst.prettyToken(source));
        if (this.atScalar) {
            this.atScalar = false;
            yield* this.step();
            this.offset += source.length;
            return;
        }
        const type = cst.tokenType(source);
        if (!type) {
            const message = `Not a YAML token: ${source}`;
            yield* this.pop({ type: 'error', offset: this.offset, message, source });
            this.offset += source.length;
        }
        else if (type === 'scalar') {
            this.atNewLine = false;
            this.atScalar = true;
            this.type = 'scalar';
        }
        else {
            this.type = type;
            yield* this.step();
            switch (type) {
                case 'newline':
                    this.atNewLine = true;
                    this.indent = 0;
                    if (this.onNewLine)
                        this.onNewLine(this.offset + source.length);
                    break;
                case 'space':
                    if (this.atNewLine && source[0] === ' ')
                        this.indent += source.length;
                    break;
                case 'explicit-key-ind':
                case 'map-value-ind':
                case 'seq-item-ind':
                    if (this.atNewLine)
                        this.indent += source.length;
                    break;
                case 'doc-mode':
                    return;
                default:
                    this.atNewLine = false;
            }
            this.offset += source.length;
        }
    }
    /** Call at end of input to push out any remaining constructions */
    *end() {
        while (this.stack.length > 0)
            yield* this.pop();
    }
    get sourceToken() {
        const st = {
            type: this.type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
        return st;
    }
    *step() {
        const top = this.peek(1);
        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {
            while (this.stack.length > 0)
                yield* this.pop();
            this.stack.push({
                type: 'doc-end',
                offset: this.offset,
                source: this.source
            });
            return;
        }
        if (!top)
            return yield* this.stream();
        switch (top.type) {
            case 'document':
                return yield* this.document(top);
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return yield* this.scalar(top);
            case 'block-scalar':
                return yield* this.blockScalar(top);
            case 'block-map':
                return yield* this.blockMap(top);
            case 'block-seq':
                return yield* this.blockSequence(top);
            case 'flow-collection':
                return yield* this.flowCollection(top);
            case 'doc-end':
                return yield* this.documentEnd(top);
        }
        /* istanbul ignore next should not happen */
        yield* this.pop();
    }
    peek(n) {
        return this.stack[this.stack.length - n];
    }
    *pop(error) {
        const token = error || this.stack.pop();
        /* istanbul ignore if should not happen */
        if (!token) {
            const message = 'Tried to pop an empty stack';
            yield { type: 'error', offset: this.offset, source: '', message };
        }
        else if (this.stack.length === 0) {
            yield token;
        }
        else {
            const top = this.peek(1);
            // For these, parent indent is needed instead of own
            if (token.type === 'block-scalar' || token.type === 'flow-collection')
                token.indent = 'indent' in top ? top.indent : -1;
            if (token.type === 'flow-collection')
                fixFlowSeqItems(token);
            switch (top.type) {
                case 'document':
                    top.value = token;
                    break;
                case 'block-scalar':
                    top.props.push(token); // error
                    break;
                case 'block-map': {
                    const it = top.items[top.items.length - 1];
                    if (it.value) {
                        top.items.push({ start: [], key: token, sep: [] });
                        this.onKeyLine = true;
                        return;
                    }
                    else if (it.sep) {
                        it.value = token;
                    }
                    else {
                        Object.assign(it, { key: token, sep: [] });
                        this.onKeyLine = !includesToken(it.start, 'explicit-key-ind');
                        return;
                    }
                    break;
                }
                case 'block-seq': {
                    const it = top.items[top.items.length - 1];
                    if (it.value)
                        top.items.push({ start: [], value: token });
                    else
                        it.value = token;
                    break;
                }
                case 'flow-collection': {
                    const it = top.items[top.items.length - 1];
                    if (!it || it.value)
                        top.items.push({ start: [], key: token, sep: [] });
                    else if (it.sep)
                        it.value = token;
                    else
                        Object.assign(it, { key: token, sep: [] });
                    return;
                }
                /* istanbul ignore next should not happen */
                default:
                    yield* this.pop();
                    yield* this.pop(token);
            }
            if ((top.type === 'document' ||
                top.type === 'block-map' ||
                top.type === 'block-seq') &&
                (token.type === 'block-map' || token.type === 'block-seq')) {
                const last = token.items[token.items.length - 1];
                if (last &&
                    !last.sep &&
                    !last.value &&
                    last.start.length > 0 &&
                    !includesNonEmpty(last.start) &&
                    (token.indent === 0 ||
                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {
                    if (top.type === 'document')
                        top.end = last.start;
                    else
                        top.items.push({ start: last.start });
                    token.items.splice(-1, 1);
                }
            }
        }
    }
    *stream() {
        switch (this.type) {
            case 'directive-line':
                yield { type: 'directive', offset: this.offset, source: this.source };
                return;
            case 'byte-order-mark':
            case 'space':
            case 'comment':
            case 'newline':
                yield this.sourceToken;
                return;
            case 'doc-mode':
            case 'doc-start': {
                const doc = {
                    type: 'document',
                    offset: this.offset,
                    start: []
                };
                if (this.type === 'doc-start')
                    doc.start.push(this.sourceToken);
                this.stack.push(doc);
                return;
            }
        }
        yield {
            type: 'error',
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML stream`,
            source: this.source
        };
    }
    *document(doc) {
        if (doc.value)
            return yield* this.lineEnd(doc);
        switch (this.type) {
            case 'doc-start': {
                if (includesNonEmpty(doc.start)) {
                    yield* this.pop();
                    yield* this.step();
                }
                else
                    doc.start.push(this.sourceToken);
                return;
            }
            case 'anchor':
            case 'tag':
            case 'space':
            case 'comment':
            case 'newline':
                doc.start.push(this.sourceToken);
                return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
            this.stack.push(bv);
        else {
            yield {
                type: 'error',
                offset: this.offset,
                message: `Unexpected ${this.type} token in YAML document`,
                source: this.source
            };
        }
    }
    *scalar(scalar) {
        if (this.type === 'map-value-ind') {
            const prev = getPrevProps(this.peek(2));
            const start = getFirstKeyStartProps(prev);
            let sep;
            if (scalar.end) {
                sep = scalar.end;
                sep.push(this.sourceToken);
                delete scalar.end;
            }
            else
                sep = [this.sourceToken];
            const map = {
                type: 'block-map',
                offset: scalar.offset,
                indent: scalar.indent,
                items: [{ start, key: scalar, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
        }
        else
            yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
        switch (this.type) {
            case 'space':
            case 'comment':
            case 'newline':
                scalar.props.push(this.sourceToken);
                return;
            case 'scalar':
                scalar.source = this.source;
                // block-scalar source includes trailing newline
                this.atNewLine = true;
                this.indent = 0;
                if (this.onNewLine) {
                    let nl = this.source.indexOf('\n') + 1;
                    while (nl !== 0) {
                        this.onNewLine(this.offset + nl);
                        nl = this.source.indexOf('\n', nl) + 1;
                    }
                }
                yield* this.pop();
                break;
            /* istanbul ignore next should not happen */
            default:
                yield* this.pop();
                yield* this.step();
        }
    }
    *blockMap(map) {
        var _a;
        const it = map.items[map.items.length - 1];
        // it.sep is true-ish if pair already has key or : separator
        switch (this.type) {
            case 'newline':
                this.onKeyLine = false;
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if ((last === null || last === void 0 ? void 0 : last.type) === 'comment')
                        end === null || end === void 0 ? void 0 : end.push(this.sourceToken);
                    else
                        map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep)
                    it.sep.push(this.sourceToken);
                else
                    it.start.push(this.sourceToken);
                return;
            case 'space':
            case 'comment':
                if (it.value)
                    map.items.push({ start: [this.sourceToken] });
                else if (it.sep)
                    it.sep.push(this.sourceToken);
                else {
                    if (this.atIndentedComment(it.start, map.indent)) {
                        const prev = map.items[map.items.length - 2];
                        const end = (_a = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a === void 0 ? void 0 : _a.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            map.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
        }
        if (this.indent >= map.indent) {
            const atNextItem = !this.onKeyLine &&
                this.indent === map.indent &&
                (it.sep || includesNonEmpty(it.start));
            switch (this.type) {
                case 'anchor':
                case 'tag':
                    if (atNextItem || it.value) {
                        map.items.push({ start: [this.sourceToken] });
                        this.onKeyLine = true;
                    }
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'explicit-key-ind':
                    if (!it.sep && !includesToken(it.start, 'explicit-key-ind'))
                        it.start.push(this.sourceToken);
                    else if (atNextItem || it.value)
                        map.items.push({ start: [this.sourceToken] });
                    else
                        this.stack.push({
                            type: 'block-map',
                            offset: this.offset,
                            indent: this.indent,
                            items: [{ start: [this.sourceToken] }]
                        });
                    this.onKeyLine = true;
                    return;
                case 'map-value-ind':
                    if (!it.sep)
                        Object.assign(it, { key: null, sep: [this.sourceToken] });
                    else if (it.value ||
                        (atNextItem && !includesToken(it.start, 'explicit-key-ind')))
                        map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                    else if (includesToken(it.sep, 'map-value-ind'))
                        this.stack.push({
                            type: 'block-map',
                            offset: this.offset,
                            indent: this.indent,
                            items: [{ start: [], key: null, sep: [this.sourceToken] }]
                        });
                    else if (includesToken(it.start, 'explicit-key-ind') &&
                        isFlowToken(it.key) &&
                        !includesToken(it.sep, 'newline')) {
                        const start = getFirstKeyStartProps(it.start);
                        const key = it.key;
                        const sep = it.sep;
                        sep.push(this.sourceToken);
                        // @ts-ignore type guard is wrong here
                        delete it.key, delete it.sep;
                        this.stack.push({
                            type: 'block-map',
                            offset: this.offset,
                            indent: this.indent,
                            items: [{ start, key, sep }]
                        });
                    }
                    else
                        it.sep.push(this.sourceToken);
                    this.onKeyLine = true;
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (atNextItem || it.value) {
                        map.items.push({ start: [], key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        this.stack.push(fs);
                    }
                    else {
                        Object.assign(it, { key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    return;
                }
                default: {
                    const bv = this.startBlockValue(map);
                    if (bv) {
                        if (atNextItem &&
                            bv.type !== 'block-seq' &&
                            includesToken(it.start, 'explicit-key-ind'))
                            map.items.push({ start: [] });
                        this.stack.push(bv);
                        return;
                    }
                }
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *blockSequence(seq) {
        var _a;
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
            case 'newline':
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if ((last === null || last === void 0 ? void 0 : last.type) === 'comment')
                        end === null || end === void 0 ? void 0 : end.push(this.sourceToken);
                    else
                        seq.items.push({ start: [this.sourceToken] });
                }
                else
                    it.start.push(this.sourceToken);
                return;
            case 'space':
            case 'comment':
                if (it.value)
                    seq.items.push({ start: [this.sourceToken] });
                else {
                    if (this.atIndentedComment(it.start, seq.indent)) {
                        const prev = seq.items[seq.items.length - 2];
                        const end = (_a = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a === void 0 ? void 0 : _a.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            seq.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
            case 'anchor':
            case 'tag':
                if (it.value || this.indent <= seq.indent)
                    break;
                it.start.push(this.sourceToken);
                return;
            case 'seq-item-ind':
                if (this.indent !== seq.indent)
                    break;
                if (it.value || includesToken(it.start, 'seq-item-ind'))
                    seq.items.push({ start: [this.sourceToken] });
                else
                    it.start.push(this.sourceToken);
                return;
        }
        if (this.indent > seq.indent) {
            const bv = this.startBlockValue(seq);
            if (bv) {
                this.stack.push(bv);
                return;
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === 'flow-error-end') {
            let top;
            do {
                yield* this.pop();
                top = this.peek(1);
            } while (top && top.type === 'flow-collection');
        }
        else if (fc.end.length === 0) {
            switch (this.type) {
                case 'comma':
                case 'explicit-key-ind':
                    if (!it || it.sep)
                        fc.items.push({ start: [this.sourceToken] });
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'map-value-ind':
                    if (!it || it.value)
                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        Object.assign(it, { key: null, sep: [this.sourceToken] });
                    return;
                case 'space':
                case 'comment':
                case 'newline':
                case 'anchor':
                case 'tag':
                    if (!it || it.value)
                        fc.items.push({ start: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (!it || it.value)
                        fc.items.push({ start: [], key: fs, sep: [] });
                    else if (it.sep)
                        this.stack.push(fs);
                    else
                        Object.assign(it, { key: fs, sep: [] });
                    return;
                }
                case 'flow-map-end':
                case 'flow-seq-end':
                    fc.end.push(this.sourceToken);
                    return;
            }
            const bv = this.startBlockValue(fc);
            /* istanbul ignore else should not happen */
            if (bv)
                this.stack.push(bv);
            else {
                yield* this.pop();
                yield* this.step();
            }
        }
        else {
            const parent = this.peek(2);
            if (parent.type === 'block-map' &&
                (this.type === 'map-value-ind' ||
                    (this.type === 'newline' &&
                        !parent.items[parent.items.length - 1].sep))) {
                yield* this.pop();
                yield* this.step();
            }
            else if (this.type === 'map-value-ind' &&
                parent.type !== 'flow-collection') {
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                fixFlowSeqItems(fc);
                const sep = fc.end.splice(1, fc.end.length);
                sep.push(this.sourceToken);
                const map = {
                    type: 'block-map',
                    offset: fc.offset,
                    indent: fc.indent,
                    items: [{ start, key: fc, sep }]
                };
                this.onKeyLine = true;
                this.stack[this.stack.length - 1] = map;
            }
            else {
                yield* this.lineEnd(fc);
            }
        }
    }
    flowScalar(type) {
        if (this.onNewLine) {
            let nl = this.source.indexOf('\n') + 1;
            while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf('\n', nl) + 1;
            }
        }
        return {
            type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
    }
    startBlockValue(parent) {
        switch (this.type) {
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return this.flowScalar(this.type);
            case 'block-scalar-header':
                return {
                    type: 'block-scalar',
                    offset: this.offset,
                    indent: this.indent,
                    props: [this.sourceToken],
                    source: ''
                };
            case 'flow-map-start':
            case 'flow-seq-start':
                return {
                    type: 'flow-collection',
                    offset: this.offset,
                    indent: this.indent,
                    start: this.sourceToken,
                    items: [],
                    end: []
                };
            case 'seq-item-ind':
                return {
                    type: 'block-seq',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [this.sourceToken] }]
                };
            case 'explicit-key-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                start.push(this.sourceToken);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start }]
                };
            }
            case 'map-value-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                };
            }
        }
        return null;
    }
    atIndentedComment(start, indent) {
        if (this.type !== 'comment')
            return false;
        if (this.indent <= indent)
            return false;
        return start.every(st => st.type === 'newline' || st.type === 'space');
    }
    *documentEnd(docEnd) {
        if (this.type !== 'doc-mode') {
            if (docEnd.end)
                docEnd.end.push(this.sourceToken);
            else
                docEnd.end = [this.sourceToken];
            if (this.type === 'newline')
                yield* this.pop();
        }
    }
    *lineEnd(token) {
        switch (this.type) {
            case 'comma':
            case 'doc-start':
            case 'doc-end':
            case 'flow-seq-end':
            case 'flow-map-end':
            case 'map-value-ind':
                yield* this.pop();
                yield* this.step();
                break;
            case 'newline':
                this.onKeyLine = false;
            // fallthrough
            case 'space':
            case 'comment':
            default:
                // all other values are errors
                if (token.end)
                    token.end.push(this.sourceToken);
                else
                    token.end = [this.sourceToken];
                if (this.type === 'newline')
                    yield* this.pop();
        }
    }
}

exports.Parser = Parser;


/***/ }),

/***/ 2963:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var composer = __nccwpck_require__(2920);
var Document = __nccwpck_require__(5663);
var errors = __nccwpck_require__(9043);
var log = __nccwpck_require__(1728);
var lineCounter = __nccwpck_require__(8257);
var parser = __nccwpck_require__(2270);

function parseOptions(options) {
    const prettyErrors = !options || options.prettyErrors !== false;
    const lineCounter$1 = (options && options.lineCounter) ||
        (prettyErrors && new lineCounter.LineCounter()) ||
        null;
    return { lineCounter: lineCounter$1, prettyErrors };
}
/**
 * Parse the input as a stream of YAML documents.
 *
 * Documents should be separated from each other by `...` or `---` marker lines.
 *
 * @returns If an empty `docs` array is returned, it will be of type
 *   EmptyStream and contain additional stream information. In
 *   TypeScript, you should use `'empty' in docs` as a type guard for it.
 */
function parseAllDocuments(source, options = {}) {
    const { lineCounter, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter === null || lineCounter === void 0 ? void 0 : lineCounter.addNewLine);
    const composer$1 = new composer.Composer(options);
    const docs = Array.from(composer$1.compose(parser$1.parse(source)));
    if (prettyErrors && lineCounter)
        for (const doc of docs) {
            doc.errors.forEach(errors.prettifyError(source, lineCounter));
            doc.warnings.forEach(errors.prettifyError(source, lineCounter));
        }
    if (docs.length > 0)
        return docs;
    return Object.assign([], { empty: true }, composer$1.streamInfo());
}
/** Parse an input string into a single YAML.Document */
function parseDocument(source, options = {}) {
    const { lineCounter, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter === null || lineCounter === void 0 ? void 0 : lineCounter.addNewLine);
    const composer$1 = new composer.Composer(options);
    // `doc` is always set by compose.end(true) at the very latest
    let doc = null;
    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
        if (!doc)
            doc = _doc;
        else if (doc.options.logLevel !== 'silent') {
            doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));
            break;
        }
    }
    if (prettyErrors && lineCounter) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter));
    }
    return doc;
}
function parse(src, reviver, options) {
    let _reviver = undefined;
    if (typeof reviver === 'function') {
        _reviver = reviver;
    }
    else if (options === undefined && reviver && typeof reviver === 'object') {
        options = reviver;
    }
    const doc = parseDocument(src, options);
    if (!doc)
        return null;
    doc.warnings.forEach(warning => log.warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
        if (doc.options.logLevel !== 'silent')
            throw doc.errors[0];
        else
            doc.errors = [];
    }
    return doc.toJS(Object.assign({ reviver: _reviver }, options));
}
function stringify(value, replacer, options) {
    let _replacer = null;
    if (typeof replacer === 'function' || Array.isArray(replacer)) {
        _replacer = replacer;
    }
    else if (options === undefined && replacer) {
        options = replacer;
    }
    if (typeof options === 'string')
        options = options.length;
    if (typeof options === 'number') {
        const indent = Math.round(options);
        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };
    }
    if (value === undefined) {
        const { keepUndefined } = options || replacer || {};
        if (!keepUndefined)
            return undefined;
    }
    return new Document.Document(value, _replacer, options).toString(options);
}

exports.parse = parse;
exports.parseAllDocuments = parseAllDocuments;
exports.parseDocument = parseDocument;
exports.stringify = stringify;


/***/ }),

/***/ 187:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Node = __nccwpck_require__(9464);
var map = __nccwpck_require__(8514);
var seq = __nccwpck_require__(4523);
var string = __nccwpck_require__(4906);
var tags = __nccwpck_require__(985);

const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
class Schema {
    constructor({ customTags, merge, resolveKnownTags, schema, sortMapEntries }) {
        this.merge = !!merge;
        this.name = schema || 'core';
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name);
        Object.defineProperty(this, Node.MAP, { value: map.map });
        Object.defineProperty(this, Node.SCALAR, { value: string.string });
        Object.defineProperty(this, Node.SEQ, { value: seq.seq });
        // Used by createMap()
        this.sortMapEntries =
            sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
    }
}

exports.Schema = Schema;


/***/ }),

/***/ 8514:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Node = __nccwpck_require__(9464);
var Pair = __nccwpck_require__(5456);
var YAMLMap = __nccwpck_require__(5505);

function createMap(schema, obj, ctx) {
    const { keepUndefined, replacer } = ctx;
    const map = new YAMLMap.YAMLMap(schema);
    const add = (key, value) => {
        if (typeof replacer === 'function')
            value = replacer.call(obj, key, value);
        else if (Array.isArray(replacer) && !replacer.includes(key))
            return;
        if (value !== undefined || keepUndefined)
            map.items.push(Pair.createPair(key, value, ctx));
    };
    if (obj instanceof Map) {
        for (const [key, value] of obj)
            add(key, value);
    }
    else if (obj && typeof obj === 'object') {
        for (const key of Object.keys(obj))
            add(key, obj[key]);
    }
    if (typeof schema.sortMapEntries === 'function') {
        map.items.sort(schema.sortMapEntries);
    }
    return map;
}
const map = {
    collection: 'map',
    createNode: createMap,
    default: true,
    nodeClass: YAMLMap.YAMLMap,
    tag: 'tag:yaml.org,2002:map',
    resolve(map, onError) {
        if (!Node.isMap(map))
            onError('Expected a mapping for this tag');
        return map;
    }
};

exports.map = map;


/***/ }),

/***/ 3361:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Scalar = __nccwpck_require__(3229);

const nullTag = {
    identify: value => value == null,
    createNode: () => new Scalar.Scalar(null),
    default: true,
    tag: 'tag:yaml.org,2002:null',
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar.Scalar(null),
    stringify: ({ source }, ctx) => source && nullTag.test.test(source) ? source : ctx.options.nullStr
};

exports.nullTag = nullTag;


/***/ }),

/***/ 4523:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var createNode = __nccwpck_require__(9718);
var Node = __nccwpck_require__(9464);
var YAMLSeq = __nccwpck_require__(4967);

function createSeq(schema, obj, ctx) {
    const { replacer } = ctx;
    const seq = new YAMLSeq.YAMLSeq(schema);
    if (obj && Symbol.iterator in Object(obj)) {
        let i = 0;
        for (let it of obj) {
            if (typeof replacer === 'function') {
                const key = obj instanceof Set ? it : String(i++);
                it = replacer.call(obj, key, it);
            }
            seq.items.push(createNode.createNode(it, undefined, ctx));
        }
    }
    return seq;
}
const seq = {
    collection: 'seq',
    createNode: createSeq,
    default: true,
    nodeClass: YAMLSeq.YAMLSeq,
    tag: 'tag:yaml.org,2002:seq',
    resolve(seq, onError) {
        if (!Node.isSeq(seq))
            onError('Expected a sequence for this tag');
        return seq;
    }
};

exports.seq = seq;


/***/ }),

/***/ 4906:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var stringifyString = __nccwpck_require__(3833);

const string = {
    identify: value => typeof value === 'string',
    default: true,
    tag: 'tag:yaml.org,2002:str',
    resolve: str => str,
    stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
    }
};

exports.string = string;


/***/ }),

/***/ 9514:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Scalar = __nccwpck_require__(3229);

const boolTag = {
    identify: value => typeof value === 'boolean',
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: str => new Scalar.Scalar(str[0] === 't' || str[0] === 'T'),
    stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
            const sv = source[0] === 't' || source[0] === 'T';
            if (value === sv)
                return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
};

exports.boolTag = boolTag;


/***/ }),

/***/ 1626:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Scalar = __nccwpck_require__(3229);
var stringifyNumber = __nccwpck_require__(2735);

const floatNaN = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
    resolve: str => str.slice(-3).toLowerCase() === 'nan'
        ? NaN
        : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
};
const floatExp = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'EXP',
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: str => parseFloat(str),
    stringify: ({ value }) => Number(value).toExponential()
};
const float = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str));
        const dot = str.indexOf('.');
        if (dot !== -1 && str[str.length - 1] === '0')
            node.minFractionDigits = str.length - dot - 1;
        return node;
    },
    stringify: stringifyNumber.stringifyNumber
};

exports.float = float;
exports.floatExp = floatExp;
exports.floatNaN = floatNaN;


/***/ }),

/***/ 7586:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var stringifyNumber = __nccwpck_require__(2735);

const intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);
const intResolve = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));
function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value) && value >= 0)
        return prefix + value.toString(radix);
    return stringifyNumber.stringifyNumber(node);
}
const intOct = {
    identify: value => intIdentify(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'OCT',
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
    stringify: node => intStringify(node, 8, '0o')
};
const int = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
};
const intHex = {
    identify: value => intIdentify(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'HEX',
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: node => intStringify(node, 16, '0x')
};

exports.int = int;
exports.intHex = intHex;
exports.intOct = intOct;


/***/ }),

/***/ 9867:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var map = __nccwpck_require__(8514);
var _null = __nccwpck_require__(3361);
var seq = __nccwpck_require__(4523);
var string = __nccwpck_require__(4906);
var bool = __nccwpck_require__(9514);
var float = __nccwpck_require__(1626);
var int = __nccwpck_require__(7586);

const schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.boolTag,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float
];

exports.schema = schema;


/***/ }),

/***/ 884:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Scalar = __nccwpck_require__(3229);
var map = __nccwpck_require__(8514);
var seq = __nccwpck_require__(4523);

function intIdentify(value) {
    return typeof value === 'bigint' || Number.isInteger(value);
}
const stringifyJSON = ({ value }) => JSON.stringify(value);
const jsonScalars = [
    {
        identify: value => typeof value === 'string',
        default: true,
        tag: 'tag:yaml.org,2002:str',
        resolve: str => str,
        stringify: stringifyJSON
    },
    {
        identify: value => value == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: 'tag:yaml.org,2002:null',
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
    },
    {
        identify: value => typeof value === 'boolean',
        default: true,
        tag: 'tag:yaml.org,2002:bool',
        test: /^true|false$/,
        resolve: str => str === 'true',
        stringify: stringifyJSON
    },
    {
        identify: intIdentify,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
    },
    {
        identify: value => typeof value === 'number',
        default: true,
        tag: 'tag:yaml.org,2002:float',
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: str => parseFloat(str),
        stringify: stringifyJSON
    }
];
const jsonError = {
    default: true,
    tag: '',
    test: /^/,
    resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
    }
};
const schema = [map.map, seq.seq].concat(jsonScalars, jsonError);

exports.schema = schema;


/***/ }),

/***/ 985:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var map = __nccwpck_require__(8514);
var _null = __nccwpck_require__(3361);
var seq = __nccwpck_require__(4523);
var string = __nccwpck_require__(4906);
var bool = __nccwpck_require__(9514);
var float = __nccwpck_require__(1626);
var int = __nccwpck_require__(7586);
var schema = __nccwpck_require__(9867);
var schema$1 = __nccwpck_require__(884);
var binary = __nccwpck_require__(3912);
var omap = __nccwpck_require__(502);
var pairs = __nccwpck_require__(2491);
var schema$2 = __nccwpck_require__(9317);
var set = __nccwpck_require__(4839);
var timestamp = __nccwpck_require__(2004);

const schemas = {
    core: schema.schema,
    failsafe: [map.map, seq.seq, string.string],
    json: schema$1.schema,
    yaml11: schema$2.schema,
    'yaml-1.1': schema$2.schema
};
const tagsByName = {
    binary: binary.binary,
    bool: bool.boolTag,
    float: float.float,
    floatExp: float.floatExp,
    floatNaN: float.floatNaN,
    floatTime: timestamp.floatTime,
    int: int.int,
    intHex: int.intHex,
    intOct: int.intOct,
    intTime: timestamp.intTime,
    map: map.map,
    null: _null.nullTag,
    omap: omap.omap,
    pairs: pairs.pairs,
    seq: seq.seq,
    set: set.set,
    timestamp: timestamp.timestamp
};
const coreKnownTags = {
    'tag:yaml.org,2002:binary': binary.binary,
    'tag:yaml.org,2002:omap': omap.omap,
    'tag:yaml.org,2002:pairs': pairs.pairs,
    'tag:yaml.org,2002:set': set.set,
    'tag:yaml.org,2002:timestamp': timestamp.timestamp
};
function getTags(customTags, schemaName) {
    let tags = schemas[schemaName];
    if (!tags) {
        const keys = Object.keys(schemas)
            .filter(key => key !== 'yaml11')
            .map(key => JSON.stringify(key))
            .join(', ');
        throw new Error(`Unknown schema "${schemaName}"; use one of ${keys}`);
    }
    if (Array.isArray(customTags)) {
        for (const tag of customTags)
            tags = tags.concat(tag);
    }
    else if (typeof customTags === 'function') {
        tags = customTags(tags.slice());
    }
    return tags.map(tag => {
        if (typeof tag !== 'string')
            return tag;
        const tagObj = tagsByName[tag];
        if (tagObj)
            return tagObj;
        const keys = Object.keys(tagsByName)
            .map(key => JSON.stringify(key))
            .join(', ');
        throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
    });
}

exports.coreKnownTags = coreKnownTags;
exports.getTags = getTags;


/***/ }),

/***/ 3912:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Scalar = __nccwpck_require__(3229);
var stringifyString = __nccwpck_require__(3833);

const binary = {
    identify: value => value instanceof Uint8Array,
    default: false,
    tag: 'tag:yaml.org,2002:binary',
    /**
     * Returns a Buffer in node and an Uint8Array in browsers
     *
     * To use the resulting buffer as an image, you'll want to do something like:
     *
     *   const blob = new Blob([buffer], { type: 'image/jpeg' })
     *   document.querySelector('#photo').src = URL.createObjectURL(blob)
     */
    resolve(src, onError) {
        if (typeof Buffer === 'function') {
            return Buffer.from(src, 'base64');
        }
        else if (typeof atob === 'function') {
            // On IE 11, atob() can't handle newlines
            const str = atob(src.replace(/[\n\r]/g, ''));
            const buffer = new Uint8Array(str.length);
            for (let i = 0; i < str.length; ++i)
                buffer[i] = str.charCodeAt(i);
            return buffer;
        }
        else {
            onError('This environment does not support reading binary tags; either Buffer or atob is required');
            return src;
        }
    },
    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        const buf = value; // checked earlier by binary.identify()
        let str;
        if (typeof Buffer === 'function') {
            str =
                buf instanceof Buffer
                    ? buf.toString('base64')
                    : Buffer.from(buf.buffer).toString('base64');
        }
        else if (typeof btoa === 'function') {
            let s = '';
            for (let i = 0; i < buf.length; ++i)
                s += String.fromCharCode(buf[i]);
            str = btoa(s);
        }
        else {
            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
        }
        if (!type)
            type = Scalar.Scalar.BLOCK_LITERAL;
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
            const n = Math.ceil(str.length / lineWidth);
            const lines = new Array(n);
            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
                lines[i] = str.substr(o, lineWidth);
            }
            str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? '\n' : ' ');
        }
        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
    }
};

exports.binary = binary;


/***/ }),

/***/ 1654:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Scalar = __nccwpck_require__(3229);

function boolStringify({ value, source }, ctx) {
    const boolObj = value ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
        return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
}
const trueTag = {
    identify: value => value === true,
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar.Scalar(true),
    stringify: boolStringify
};
const falseTag = {
    identify: value => value === false,
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
    resolve: () => new Scalar.Scalar(false),
    stringify: boolStringify
};

exports.falseTag = falseTag;
exports.trueTag = trueTag;


/***/ }),

/***/ 6117:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Scalar = __nccwpck_require__(3229);
var stringifyNumber = __nccwpck_require__(2735);

const floatNaN = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === 'nan'
        ? NaN
        : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
};
const floatExp = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'EXP',
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, '')),
    stringify: ({ value }) => Number(value).toExponential()
};
const float = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, '')));
        const dot = str.indexOf('.');
        if (dot !== -1) {
            const f = str.substring(dot + 1).replace(/_/g, '');
            if (f[f.length - 1] === '0')
                node.minFractionDigits = f.length;
        }
        return node;
    },
    stringify: stringifyNumber.stringifyNumber
};

exports.float = float;
exports.floatExp = floatExp;
exports.floatNaN = floatNaN;


/***/ }),

/***/ 963:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var stringifyNumber = __nccwpck_require__(2735);

const intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);
function intResolve(str, offset, radix, { intAsBigInt }) {
    const sign = str[0];
    if (sign === '-' || sign === '+')
        offset += 1;
    str = str.substring(offset).replace(/_/g, '');
    if (intAsBigInt) {
        switch (radix) {
            case 2:
                str = `0b${str}`;
                break;
            case 8:
                str = `0o${str}`;
                break;
            case 16:
                str = `0x${str}`;
                break;
        }
        const n = BigInt(str);
        return sign === '-' ? BigInt(-1) * n : n;
    }
    const n = parseInt(str, radix);
    return sign === '-' ? -1 * n : n;
}
function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber.stringifyNumber(node);
}
const intBin = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'BIN',
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
    stringify: node => intStringify(node, 2, '0b')
};
const intOct = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'OCT',
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
    stringify: node => intStringify(node, 8, '0')
};
const int = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
};
const intHex = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'HEX',
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: node => intStringify(node, 16, '0x')
};

exports.int = int;
exports.intBin = intBin;
exports.intHex = intHex;
exports.intOct = intOct;


/***/ }),

/***/ 502:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var YAMLSeq = __nccwpck_require__(4967);
var toJS = __nccwpck_require__(7346);
var Node = __nccwpck_require__(9464);
var YAMLMap = __nccwpck_require__(5505);
var pairs = __nccwpck_require__(2491);

class YAMLOMap extends YAMLSeq.YAMLSeq {
    constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = YAMLOMap.tag;
    }
    /**
     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
     * but TypeScript won't allow widening the signature of a child method.
     */
    toJSON(_, ctx) {
        if (!ctx)
            return super.toJSON(_);
        const map = new Map();
        if (ctx && ctx.onCreate)
            ctx.onCreate(map);
        for (const pair of this.items) {
            let key, value;
            if (Node.isPair(pair)) {
                key = toJS.toJS(pair.key, '', ctx);
                value = toJS.toJS(pair.value, key, ctx);
            }
            else {
                key = toJS.toJS(pair, '', ctx);
            }
            if (map.has(key))
                throw new Error('Ordered maps must not include duplicate keys');
            map.set(key, value);
        }
        return map;
    }
}
YAMLOMap.tag = 'tag:yaml.org,2002:omap';
const omap = {
    collection: 'seq',
    identify: value => value instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: 'tag:yaml.org,2002:omap',
    resolve(seq, onError) {
        const pairs$1 = pairs.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
            if (Node.isScalar(key)) {
                if (seenKeys.includes(key.value)) {
                    onError(`Ordered maps must not include duplicate keys: ${key.value}`);
                }
                else {
                    seenKeys.push(key.value);
                }
            }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
    },
    createNode(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap = new YAMLOMap();
        omap.items = pairs$1.items;
        return omap;
    }
};

exports.YAMLOMap = YAMLOMap;
exports.omap = omap;


/***/ }),

/***/ 2491:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Node = __nccwpck_require__(9464);
var Pair = __nccwpck_require__(5456);
var Scalar = __nccwpck_require__(3229);
var YAMLSeq = __nccwpck_require__(4967);

function resolvePairs(seq, onError) {
    if (Node.isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
            let item = seq.items[i];
            if (Node.isPair(item))
                continue;
            else if (Node.isMap(item)) {
                if (item.items.length > 1)
                    onError('Each pair must have its own sequence indicator');
                const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
                if (item.commentBefore)
                    pair.key.commentBefore = pair.key.commentBefore
                        ? `${item.commentBefore}\n${pair.key.commentBefore}`
                        : item.commentBefore;
                if (item.comment) {
                    const cn = pair.value || pair.key;
                    cn.comment = cn.comment
                        ? `${item.comment}\n${cn.comment}`
                        : item.comment;
                }
                item = pair;
            }
            seq.items[i] = Node.isPair(item) ? item : new Pair.Pair(item);
        }
    }
    else
        onError('Expected a sequence for this tag');
    return seq;
}
function createPairs(schema, iterable, ctx) {
    const { replacer } = ctx;
    const pairs = new YAMLSeq.YAMLSeq(schema);
    pairs.tag = 'tag:yaml.org,2002:pairs';
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
            if (typeof replacer === 'function')
                it = replacer.call(iterable, String(i++), it);
            let key, value;
            if (Array.isArray(it)) {
                if (it.length === 2) {
                    key = it[0];
                    value = it[1];
                }
                else
                    throw new TypeError(`Expected [key, value] tuple: ${it}`);
            }
            else if (it && it instanceof Object) {
                const keys = Object.keys(it);
                if (keys.length === 1) {
                    key = keys[0];
                    value = it[key];
                }
                else
                    throw new TypeError(`Expected { key: value } tuple: ${it}`);
            }
            else {
                key = it;
            }
            pairs.items.push(Pair.createPair(key, value, ctx));
        }
    return pairs;
}
const pairs = {
    collection: 'seq',
    default: false,
    tag: 'tag:yaml.org,2002:pairs',
    resolve: resolvePairs,
    createNode: createPairs
};

exports.createPairs = createPairs;
exports.pairs = pairs;
exports.resolvePairs = resolvePairs;


/***/ }),

/***/ 9317:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var map = __nccwpck_require__(8514);
var _null = __nccwpck_require__(3361);
var seq = __nccwpck_require__(4523);
var string = __nccwpck_require__(4906);
var binary = __nccwpck_require__(3912);
var bool = __nccwpck_require__(1654);
var float = __nccwpck_require__(6117);
var int = __nccwpck_require__(963);
var omap = __nccwpck_require__(502);
var pairs = __nccwpck_require__(2491);
var set = __nccwpck_require__(4839);
var timestamp = __nccwpck_require__(2004);

const schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.trueTag,
    bool.falseTag,
    int.intBin,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float,
    binary.binary,
    omap.omap,
    pairs.pairs,
    set.set,
    timestamp.intTime,
    timestamp.floatTime,
    timestamp.timestamp
];

exports.schema = schema;


/***/ }),

/***/ 4839:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Node = __nccwpck_require__(9464);
var Pair = __nccwpck_require__(5456);
var YAMLMap = __nccwpck_require__(5505);

class YAMLSet extends YAMLMap.YAMLMap {
    constructor(schema) {
        super(schema);
        this.tag = YAMLSet.tag;
    }
    add(key) {
        let pair;
        if (Node.isPair(key))
            pair = key;
        else if (typeof key === 'object' &&
            'key' in key &&
            'value' in key &&
            key.value === null)
            pair = new Pair.Pair(key.key, null);
        else
            pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev)
            this.items.push(pair);
    }
    get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && Node.isPair(pair)
            ? Node.isScalar(pair.key)
                ? pair.key.value
                : pair.key
            : pair;
    }
    set(key, value) {
        if (typeof value !== 'boolean')
            throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value) {
            this.items.splice(this.items.indexOf(prev), 1);
        }
        else if (!prev && value) {
            this.items.push(new Pair.Pair(key));
        }
    }
    toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        if (this.hasAllNullValues(true))
            return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
            throw new Error('Set items must all have null values');
    }
}
YAMLSet.tag = 'tag:yaml.org,2002:set';
const set = {
    collection: 'map',
    identify: value => value instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: 'tag:yaml.org,2002:set',
    resolve(map, onError) {
        if (Node.isMap(map)) {
            if (map.hasAllNullValues(true))
                return Object.assign(new YAMLSet(), map);
            else
                onError('Set items must all have null values');
        }
        else
            onError('Expected a mapping for this tag');
        return map;
    },
    createNode(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set = new YAMLSet(schema);
        if (iterable && Symbol.iterator in Object(iterable))
            for (let value of iterable) {
                if (typeof replacer === 'function')
                    value = replacer.call(iterable, value, value);
                set.items.push(Pair.createPair(value, null, ctx));
            }
        return set;
    }
};

exports.YAMLSet = YAMLSet;
exports.set = set;


/***/ }),

/***/ 2004:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var stringifyNumber = __nccwpck_require__(2735);

/** Internal types handle bigint as number, because TS can't figure it out. */
function parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === '-' || sign === '+' ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts
        .replace(/_/g, '')
        .split(':')
        .reduce((res, p) => res * num(60) + num(p), num(0));
    return (sign === '-' ? num(-1) * res : res);
}
/**
 * hhhh:mm:ss.sss
 *
 * Internal types handle bigint as number, because TS can't figure it out.
 */
function stringifySexagesimal(node) {
    let { value } = node;
    let num = (n) => n;
    if (typeof value === 'bigint')
        num = n => BigInt(n);
    else if (isNaN(value) || !isFinite(value))
        return stringifyNumber.stringifyNumber(node);
    let sign = '';
    if (value < 0) {
        sign = '-';
        value *= num(-1);
    }
    const _60 = num(60);
    const parts = [value % _60]; // seconds, including ms
    if (value < 60) {
        parts.unshift(0); // at least one : is required
    }
    else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60); // minutes
        if (value >= 60) {
            value = (value - parts[0]) / _60;
            parts.unshift(value); // hours
        }
    }
    return (sign +
        parts
            .map(n => (n < 10 ? '0' + String(n) : String(n)))
            .join(':')
            .replace(/000000\d*$/, '') // % 60 may introduce error
    );
}
const intTime = {
    identify: value => typeof value === 'bigint' || Number.isInteger(value),
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'TIME',
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
};
const floatTime = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'TIME',
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: str => parseSexagesimal(str, false),
    stringify: stringifySexagesimal
};
const timestamp = {
    identify: value => value instanceof Date,
    default: true,
    tag: 'tag:yaml.org,2002:timestamp',
    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
    // may be omitted altogether, resulting in a date format. In such a case, the time part is
    // assumed to be 00:00:00Z (start of day, UTC).
    test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
        '(?:' + // time is optional
        '(?:t|T|[ \\t]+)' + // t | T | whitespace
        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
        '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
        ')?$'),
    resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
            throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== 'Z') {
            let d = parseSexagesimal(tz, false);
            if (Math.abs(d) < 30)
                d *= 60;
            date -= 60000 * d;
        }
        return new Date(date);
    },
    stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, '')
};

exports.floatTime = floatTime;
exports.intTime = intTime;
exports.timestamp = timestamp;


/***/ }),

/***/ 2069:
/***/ ((__unused_webpack_module, exports) => {



const FOLD_FLOW = 'flow';
const FOLD_BLOCK = 'block';
const FOLD_QUOTED = 'quoted';
/**
 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
 * terminated with `\n` and started with `indent`.
 */
function foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
        return text;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep)
        return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === 'number') {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
            folds.push(0);
        else
            end = lineWidth - indentAtStart;
    }
    let split = undefined;
    let prev = undefined;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i);
        if (i !== -1)
            end = i + endStep;
    }
    for (let ch; (ch = text[(i += 1)]);) {
        if (mode === FOLD_QUOTED && ch === '\\') {
            escStart = i;
            switch (text[i + 1]) {
                case 'x':
                    i += 3;
                    break;
                case 'u':
                    i += 5;
                    break;
                case 'U':
                    i += 9;
                    break;
                default:
                    i += 1;
            }
            escEnd = i;
        }
        if (ch === '\n') {
            if (mode === FOLD_BLOCK)
                i = consumeMoreIndentedLines(text, i);
            end = i + endStep;
            split = undefined;
        }
        else {
            if (ch === ' ' &&
                prev &&
                prev !== ' ' &&
                prev !== '\n' &&
                prev !== '\t') {
                // space surrounded by non-space can be replaced with newline + indent
                const next = text[i + 1];
                if (next && next !== ' ' && next !== '\n' && next !== '\t')
                    split = i;
            }
            if (i >= end) {
                if (split) {
                    folds.push(split);
                    end = split + endStep;
                    split = undefined;
                }
                else if (mode === FOLD_QUOTED) {
                    // white-space collected at end may stretch past lineWidth
                    while (prev === ' ' || prev === '\t') {
                        prev = ch;
                        ch = text[(i += 1)];
                        overflow = true;
                    }
                    // Account for newline escape, but don't break preceding escape
                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;
                    // Bail out if lineWidth & minContentWidth are shorter than an escape string
                    if (escapedFolds[j])
                        return text;
                    folds.push(j);
                    escapedFolds[j] = true;
                    end = j + endStep;
                    split = undefined;
                }
                else {
                    overflow = true;
                }
            }
        }
        prev = ch;
    }
    if (overflow && onOverflow)
        onOverflow();
    if (folds.length === 0)
        return text;
    if (onFold)
        onFold();
    let res = text.slice(0, folds[0]);
    for (let i = 0; i < folds.length; ++i) {
        const fold = folds[i];
        const end = folds[i + 1] || text.length;
        if (fold === 0)
            res = `\n${indent}${text.slice(0, end)}`;
        else {
            if (mode === FOLD_QUOTED && escapedFolds[fold])
                res += `${text[fold]}\\`;
            res += `\n${indent}${text.slice(fold + 1, end)}`;
        }
    }
    return res;
}
/**
 * Presumes `i + 1` is at the start of a line
 * @returns index of last newline in more-indented block
 */
function consumeMoreIndentedLines(text, i) {
    let ch = text[i + 1];
    while (ch === ' ' || ch === '\t') {
        do {
            ch = text[(i += 1)];
        } while (ch && ch !== '\n');
        ch = text[i + 1];
    }
    return i;
}

exports.FOLD_BLOCK = FOLD_BLOCK;
exports.FOLD_FLOW = FOLD_FLOW;
exports.FOLD_QUOTED = FOLD_QUOTED;
exports.foldFlowLines = foldFlowLines;


/***/ }),

/***/ 7354:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var anchors = __nccwpck_require__(793);
var Node = __nccwpck_require__(9464);
var stringifyString = __nccwpck_require__(3833);

const createStringifyContext = (doc, options) => ({
    anchors: new Set(),
    doc,
    indent: '',
    indentStep: typeof options.indent === 'number' ? ' '.repeat(options.indent) : '  ',
    options: Object.assign({
        defaultKeyType: null,
        defaultStringType: 'PLAIN',
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: 'false',
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: 'null',
        simpleKeys: false,
        singleQuote: false,
        trueStr: 'true',
        verifyAliasOrder: true
    }, options)
});
function getTagObject(tags, item) {
    if (item.tag) {
        const match = tags.filter(t => t.tag === item.tag);
        if (match.length > 0)
            return match.find(t => t.format === item.format) || match[0];
    }
    let tagObj = undefined;
    let obj;
    if (Node.isScalar(item)) {
        obj = item.value;
        const match = tags.filter(t => t.identify && t.identify(obj));
        tagObj =
            match.find(t => t.format === item.format) || match.find(t => !t.format);
    }
    else {
        obj = item;
        tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
        // @ts-ignore
        const name = obj && obj.constructor ? obj.constructor.name : typeof obj;
        throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
}
// needs to be called before value stringifier to allow for circular anchor refs
function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
    const props = [];
    const anchor = (Node.isScalar(node) || Node.isCollection(node)) && node.anchor;
    if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
    }
    if (node.tag) {
        props.push(doc.directives.tagString(node.tag));
    }
    else if (!tagObj.default) {
        props.push(doc.directives.tagString(tagObj.tag));
    }
    return props.join(' ');
}
function stringify(item, ctx, onComment, onChompKeep) {
    if (Node.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
    if (Node.isAlias(item))
        return item.toString(ctx);
    let tagObj = undefined;
    const node = Node.isNode(item)
        ? item
        : ctx.doc.createNode(item, { onTagObj: o => (tagObj = o) });
    if (!tagObj)
        tagObj = getTagObject(ctx.doc.schema.tags, node);
    const props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
    const str = typeof tagObj.stringify === 'function'
        ? tagObj.stringify(node, ctx, onComment, onChompKeep)
        : Node.isScalar(node)
            ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep)
            : node.toString(ctx, onComment, onChompKeep);
    if (!props)
        return str;
    return Node.isScalar(node) || str[0] === '{' || str[0] === '['
        ? `${props} ${str}`
        : `${props}\n${ctx.indent}${str}`;
}

exports.createStringifyContext = createStringifyContext;
exports.stringify = stringify;


/***/ }),

/***/ 7842:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Collection = __nccwpck_require__(7381);
var Node = __nccwpck_require__(9464);
var stringify = __nccwpck_require__(7354);
var stringifyComment = __nccwpck_require__(5523);

function stringifyCollection({ comment, flow, items }, ctx, { blockItem, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, indentStep } = ctx;
    const inFlow = flow || ctx.inFlow;
    if (inFlow)
        itemIndent += indentStep;
    ctx = Object.assign({}, ctx, { indent: itemIndent, inFlow, type: null });
    let singleLineOutput = true;
    let chompKeep = false; // flag for the preceding node's status
    const nodes = items.reduce((nodes, item, i) => {
        let comment = null;
        if (Node.isNode(item)) {
            if (!chompKeep && item.spaceBefore)
                nodes.push({ comment: true, str: '' });
            let cb = item.commentBefore;
            if (cb && chompKeep)
                cb = cb.replace(/^\n+/, '');
            if (cb) {
                if (/^\n+$/.test(cb))
                    cb = cb.substring(1);
                // This match will always succeed on a non-empty string
                for (const line of cb.match(/^.*$/gm)) {
                    const str = line === ' ' ? '#' : line ? `#${line}` : '';
                    nodes.push({ comment: true, str });
                }
            }
            if (item.comment) {
                comment = item.comment;
                singleLineOutput = false;
            }
        }
        else if (Node.isPair(item)) {
            const ik = Node.isNode(item.key) ? item.key : null;
            if (ik) {
                if (!chompKeep && ik.spaceBefore)
                    nodes.push({ comment: true, str: '' });
                let cb = ik.commentBefore;
                if (cb && chompKeep)
                    cb = cb.replace(/^\n+/, '');
                if (cb) {
                    if (/^\n+$/.test(cb))
                        cb = cb.substring(1);
                    // This match will always succeed on a non-empty string
                    for (const line of cb.match(/^.*$/gm)) {
                        const str = line === ' ' ? '#' : line ? `#${line}` : '';
                        nodes.push({ comment: true, str });
                    }
                }
                if (ik.comment)
                    singleLineOutput = false;
            }
            if (inFlow) {
                const iv = Node.isNode(item.value) ? item.value : null;
                if (iv) {
                    if (iv.comment)
                        comment = iv.comment;
                    if (iv.comment || iv.commentBefore)
                        singleLineOutput = false;
                }
                else if (item.value == null && ik && ik.comment) {
                    comment = ik.comment;
                }
            }
        }
        chompKeep = false;
        let str = stringify.stringify(item, ctx, () => (comment = null), () => (chompKeep = true));
        if (inFlow && i < items.length - 1)
            str += ',';
        str = stringifyComment.addComment(str, itemIndent, comment);
        if (chompKeep && (comment || inFlow))
            chompKeep = false;
        nodes.push({ comment: false, str });
        return nodes;
    }, []);
    let str;
    if (nodes.length === 0) {
        str = flowChars.start + flowChars.end;
    }
    else if (inFlow) {
        const { start, end } = flowChars;
        const strings = nodes.map(n => n.str);
        let singleLineLength = 2;
        for (const node of nodes) {
            if (node.comment || node.str.includes('\n')) {
                singleLineOutput = false;
                break;
            }
            singleLineLength += node.str.length + 2;
        }
        if (!singleLineOutput ||
            singleLineLength > Collection.Collection.maxFlowStringSingleLineLength) {
            str = start;
            for (const s of strings) {
                str += s ? `\n${indentStep}${indent}${s}` : '\n';
            }
            str += `\n${indent}${end}`;
        }
        else {
            str = `${start} ${strings.join(' ')} ${end}`;
        }
    }
    else {
        const strings = nodes.map(blockItem);
        str = strings.shift() || '';
        for (const s of strings)
            str += s ? `\n${indent}${s}` : '\n';
    }
    if (comment) {
        str += '\n' + stringifyComment.stringifyComment(comment, indent);
        if (onComment)
            onComment();
    }
    else if (chompKeep && onChompKeep)
        onChompKeep();
    return str;
}

exports.stringifyCollection = stringifyCollection;


/***/ }),

/***/ 5523:
/***/ ((__unused_webpack_module, exports) => {



const stringifyComment = (comment, indent) => /^\n+$/.test(comment)
    ? comment.substring(1)
    : comment.replace(/^(?!$)(?: $)?/gm, `${indent}#`);
function addComment(str, indent, comment) {
    return !comment
        ? str
        : comment.includes('\n')
            ? `${str}\n` + stringifyComment(comment, indent)
            : str.endsWith(' ')
                ? `${str}#${comment}`
                : `${str} #${comment}`;
}

exports.addComment = addComment;
exports.stringifyComment = stringifyComment;


/***/ }),

/***/ 7351:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Node = __nccwpck_require__(9464);
var stringify = __nccwpck_require__(7354);
var stringifyComment = __nccwpck_require__(5523);

function stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false) {
        const dir = doc.directives.toString(doc);
        if (dir) {
            lines.push(dir);
            hasDirectives = true;
        }
        else if (doc.directives.marker)
            hasDirectives = true;
    }
    if (hasDirectives)
        lines.push('---');
    if (doc.commentBefore) {
        if (lines.length !== 1)
            lines.unshift('');
        lines.unshift(stringifyComment.stringifyComment(doc.commentBefore, ''));
    }
    const ctx = stringify.createStringifyContext(doc, options);
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
        if (Node.isNode(doc.contents)) {
            if (doc.contents.spaceBefore && hasDirectives)
                lines.push('');
            if (doc.contents.commentBefore)
                lines.push(stringifyComment.stringifyComment(doc.contents.commentBefore, ''));
            // top-level block scalars need to be indented if followed by a comment
            ctx.forceBlockIndent = !!doc.comment;
            contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);
        let body = stringify.stringify(doc.contents, ctx, () => (contentComment = null), onChompKeep);
        if (contentComment)
            body = stringifyComment.addComment(body, '', contentComment);
        if ((body[0] === '|' || body[0] === '>') &&
            lines[lines.length - 1] === '---') {
            // Top-level block scalars with a preceding doc marker ought to use the
            // same line for their header.
            lines[lines.length - 1] = `--- ${body}`;
        }
        else
            lines.push(body);
    }
    else {
        lines.push(stringify.stringify(doc.contents, ctx));
    }
    let dc = doc.comment;
    if (dc && chompKeep)
        dc = dc.replace(/^\n+/, '');
    if (dc) {
        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')
            lines.push('');
        lines.push(stringifyComment.stringifyComment(dc, ''));
    }
    return lines.join('\n') + '\n';
}

exports.stringifyDocument = stringifyDocument;


/***/ }),

/***/ 2735:
/***/ ((__unused_webpack_module, exports) => {



function stringifyNumber({ format, minFractionDigits, tag, value }) {
    if (typeof value === 'bigint')
        return String(value);
    const num = typeof value === 'number' ? value : Number(value);
    if (!isFinite(num))
        return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';
    let n = JSON.stringify(value);
    if (!format &&
        minFractionDigits &&
        (!tag || tag === 'tag:yaml.org,2002:float') &&
        /^\d/.test(n)) {
        let i = n.indexOf('.');
        if (i < 0) {
            i = n.length;
            n += '.';
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
            n += '0';
    }
    return n;
}

exports.stringifyNumber = stringifyNumber;


/***/ }),

/***/ 1156:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Node = __nccwpck_require__(9464);
var Scalar = __nccwpck_require__(3229);
var stringify = __nccwpck_require__(7354);
var stringifyComment = __nccwpck_require__(5523);

function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { indentSeq, simpleKeys } } = ctx;
    let keyComment = (Node.isNode(key) && key.comment) || null;
    if (simpleKeys) {
        if (keyComment) {
            throw new Error('With simple keys, key nodes cannot have comments');
        }
        if (Node.isCollection(key)) {
            const msg = 'With simple keys, collection cannot be used as a key value';
            throw new Error(msg);
        }
    }
    let explicitKey = !simpleKeys &&
        (!key ||
            (keyComment && value == null && !ctx.inFlow) ||
            Node.isCollection(key) ||
            (Node.isScalar(key)
                ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL
                : typeof key === 'object'));
    ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify.stringify(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');
        explicitKey = true;
    }
    if (ctx.inFlow) {
        if (allNullValues || value == null) {
            if (keyCommentDone && onComment)
                onComment();
            return explicitKey ? `? ${str}` : str;
        }
    }
    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {
        if (keyCommentDone)
            keyComment = null;
        if (chompKeep && !keyComment && onChompKeep)
            onChompKeep();
        return stringifyComment.addComment(`? ${str}`, ctx.indent, keyComment);
    }
    if (keyCommentDone)
        keyComment = null;
    str = explicitKey
        ? `? ${stringifyComment.addComment(str, ctx.indent, keyComment)}\n${indent}:`
        : stringifyComment.addComment(`${str}:`, ctx.indent, keyComment);
    let vcb = '';
    let valueComment = null;
    if (Node.isNode(value)) {
        if (value.spaceBefore)
            vcb = '\n';
        if (value.commentBefore)
            vcb += `\n${stringifyComment.stringifyComment(value.commentBefore, ctx.indent)}`;
        valueComment = value.comment;
    }
    else if (value && typeof value === 'object') {
        value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && Node.isScalar(value))
        ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq &&
        indentStep.length >= 2 &&
        !ctx.inFlow &&
        !explicitKey &&
        Node.isSeq(value) &&
        !value.flow &&
        !value.tag &&
        !value.anchor) {
        // If indentSeq === false, consider '- ' as part of indentation where possible
        ctx.indent = ctx.indent.substr(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify.stringify(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));
    let ws = ' ';
    if (vcb || keyComment) {
        ws = `${vcb}\n${ctx.indent}`;
    }
    else if (!explicitKey && Node.isCollection(value)) {
        const flow = valueStr[0] === '[' || valueStr[0] === '{';
        if (!flow || valueStr.includes('\n'))
            ws = `\n${ctx.indent}`;
    }
    else if (valueStr[0] === '\n')
        ws = '';
    if (ctx.inFlow) {
        if (valueCommentDone && onComment)
            onComment();
        return str + ws + valueStr;
    }
    else {
        if (valueCommentDone)
            valueComment = null;
        if (chompKeep && !valueComment && onChompKeep)
            onChompKeep();
        return stringifyComment.addComment(str + ws + valueStr, ctx.indent, valueComment);
    }
}

exports.stringifyPair = stringifyPair;


/***/ }),

/***/ 3833:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Scalar = __nccwpck_require__(3229);
var foldFlowLines = __nccwpck_require__(2069);

const getFoldOptions = (ctx) => ({
    indentAtStart: ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
});
// Also checks for lines starting with %, as parsing the output as YAML 1.1 will
// presume that's starting a new document.
const containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
        return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
        return false;
    for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === '\n') {
            if (i - start > limit)
                return true;
            start = i + 1;
            if (strLen - start <= limit)
                return false;
        }
    }
    return true;
}
function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
        return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    let str = '';
    let start = 0;
    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
            // space before newline needs to be escaped to not be folded
            str += json.slice(start, i) + '\\ ';
            i += 1;
            start = i;
            ch = '\\';
        }
        if (ch === '\\')
            switch (json[i + 1]) {
                case 'u':
                    {
                        str += json.slice(start, i);
                        const code = json.substr(i + 2, 4);
                        switch (code) {
                            case '0000':
                                str += '\\0';
                                break;
                            case '0007':
                                str += '\\a';
                                break;
                            case '000b':
                                str += '\\v';
                                break;
                            case '001b':
                                str += '\\e';
                                break;
                            case '0085':
                                str += '\\N';
                                break;
                            case '00a0':
                                str += '\\_';
                                break;
                            case '2028':
                                str += '\\L';
                                break;
                            case '2029':
                                str += '\\P';
                                break;
                            default:
                                if (code.substr(0, 2) === '00')
                                    str += '\\x' + code.substr(2);
                                else
                                    str += json.substr(i, 6);
                        }
                        i += 5;
                        start = i + 1;
                    }
                    break;
                case 'n':
                    if (implicitKey ||
                        json[i + 2] === '"' ||
                        json.length < minMultiLineLength) {
                        i += 1;
                    }
                    else {
                        // folding will eat first newline
                        str += json.slice(start, i) + '\n\n';
                        while (json[i + 2] === '\\' &&
                            json[i + 3] === 'n' &&
                            json[i + 4] !== '"') {
                            str += '\n';
                            i += 2;
                        }
                        str += indent;
                        // space after newline needs to be escaped to not be folded
                        if (json[i + 2] === ' ')
                            str += '\\';
                        i += 1;
                        start = i + 1;
                    }
                    break;
                default:
                    i += 1;
            }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey
        ? str
        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx));
}
function singleQuotedString(value, ctx) {
    if (ctx.implicitKey) {
        if (/\n/.test(value))
            return doubleQuotedString(value, ctx);
    }
    else {
        // single quoted string can't have leading or trailing whitespace around newline
        if (/[ \t]\n|\n[ \t]/.test(value))
            return doubleQuotedString(value, ctx);
    }
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
    return ctx.implicitKey
        ? res
        : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx));
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    // 1. Block can't end in whitespace unless the last line is non-empty.
    // 2. Strings consisting of only whitespace are best rendered explicitly.
    if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return doubleQuotedString(value, ctx);
    }
    const indent = ctx.indent ||
        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
    const literal = type === Scalar.Scalar.BLOCK_FOLDED
        ? false
        : type === Scalar.Scalar.BLOCK_LITERAL
            ? true
            : !lineLengthOverLimit(value, ctx.options.lineWidth, indent.length);
    if (!value)
        return literal ? '|\n' : '>\n';
    // determine chomping from whitespace at value end
    let chomp;
    let endStart;
    for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== '\n' && ch !== '\t' && ch !== ' ')
            break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf('\n');
    if (endNlPos === -1) {
        chomp = '-'; // strip
    }
    else if (value === end || endNlPos !== end.length - 1) {
        chomp = '+'; // keep
        if (onChompKeep)
            onChompKeep();
    }
    else {
        chomp = ''; // clip
    }
    if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === '\n')
            end = end.slice(0, -1);
        end = end.replace(/\n+(?!\n|$)/g, `$&${indent}`);
    }
    // determine indent indicator from whitespace at value start
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === ' ')
            startWithSpace = true;
        else if (ch === '\n')
            startNlPos = startEnd;
        else
            break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? '2' : '1'; // root is at -1
    let header = (literal ? '|' : '>') + (startWithSpace ? indentSize : '') + chomp;
    if (comment) {
        header += ' #' + comment.replace(/ ?[\r\n]+/g, ' ');
        if (onComment)
            onComment();
    }
    if (literal) {
        value = value.replace(/\n+/g, `$&${indent}`);
        return `${header}\n${indent}${start}${value}${end}`;
    }
    value = value
        .replace(/\n+/g, '\n$&')
        .replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
        //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent
        .replace(/\n+/g, `$&${indent}`);
    const body = foldFlowLines.foldFlowLines(`${start}${value}${end}`, indent, foldFlowLines.FOLD_BLOCK, getFoldOptions(ctx));
    return `${header}\n${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
    var _a;
    const { type, value } = item;
    const { actualString, implicitKey, indent, inFlow } = ctx;
    if ((implicitKey && /[\n[\]{},]/.test(value)) ||
        (inFlow && /[[\]{},]/.test(value))) {
        return doubleQuotedString(value, ctx);
    }
    if (!value ||
        /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        const hasDouble = value.indexOf('"') !== -1;
        const hasSingle = value.indexOf("'") !== -1;
        let quotedString;
        if (hasDouble && !hasSingle) {
            quotedString = singleQuotedString;
        }
        else if (hasSingle && !hasDouble) {
            quotedString = doubleQuotedString;
        }
        else if (ctx.options.singleQuote) {
            quotedString = singleQuotedString;
        }
        else {
            quotedString = doubleQuotedString;
        }
        // not allowed:
        // - empty string, '-' or '?'
        // - start with an indicator character (except [?:-]) or /[?-] /
        // - '\n ', ': ' or ' \n' anywhere
        // - '#' not preceded by a non-space char
        // - end with ' ' or ':'
        return implicitKey || inFlow || value.indexOf('\n') === -1
            ? quotedString(value, ctx)
            : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey &&
        !inFlow &&
        type !== Scalar.Scalar.PLAIN &&
        value.indexOf('\n') !== -1) {
        // Where allowed & type not set explicitly, prefer block style for multiline strings
        return blockString(item, ctx, onComment, onChompKeep);
    }
    if (indent === '' && containsDocumentMarker(value)) {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
    }
    const str = value.replace(/\n+/g, `$&\n${indent}`);
    // Verify that output will be parsed as a string, as e.g. plain numbers and
    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
    // and others in v1.1.
    if (actualString) {
        for (const tag of ctx.doc.schema.tags) {
            if (tag.default &&
                tag.tag !== 'tag:yaml.org,2002:str' &&
                ((_a = tag.test) === null || _a === void 0 ? void 0 : _a.test(str)))
                return doubleQuotedString(value, ctx);
        }
    }
    return implicitKey
        ? str
        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === 'string'
        ? item
        : Object.assign({}, item, { value: String(item.value) });
    let { type } = item;
    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        // force double quotes on control characters & unpaired surrogates
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
            type = Scalar.Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
        switch (_type) {
            case Scalar.Scalar.BLOCK_FOLDED:
            case Scalar.Scalar.BLOCK_LITERAL:
                return implicitKey || inFlow
                    ? doubleQuotedString(ss.value, ctx) // blocks are not valid inside flow containers
                    : blockString(ss, ctx, onComment, onChompKeep);
            case Scalar.Scalar.QUOTE_DOUBLE:
                return doubleQuotedString(ss.value, ctx);
            case Scalar.Scalar.QUOTE_SINGLE:
                return singleQuotedString(ss.value, ctx);
            case Scalar.Scalar.PLAIN:
                return plainString(ss, ctx, onComment, onChompKeep);
            default:
                return null;
        }
    };
    let res = _stringify(type);
    if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = (implicitKey && defaultKeyType) || defaultStringType;
        res = _stringify(t);
        if (res === null)
            throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
}

exports.stringifyString = stringifyString;


/***/ }),

/***/ 3774:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {



var Node = __nccwpck_require__(9464);

const BREAK = Symbol('break visit');
const SKIP = Symbol('skip children');
const REMOVE = Symbol('remove node');
/**
 * Apply a visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */
function visit(node, visitor) {
    if (typeof visitor === 'object' &&
        (visitor.Collection || visitor.Node || visitor.Value)) {
        visitor = Object.assign({
            Alias: visitor.Node,
            Map: visitor.Node,
            Scalar: visitor.Node,
            Seq: visitor.Node
        }, visitor.Value && {
            Map: visitor.Value,
            Scalar: visitor.Value,
            Seq: visitor.Value
        }, visitor.Collection && {
            Map: visitor.Collection,
            Seq: visitor.Collection
        }, visitor);
    }
    if (Node.isDocument(node)) {
        const cd = _visit(null, node.contents, visitor, Object.freeze([node]));
        if (cd === REMOVE)
            node.contents = null;
    }
    else
        _visit(null, node, visitor, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visit.BREAK = BREAK;
/** Do not visit the children of the current node */
visit.SKIP = SKIP;
/** Remove the current node */
visit.REMOVE = REMOVE;
function _visit(key, node, visitor, path) {
    let ctrl = undefined;
    if (typeof visitor === 'function')
        ctrl = visitor(key, node, path);
    else if (Node.isMap(node)) {
        if (visitor.Map)
            ctrl = visitor.Map(key, node, path);
    }
    else if (Node.isSeq(node)) {
        if (visitor.Seq)
            ctrl = visitor.Seq(key, node, path);
    }
    else if (Node.isPair(node)) {
        if (visitor.Pair)
            ctrl = visitor.Pair(key, node, path);
    }
    else if (Node.isScalar(node)) {
        if (visitor.Scalar)
            ctrl = visitor.Scalar(key, node, path);
    }
    else if (Node.isAlias(node)) {
        if (visitor.Alias)
            ctrl = visitor.Alias(key, node, path);
    }
    if (Node.isNode(ctrl) || Node.isPair(ctrl)) {
        const parent = path[path.length - 1];
        if (Node.isCollection(parent)) {
            parent.items[key] = ctrl;
        }
        else if (Node.isPair(parent)) {
            if (key === 'key')
                parent.key = ctrl;
            else
                parent.value = ctrl;
        }
        else if (Node.isDocument(parent)) {
            parent.contents = ctrl;
        }
        else {
            const pt = Node.isAlias(parent) ? 'alias' : 'scalar';
            throw new Error(`Cannot replace node with ${pt} parent`);
        }
        return _visit(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== 'symbol') {
        if (Node.isCollection(node)) {
            path = Object.freeze(path.concat(node));
            for (let i = 0; i < node.items.length; ++i) {
                const ci = _visit(i, node.items[i], visitor, path);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    node.items.splice(i, 1);
                    i -= 1;
                }
            }
        }
        else if (Node.isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = _visit('key', node.key, visitor, path);
            if (ck === BREAK)
                return BREAK;
            else if (ck === REMOVE)
                node.key = null;
            const cv = _visit('value', node.value, visitor, path);
            if (cv === BREAK)
                return BREAK;
            else if (cv === REMOVE)
                node.value = null;
        }
    }
    return ctrl;
}

exports.visit = visit;


/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __nccwpck_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	var threw = true;
/******/ 	try {
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
/******/ 		threw = false;
/******/ 	} finally {
/******/ 		if(threw) delete __webpack_module_cache__[moduleId];
/******/ 	}
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat */
/******/ 
/******/ if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = new URL('.', import.meta.url).pathname.slice(import.meta.url.match(/^file:\/\/\/\w:/) ? 1 : 0, -1) + "/";
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {

// EXTERNAL MODULE: ./node_modules/cdk8s/lib/index.js
var lib = __nccwpck_require__(1227);
// EXTERNAL MODULE: ./node_modules/@actions/core/lib/core.js
var core = __nccwpck_require__(2186);
// EXTERNAL MODULE: ./node_modules/cdk8s-plus-22/lib/index.js
var cdk8s_plus_22_lib = __nccwpck_require__(9107);
;// CONCATENATED MODULE: ./src/resources.js



/**
 * Get the pod resources based on a size string to simplify this for the end user.
 * i.e. container_size: "medium"
 *
 * @param {string} size the size of the instance
 * @returns {array} The resources array
 */
function getResources(size) {
    /**
     * This function will return a tuple with the resources we should
     * allocate the docker container
     *
     * Example from the manifest:
     * resources:
     *      requests:
     *      memory: "1.5Gi"
     *      cpu: "1000m"
     *      limits:
     *      memory: "1.5Gi"
     *      cpu: "1000m"
     *
     * This will be CapacityProvisioned=1vCPU 2GB for the Fargate instance.
     *
     * Note: Fargate always add 0.5Gi of memory by default, so 1.5Gi would equal 2Gi
     * TODO: Review these instances and adjust accordingly
     *
     */

    // [memory in Gi, CPU in millis]
    const resources = {
        small: [0.5, 500],
        medium: [1.5, 1000],
        large: [2.5, 1000],
        xlarge: [3.5, 2000],
    };

    if (resources[size] === undefined) {
        // This will fallback to 0.5GB / 0.25vCPU, which is the default fargate instance
        return [0, 0];
    }

    return resources[size];
}

/**
 * Create the resource object for the docker container
 *
 * @param {string} size the size of the instance
 * @returns {object} The resources for the container
 */
function createResources(containerSize) {
    const [memory, cpu] = getResources(containerSize);

    // if these are not set to 0 (aka false)
    if (!cpu && !memory) {
        // Return an empty object. This will not add the resources to the container object,
        // which means it is using the default set by fargate.
        return {};
    }

    // Information regarding resources
    // https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    return {
        resources: {
            cpu: {
                limit: cdk8s_plus_22_lib.Cpu.millis(cpu),
                request: cdk8s_plus_22_lib.Cpu.millis(cpu),
            },
            memory: {
                limit: lib.Size.gibibytes(memory),
                request: lib.Size.gibibytes(memory),
            },
        },
    };
}

;// CONCATENATED MODULE: ./imports/external-secrets.js
// generated by cdk8s

/**
 *
 *
 * @schema ExternalSecret
 */
class ExternalSecret extends lib.ApiObject {
    /**
     * Returns the apiVersion and kind for "ExternalSecret"
     */
    static GVK = {
        apiVersion: 'kubernetes-client.io/v1',
        kind: 'ExternalSecret',
    };
    /**
     * Renders a Kubernetes manifest for "ExternalSecret".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...ExternalSecret.GVK,
            ...toJson_ExternalSecretProps(props),
        };
    }
    /**
     * Defines a "ExternalSecret" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...ExternalSecret.GVK,
            ...props,
        });
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...ExternalSecret.GVK,
            ...toJson_ExternalSecretProps(resolved),
        };
    }
}
/**
 * Converts an object of type 'ExternalSecretProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ExternalSecretProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        spec: toJson_ExternalSecretSpec(obj.spec),
        metadata: obj.metadata,
    };
    // filter undefined values
    return Object.entries(result).reduce(
        (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
        {}
    );
}
/**
 * Converts an object of type 'ExternalSecretSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ExternalSecretSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        controllerId: obj.controllerId,
        type: obj.type,
        template: obj.template,
        backendType: obj.backendType,
        vaultRole: obj.vaultRole,
        vaultMountPoint: obj.vaultMountPoint,
        kvVersion: obj.kvVersion,
        keyVaultName: obj.keyVaultName,
        dataFrom: obj.dataFrom?.map((y) => y),
        data: obj.data?.map((y) => toJson_ExternalSecretSpecData(y)),
        roleArn: obj.roleArn,
        region: obj.region,
        projectId: obj.projectId,
    };
    // filter undefined values
    return Object.entries(result).reduce(
        (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
        {}
    );
}
/* eslint-enable max-len, quote-props */
/**
 * Determines which backend to use for fetching secrets
 *
 * @schema ExternalSecretSpecBackendType
 */
var ExternalSecretSpecBackendType;
(function (ExternalSecretSpecBackendType) {
    /** secretsManager */
    ExternalSecretSpecBackendType['SECRETS_MANAGER'] = 'secretsManager';
    /** systemManager */
    ExternalSecretSpecBackendType['SYSTEM_MANAGER'] = 'systemManager';
    /** vault */
    ExternalSecretSpecBackendType['VAULT'] = 'vault';
    /** azureKeyVault */
    ExternalSecretSpecBackendType['AZURE_KEY_VAULT'] = 'azureKeyVault';
    /** gcpSecretsManager */
    ExternalSecretSpecBackendType['GCP_SECRETS_MANAGER'] = 'gcpSecretsManager';
    /** alicloudSecretsManager */
    ExternalSecretSpecBackendType['ALICLOUD_SECRETS_MANAGER'] = 'alicloudSecretsManager';
    /** ibmcloudSecretsManager */
    ExternalSecretSpecBackendType['IBMCLOUD_SECRETS_MANAGER'] = 'ibmcloudSecretsManager';
})(ExternalSecretSpecBackendType || (ExternalSecretSpecBackendType = {}));
/**
 * Converts an object of type 'ExternalSecretSpecData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
function toJson_ExternalSecretSpecData(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        key: obj.key,
        name: obj.name,
        property: obj.property,
        isBinary: obj.isBinary,
        path: obj.path,
        recursive: obj.recursive,
        secretType: obj.secretType,
        version: obj.version,
        versionStage: obj.versionStage,
        versionId: obj.versionId,
    };
    // filter undefined values
    return Object.entries(result).reduce(
        (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
        {}
    );
}
/* eslint-enable max-len, quote-props */

;// CONCATENATED MODULE: ./src/secrets.js



/**
 * Create and populate the chart with the secrets location
 *
 * @param {object} chart the manifest chart
 * @param {object} inputs the github action inputs
 * @returns {object} The secret source for the docker container
 */
function createSecrets(chart, inputs) {
    if (!inputs.secretsmanager && !inputs.clusterName) {
        return {};
    }

    // We are using this service to handle the external secrets coming from
    // AWS Secrets Manager: https://github.com/external-secrets/external-secrets
    // it will fetch data from `cluster/cluster_name/app_name`.
    // This will transform all key values to env vars for the deployment
    new ExternalSecret(chart, 'external-secret', {
        metadata: {
            name: inputs.appName,
            namespace: inputs.namespace,
        },
        spec: {
            backendType: ExternalSecretSpecBackendType.SECRETS_MANAGER,
            dataFrom: [`cluster/${inputs.clusterName}/${inputs.appName}`],
        },
    });

    // Information regarding secrets
    // https://kubernetes.io/docs/concepts/configuration/secret/
    const secret = new cdk8s_plus_22_lib.Secret(chart, 'secret', {
        metadata: {
            name: inputs.appName,
        },
    });

    const secretSource = cdk8s_plus_22_lib.Env.fromSecret(secret);

    return { envFrom: [secretSource] };
}

;// CONCATENATED MODULE: ./src/service/webservice.js





/**
 * This function will create a webservice manifest.
 *
 * @param {object} app the app created by the main.js file
 * @param {object} inputs the inputs coming from the github action
 * @returns
 */
function createWebservice(app, inputs) {
    const labels = {
        app: inputs.appName,
        'app.kubernetes.io/name': inputs.appName,
    };

    const chart = new lib.Chart(app, inputs.appName + '-webservice', {
        labels,
        namespace: inputs.namespace,
    });

    // The docker container configuration
    // Information https://kubernetes.io/docs/concepts/containers/
    const dockerContainer = {
        name: inputs.appName,
        image: inputs.dockerImage,
        port: inputs.containerPort,
        command: inputs.containerCommand,
        args: inputs.containerArgs,

        // Information regarding liveness and readiness
        // https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
        liveness: cdk8s_plus_22_lib.Probe.fromTcpSocket({
            failureThreshold: 3,
            periodSeconds: lib.Duration.seconds(15),
            timeoutSeconds: lib.Duration.seconds(60),
            port: inputs.containerPort,
        }),
        readiness: cdk8s_plus_22_lib.Probe.fromTcpSocket({
            failureThreshold: 3,
            periodSeconds: lib.Duration.seconds(15),
            timeoutSeconds: lib.Duration.seconds(60),
            port: inputs.containerPort,
        }),

        // Information regarding security context
        // https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        securityContext: {
            ensureNonRoot: true,
            // https://hub.armo.cloud/docs/c-0017
            // if we set this to true, it is not possible to write to /tmp
            readOnlyRootFilesystem: false,
            privileged: false,
            user: 1000,
            group: 3000,
            // https://hub.armo.cloud/docs/c-0016
            allowPrivilegeEscalation: false,
        },
    };

    // assign it to the container object
    Object.assign(dockerContainer, createResources(inputs.containerSize));

    // assign the secrets created in kubernetes by external secret to the container
    Object.assign(dockerContainer, createSecrets(chart, inputs));

    // This is the main object for our deployment manifest. Also
    // known as a workload resource.
    // https://kubernetes.io/docs/concepts/workloads/controllers/deployment/
    const deployment = new cdk8s_plus_22_lib.Deployment(chart, 'deployment', {
        select: false,
        containers: [dockerContainer],
        restartPolicy: cdk8s_plus_22_lib.RestartPolicy.ALWAYS,
        replicas: inputs.replicas,
        metadata: {
            name: inputs.appName,
            labels: labels,
            namespace: inputs.namespace,
        },
        podMetadata: {
            name: inputs.appName,
            labels: labels,
        },
        securityContext: {
            ensureNonRoot: true,
            // https://hub.armo.cloud/docs/c-0013
            runAsUser: 1000,
            runAsGroup: 3000,
            fsGroup: 2000,
        },
    });

    if (!inputs.fargate) {
        deployment.scheduling.attract(
            cdk8s_plus_22_lib.Node.labeled(cdk8s_plus_22_lib.NodeLabelQuery.is('instance', inputs.instance))
        );
    }

    // This line will set the selector for the deployment to "app: <app_name>" to be static and not dynamic.
    // If it is dynamic, it will be a conflict with kubernetes immutability for deployments, and will block
    // the deployment from being deployed
    deployment.select(cdk8s_plus_22_lib.LabelSelector.of({ labels: { app: inputs.appName } }));

    // The service to expose our pod/application to the Internet
    // https://kubernetes.io/docs/concepts/services-networking/service/
    const service = new cdk8s_plus_22_lib.Service(chart, 'service', {
        ports: [{ port: inputs.port, targetPort: inputs.containerPort }],
        metadata: {
            name: inputs.appName,
            labels: labels,
            namespace: inputs.namespace,
            // The alb ingress target type is set to IP so the ALB can create
            // a target group with the service IP to allow traffic to the pod
            annotations: { 'alb.ingress.kubernetes.io/target-type': 'ip' },
        },
        type: cdk8s_plus_22_lib.ServiceType.NODE_PORT,
    });

    service.selectLabel('app', inputs.appName);

    // Return the manifest object
    return app;
}

;// CONCATENATED MODULE: ./src/strategy.js



const services = {
    webservice: createWebservice,
};

/**
 * This function selects the service based on what type
 * we are passing to the function.
 * This could be a generic webservice (currently just supporting this),
 * a cron job, some special service we have to create. Etc.
 *
 * @param {string} serviceType
 * @returns {function} The service chosen by the service type
 */
function generateManifest(serviceType) {
    const service = services[serviceType];

    if (service === undefined) {
        core.setFailed(` [!] No service type with name "${serviceType}" found!`);

        // Return a noop function
        return () => {};
    }

    // Return the service
    return service;
}

;// CONCATENATED MODULE: ./main.js





const DEVELOPMENT = process.env.DEVELOPMENT === 'true';

// All inputs coming from the action
// Integers and booleans are transformed from strings to int/bool using JSON.parse
const inputs = {
    // Required
    appName: core.getInput('app_name', { required: true }),
    namespace: core.getInput('namespace', { required: true }),
    serviceType: core.getInput('service_type', { required: true }),
    dockerImage: core.getInput('docker_image', { required: true }),
    containerPort: JSON.parse(core.getInput('container_port', { required: true })),
    port: JSON.parse(core.getInput('port', { required: true })),
    instance: core.getInput('instance', { required: true }),

    // Optional
    replicas: JSON.parse(core.getInput('replicas') || '1'),
    clusterName: core.getInput('cluster_name') || null,
    containerSize: core.getInput('container_size') || null,
    containerCommand: JSON.parse(core.getInput('container_command') || null),
    containerArgs: JSON.parse(core.getInput('container_args') || null),
    secretsmanager: JSON.parse(core.getInput('secretsmanager') || 'false'),
    fargate: JSON.parse(core.getInput('fargate') || 'true'),
};

const app = new lib.App();

core.info(` [*] Creating manifest files for ${inputs.appName}`);

try {
    // This will populate the app object
    generateManifest(inputs.serviceType)(app, inputs);

    // Base64 encode the yaml
    const buff = new Buffer.from(app.synthYaml());
    const base64data = buff.toString('base64');

    // Create the output manifest yaml
    core.setOutput('manifest', base64data);

    if (DEVELOPMENT) {
        console.log(app.synthYaml());
    }
} catch (error) {
    core.setFailed(error.message);
}

})();


//# sourceMappingURL=index.js.map